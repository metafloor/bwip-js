% --BEGIN RENDERER renlinear--
% --REQUIRES preamble raiseerror processoptions--
%%BeginResource: uk.co.terryburton.bwipp renlinear 0.0 2023122500 83313 82223
%%BeginData:        245 ASCII Lines
/setpacking where {pop currentpacking true setpacking} if
10 dict
dup /raiseerror dup /uk.co.terryburton.bwipp findresource put
dup /processoptions dup /uk.co.terryburton.bwipp findresource put
begin
/renlinear {

    20 dict begin          % Confine variables to local scope

    % Default options
    /sbs [] def
    /bhs [] def
    /bbs [] def
    /txt [] def
    /barcolor (unset) def
    /includetext false def
    /textcolor (unset) def
    /textxalign (unset) def
    /textyalign (unset) def
    /textfont (Courier) def
    /textsize 10.0 def
    /textxoffset 0.0 def
    /textyoffset 0.0 def
    /textgaps 0.0 def
    /alttext () def
    /bordercolor (unset) def
    /backgroundcolor (unset) def
    /inkspread 0.15 def
    /width 0.0 def
    /barratio 1.0 def
    /spaceratio 1.0 def
    /showborder false def
    /showbearer false def
    /borderleft 10.0 def
    /borderright 10.0 def
    /bordertop 0.0 def
    /borderbottom 0.0 def
    /borderwidth 0.5 def
    /guardwhitespace false def
    /guardleftpos 0.0 def
    /guardleftypos 0.0 def
    /guardrightpos 0.0 def
    /guardrightypos 0.0 def
    /guardwidth 5.0 def
    /guardheight 7.0 def

    {def} forall
    opt currentdict /opt undef //processoptions exec pop

    textsize 0 le {
        /bwipp.renlinearBadTextsize (The font size must be greater than zero) //raiseerror exec
    } if

    % Create bar elements and put them into the bars array
    /bars sbs length 1 add 2 idiv array def
    /pixx 0 def /pixy 0 def
    0 1 sbs length 1 add 2 idiv 2 mul 2 sub {
        /i exch def
        i 2 mod 0 eq {           % i is even
            /d sbs i get barratio mul barratio sub 1 add def  % d = digit*r-r+1
            sbs i get 0 ne {
                /h bhs i 2 idiv get 72 mul def  % Height from bhs
                /c d 2 div pixx add def         % Centre of the bar = pixx + d/2
                /y bbs i 2 idiv get 72 mul def  % Baseline from bbs
                /w d inkspread sub def          % bar width = digit - inkspread
                bars i 2 idiv [h c y w] put     % Add the bar entry
                h y add pixy gt {/pixy h y add def} if
            } {
                bars i 2 idiv -1 put            % Dummy entry
            } ifelse
        } {
            /d sbs i get spaceratio mul spaceratio sub 1 add def  % d = digit*r-r+1
        } ifelse
        /pixx pixx d add def  % pixx += d
    } for

    gsave

    currentpoint translate

    % Force symbol to given width
    width 0 ne {
        width 72 mul pixx div 1 scale
    } if

    % Set RGB or CMYK color depending on length of given hex string
    /setanycolor {
        /anycolor exch def
        anycolor length dup 6 ne exch 8 ne and {
            /bwipp.renlinearBadColorLength (Colors must be 6 or 8 characters) //raiseerror exec
        } if
        anycolor {
            dup     dup 48 ge exch  59 le and  % 0-9
            1 index dup 65 ge exch  70 le and  % A-F
            2 index dup 97 ge exch 102 le and  % a-f
            or or exch pop not {
                /bwipp.renlinearBadColorCharacter (Colors must be in hexadecimal notation) //raiseerror exec
            } if
        } forall
        anycolor length 6 eq { (<      >) } { (<        >) } ifelse dup length string copy
        dup 1 anycolor putinterval cvx exec {255 div} forall
        anycolor length 6 eq { setrgbcolor } { setcmykcolor } ifelse
    } def

    % Display the border and background
    /tl [ borderleft borderwidth 2 div add neg        pixy bordertop add borderwidth 2 div add ] def
    /tr [ pixx borderright add borderwidth 2 div add  pixy bordertop add borderwidth 2 div add ] def
    /bl [ borderleft borderwidth 2 div add neg        borderbottom borderwidth 2 div add neg   ] def
    /br [ pixx borderright add borderwidth 2 div add  borderbottom borderwidth 2 div add neg   ] def
    backgroundcolor (unset) ne {
        gsave
        newpath bl aload pop moveto [ br tr tl ] { aload pop lineto } forall closepath
        backgroundcolor setanycolor fill
        grestore
    } if
    showbearer {  % Overrides showborder
        gsave
        newpath
        bl aload pop moveto br aload pop lineto
        tl aload pop moveto tr aload pop lineto
        bordercolor (unset) ne { bordercolor setanycolor } if
        borderwidth inkspread 2 mul sub setlinewidth stroke
        grestore
    } {
    showborder {
        gsave
        newpath bl aload pop moveto [ br tr tl ] { aload pop lineto } forall closepath
        bordercolor (unset) ne { bordercolor setanycolor } if
        borderwidth inkspread 2 mul sub setlinewidth stroke
        grestore
    } if } ifelse

    % Display the bars for elements in the bars array
    gsave
    barcolor (unset) ne { barcolor setanycolor } if
    newpath
    bars {
        dup -1 ne {
            aload pop  % h x y w
            2 index 1 index 2 div sub 2 index moveto
            0 4 index rlineto
            dup 0 rlineto
            0 4 index neg rlineto
            closepath
            pop pop pop pop
        } {
            pop
        } ifelse
    } forall
    fill
    grestore

    % Display the text for elements in the text array
    textcolor (unset) ne { textcolor setanycolor } if
    includetext {
        textxalign (unset) eq textyalign (unset) eq and alttext () eq and {
            /s 0 def /fn () def
            txt {
                aload pop
                2 copy s ne exch fn ne or {
                    dup 0 le {
                        pop pop pop pop pop
                        /bwipp.renlinearFontTooSmall (The font size is too small) //raiseerror exec
                    } if
                    2 copy /s exch def /fn exch def
                    selectfont
                } {
                    pop pop
                } ifelse
                moveto show
            } forall
        } {
            textfont textsize selectfont
            alttext () eq {
                /txt [ txt { 0 get {} forall } forall ] def
                /tstr txt length string def
                0 1 txt length 1 sub { dup txt exch get tstr 3 1 roll put } for
            } {
                /tstr alttext def
            } ifelse

            % Find true ascent of font
            tstr length 0 eq {
                0
            } {
                gsave
                newpath 0 0 moveto (0) false charpath pathbbox
                4 1 roll pop pop pop
                grestore
                currentfont /PaintType known {currentfont /PaintType get 2 eq} {false} ifelse
                currentfont /StrokeWidth known and {
                    currentfont /StrokeWidth get 2 div 0 exch
                    currentfont /FontMatrix get dtransform
                    dup mul exch dup mul add sqrt
                    add
                } if
            } ifelse
            /textascent exch def
            /textwidth tstr stringwidth pop tstr length 1 sub textgaps mul add def

            /textxpos textxoffset pixx textwidth sub 2 div add def
            textxalign (left) eq { /textxpos textxoffset def } if
            textxalign (right) eq { /textxpos pixx textxoffset sub textwidth sub def } if
            textxalign (offleft) eq { /textxpos textwidth textxoffset add neg def } if
            textxalign (offright) eq { /textxpos pixx textxoffset add def } if
            textxalign (justify) eq textwidth pixx lt and {
                /textxpos 0 def
                /textgaps pixx textwidth sub tstr length 1 sub div def
            } if
            /textypos textyoffset textascent add 1 add neg def
            textyalign (above) eq { /textypos textyoffset pixy add 1 add def } if
            textyalign (center) eq { /textypos textyoffset pixy textascent sub 2 div add def } if
            textxpos textypos moveto textgaps 0 tstr ashow
        } ifelse
    } if

    % Display the guard elements
    guardwhitespace {
        0.75 setlinewidth
        guardleftpos 0 ne {
            newpath
            guardleftpos neg guardwidth add guardleftypos guardheight 2 div add moveto
            guardwidth neg guardheight -2 div rlineto
            guardwidth guardheight -2 div rlineto
            stroke
        } if
        guardrightpos 0 ne {
            newpath
            guardrightpos pixx add guardwidth sub guardrightypos guardheight 2 div add moveto
            guardwidth guardheight -2 div rlineto
            guardwidth neg guardheight -2 div rlineto
            stroke
        } if
    } if

    grestore

    end

}
[/barcode] {null def} forall
bind def
/renlinear dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if
%%EndData
%%EndResource
% --END RENDERER renlinear--
