<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8" >
<title>debug psc</title>
<script type="text/javascript" src="psc.js"></script>
<style type="text/css">
body, html {
    margin:             0;
    padding:            0;
}
pre.code {
    white-space:        pre;
    margin:             0;
    padding:            0;
}
pre.code:before {
    counter-reset:      listing;
}
pre.code code {
    counter-increment:  listing;
    line-height:        1.25;
}
pre.code code::before {
  content:      counter(listing) " ";
  display:      inline-block;
  width:        8ch;
  padding-left: auto;
  margin-left:  auto;
  margin-right: 1ch;
  text-align:   right;
  background:   #e8ebed;
  border-right: 2px solid #a8abad;
}
div {
    font-size:      16pt;
    font-family:    sans-serif;
    padding:        1ch;
    padding-left:   5ch;
}
div span {
    color:          cornflowerblue;
    cursor:         default;
}
div span:hover {
    color:          orange;
}
</style>
</head>
<body>
<div>&#x27a7; Open devtools, then click<span id="run-btn">&nbsp;Run&nbsp;</span></div>
<pre id="barcode.ps" class="code">
<code>%!PS</code>
<code></code>
<code>% Barcode Writer in Pure PostScript - Version 2024-01-03</code>
<code>% https://bwipp.terryburton.co.uk</code>
<code>%</code>
<code>% Copyright (c) 2004-2024 Terry Burton</code>
<code>%</code>
<code>% Permission is hereby granted, free of charge, to any</code>
<code>% person obtaining a copy of this software and associated</code>
<code>% documentation files (the "Software"), to deal in the</code>
<code>% Software without restriction, including without</code>
<code>% limitation the rights to use, copy, modify, merge,</code>
<code>% publish, distribute, sublicense, and/or sell copies of</code>
<code>% the Software, and to permit persons to whom the Software</code>
<code>% is furnished to do so, subject to the following</code>
<code>% conditions:</code>
<code>%</code>
<code>% The above copyright notice and this permission notice</code>
<code>% shall be included in all copies or substantial portions</code>
<code>% of the Software.</code>
<code>%</code>
<code>% THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY</code>
<code>% KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO</code>
<code>% THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A</code>
<code>% PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL</code>
<code>% THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,</code>
<code>% DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF</code>
<code>% CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN</code>
<code>% CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS</code>
<code>% IN THE SOFTWARE.</code>
<code></code>
<code>% --BEGIN TEMPLATE--</code>
<code></code>
<code>% --BEGIN RESOURCE preamble--</code>
<code>%%BeginResource: Category uk.co.terryburton.bwipp 0.0 2024010300 29733 32838</code>
<code>%%BeginData:          6 ASCII Lines</code>
<code>%psc currentglobal</code>
<code>%psc true setglobal</code>
<code>%psc /Generic /Category findresource dup length 1 add dict copy dup</code>
<code>%psc /InstanceType /setpacking where {pop /packedarraytype} {/arraytype} ifelse put</code>
<code>%psc /uk.co.terryburton.bwipp exch /Category defineresource pop</code>
<code>%psc setglobal</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END RESOURCE preamble--</code>
<code></code>
<code>% --BEGIN RESOURCE loadctx--</code>
<code>% --REQUIRES preamble--</code>
<code>%%BeginResource: uk.co.terryburton.bwipp loadctx 0.0 2024010300 41297 40927</code>
<code>%%BeginData:         30 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 1 dict</code>
<code>%psc begin</code>
<code>%psc /loadctx {</code>
<code>%psc     % Place a context dictionary just below the current dictionary, which can</code>
<code>%psc     % be populated with static data on the first run and then carried between</code>
<code>%psc     % invocations of the encoder</code>
<code>%psc     /ctxname exch def</code>
<code>%psc     /uk.co.terryburton.bwipp.global_ctx dup where {exch get /ctx exch def} {pop} ifelse</code>
<code>%psc     ctx null ne {</code>
<code>%psc         1 {  % Common exit</code>
<code>%psc             ctx ctxname known {</code>
<code>%psc                 ctx ctxname get /_FINALIZED known {</code>
<code>%psc                     /ctxdef {pop} def  % No need to redefine within the existing context</code>
<code>%psc                     exit</code>
<code>%psc                 } if</code>
<code>%psc             } if</code>
<code>%psc             ctx ctxname 10 dict put</code>
<code>%psc             /ctxdef {ctx ctxname get begin exec end} def</code>
<code>%psc         } repeat</code>
<code>%psc         currentdict ctx ctxname get end begin begin</code>
<code>%psc     } {</code>
<code>%psc         /ctxdef {exec} def  % No context provided, so define ephemerally</code>
<code>%psc     } ifelse</code>
<code>%psc }</code>
<code>%psc [/barcode] {null def} forall</code>
<code>%psc bind def</code>
<code>%psc /loadctx dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END RESOURCE loadctx--</code>
<code></code>
<code>% --BEGIN RESOURCE unloadctx--</code>
<code>% --REQUIRES preamble--</code>
<code>%%BeginResource: uk.co.terryburton.bwipp unloadctx 0.0 2024010300 38938 38741</code>
<code>%%BeginData:         14 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 1 dict</code>
<code>%psc begin</code>
<code>%psc /unloadctx {</code>
<code>%psc     % Finalize and remove the context, which is expected to be just underneath currentdict</code>
<code>%psc     ctx null ne {</code>
<code>%psc         currentdict end /_FINALIZED true def end begin</code>
<code>%psc     } if</code>
<code>%psc }</code>
<code>%psc [/barcode] {null def} forall</code>
<code>%psc bind def</code>
<code>%psc /unloadctx dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END RESOURCE unloadctx--</code>
<code></code>
<code>% --BEGIN RESOURCE raiseerror--</code>
<code>% --REQUIRES preamble--</code>
<code>%%BeginResource: uk.co.terryburton.bwipp raiseerror 0.0 2024010300 39029 38860</code>
<code>%%BeginData:         15 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc begin</code>
<code>%psc /raiseerror {</code>
<code>%psc     $error exch /errorinfo exch put</code>
<code>%psc     $error exch /errorname exch put</code>
<code>%psc     $error /command null put</code>
<code>%psc     $error /newerror true put</code>
<code>%psc     stop</code>
<code>%psc }</code>
<code>%psc [/barcode] {null def} forall</code>
<code>%psc bind def</code>
<code>%psc /raiseerror dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END RESOURCE raiseerror--</code>
<code></code>
<code>% --BEGIN RESOURCE processoptions--</code>
<code>% --REQUIRES preamble raiseerror--</code>
<code>%%BeginResource: uk.co.terryburton.bwipp processoptions 0.0 2024010300 48428 48479</code>
<code>%%BeginData:         50 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>%psc /processoptions {</code>
<code>%psc </code>
<code>%psc     % Convert string to dict</code>
<code>%psc     dup type /stringtype eq {</code>
<code>%psc         &lt;&lt; exch</code>
<code>%psc             {</code>
<code>%psc                 dup () eq {pop exit} if</code>
<code>%psc                 ( ) search not { () exch null exch } if exch pop</code>
<code>%psc                 (=) search not { true exch null exch } if exch pop   % k =&gt; k = true</code>
<code>%psc                 exch 3 -1 roll</code>
<code>%psc             } loop</code>
<code>%psc         &gt;&gt;</code>
<code>%psc     } if</code>
<code>%psc </code>
<code>%psc     % Apply options that exist in currentdict, converting values to existing types</code>
<code>%psc     mark exch dup</code>
<code>%psc     {</code>
<code>%psc         exch dup currentdict exch known {</code>
<code>%psc             dup load type 3 -1 roll exch &lt;&lt;</code>
<code>%psc                 /booleantype { false or }                             % Force a type error if not boolean value</code>
<code>%psc                 /stringtype  { dup length string cvs }                % Conversion to string to force a boolean to fail</code>
<code>%psc                 /nametype    1 index                                  % Conversion original nametype to string is fine</code>
<code>%psc                 /realtype    { dup cvr exch pop }</code>
<code>%psc                 /nulltype    1 index                                  % We define "null" as the sentinal value of a realtype</code>
<code>%psc                 /integertype { dup cvr dup cvi ne {dup not} if cvi }  % Force type error when precision is lost or boolean is given</code>
<code>%psc             &gt;&gt; exch get stopped {</code>
<code>%psc                 pop pop</code>
<code>%psc                 dup length string cvs dup length 24 add string</code>
<code>%psc                 dup 0 (Invalid type for option ) putinterval</code>
<code>%psc                 dup 24 4 -1 roll putinterval</code>
<code>%psc                 counttomark {exch pop} repeat</code>
<code>%psc                 /bwipp.invalidOptionType exch //raiseerror exec</code>
<code>%psc             } if</code>
<code>%psc             def</code>
<code>%psc         } {</code>
<code>%psc             pop pop  % Ignore unknown options</code>
<code>%psc         } ifelse</code>
<code>%psc     } forall</code>
<code>%psc     exch pop</code>
<code>%psc </code>
<code>%psc }</code>
<code>%psc [/barcode] {null def} forall</code>
<code>%psc bind def</code>
<code>%psc /processoptions dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END RESOURCE processoptions--</code>
<code></code>
<code>% --BEGIN RESOURCE parseinput--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror--</code>
<code>%%BeginResource: uk.co.terryburton.bwipp parseinput 0.0 2024010300 73457 69318</code>
<code>%%BeginData:        174 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/parseinput {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    /parseinput //loadctx exec</code>
<code></code>
<code>    /fncvals exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /parse     dup dup fncvals exch get def fncvals exch undef</code>
<code>    /parsefnc  dup dup fncvals exch get def fncvals exch undef</code>
<code>    /parseonly dup dup fncvals exch known def fncvals exch undef</code>
<code>    /eci       dup dup fncvals exch known def fncvals exch undef</code>
<code></code>
<code>    % Control character names to ordinals</code>
<code>{</code>
<code>    &lt;&lt;</code>
<code>        [</code>
<code>            /NUL /SOH /STX /ETX /EOT /ENQ /ACK /BEL</code>
<code>            /BS  /TAB /LF  /VT  /FF  /CR  ()   ()    % SO and SI prefix clash with SOH</code>
<code>            /DLE /DC1 /DC2 /DC3 /DC4 /NAK /SYN /ETB</code>
<code>            /CAN /EM  /SUB /ESC /FS  /GS  /RS  /US</code>
<code>        ]</code>
<code>        0 exch {</code>
<code>            1 index 1 add 3 1 roll exch 3 -1 roll</code>
<code>        } forall pop</code>
<code>    &gt;&gt; /ctrl exch def</code>
<code>} ctxdef</code>
<code></code>
<code>    /msg barcode length array def</code>
<code>    /j 0 def</code>
<code>    barcode {  % loop</code>
<code>        (^) search exch</code>
<code>        % Copy characters up to a "^"</code>
<code>        dup length exch</code>
<code>        msg exch j exch [ exch {} forall ] putinterval</code>
<code>        j add /j exch def</code>
<code>        {  % Found a "^" escape character</code>
<code>            pop</code>
<code>            1 {  % common exit</code>
<code></code>
<code>                parse not parsefnc not and {  % "^" as is</code>
<code>                    msg j 94 put</code>
<code>                    /j j 1 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code></code>
<code>                % Encode "^" to start with</code>
<code>                msg j 94 put</code>
<code>                /j j 1 add def</code>
<code></code>
<code>                % parse</code>
<code>                parse {</code>
<code>                    dup length 3 ge {  % "^XXX" byte</code>
<code>                        dup 0 3 getinterval ctrl exch</code>
<code>                        2 copy known {</code>
<code>                            /j j 1 sub def  % Replace "^" with ordinal</code>
<code>                            get msg exch j exch put</code>
<code>                            /j j 1 add def</code>
<code>                            dup length 3 sub 3 exch getinterval</code>
<code>                            exit</code>
<code>                        } {</code>
<code>                            pop pop</code>
<code>                        } ifelse</code>
<code>                    } if</code>
<code>                    dup length 2 ge {  % "^XX" to byte</code>
<code>                        dup 0 2 getinterval ctrl exch</code>
<code>                        2 copy known {</code>
<code>                            /j j 1 sub def  % Replace "^" with ordinal</code>
<code>                            get msg exch j exch put</code>
<code>                            /j j 1 add def</code>
<code>                            dup length 2 sub 2 exch getinterval</code>
<code>                            exit</code>
<code>                        } {</code>
<code>                            pop pop</code>
<code>                        } ifelse</code>
<code>                    } if</code>
<code>                    dup length 3 ge {  % "^NNN" to byte</code>
<code>                        dup 0 3 getinterval true exch {</code>
<code>                            dup 48 lt exch 57 gt or { pop false } if</code>
<code>                        } forall</code>
<code>                        {</code>
<code>                            dup 0 3 getinterval cvi dup 255 gt {</code>
<code>                                pop pop</code>
<code>                                /bwipp.invalidOrdinal (Ordinal must be 000 to 255) //raiseerror exec</code>
<code>                            } if</code>
<code>                            /j j 1 sub def  % Replace "^" with ordinal</code>
<code>                            msg exch j exch put</code>
<code>                            /j j 1 add def</code>
<code>                            dup length 3 sub 3 exch getinterval</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                } if</code>
<code></code>
<code>                parseonly</code>
<code>                parsefnc not or</code>
<code>                msg j 1 sub get 94 ne  % Carat was substituted away</code>
<code>                or {exit} if</code>
<code></code>
<code>                % parsefnc</code>
<code>                /j j 1 sub def</code>
<code>                dup length 3 lt {</code>
<code>                    pop</code>
<code>                    /bwipp.truncatedFNC (Function character truncated) //raiseerror exec</code>
<code>                } if</code>
<code>                dup 0 get 94 eq {  % "^^" -&gt; "^"</code>
<code>                    msg j 94 put</code>
<code>                    /j j 1 add def</code>
<code>                    dup length 1 sub 1 exch getinterval</code>
<code>                    exit</code>
<code>                } if</code>
<code>                dup 0 3 getinterval (ECI) eq eci and {  % "^ECInnnnnn" -&gt; -1nnnnnn</code>
<code>                    dup length 9 lt {</code>
<code>                        pop</code>
<code>                        /bwipp.truncatedECI (ECI truncated) //raiseerror exec</code>
<code>                    } if</code>
<code>                    dup 3 6 getinterval</code>
<code>                    dup {</code>
<code>                        dup 48 lt exch 57 gt or {</code>
<code>                            pop pop</code>
<code>                            /bwipp.invalidECI (ECI must be 000000 to 999999) //raiseerror exec</code>
<code>                        } if</code>
<code>                    } forall</code>
<code>                    0 exch {48 sub sub 10 mul} forall 10 idiv 1000000 sub</code>
<code>                    msg exch j exch put</code>
<code>                    /j j 1 add def</code>
<code>                    dup length 9 sub 9 exch getinterval</code>
<code>                    exit</code>
<code>                } if</code>
<code>                dup length 4 lt {  % "^FNCx" -&gt; fncvals{FNCx}</code>
<code>                    pop</code>
<code>                    /bwipp.truncatedFNC (Function character truncated) //raiseerror exec</code>
<code>                } if</code>
<code>                dup 0 4 getinterval dup fncvals exch known not {</code>
<code>                    dup length 28 add string dup 28 4 -1 roll putinterval</code>
<code>                    dup 0 (Unknown function character: ) putinterval</code>
<code>                    exch pop</code>
<code>                    /bwipp.unknownFNC exch //raiseerror exec</code>
<code>                } if</code>
<code>                fncvals exch get</code>
<code>                msg exch j exch put</code>
<code>                /j j 1 add def</code>
<code>                dup length 4 sub 4 exch getinterval</code>
<code>                exit</code>
<code></code>
<code>            } repeat</code>
<code>        } {  % No more "^" characters</code>
<code>            exit</code>
<code>        }  ifelse</code>
<code>    } loop</code>
<code></code>
<code>    parseonly not {</code>
<code>        msg 0 j getinterval</code>
<code>    } {</code>
<code>        j string</code>
<code>        0 1 j 1 sub { 1 index exch dup msg exch get put } for</code>
<code>    } ifelse</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /parseinput dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END RESOURCE parseinput--</code>
<code></code>
<code>% --BEGIN RESOURCE gs1process--</code>
<code>% --REQUIRES preamble loadctx unloadctx parseinput raiseerror--</code>
<code>%%BeginResource: uk.co.terryburton.bwipp gs1process 0.0 2024010300 600758 650584</code>
<code>%%BeginData:       2992 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/gs1process {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    /gs1process //loadctx exec</code>
<code></code>
<code>{</code>
<code>    % Extracted from the GS1 Syntax Dictionary</code>
<code>    /gs1syntax &lt;&lt;</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min 18  /max 18  /opt false  /linters [ /lintcsum /lintkey ] &gt;&gt;</code>
<code>            ]</code>
<code>            /dlpkey [ ]</code>
<code>        &gt;&gt;</code>
<code>        (00) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min 14  /max 14  /opt false  /linters [ /lintcsum /lintkey ] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (02) (255) (37) ]</code>
<code>            /dlpkey [ [ (22) (10) (21) ] [ (235) ] ]</code>
<code>        &gt;&gt;</code>
<code>        (01) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min 14  /max 14  /opt false  /linters [ /lintcsum /lintkey ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (37) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (02) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 20  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] [ (8006) ] [ (8026) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (10) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [ /lintyymmd0 ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] [ (8006) ] [ (8026) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (11) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [ /lintyymmd0 ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (8020) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (12) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [ /lintyymmd0 ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] [ (8006) ] [ (8026) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (13) exch dup</code>
<code>        (15) exch dup</code>
<code>        (16) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [ /lintyymmd0 ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] [ (255) ] [ (8006) ] [ (8026) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (17) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  2  /max  2  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] [ (8006) ] [ (8026) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (20) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 20  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (235) ]</code>
<code>            /req    [ [ [ (01) ] [ (8006) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (21) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 20  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (22) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 28  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (235) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 30  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] [ (8006) ] [ (8026) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (240) exch dup</code>
<code>        (241) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  1  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] [ (8006) ] [ (8026) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (242) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 20  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (243) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 30  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (8006) ] ] [ [ (21) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (250) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 30  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (8006) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (251) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min 13  /max 13  /opt false  /linters [ /lintcsum /lintkey ] &gt;&gt;</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 17  /opt true   /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /dlpkey [ ]</code>
<code>        &gt;&gt;</code>
<code>        (253) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 20  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (414) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (254) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min 13  /max 13  /opt false  /linters [ /lintcsum /lintkey ] &gt;&gt;</code>
<code>                &lt;&lt; /cset /N  /min  1  /max 12  /opt true   /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (01) (02) (415) (8006) (8020) (8026) ]</code>
<code>            /dlpkey [ ]</code>
<code>        &gt;&gt;</code>
<code>        (255) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  1  /max  8  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (30) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (310n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3100) exch dup</code>
<code>        (3101) exch dup</code>
<code>        (3102) exch dup</code>
<code>        (3103) exch dup</code>
<code>        (3104) exch dup</code>
<code>        (3105) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (311n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3110) exch dup</code>
<code>        (3111) exch dup</code>
<code>        (3112) exch dup</code>
<code>        (3113) exch dup</code>
<code>        (3114) exch dup</code>
<code>        (3115) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (312n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3120) exch dup</code>
<code>        (3121) exch dup</code>
<code>        (3122) exch dup</code>
<code>        (3123) exch dup</code>
<code>        (3124) exch dup</code>
<code>        (3125) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (313n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3130) exch dup</code>
<code>        (3131) exch dup</code>
<code>        (3132) exch dup</code>
<code>        (3133) exch dup</code>
<code>        (3134) exch dup</code>
<code>        (3135) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (314n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3140) exch dup</code>
<code>        (3141) exch dup</code>
<code>        (3142) exch dup</code>
<code>        (3143) exch dup</code>
<code>        (3144) exch dup</code>
<code>        (3145) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (315n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3150) exch dup</code>
<code>        (3151) exch dup</code>
<code>        (3152) exch dup</code>
<code>        (3153) exch dup</code>
<code>        (3154) exch dup</code>
<code>        (3155) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (316n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3160) exch dup</code>
<code>        (3161) exch dup</code>
<code>        (3162) exch dup</code>
<code>        (3163) exch dup</code>
<code>        (3164) exch dup</code>
<code>        (3165) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (320n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3200) exch dup</code>
<code>        (3201) exch dup</code>
<code>        (3202) exch dup</code>
<code>        (3203) exch dup</code>
<code>        (3204) exch dup</code>
<code>        (3205) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (321n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3210) exch dup</code>
<code>        (3211) exch dup</code>
<code>        (3212) exch dup</code>
<code>        (3213) exch dup</code>
<code>        (3214) exch dup</code>
<code>        (3215) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (322n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3220) exch dup</code>
<code>        (3221) exch dup</code>
<code>        (3222) exch dup</code>
<code>        (3223) exch dup</code>
<code>        (3224) exch dup</code>
<code>        (3225) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (323n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3230) exch dup</code>
<code>        (3231) exch dup</code>
<code>        (3232) exch dup</code>
<code>        (3233) exch dup</code>
<code>        (3234) exch dup</code>
<code>        (3235) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (324n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3240) exch dup</code>
<code>        (3241) exch dup</code>
<code>        (3242) exch dup</code>
<code>        (3243) exch dup</code>
<code>        (3244) exch dup</code>
<code>        (3245) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (325n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3250) exch dup</code>
<code>        (3251) exch dup</code>
<code>        (3252) exch dup</code>
<code>        (3253) exch dup</code>
<code>        (3254) exch dup</code>
<code>        (3255) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (326n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3260) exch dup</code>
<code>        (3261) exch dup</code>
<code>        (3262) exch dup</code>
<code>        (3263) exch dup</code>
<code>        (3264) exch dup</code>
<code>        (3265) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (327n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3270) exch dup</code>
<code>        (3271) exch dup</code>
<code>        (3272) exch dup</code>
<code>        (3273) exch dup</code>
<code>        (3274) exch dup</code>
<code>        (3275) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (328n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3280) exch dup</code>
<code>        (3281) exch dup</code>
<code>        (3282) exch dup</code>
<code>        (3283) exch dup</code>
<code>        (3284) exch dup</code>
<code>        (3285) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (329n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3290) exch dup</code>
<code>        (3291) exch dup</code>
<code>        (3292) exch dup</code>
<code>        (3293) exch dup</code>
<code>        (3294) exch dup</code>
<code>        (3295) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (330n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3300) exch dup</code>
<code>        (3301) exch dup</code>
<code>        (3302) exch dup</code>
<code>        (3303) exch dup</code>
<code>        (3304) exch dup</code>
<code>        (3305) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (331n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3310) exch dup</code>
<code>        (3311) exch dup</code>
<code>        (3312) exch dup</code>
<code>        (3313) exch dup</code>
<code>        (3314) exch dup</code>
<code>        (3315) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (332n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3320) exch dup</code>
<code>        (3321) exch dup</code>
<code>        (3322) exch dup</code>
<code>        (3323) exch dup</code>
<code>        (3324) exch dup</code>
<code>        (3325) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (333n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3330) exch dup</code>
<code>        (3331) exch dup</code>
<code>        (3332) exch dup</code>
<code>        (3333) exch dup</code>
<code>        (3334) exch dup</code>
<code>        (3335) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (334n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3340) exch dup</code>
<code>        (3341) exch dup</code>
<code>        (3342) exch dup</code>
<code>        (3343) exch dup</code>
<code>        (3344) exch dup</code>
<code>        (3345) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (335n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3350) exch dup</code>
<code>        (3351) exch dup</code>
<code>        (3352) exch dup</code>
<code>        (3353) exch dup</code>
<code>        (3354) exch dup</code>
<code>        (3355) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (336n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3360) exch dup</code>
<code>        (3361) exch dup</code>
<code>        (3362) exch dup</code>
<code>        (3363) exch dup</code>
<code>        (3364) exch dup</code>
<code>        (3365) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (337n) ]</code>
<code>            /req    [ [ [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3370) exch dup</code>
<code>        (3371) exch dup</code>
<code>        (3372) exch dup</code>
<code>        (3373) exch dup</code>
<code>        (3374) exch dup</code>
<code>        (3375) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (340n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3400) exch dup</code>
<code>        (3401) exch dup</code>
<code>        (3402) exch dup</code>
<code>        (3403) exch dup</code>
<code>        (3404) exch dup</code>
<code>        (3405) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (341n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3410) exch dup</code>
<code>        (3411) exch dup</code>
<code>        (3412) exch dup</code>
<code>        (3413) exch dup</code>
<code>        (3414) exch dup</code>
<code>        (3415) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (342n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3420) exch dup</code>
<code>        (3421) exch dup</code>
<code>        (3422) exch dup</code>
<code>        (3423) exch dup</code>
<code>        (3424) exch dup</code>
<code>        (3425) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (343n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3430) exch dup</code>
<code>        (3431) exch dup</code>
<code>        (3432) exch dup</code>
<code>        (3433) exch dup</code>
<code>        (3434) exch dup</code>
<code>        (3435) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (344n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3440) exch dup</code>
<code>        (3441) exch dup</code>
<code>        (3442) exch dup</code>
<code>        (3443) exch dup</code>
<code>        (3444) exch dup</code>
<code>        (3445) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (345n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3450) exch dup</code>
<code>        (3451) exch dup</code>
<code>        (3452) exch dup</code>
<code>        (3453) exch dup</code>
<code>        (3454) exch dup</code>
<code>        (3455) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (346n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3460) exch dup</code>
<code>        (3461) exch dup</code>
<code>        (3462) exch dup</code>
<code>        (3463) exch dup</code>
<code>        (3464) exch dup</code>
<code>        (3465) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (347n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3470) exch dup</code>
<code>        (3471) exch dup</code>
<code>        (3472) exch dup</code>
<code>        (3473) exch dup</code>
<code>        (3474) exch dup</code>
<code>        (3475) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (348n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3480) exch dup</code>
<code>        (3481) exch dup</code>
<code>        (3482) exch dup</code>
<code>        (3483) exch dup</code>
<code>        (3484) exch dup</code>
<code>        (3485) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (349n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3490) exch dup</code>
<code>        (3491) exch dup</code>
<code>        (3492) exch dup</code>
<code>        (3493) exch dup</code>
<code>        (3494) exch dup</code>
<code>        (3495) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (350n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3500) exch dup</code>
<code>        (3501) exch dup</code>
<code>        (3502) exch dup</code>
<code>        (3503) exch dup</code>
<code>        (3504) exch dup</code>
<code>        (3505) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (351n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3510) exch dup</code>
<code>        (3511) exch dup</code>
<code>        (3512) exch dup</code>
<code>        (3513) exch dup</code>
<code>        (3514) exch dup</code>
<code>        (3515) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (352n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3520) exch dup</code>
<code>        (3521) exch dup</code>
<code>        (3522) exch dup</code>
<code>        (3523) exch dup</code>
<code>        (3524) exch dup</code>
<code>        (3525) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (353n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3530) exch dup</code>
<code>        (3531) exch dup</code>
<code>        (3532) exch dup</code>
<code>        (3533) exch dup</code>
<code>        (3534) exch dup</code>
<code>        (3535) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (354n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3540) exch dup</code>
<code>        (3541) exch dup</code>
<code>        (3542) exch dup</code>
<code>        (3543) exch dup</code>
<code>        (3544) exch dup</code>
<code>        (3545) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (355n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3550) exch dup</code>
<code>        (3551) exch dup</code>
<code>        (3552) exch dup</code>
<code>        (3553) exch dup</code>
<code>        (3554) exch dup</code>
<code>        (3555) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (356n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3560) exch dup</code>
<code>        (3561) exch dup</code>
<code>        (3562) exch dup</code>
<code>        (3563) exch dup</code>
<code>        (3564) exch dup</code>
<code>        (3565) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (357n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3570) exch dup</code>
<code>        (3571) exch dup</code>
<code>        (3572) exch dup</code>
<code>        (3573) exch dup</code>
<code>        (3574) exch dup</code>
<code>        (3575) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (360n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3600) exch dup</code>
<code>        (3601) exch dup</code>
<code>        (3602) exch dup</code>
<code>        (3603) exch dup</code>
<code>        (3604) exch dup</code>
<code>        (3605) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (361n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3610) exch dup</code>
<code>        (3611) exch dup</code>
<code>        (3612) exch dup</code>
<code>        (3613) exch dup</code>
<code>        (3614) exch dup</code>
<code>        (3615) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (362n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3620) exch dup</code>
<code>        (3621) exch dup</code>
<code>        (3622) exch dup</code>
<code>        (3623) exch dup</code>
<code>        (3624) exch dup</code>
<code>        (3625) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (363n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3630) exch dup</code>
<code>        (3631) exch dup</code>
<code>        (3632) exch dup</code>
<code>        (3633) exch dup</code>
<code>        (3634) exch dup</code>
<code>        (3635) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (364n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3640) exch dup</code>
<code>        (3641) exch dup</code>
<code>        (3642) exch dup</code>
<code>        (3643) exch dup</code>
<code>        (3644) exch dup</code>
<code>        (3645) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (365n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3650) exch dup</code>
<code>        (3651) exch dup</code>
<code>        (3652) exch dup</code>
<code>        (3653) exch dup</code>
<code>        (3654) exch dup</code>
<code>        (3655) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (366n) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3660) exch dup</code>
<code>        (3661) exch dup</code>
<code>        (3662) exch dup</code>
<code>        (3663) exch dup</code>
<code>        (3664) exch dup</code>
<code>        (3665) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (367n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3670) exch dup</code>
<code>        (3671) exch dup</code>
<code>        (3672) exch dup</code>
<code>        (3673) exch dup</code>
<code>        (3674) exch dup</code>
<code>        (3675) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (368n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3680) exch dup</code>
<code>        (3681) exch dup</code>
<code>        (3682) exch dup</code>
<code>        (3683) exch dup</code>
<code>        (3684) exch dup</code>
<code>        (3685) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (369n) ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3690) exch dup</code>
<code>        (3691) exch dup</code>
<code>        (3692) exch dup</code>
<code>        (3693) exch dup</code>
<code>        (3694) exch dup</code>
<code>        (3695) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  1  /max  8  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (00) ] ] [ [ (02) ] [ (8026) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (37) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  1  /max 15  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (390n) (391n) (394n) (8111) ]</code>
<code>            /req    [ [ [ (255) ] [ (8020) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3900) exch dup</code>
<code>        (3901) exch dup</code>
<code>        (3902) exch dup</code>
<code>        (3903) exch dup</code>
<code>        (3904) exch dup</code>
<code>        (3905) exch dup</code>
<code>        (3906) exch dup</code>
<code>        (3907) exch dup</code>
<code>        (3908) exch dup</code>
<code>        (3909) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  3  /max  3  /opt false  /linters [ /lintiso4217 ] &gt;&gt;</code>
<code>                &lt;&lt; /cset /N  /min  1  /max 15  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (391n) ]</code>
<code>            /req    [ [ [ (8020) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3910) exch dup</code>
<code>        (3911) exch dup</code>
<code>        (3912) exch dup</code>
<code>        (3913) exch dup</code>
<code>        (3914) exch dup</code>
<code>        (3915) exch dup</code>
<code>        (3916) exch dup</code>
<code>        (3917) exch dup</code>
<code>        (3918) exch dup</code>
<code>        (3919) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  1  /max 15  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (392n) (393n) ]</code>
<code>            /req    [ [ [ (01) ] ] [ [ (30) ] [ (31nn) ] [ (32nn) ] [ (35nn) ] [ (36nn) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3920) exch dup</code>
<code>        (3921) exch dup</code>
<code>        (3922) exch dup</code>
<code>        (3923) exch dup</code>
<code>        (3924) exch dup</code>
<code>        (3925) exch dup</code>
<code>        (3926) exch dup</code>
<code>        (3927) exch dup</code>
<code>        (3928) exch dup</code>
<code>        (3929) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  3  /max  3  /opt false  /linters [ /lintiso4217 ] &gt;&gt;</code>
<code>                &lt;&lt; /cset /N  /min  1  /max 15  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (393n) ]</code>
<code>            /req    [ [ [ (30) ] [ (31nn) ] [ (32nn) ] [ (35nn) ] [ (36nn) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3930) exch dup</code>
<code>        (3931) exch dup</code>
<code>        (3932) exch dup</code>
<code>        (3933) exch dup</code>
<code>        (3934) exch dup</code>
<code>        (3935) exch dup</code>
<code>        (3936) exch dup</code>
<code>        (3937) exch dup</code>
<code>        (3938) exch dup</code>
<code>        (3939) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  4  /max  4  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (394n) (8111) ]</code>
<code>            /req    [ [ [ (255) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3940) exch dup</code>
<code>        (3941) exch dup</code>
<code>        (3942) exch dup</code>
<code>        (3943) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (392n) (393n) (395n) (8005) ]</code>
<code>            /req    [ [ [ (30) ] [ (31nn) ] [ (32nn) ] [ (35nn) ] [ (36nn) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (3950) exch dup</code>
<code>        (3951) exch dup</code>
<code>        (3952) exch dup</code>
<code>        (3953) exch dup</code>
<code>        (3954) exch dup</code>
<code>        (3955) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 30  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>        &gt;&gt;</code>
<code>        (400) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 30  /opt false  /linters [ /lintkey ] &gt;&gt;</code>
<code>            ]</code>
<code>            /dlpkey [ ]</code>
<code>        &gt;&gt;</code>
<code>        (401) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min 17  /max 17  /opt false  /linters [ /lintcsum /lintkey ] &gt;&gt;</code>
<code>            ]</code>
<code>            /dlpkey [ ]</code>
<code>        &gt;&gt;</code>
<code>        (402) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 30  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (00) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (403) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min 13  /max 13  /opt false  /linters [ /lintcsum /lintkey ] &gt;&gt;</code>
<code>            ]</code>
<code>        &gt;&gt;</code>
<code>        (410) exch dup</code>
<code>        (411) exch dup</code>
<code>        (412) exch dup</code>
<code>        (413) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min 13  /max 13  /opt false  /linters [ /lintcsum /lintkey ] &gt;&gt;</code>
<code>            ]</code>
<code>            /dlpkey [ [ (254) ] [ (7040) ] ]</code>
<code>        &gt;&gt;</code>
<code>        (414) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min 13  /max 13  /opt false  /linters [ /lintcsum /lintkey ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (8020) ] ] ]</code>
<code>            /dlpkey [ [ (8020) ] ]</code>
<code>        &gt;&gt;</code>
<code>        (415) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min 13  /max 13  /opt false  /linters [ /lintcsum /lintkey ] &gt;&gt;</code>
<code>            ]</code>
<code>        &gt;&gt;</code>
<code>        (416) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min 13  /max 13  /opt false  /linters [ /lintcsum /lintkey ] &gt;&gt;</code>
<code>            ]</code>
<code>            /dlpkey [ [ (7040) ] ]</code>
<code>        &gt;&gt;</code>
<code>        (417) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 20  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (421) ]</code>
<code>        &gt;&gt;</code>
<code>        (420) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  3  /max  3  /opt false  /linters [ /lintiso3166 ] &gt;&gt;</code>
<code>                &lt;&lt; /cset /X  /min  1  /max  9  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (4307) ]</code>
<code>        &gt;&gt;</code>
<code>        (421) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  3  /max  3  /opt false  /linters [ /lintiso3166 ] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (426) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] [ (8006) ] [ (8026) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (422) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  1  /max 15  /opt false  /linters [ /lintiso3166list ] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (426) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (423) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  3  /max  3  /opt false  /linters [ /lintiso3166 ] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (426) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (424) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  1  /max 15  /opt false  /linters [ /lintiso3166list ] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (426) ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (425) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  3  /max  3  /opt false  /linters [ /lintiso3166 ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (426) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max  3  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] [ [ (422) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (427) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 35  /opt false  /linters [ /lintpcenc ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (00) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (4300) exch dup</code>
<code>        (4301) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 70  /opt false  /linters [ /lintpcenc ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (00) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (4302) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 70  /opt false  /linters [ /lintpcenc ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (4302) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (4303) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 70  /opt false  /linters [ /lintpcenc ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (00) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (4304) exch dup</code>
<code>        (4305) exch dup</code>
<code>        (4306) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  2  /max  2  /opt false  /linters [ /lintiso3166alpha2 ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (00) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (4307) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 30  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (00) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (4308) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min 10  /max 10  /opt false  /linters [ /lintlatitude ] &gt;&gt;</code>
<code>                &lt;&lt; /cset /N  /min 10  /max 10  /opt false  /linters [ /lintlongitude ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (00) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (4309) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 35  /opt false  /linters [ /lintpcenc ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (00) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (4310) exch dup</code>
<code>        (4311) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 70  /opt false  /linters [ /lintpcenc ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (00) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (4312) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 70  /opt false  /linters [ /lintpcenc ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (4312) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (4313) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 70  /opt false  /linters [ /lintpcenc ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (00) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (4314) exch dup</code>
<code>        (4315) exch dup</code>
<code>        (4316) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  2  /max  2  /opt false  /linters [ /lintiso3166alpha2 ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (00) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (4317) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 20  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (00) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (4318) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 30  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (00) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (4319) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 35  /opt false  /linters [ /lintpcenc ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (00) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (4320) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  1  /max  1  /opt false  /linters [ /lintyesno ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (00) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (4321) exch dup</code>
<code>        (4322) exch dup</code>
<code>        (4323) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [ /lintyymmd0 ] &gt;&gt;</code>
<code>                &lt;&lt; /cset /N  /min  4  /max  4  /opt false  /linters [ /linthhmm ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (00) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (4324) exch dup</code>
<code>        (4325) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [ /lintyymmdd ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (00) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (4326) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min 13  /max 13  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] [ (8006) ] [ (8026) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (7001) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 30  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (7002) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [ /lintyymmdd ] &gt;&gt;</code>
<code>                &lt;&lt; /cset /N  /min  4  /max  4  /opt false  /linters [ /linthhmm ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (7003) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  1  /max  4  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] ] [ [ (10) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (7004) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 12  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (7005) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [ /lintyymmdd ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (7006) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [ /lintyymmdd ] &gt;&gt;</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt true   /linters [ /lintyymmdd ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (7007) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max  3  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (7008) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 10  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (7009) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max  2  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (7010) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [ /lintyymmdd ] &gt;&gt;</code>
<code>                &lt;&lt; /cset /N  /min  4  /max  4  /opt true   /linters [ /linthhmm ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (7011) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 20  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (8006) ] ] [ [ (416) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (7020) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 20  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (8006) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (7021) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 20  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (7021) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (7022) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 30  /opt false  /linters [ /lintkey ] &gt;&gt;</code>
<code>            ]</code>
<code>        &gt;&gt;</code>
<code>        (7023) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  3  /max  3  /opt false  /linters [ /lintiso3166999 ] &gt;&gt;</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 27  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (7030) exch dup</code>
<code>        (7031) exch dup</code>
<code>        (7032) exch dup</code>
<code>        (7033) exch dup</code>
<code>        (7034) exch dup</code>
<code>        (7035) exch dup</code>
<code>        (7036) exch dup</code>
<code>        (7037) exch dup</code>
<code>        (7038) exch dup</code>
<code>        (7039) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  1  /max  1  /opt false  /linters [] &gt;&gt;</code>
<code>                &lt;&lt; /cset /X  /min  1  /max  1  /opt false  /linters [] &gt;&gt;</code>
<code>                &lt;&lt; /cset /X  /min  1  /max  1  /opt false  /linters [] &gt;&gt;</code>
<code>                &lt;&lt; /cset /X  /min  1  /max  1  /opt false  /linters [ /lintimporteridx ] &gt;&gt;</code>
<code>            ]</code>
<code>        &gt;&gt;</code>
<code>        (7040) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 20  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (710) exch dup</code>
<code>        (711) exch dup</code>
<code>        (712) exch dup</code>
<code>        (713) exch dup</code>
<code>        (714) exch dup</code>
<code>        (715) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  2  /max  2  /opt false  /linters [] &gt;&gt;</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 28  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (8004) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (7230) exch dup</code>
<code>        (7231) exch dup</code>
<code>        (7232) exch dup</code>
<code>        (7233) exch dup</code>
<code>        (7234) exch dup</code>
<code>        (7235) exch dup</code>
<code>        (7236) exch dup</code>
<code>        (7237) exch dup</code>
<code>        (7238) exch dup</code>
<code>        (7239) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 20  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (8006) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (7240) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  2  /max  2  /opt false  /linters [ /lintmediatype ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (8017) ] [ (8018) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (7241) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 25  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (8017) ] [ (8018) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (7242) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  4  /max  4  /opt false  /linters [ /lintnonzero ] &gt;&gt;</code>
<code>                &lt;&lt; /cset /N  /min  5  /max  5  /opt false  /linters [ /lintnonzero ] &gt;&gt;</code>
<code>                &lt;&lt; /cset /N  /min  3  /max  3  /opt false  /linters [ /lintnonzero ] &gt;&gt;</code>
<code>                &lt;&lt; /cset /N  /min  1  /max  1  /opt false  /linters [ /lintwinding ] &gt;&gt;</code>
<code>                &lt;&lt; /cset /N  /min  1  /max  1  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (8001) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 20  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>        &gt;&gt;</code>
<code>        (8002) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  1  /max  1  /opt false  /linters [ /lintzero ] &gt;&gt;</code>
<code>                &lt;&lt; /cset /N  /min 13  /max 13  /opt false  /linters [ /lintcsum /lintkey ] &gt;&gt;</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 16  /opt true   /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /dlpkey [ ]</code>
<code>        &gt;&gt;</code>
<code>        (8003) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 30  /opt false  /linters [ /lintkey ] &gt;&gt;</code>
<code>            ]</code>
<code>            /dlpkey [ [ (7040) ] ]</code>
<code>        &gt;&gt;</code>
<code>        (8004) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  6  /max  6  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (8005) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min 14  /max 14  /opt false  /linters [ /lintcsum ] &gt;&gt;</code>
<code>                &lt;&lt; /cset /N  /min  4  /max  4  /opt false  /linters [ /lintpieceoftotal ] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (01) (37) ]</code>
<code>            /dlpkey [ [ (22) (10) (21) ] ]</code>
<code>        &gt;&gt;</code>
<code>        (8006) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 34  /opt false  /linters [ /lintiban ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (415) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (8007) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  8  /max  8  /opt false  /linters [ /lintyymmddhh ] &gt;&gt;</code>
<code>                &lt;&lt; /cset /N  /min  1  /max  4  /opt true   /linters [ /lintmmoptss ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (02) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (8008) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 50  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (8009) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /Y  /min  1  /max 30  /opt false  /linters [ /lintkey ] &gt;&gt;</code>
<code>            ]</code>
<code>            /dlpkey [ [ (8011) ] ]</code>
<code>        &gt;&gt;</code>
<code>        (8010) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  1  /max 12  /opt false  /linters [ /lintnozeroprefix ] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (8010) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (8011) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 20  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] [ (8006) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (8012) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 25  /opt false  /linters [ /lintcsumalpha /lintkey ] &gt;&gt;</code>
<code>            ]</code>
<code>            /dlpkey [ ]</code>
<code>        &gt;&gt;</code>
<code>        (8013) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min 18  /max 18  /opt false  /linters [ /lintcsum /lintkey ] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (8018) ]</code>
<code>            /dlpkey [ [ (8019) ] ]</code>
<code>        &gt;&gt;</code>
<code>        (8017) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min 18  /max 18  /opt false  /linters [ /lintcsum /lintkey ] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (8017) ]</code>
<code>            /dlpkey [ [ (8019) ] ]</code>
<code>        &gt;&gt;</code>
<code>        (8018) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  1  /max 10  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (8017) ] [ (8018) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (8019) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 25  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (415) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (8020) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min 14  /max 14  /opt false  /linters [ /lintcsum ] &gt;&gt;</code>
<code>                &lt;&lt; /cset /N  /min  4  /max  4  /opt false  /linters [ /lintpieceoftotal ] &gt;&gt;</code>
<code>            ]</code>
<code>            /ex     [ (02) (8006) ]</code>
<code>            /req    [ [ [ (37) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (8026) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /Z  /min  1  /max 90  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (00) ] [ (01) ] [ (253) ] [ (255) ] [ (8003) ] [ (8004) ] [ (8006) ] [ (8010) ] [ (8017) ] [ (8018) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (8030) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 70  /opt false  /linters [ /lintcouponcode ] &gt;&gt;</code>
<code>            ]</code>
<code>        &gt;&gt;</code>
<code>        (8110) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /N  /min  4  /max  4  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (255) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (8111) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 70  /opt false  /linters [ /lintcouponposoffer ] &gt;&gt;</code>
<code>            ]</code>
<code>        &gt;&gt;</code>
<code>        (8112) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 70  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>            /req    [ [ [ (01) ] ] ]</code>
<code>        &gt;&gt;</code>
<code>        (8200) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 30  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>        &gt;&gt;</code>
<code>        (90) exch dup</code>
<code>        pop</code>
<code></code>
<code>        &lt;&lt;</code>
<code>            /parts [</code>
<code>                &lt;&lt; /cset /X  /min  1  /max 90  /opt false  /linters [] &gt;&gt;</code>
<code>            ]</code>
<code>        &gt;&gt;</code>
<code>        (91) exch dup</code>
<code>        (92) exch dup</code>
<code>        (93) exch dup</code>
<code>        (94) exch dup</code>
<code>        (95) exch dup</code>
<code>        (96) exch dup</code>
<code>        (97) exch dup</code>
<code>        (98) exch dup</code>
<code>        (99) exch dup</code>
<code>        pop</code>
<code></code>
<code>    &gt;&gt; def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Extract AIs and vals from provided GS1 data in the indicated format</code>
<code></code>
<code>    /ai eq {  % Bracketed AI element string</code>
<code></code>
<code>        % Parse out AIs and values</code>
<code>        (\() anchorsearch not {</code>
<code>            pop /bwipp.GS1aiMissingOpenParen (AIs must start with '\(') //raiseerror exec</code>
<code>        } if</code>
<code>        pop</code>
<code>        mark exch {  % loop</code>
<code>            dup () eq {pop exit} if</code>
<code>            (\)) search not {</code>
<code>                cleartomark /bwipp.GS1aiMissingCloseParen (AIs must end with '\)') //raiseerror exec</code>
<code>            } if</code>
<code>            exch pop exch</code>
<code>            (\() search { exch pop exch } { () } ifelse</code>
<code>        } loop</code>
<code>        counttomark dup 0 gt {dup 2 idiv 1 add -1 exch {-1 roll} for} {pop} ifelse</code>
<code>        counttomark 2 idiv array astore /ais exch def</code>
<code>        counttomark array astore [ exch {  % Expand ordinals of the form ^NNN to ASCII</code>
<code>            &lt;&lt; /parse parse /parseonly true /parsefnc false &gt;&gt; //parseinput exec</code>
<code>        } forall ] /vals exch def</code>
<code>        pop</code>
<code></code>
<code>    } {  % Digital Link URI</code>
<code></code>
<code>        % Validate and strip the scheme</code>
<code>        (http://) anchorsearch not {</code>
<code>        (https://) anchorsearch not {</code>
<code>            pop /bwipp.GS1dlURIbadScheme (Scheme must be http:// or https://) //raiseerror exec</code>
<code>        } if} if</code>
<code>        pop</code>
<code></code>
<code>        % Strip the domain</code>
<code>        (/) search not {</code>
<code>            pop /bwipp.GS1dlMissingDomainOrPathInfo (URI must contain a domain and path info) //raiseerror exec</code>
<code>        } if</code>
<code>        pop pop</code>
<code></code>
<code>        % Fragment delimits end of data</code>
<code>        (#) search {</code>
<code>            exch pop exch pop</code>
<code>        } if</code>
<code></code>
<code>        % Query parameter marker splits path info and query parameters</code>
<code>        (?) search not {</code>
<code>            () exch null exch</code>
<code>        } if</code>
<code>        /pp exch def</code>
<code>        pop</code>
<code>        /qp exch def</code>
<code></code>
<code>        % Find positions of character immediately following "/" in the path info</code>
<code>        mark 0</code>
<code>        0 pp {</code>
<code>            (/) search not {pop exit} if</code>
<code>            length 1 add exch pop 2 index add exch</code>
<code>        } loop</code>
<code>        counttomark 1 sub array astore /pipos exch def pop pop</code>
<code>        pipos length 1 le {</code>
<code>            /bwipp.GS1dlNoAIinfo (The path was too short to contain AI info) //raiseerror exec</code>
<code>        } if</code>
<code></code>
<code>        % Walk backwards to find the right-most path element that is a valid dlpkey</code>
<code>        false</code>
<code>        pipos length 2 sub -2 0 {</code>
<code>            dup</code>
<code>            dup pipos exch get</code>
<code>            exch pipos exch 1 add get 1 index sub 1 sub pp 3 1 roll getinterval</code>
<code>            dup gs1syntax exch known {</code>
<code>                gs1syntax exch get /dlpkey known {</code>
<code>                    exch pop true exit</code>
<code>                } if</code>
<code>            } {</code>
<code>                pop</code>
<code>            } ifelse</code>
<code>            pop</code>
<code>        } for</code>
<code>        not {</code>
<code>            /bwipp.GS1dlNoAIinfo (The path does not contain a valid primary key) //raiseerror exec</code>
<code>        } if</code>
<code>        pipos exch get dup pp length exch sub pp 3 1 roll getinterval /pp exch def</code>
<code></code>
<code>        /uriunescape {</code>
<code>            /qq exch def  % Is query parameter</code>
<code>            /in exch def</code>
<code>            /out in length string def</code>
<code>            0 0 {</code>
<code>                1 index in length ge {exit} if</code>
<code>                in 2 index get</code>
<code>                dup 43 eq qq and {  % "+" -&gt; " " in query params</code>
<code>                    pop out 1 index 32 put</code>
<code>                    1 add exch 1 add exch</code>
<code>                } {</code>
<code>                dup 37 eq 3 index in length 2 sub lt and {  % "%nn" -&gt; ord</code>
<code>                    pop</code>
<code>                    (&lt;  &gt;) 4 string copy dup 1 in 5 index 1 add 2 getinterval putinterval cvx</code>
<code>                    stopped {</code>
<code>                        pop pop /bwipp.GS1dlBadHexCharacter (Invalid hex character) //raiseerror exec</code>
<code>                    } if</code>
<code>                    0 get out exch 2 index exch put</code>
<code>                    1 add exch 3 add exch</code>
<code>                } {</code>
<code>                    out exch 2 index exch put</code>
<code>                    1 add exch 1 add exch</code>
<code>                } ifelse } ifelse</code>
<code>            } loop</code>
<code>            out exch 0 exch getinterval /out exch def</code>
<code>            pop</code>
<code>            out</code>
<code>        } def</code>
<code></code>
<code>        /isvaliddlpkeyseq {</code>
<code>            /in exch def</code>
<code>            false</code>
<code>            gs1syntax in 0 get get /dlpkey get {</code>
<code>                /seq exch def</code>
<code>                /i 1 def  /j 0 def</code>
<code>                {</code>
<code>                    i in length ge {exit} if</code>
<code>                    j seq length ge {exit} if</code>
<code>                    in i get seq j get eq {</code>
<code>                        /i i 1 add def</code>
<code>                    } if</code>
<code>                    /j j 1 add def</code>
<code>                } loop</code>
<code>                i in length eq {pop true exit} if</code>
<code>            } forall</code>
<code>        } def</code>
<code></code>
<code>        /ais 99 array def</code>
<code>        /vals 99 array def</code>
<code>        0</code>
<code></code>
<code>        % Extract AIs from the path components</code>
<code>        pp {</code>
<code>            (/) search {</code>
<code>                ais exch 4 index exch put</code>
<code>                pop</code>
<code>                (/) search {exch pop} {() exch} ifelse</code>
<code>                vals exch 3 index exch false uriunescape put</code>
<code>            } {</code>
<code>                pop exit</code>
<code>            } ifelse</code>
<code>            exch 1 add exch</code>
<code>        } loop</code>
<code>        dup /plen exch def</code>
<code></code>
<code>        % Validate the key-qualifiers in the path info sequence</code>
<code>        dup 1 gt {</code>
<code>            ais 0 plen getinterval isvaliddlpkeyseq not {</code>
<code>                pop /bwipp.GS1dlBadPathInfo (The AIs in the path are not a valid key-qualifier sequence for the key) //raiseerror exec</code>
<code>            } if</code>
<code>        } if</code>
<code></code>
<code>        % Extract AIs from the query parameters</code>
<code>        qp {</code>
<code>            dup () eq {pop exit} if</code>
<code>            (&amp;) search {exch pop} {() exch} ifelse</code>
<code>            (=) search {</code>
<code>                true 1 index {dup 48 ge exch 57 le and and} forall {</code>
<code>                    ais exch 5 index exch put</code>
<code>                    pop</code>
<code>                    vals exch 3 index exch true uriunescape put</code>
<code>                    exch 1 add exch</code>
<code>                } {  % Ignore non-numeric parameters</code>
<code>                    pop pop pop</code>
<code>                } ifelse</code>
<code>            } {  % Ignore singletons and empty parameters</code>
<code>                pop</code>
<code>            } ifelse</code>
<code>        } loop</code>
<code></code>
<code>        % Check for valid path info attributes in query params</code>
<code>        ais plen 2 index plen sub getinterval {</code>
<code>            plen -1 1 {  % Trial the query param at each non-initial path info position</code>
<code>                1 index [</code>
<code>                    ais 0 plen getinterval aload pop</code>
<code>                    counttomark 3 add -2 roll exch 1 roll</code>
<code>                ] isvaliddlpkeyseq {</code>
<code>                    exch pop</code>
<code>                    dup length dup 50 add string</code>
<code>                    dup 0 (AI \() putinterval</code>
<code>                    dup 4 4 index putinterval</code>
<code>                    dup 2 index 4 add (\) from query params should be in the path info) putinterval</code>
<code>                    exch pop exch pop /bwipp.GS1dlAttributeMustBeQualifier exch //raiseerror exec</code>
<code>                } if</code>
<code>            } for</code>
<code>            pop</code>
<code>        } forall</code>
<code></code>
<code>        /ais ais 0 3 index getinterval def</code>
<code>        /vals vals 0 3 index getinterval def</code>
<code>        pop</code>
<code></code>
<code>        % Expand any extracted GTINs</code>
<code>        0 1 ais length 1 sub {</code>
<code>            dup ais exch get (01) eq {</code>
<code>                dup vals exch get</code>
<code>                dup length dup 8 eq exch dup 12 eq exch 13 eq or or {</code>
<code>                    (00000000000000) 14 string copy dup 3 -1 roll dup length 14 exch sub exch putinterval</code>
<code>                    vals exch 2 index exch put</code>
<code>                } {</code>
<code>                    pop</code>
<code>                } ifelse</code>
<code>            } if</code>
<code>            pop</code>
<code>        } for</code>
<code></code>
<code>    } ifelse</code>
<code></code>
<code>    % AIs not requiring FNC1 separation</code>
<code>{</code>
<code>    /aifixed &lt;&lt; [</code>
<code>        (00) (01) (02) (03) (04)</code>
<code>        (11) (12) (13) (14) (15) (16) (17) (18) (19) (20)</code>
<code>        % (23)   % Reassigned to variable-length AI (235)!</code>
<code>        (31) (32) (33) (34) (35) (36)</code>
<code>        (41)</code>
<code>    ] {dup} forall &gt;&gt; def</code>
<code>} ctxdef</code>
<code></code>
<code>    /fncs [</code>
<code>        ais {</code>
<code>            true exch</code>
<code>            dup length 2 ge {</code>
<code>                0 2 getinterval aifixed exch known {pop false} if</code>
<code>            } {</code>
<code>                pop</code>
<code>            } ifelse</code>
<code>        } forall</code>
<code>    ] def</code>
<code></code>
<code></code>
<code>    % Linter routines for validating AI components</code>
<code>{</code>
<code>    /cset82 &lt;&lt;</code>
<code>        0 (!"%&amp;'\(\)*+,-./0123456789:;&lt;=&gt;?ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz)</code>
<code>        { exch dup 1 add } forall pop</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /cset39 &lt;&lt;</code>
<code>        0 (#-/0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ)</code>
<code>        { exch dup 1 add } forall pop</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /cset32 &lt;&lt;</code>
<code>        0 (23456789ABCDEFGHJKLMNPQRSTUVWXYZ)</code>
<code>        { exch dup 1 add } forall pop</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /cset64 &lt;&lt;</code>
<code>        0 (ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_)</code>
<code>        { exch dup 1 add } forall pop</code>
<code>    &gt;&gt; def</code>
<code>} ctxdef</code>
<code></code>
<code>    /lintnumeric {</code>
<code>        true exch { dup 48 lt exch 57 gt or { pop false exit } if } forall</code>
<code>        not { pop /bwipp.GS1notNumeric (Not numeric) false exit } if</code>
<code>    } def</code>
<code></code>
<code>    /lintcset82 {</code>
<code>        true exch { cset82 exch known not { pop false exit } if } forall</code>
<code>        not { pop /bwipp.GS1badCSET82character (Invalid CSET 82 character) false exit } if</code>
<code>    } def</code>
<code></code>
<code>    /lintcset39 {</code>
<code>        true exch { cset39 exch known not { pop false exit } if } forall</code>
<code>        not { pop /bwipp.GS1badCSET39character  (Invalid CSET 39 character) false exit } if</code>
<code>    } def</code>
<code></code>
<code>    /lintcset64 {</code>
<code>        % TODO Validate base64 padding rules</code>
<code>        true exch { dup cset64 exch known not exch 61 ne and { pop false exit } if } forall</code>
<code>        not { pop /bwipp.GS1badCSET64character  (Invalid CSET 64 character) false exit } if</code>
<code>    } def</code>
<code></code>
<code>    /lintkey {</code>
<code>        dup length 2 lt { pop pop /bwipp.GS1keyTooShort (Key is too short) false exit } if</code>
<code>        dup 0 get dup 48 lt exch 57 gt or exch</code>
<code>        1 get dup 48 lt exch 57 gt or or {</code>
<code>            pop /bwipp.GS1badGCP (Non-numeric company prefix) false exit</code>
<code>        } if</code>
<code>    } def</code>
<code></code>
<code>    /lintimporteridx {</code>
<code>        (-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz)</code>
<code>        exch search not {pop pop /bwipp.GS1badImporterIndex (Invalid importer index) false exit} if</code>
<code>        pop pop pop</code>
<code>    } def</code>
<code></code>
<code>    /lintcsum {</code>
<code>        mark exch</code>
<code>        dup length 2 mod 0 eq {3} {1} ifelse</code>
<code>        exch { 48 sub 1 index mul exch 4 exch sub } forall pop</code>
<code>        0 counttomark 1 sub {add} repeat exch pop</code>
<code>        10 mod 0 ne { pop /bwipp.GS1badChecksum (Bad checksum) false exit } if</code>
<code>    } def</code>
<code></code>
<code>    /lintcsumalpha {</code>
<code>        dup length 2 lt { pop pop /bwipp.GS1alphaTooShort (Alphanumeric string is too short to check) false exit} if</code>
<code>        dup length 2 sub</code>
<code>        2 copy</code>
<code>        0 exch getinterval mark exch {</code>
<code>            dup cset82 exch known { cset82 exch get } { -1 exit } ifelse</code>
<code>        } forall</code>
<code>        dup -1 eq { cleartomark pop pop pop /bwipp.GS1UnknownCSET82Character (Unknown CSET 82 character) false exit} if</code>
<code>        counttomark array astore exch pop</code>
<code>        3 1 roll</code>
<code>        2 getinterval mark exch {</code>
<code>            dup cset32 exch known { cset32 exch get } { -1 exit } ifelse</code>
<code>        } forall</code>
<code>        dup -1 eq { cleartomark pop pop /bwipp.GS1UnknownCSET32Character (Unknown CSET 32 character) false exit} if</code>
<code>        counttomark array astore exch pop</code>
<code>        dup 0 get 5 bitshift exch 1 get add exch</code>
<code>        [ 2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 ]</code>
<code>        1 index length</code>
<code>        dup 2 index length gt { pop pop pop pop pop /bwipp.GS1alphaTooLong (Alphanumeric string is too long to check) false exit} if</code>
<code>        0 exch getinterval {exch} forall</code>
<code>        0 exch { 3 -1 roll exch mul add } forall 1021 mod</code>
<code>        ne { pop /bwipp.GS1badAlphaCheckCharacters (Bad alphanumeric check characters) false exit} if</code>
<code>    } def</code>
<code></code>
<code>{</code>
<code>    /iso3166 &lt;&lt; [</code>
<code>        /004 /008 /010 /012 /016 /020 /024 /028 /031 /032 /036 /040 /044 /048</code>
<code>        /050 /051 /052 /056 /060 /064 /068 /070 /072 /074 /076 /084 /086 /090 /092 /096</code>
<code>        /100 /104 /108 /112 /116 /120 /124 /132 /136 /140 /144 /148</code>
<code>        /152 /156 /158 /162 /166 /170 /174 /175 /178 /180 /184 /188 /191 /192 /196</code>
<code>        /203 /204 /208 /212 /214 /218 /222 /226 /231 /232 /233 /234 /238 /239 /242 /246 /248</code>
<code>        /250 /254 /258 /260 /262 /266 /268 /270 /275 /276 /288 /292 /296</code>
<code>        /300 /304 /308 /312 /316 /320 /324 /328 /332 /334 /336 /340 /344 /348</code>
<code>        /352 /356 /360 /364 /368 /372 /376 /380 /384 /388 /392 /398</code>
<code>        /400 /404 /408 /410 /414 /417 /418 /422 /426 /428 /430 /434 /438 /440 /442 /446</code>
<code>        /450 /454 /458 /462 /466 /470 /474 /478 /480 /484 /492 /496 /498 /499</code>
<code>        /500 /504 /508 /512 /516 /520 /524 /528 /531 /533 /534 /535 /540 /548</code>
<code>        /554 /558 /562 /566 /570 /574 /578 /580 /581 /583 /584 /585 /586 /591 /598</code>
<code>        /600 /604 /608 /612 /616 /620 /624 /626 /630 /634 /638 /642 /643 /646</code>
<code>        /652 /654 /659 /660 /662 /663 /666 /670 /674 /678 /682 /686 /688 /690 /694</code>
<code>        /702 /703 /704 /705 /706 /710 /716 /724 /728 /729 /732 /740 /744 /748</code>
<code>        /752 /756 /760 /762 /764 /768 /772 /776 /780 /784 /788 /792 /795 /796 /798</code>
<code>        /800 /804 /807 /818 /826 /831 /832 /833 /834 /840</code>
<code>        /850 /854 /858 /860 /862 /876 /882 /887 /894</code>
<code>    ] {dup} forall &gt;&gt; def</code>
<code>} ctxdef</code>
<code></code>
<code>    /lintiso3166 {</code>
<code>        iso3166 exch known not { pop /bwipp.GS1UnknownCountry (Unknown country code) false exit } if</code>
<code>    } def</code>
<code></code>
<code>    /lintiso3166999 {</code>
<code>        dup /999 ne {</code>
<code>            iso3166 exch known not { pop /bwipp.GS1UnknownCountryOr999 (Unknown country code or not 999) false exit } if</code>
<code>        } {</code>
<code>            pop</code>
<code>        } ifelse</code>
<code>    } def</code>
<code></code>
<code>    /lintiso3166list {</code>
<code>        dup length 3 mod 0 ne {</code>
<code>            pop pop /bwipp.GS1BadCountryListLength (Not a group of three-digit country codes) false exit</code>
<code>        } if</code>
<code>        true</code>
<code>        0 3 3 index length 1 sub {</code>
<code>            2 index exch 3 getinterval</code>
<code>            iso3166 exch known not { pop pop false exit } if</code>
<code>        } for</code>
<code>        not { pop /bwipp.GS1UnknownCountry (Unknown country code) false exit } if</code>
<code>        pop</code>
<code>    } def</code>
<code></code>
<code>{</code>
<code>    /iso3166alpha2 &lt;&lt; [</code>
<code>        /AD /AE /AF /AG /AI /AL /AM /AO /AQ /AR /AS /AT /AU /AW /AX /AZ</code>
<code>        /BA /BB /BD /BE /BF /BG /BH /BI /BJ /BL /BM /BN /BO /BQ /BR /BS /BT /BV /BW /BY /BZ</code>
<code>        /CA /CC /CD /CF /CG /CH /CI /CK /CL /CM /CN /CO /CR /CU /CV /CW /CX /CY /CZ</code>
<code>        /DE /DJ /DK /DM /DO /DZ</code>
<code>        /EC /EE /EG /EH /ER /ES /ET</code>
<code>        /FI /FJ /FK /FM /FO /FR</code>
<code>        /GA /GB /GD /GE /GF /GG /GH /GI /GL /GM /GN /GP /GQ /GR /GS /GT /GU /GW /GY</code>
<code>        /HK /HM /HN /HR /HT /HU</code>
<code>        /ID /IE /IL /IM /IN /IO /IQ /IR /IS /IT /JE /JM /JO /JP</code>
<code>        /KE /KG /KH /KI /KM /KN /KP /KR /KW /KY /KZ</code>
<code>        /LA /LB /LC /LI /LK /LR /LS /LT /LU /LV /LY</code>
<code>        /MA /MC /MD /ME /MF /MG /MH /MK /ML /MM /MN /MO /MP /MQ /MR /MS /MT /MU /MV /MW /MX /MY /MZ</code>
<code>        /NA /NC /NE /NF /NG /NI /NL /NO /NP /NR /NU /NZ</code>
<code>        /OM</code>
<code>        /PA /PE /PF /PG /PH /PK /PL /PM /PN /PR /PS /PT /PW /PY</code>
<code>        /QA</code>
<code>        /RE /RO /RS /RU /RW</code>
<code>        /SA /SB /SC /SD /SE /SG /SH /SI /SJ /SK /SL /SM /SN /SO /SR /SS /ST /SV /SX /SY /SZ</code>
<code>        /TC /TD /TF /TG /TH /TJ /TK /TL /TM /TN /TO /TR /TT /TV /TW /TZ</code>
<code>        /UA /UG /UM /US /UY /UZ</code>
<code>        /VA /VC /VE /VG /VI /VN /VU</code>
<code>        /WF /WS</code>
<code>        /YE /YT</code>
<code>        /ZA /ZM /ZW</code>
<code>    ] {dup} forall &gt;&gt; def</code>
<code>} ctxdef</code>
<code></code>
<code>    /lintiso3166alpha2 {</code>
<code>        iso3166alpha2 exch known not { pop /bwipp.GS1UnknownCountryAlpha (Unknown country alpha code) false exit } if</code>
<code>    } def</code>
<code></code>
<code>{</code>
<code>    /iso4217 &lt;&lt; [</code>
<code>        /008 /012 /032 /036 /044 /048</code>
<code>        /050 /051 /052 /060 /064 /068 /072 /084 /090 /096</code>
<code>        /104 /108 /116 /124 /132 /136 /144</code>
<code>        /152 /156 /170 /174 /188 /191 /192</code>
<code>        /203 /208 /214 /222 /230 /232 /238 /242 /262 /270 /292</code>
<code>        /320 /324 /328 /332 /340 /344 /348</code>
<code>        /352 /356 /360 /364 /368 /376 /388 /392 /398</code>
<code>        /400 /404 /408 /410 /414 /417 /418</code>
<code>        /422 /426 /430 /434 /446</code>
<code>        /454 /458 /462 /480 /484 /496 /498</code>
<code>        /504 /512 /516 /524 /532 /533 /548</code>
<code>        /554 /558 /566 /578 /586 /590 /598</code>
<code>        /600 /604 /608 /634 /643 /646 /654 /682 /690 /694</code>
<code>        /702 /704 /706 /710 /728 /748</code>
<code>        /752 /756 /760 /764 /776 /780 /784 /788</code>
<code>        /800 /807 /818 /826 /834 /840 /858 /860 /882 /886</code>
<code>        /901 /925 /927 /928 /929 /930 /931 /932 /933 /934 /936 /938</code>
<code>        /940 /941 /943 /944 /946 /947 /948 /949</code>
<code>        /950 /951 /952 /953 /955 /956 /957 /958 /959</code>
<code>        /960 /961 /962 /963 /964 /965 /967 /968 /969</code>
<code>        /970 /971 /972 /973 /975 /976 /977 /978 /979</code>
<code>        /980 /981 /984 /985 /986 /990 /994 /997 /999</code>
<code>    ] {dup} forall &gt;&gt; def</code>
<code>} ctxdef</code>
<code></code>
<code>    /lintiso4217 {</code>
<code>        iso4217 exch known not { pop /bwipp.GS1UnknownCurrency (Unknown currency code) false exit } if</code>
<code>    } def</code>
<code></code>
<code>    /lintiban {</code>
<code>        dup length 4 le { pop pop /bwipp.GS1tooShort (IBAN too short) false exit } if</code>
<code>        dup true exch {</code>
<code>            1 string dup 0 4 -1 roll put</code>
<code>            (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ)</code>
<code>            exch search not { pop pop false exit } if</code>
<code>            pop pop pop</code>
<code>        } forall</code>
<code>        not { pop /bwipp.GS1badIBANcharacter (Invalid IBAN character) false exit } if</code>
<code>        dup mark exch mark exch {} forall counttomark -4 roll counttomark array astore exch pop {</code>
<code>            48 sub dup 9 gt {7 sub dup 10 idiv exch 10 mod} if</code>
<code>        } forall counttomark array astore exch pop</code>
<code>        0 exch {exch 10 mul add 97 mod} forall</code>
<code>        1 ne { pop pop /bwipp.GS1badIBANchecksum (IBAN checksum incorrect) false exit } if</code>
<code>        0 2 getinterval lintiso3166alpha2</code>
<code>    } def</code>
<code></code>
<code>    /lintzero {</code>
<code>        (0) ne { pop /bwipp.GS1zeroRequired (Zero is required) false exit } if</code>
<code>    } def</code>
<code></code>
<code>    /lintnonzero {</code>
<code>        false exch { 48 ne {pop true} if } forall</code>
<code>        not { pop /bwipp.GS1zeroNotPermitted (Zero not permitted) false exit } if</code>
<code>    } def</code>
<code></code>
<code>    /lintnozeroprefix {</code>
<code>        dup length 1 gt exch 0 get 48 eq and {</code>
<code>            pop /bwipp.GS1badZeroPrefix (Zero prefix is not permitted) false exit</code>
<code>        } if</code>
<code>    } def</code>
<code></code>
<code>    /lintyymmd0 {</code>
<code>        dup 2 2 getinterval cvi dup 1 lt exch 12 gt or { pop /bwipp.GS1badMonth (Invalid month) false exit } if</code>
<code>        dup 0 2 getinterval cvi dup  21  sub  % Update 20YY periodically for century calculation</code>
<code>        dup 51 ge {pop 1900 add} { -50 le {2100 add} {2000 add} ifelse} ifelse  % YYYY</code>
<code>        dup 400 mod 0 eq exch dup 4 mod 0 eq exch 100 mod 0 ne and or           % Leap year?</code>
<code>        [ 31  3 -1 roll {29} {28} ifelse  31 30 31 30 31 31 30 31 30 31 ]</code>
<code>        1 index 2 2 getinterval cvi 1 sub get</code>
<code>        exch 4 2 getinterval cvi lt { pop /bwipp.GS1badDay (Invalid day of month) false exit } if</code>
<code>    } def</code>
<code></code>
<code>    /lintyymmdd {</code>
<code>        dup length 6 ne { pop /bwipp.GS1badDateLength (Invalid length for date) false exit } if</code>
<code>        dup 4 2 getinterval cvi 1 lt { pop /bwipp.GS1badDay (Invalid day of month) false exit } if</code>
<code>        lintyymmd0</code>
<code>    } def</code>
<code></code>
<code>    /lintyymmddhh {</code>
<code>        dup length 8 ne { pop /bwipp.GS1badYYMMDDHHLength (Invalid length for date with hour) false exit } if</code>
<code>        dup 6 2 getinterval cvi 23 gt { pop pop /bwipp.GS1badHour (Invalid hour of day) false exit } if</code>
<code>        0 6 getinterval lintyymmdd</code>
<code>    } def</code>
<code></code>
<code>    /linthhmm {</code>
<code>        dup 0 2 getinterval cvi 23 gt { pop pop /bwipp.GS1badHour (Invalid hour of day) false exit } if</code>
<code>        2 2 getinterval cvi 59 gt { pop /bwipp.GS1badMinute (Invalid minute in the hour) false exit } if</code>
<code>    } def</code>
<code></code>
<code>    /lintmmoptss {</code>
<code>        dup length dup 2 ne exch 4 ne and {</code>
<code>            pop /bwipp.GS1badTimeLength (Invalid length for optional minutes and seconds) false exit</code>
<code>        } if</code>
<code>        dup 0 2 getinterval cvi 59 gt { pop pop /bwipp.GS1badMinute (Invalid minute in the hour) false exit } if</code>
<code>        dup length 4 ge {</code>
<code>            dup 2 2 getinterval cvi 59 gt { pop pop /bwipp.GS1badSecond (Invalid second in the minute) false exit } if</code>
<code>        } if</code>
<code>        pop</code>
<code>    } def</code>
<code></code>
<code>    /lintyesno {</code>
<code>        dup (0) ne exch (1) ne and {</code>
<code>            pop /bwipp.GS1badBoolean (Neither 0 nor 1 for yes or no) false exit</code>
<code>        } if</code>
<code>    } def</code>
<code></code>
<code>    /lintwinding {</code>
<code>        dup (0) ne exch dup (1) ne exch (9) ne and and {</code>
<code>            pop /bwipp.GS1badWinding (Invalid winding direction) false exit</code>
<code>        } if</code>
<code>    } def</code>
<code></code>
<code>    /lintpieceoftotal {</code>
<code>        dup length 2 mod 0 ne { pop pop /bwipp.GS1badPieceTotalLength (Invalid piece/total length) false exit } if</code>
<code>        dup dup length 2 idiv 0 exch getinterval cvi</code>
<code>        dup 0 eq { pop pop pop /bwipp.GS1badPieceNumber (Invalid piece number) false exit } if</code>
<code>        exch dup length 2 idiv dup getinterval cvi</code>
<code>        dup 0 eq { pop pop pop /bwipp.GS1badPieceTotal (Invalid total number) false exit } if</code>
<code>        gt { pop /bwipp.GS1pieceExceedsTotal (Piece number exceeds total) false exit } if</code>
<code>    } def</code>
<code></code>
<code>    /lintpcenc {</code>
<code>        {</code>
<code>            (%) search not {pop exit} if</code>
<code>            pop pop dup length 2 lt { pop pop /bwipp.GS1badPercentEscape (Invalid % escape) false exit } if</code>
<code>            dup 0 2 getinterval true exch {</code>
<code>                1 string dup 0 4 -1 roll put</code>
<code>                (0123456789ABCDEFabcdef)</code>
<code>                exch search not { pop pop false exit } if</code>
<code>                pop pop pop</code>
<code>            } forall</code>
<code>            not { pop pop /bwipp.GS1badPercentChars (Invalid characters for percent encoding) false exit } if</code>
<code>        } loop</code>
<code>    } def</code>
<code></code>
<code>    /lintcouponcode {</code>
<code>        dup true exch {</code>
<code>            dup 48 lt exch 57 gt or { pop false exit } if</code>
<code>        } forall</code>
<code>        not { pop pop /bwipp.GS1couponNotNumeric (Coupon not numeric) false exit } if</code>
<code></code>
<code>        % GCP VLI and value</code>
<code>        dup length 1 lt {</code>
<code>            pop pop /bwipp.GS1couponTooShortGCPVLI (Coupon too short: Missing GCP VLI) false exit</code>
<code>        } if</code>
<code>        dup 0 1 getinterval cvi dup 6 gt {</code>
<code>            pop pop /bwipp.GS1couponBadGCPVLI (Coupon GCP length indicator must be 0-6) false exit</code>
<code>        } if</code>
<code>        6 add 1 add</code>
<code>        2 copy exch length gt {</code>
<code>            pop pop pop /bwipp.GS1couponTooShortGCP (Coupon too short: GCP truncated) false exit</code>
<code>        } if</code>
<code>        dup 2 index length exch sub getinterval</code>
<code></code>
<code>        % Offer Code</code>
<code>        dup length 6 lt {</code>
<code>            pop pop /bwipp.GS1couponTooShortOfferCode (Coupon too short: Offer Code truncated) false exit</code>
<code>        } if</code>
<code>        dup length 6 sub 6 exch getinterval</code>
<code></code>
<code>        % Save Value VLI and value</code>
<code>        dup length 1 lt {</code>
<code>            pop pop /bwipp.GS1couponTooShortSaveValueVLI (Coupon too short: Missing Save Value VLI) false exit</code>
<code>        } if</code>
<code>        dup 0 1 getinterval cvi dup dup 1 lt exch 5 gt or {</code>
<code>            pop pop /bwipp.GS1couponBadSaveValueVLI (Coupon Save Value length indicator must be 1-5) false exit</code>
<code>        } if</code>
<code>        1 add</code>
<code>        2 copy exch length gt {</code>
<code>            pop pop pop /bwipp.GS1couponTooShortSaveValue (Coupon too short: Save Value truncated) false exit</code>
<code>        } if</code>
<code>        dup 2 index length exch sub getinterval</code>
<code></code>
<code>        % 1st Purchase Requirement VLI and value</code>
<code>        dup length 1 lt {</code>
<code>            pop pop /bwipp.GS1couponTooShort1stPurchaseRequirementVLI (Coupon too short: Missing 1st Purchase Requirement VLI) false exit</code>
<code>        } if</code>
<code>        dup 0 1 getinterval cvi dup dup 1 lt exch 5 gt or {</code>
<code>            pop pop /bwipp.GS1couponBad1stPurchaseRequirementVLI (Coupon 1st Purchase Requirement length indicator must be 1-5) false exit</code>
<code>        } if</code>
<code>        1 add</code>
<code>        2 copy exch length gt {</code>
<code>            pop pop pop /bwipp.GS1couponTooShort1stPurchaseRequirement (Coupon too short: 1st Purchase Requirement truncated) false exit</code>
<code>        } if</code>
<code>        dup 2 index length exch sub getinterval</code>
<code></code>
<code>        % 1st Purchase Requirement Code</code>
<code>        dup length 1 lt {</code>
<code>            pop pop /bwipp.GS1couponTooShort1stPurchaseRequirementCode (Coupon too short: Missing 1st Purchase Requirement Code) false exit</code>
<code>        } if</code>
<code>        dup 0 1 getinterval cvi dup 4 gt exch 9 ne and {</code>
<code>            pop pop /bwipp.GS1couponBad1stPurchaseRequirementCode (Coupon 1st Purchase Requirement Code must be 0-4 or 9) false exit</code>
<code>        } if</code>
<code>        dup length 1 sub 1 exch getinterval</code>
<code></code>
<code>        % 1st Purchase Family Code</code>
<code>        dup length 3 lt {</code>
<code>            pop pop /bwipp.GS1couponTooShort1stPurchaseFamilyCode (Coupon too short: 1st Purchase Family Code truncated) false exit</code>
<code>        } if</code>
<code>        dup length 3 sub 3 exch getinterval</code>
<code></code>
<code>        % Optional field 1</code>
<code>        dup length 1 ge { dup 0 1 getinterval cvi 1 eq {</code>
<code>            1 dup 2 index length exch sub getinterval</code>
<code></code>
<code>            % Additional Purchase Rules Code</code>
<code>            dup length 1 lt {</code>
<code>                pop pop /bwipp.GS1couponTooShortAdditionalPurchaseRulesCode (Coupon too short: Missing Additional Purchase Rules Code) false exit</code>
<code>            } if</code>
<code>            dup 0 1 getinterval cvi 3 gt {</code>
<code>                pop pop /bwipp.GS1couponBadAdditionalPurchaseRulesCode (Coupon Additional Purchase Rules Code must be 0-3) false exit</code>
<code>            } if</code>
<code>            dup length 1 sub 1 exch getinterval</code>
<code></code>
<code>            % 2nd Purchase RequirementVLI and value</code>
<code>            dup length 1 lt {</code>
<code>                pop pop /bwipp.GS1couponTooShort2ndPurchaseRequirementVLI (Coupon too short: Missing 2nd Purchase Requirement VLI) false exit</code>
<code>            } if</code>
<code>            dup 0 1 getinterval cvi dup dup 1 lt exch 5 gt or {</code>
<code>                pop pop /bwipp.GS1couponBad2ndPurchaseRequirementVLI (Coupon 2nd Purchase Requirement length indicator must be 1-5) false exit</code>
<code>            } if</code>
<code>            1 add</code>
<code>            2 copy exch length gt {</code>
<code>                pop pop pop /bwipp.GS1couponTooShort2ndPurchaseRequirement (Coupon too short: 2nd Purchase Requirement truncated) false exit</code>
<code>            } if</code>
<code>            dup 2 index length exch sub getinterval</code>
<code></code>
<code>            % 2nd Purchase Requirement Code</code>
<code>            dup length 1 lt {</code>
<code>                pop pop /bwipp.GS1couponTooShort2ndPurchaseRequirementCode (Coupon too short: Missing 2nd Purchase Requirement Code) false exit</code>
<code>            } if</code>
<code>            dup 0 1 getinterval cvi dup 4 gt exch 9 ne and {</code>
<code>                pop pop /bwipp.GS1couponBad2ndPurchaseRequirementCode (Coupon 2nd Purchase Requirement Code must be 0-4 or 9) false exit</code>
<code>            } if</code>
<code>            dup length 1 sub 1 exch getinterval</code>
<code></code>
<code>            % 2nd Purchase Family Code</code>
<code>            dup length 3 lt {</code>
<code>                pop pop /bwipp.GS1couponTooShort2ndPurchaseFamilyCode (Coupon too short: 2nd Purchase Family Code truncated) false exit</code>
<code>            } if</code>
<code>            dup length 3 sub 3 exch getinterval</code>
<code></code>
<code>            % 2nd Purchase GCP VLI and value</code>
<code>            dup length 1 lt {</code>
<code>                pop pop /bwipp.GS1couponTooShort2ndPurchaseGCPVLI (Coupon too short: Missing 2nd Purchase GCP VLI) false exit</code>
<code>            } if</code>
<code>            dup 0 1 getinterval cvi dup dup 6 gt exch 9 ne and {</code>
<code>                pop pop /bwipp.GS1couponBad2ndPurchaseGCPVLI (Coupon 2nd Purchase GCP length indicator must be 0-6 or 9) false exit</code>
<code>            } if</code>
<code>            dup 9 ne {6 add} {pop 0} ifelse 1 add</code>
<code>            2 copy exch length gt {</code>
<code>                pop pop pop /bwipp.GS1couponTooShort2ndPurchaseGCP (Coupon too short: 2nd Purchase GCP truncated) false exit</code>
<code>            } if</code>
<code>            dup 2 index length exch sub getinterval</code>
<code></code>
<code>        } if } if</code>
<code></code>
<code>        % Optional field 2</code>
<code>        dup length 1 ge { dup 0 1 getinterval cvi 2 eq {</code>
<code>            1 dup 2 index length exch sub getinterval</code>
<code></code>
<code>            % 3rd Purchase RequirementVLI and value</code>
<code>            dup length 1 lt {</code>
<code>                pop pop /bwipp.GS1couponTooShort3rdPurchaseRequirementVLI (Coupon too short: Missing 3rd Purchase Requirement VLI) false exit</code>
<code>            } if</code>
<code>            dup 0 1 getinterval cvi dup dup 1 lt exch 5 gt or {</code>
<code>                pop pop /bwipp.GS1couponBad3rdPurchaseRequirementVLI (Coupon 3rd Purchase Requirement length indicator must be 1-5) false exit</code>
<code>            } if</code>
<code>            1 add</code>
<code>            2 copy exch length gt {</code>
<code>                pop pop pop /bwipp.GS1couponTooShort3rdPurchaseRequirement (Coupon too short: 3rd Purchase Requirement truncated) false exit</code>
<code>            } if</code>
<code>            dup 2 index length exch sub getinterval</code>
<code></code>
<code>            % 3rd Purchase Requirement Code</code>
<code>            dup length 1 lt {</code>
<code>                pop pop /bwipp.GS1couponTooShort3rdPurchaseRequirementCode (Coupon too short: Missing 3rd Purchase Requirement Code) false exit</code>
<code>            } if</code>
<code>            dup 0 1 getinterval cvi dup 4 gt exch 9 ne and {</code>
<code>                pop pop /bwipp.GS1couponBad3rdPurchaseRequirementCode (Coupon 3rd Purchase Requirement Code must be 0-4 or 9) false exit</code>
<code>            } if</code>
<code>            dup length 1 sub 1 exch getinterval</code>
<code></code>
<code>            % 3rd Purchase Family Code</code>
<code>            dup length 3 lt {</code>
<code>                pop pop /bwipp.GS1couponTooShort3rdPurchaseFamilyCode (Coupon too short: 3rd Purchase Family Code truncated) false exit</code>
<code>            } if</code>
<code>            dup length 3 sub 3 exch getinterval</code>
<code></code>
<code>            % 3rd Purchase GCP VLI and value</code>
<code>            dup length 1 lt {</code>
<code>                pop pop /bwipp.GS1couponTooShort3rdPurchaseGCPVLI (Coupon too short: Missing 3rd Purchase GCP VLI) false exit</code>
<code>            } if</code>
<code>            dup 0 1 getinterval cvi dup dup 6 gt exch 9 ne and {</code>
<code>                pop pop /bwipp.GS1couponBad3rdPurchaseGCPVLI (Coupon 3rd Purchase GCP length indicator must be 0-6 or 9) false exit</code>
<code>            } if</code>
<code>            dup 9 ne {6 add} {pop 0} ifelse 1 add</code>
<code>            2 copy exch length gt {</code>
<code>                pop pop pop /bwipp.GS1couponTooShort3rdPurchaseGCP (Coupon too short: 3rd Purchase GCP truncated) false exit</code>
<code>            } if</code>
<code>            dup 2 index length exch sub getinterval</code>
<code></code>
<code>        } if } if</code>
<code></code>
<code>        % Optional field 3</code>
<code>        /couponexpire -1 def</code>
<code>        dup length 1 ge { dup 0 1 getinterval cvi 3 eq {</code>
<code>            1 dup 2 index length exch sub getinterval</code>
<code></code>
<code>            % Expiration date</code>
<code>            dup length 6 lt {</code>
<code>                pop pop /bwipp.GS1couponTooShortExpirationDate (Coupon too short: Expiration date) false exit</code>
<code>            } if</code>
<code>            dup 2 2 getinterval cvi dup 1 lt exch 12 gt or { pop pop /bwipp.GS1couponExpirationDateBadMonth (Invalid month in expiration date) false exit } if</code>
<code>            dup 0 2 getinterval cvi dup 21 sub  % Update 20YY periodically for century calculation</code>
<code>            dup 51 ge {pop 1900 add} { -50 le {2100 add} {2000 add} ifelse} ifelse  % YYYY</code>
<code>            dup 400 mod 0 eq exch dup 4 mod 0 eq exch 100 mod 0 ne and or           % Leap year?</code>
<code>            [ 31  3 -1 roll {29} {28} ifelse  31 30 31 30 31 31 30 31 30 31 ]</code>
<code>            1 index 2 2 getinterval cvi 1 sub get</code>
<code>            1 index 4 2 getinterval cvi dup 3 1 roll lt</code>
<code>            exch 1 lt or { pop pop /bwipp.GS1couponExpirationDateBadDay (Invalid day of month in expiration date) false exit } if</code>
<code>            dup 0 6 getinterval cvi /couponexpire exch def</code>
<code>            dup length 6 sub 6 exch getinterval</code>
<code></code>
<code>        } if } if</code>
<code></code>
<code>        % Optional field 4</code>
<code>        dup length 1 ge { dup 0 1 getinterval cvi 4 eq {</code>
<code>            1 dup 2 index length exch sub getinterval</code>
<code></code>
<code>            % Start date</code>
<code>            dup length 6 lt {</code>
<code>                pop pop /bwipp.GS1couponTooShortStartDate (Coupon too short: Start date) false exit</code>
<code>            } if</code>
<code>            dup 2 2 getinterval cvi dup 1 lt exch 12 gt or { pop pop /bwipp.GS1couponStartDateBadMonth (Invalid month in start date) false exit } if</code>
<code>            dup 0 2 getinterval cvi dup 21 sub  % Update 20YY periodically for century calculation</code>
<code>            dup 51 ge {pop 1900 add} { -50 le {2100 add} {2000 add} ifelse} ifelse  % YYYY</code>
<code>            dup 400 mod 0 eq exch dup 4 mod 0 eq exch 100 mod 0 ne and or           % Leap year?</code>
<code>            [ 31  3 -1 roll {29} {28} ifelse  31 30 31 30 31 31 30 31 30 31 ]</code>
<code>            1 index 2 2 getinterval cvi 1 sub get</code>
<code>            1 index 4 2 getinterval cvi dup 3 1 roll lt</code>
<code>            exch 1 lt or { pop pop /bwipp.GS1couponStartDateBadDay (Invalid day of month in start date) false exit } if</code>
<code>            dup 0 6 getinterval cvi /couponstart exch def</code>
<code>            couponexpire -1 ne couponexpire couponstart lt and {</code>
<code>                pop pop /bwipp.GS1couponExpireDateBeforeStartDate (Coupon expires before it starts) false exit</code>
<code>            } if</code>
<code>            dup length 6 sub 6 exch getinterval</code>
<code></code>
<code>        } if } if</code>
<code></code>
<code>        % Optional field 5</code>
<code>        dup length 1 ge { dup 0 1 getinterval cvi 5 eq {</code>
<code>            1 dup 2 index length exch sub getinterval</code>
<code></code>
<code>            % Serial Number VLI and value</code>
<code>            dup length 1 lt {</code>
<code>                pop pop /bwipp.GS1couponTooShortSerialNumberVLI (Coupon too short: Missing Serial Number VLI) false exit</code>
<code>            } if</code>
<code>            dup 0 1 getinterval cvi 6 add 1 add</code>
<code>            2 copy exch length gt {</code>
<code>                pop pop pop /bwipp.GS1couponTooShortSerialNumber (Coupon too short: Serial Number truncated) false exit</code>
<code>            } if</code>
<code>            dup 2 index length exch sub getinterval</code>
<code></code>
<code>        } if } if</code>
<code></code>
<code>        % Optional field 6</code>
<code>        dup length 1 ge { dup 0 1 getinterval cvi 6 eq {</code>
<code>            1 dup 2 index length exch sub getinterval</code>
<code></code>
<code>            % Retailer GCP/GLN VLI and value</code>
<code>            dup length 1 lt {</code>
<code>                pop pop /bwipp.GS1couponTooShortRetailerGCPGLNVLI (Coupon too short: Missing Retailer GCP/GLN VLI) false exit</code>
<code>            } if</code>
<code>            dup 0 1 getinterval cvi dup dup 1 lt exch 7 gt or {</code>
<code>                pop pop /bwipp.GS1couponBadRetailerGCPGLNVLI (Coupon Retailer GCP/GLN length indicator must be 1-7) false exit</code>
<code>            } if</code>
<code>            6 add 1 add</code>
<code>            2 copy exch length gt {</code>
<code>                pop pop pop /bwipp.GS1couponTooShortRetailerGCPGLN (Coupon too short: Retailer GCP/GLN truncated) false exit</code>
<code>            } if</code>
<code>            dup 2 index length exch sub getinterval</code>
<code></code>
<code>        } if } if</code>
<code></code>
<code>        % Optional field 9</code>
<code>        dup length 1 ge { dup 0 1 getinterval cvi 9 eq {</code>
<code>            1 dup 2 index length exch sub getinterval</code>
<code></code>
<code>            % Save Value Code</code>
<code>            dup length 1 lt {</code>
<code>                pop pop /bwipp.GS1couponTooShortSaveValueCode (Coupon too short: Missing Save Value Code) false exit</code>
<code>            } if</code>
<code>            dup 0 1 getinterval cvi dup 6 gt exch dup 3 eq exch 4 eq or or {</code>
<code>                pop pop /bwipp.GS1couponBadSaveValueCode (Coupon Save Value Code must be 0,1,2,5 or 6) false exit</code>
<code>            } if</code>
<code>            dup length 1 sub 1 exch getinterval</code>
<code></code>
<code>            % Save Value Applies to Item</code>
<code>            dup length 1 lt {</code>
<code>                pop pop /bwipp.GS1couponTooShortSaveValueAppliesToItem (Coupon too short: Missing Save Value Applies to Item) false exit</code>
<code>            } if</code>
<code>            dup 0 1 getinterval cvi 2 gt {</code>
<code>                pop pop /bwipp.GS1couponBadSaveValueAppliesToItem (Coupon Save Value Applies to Item must be 0-2) false exit</code>
<code>            } if</code>
<code>            dup length 1 sub 1 exch getinterval</code>
<code></code>
<code>            % Store Coupon Flag</code>
<code>            dup length 1 lt {</code>
<code>                pop pop /bwipp.GS1couponTooShortStoreCouponFlag (Coupon too short: Missing Store Coupon Flag) false exit</code>
<code>            } if</code>
<code>            dup length 1 sub 1 exch getinterval</code>
<code></code>
<code>            % Don't Multiply Flag</code>
<code>            dup length 1 lt {</code>
<code>                pop pop /bwipp.GS1couponTooShortDontMultiplyFlag (Coupon too short: Missing Don't Multiply Flag) false exit</code>
<code>            } if</code>
<code>            dup 0 1 getinterval cvi 1 gt {</code>
<code>                pop pop /bwipp.GS1couponBadDontMultiplyFlag (Don't Multiply Flag must be 0 or 1) false exit</code>
<code>            } if</code>
<code>            dup length 1 sub 1 exch getinterval</code>
<code></code>
<code>        } if } if</code>
<code></code>
<code>        dup length 0 ne {</code>
<code>            pop pop /bwipp.GS1couponUnrecognisedOptionalField (Coupon fields must be 1,2,3,4,5,6 or 9, increasing order) false exit</code>
<code>        } if</code>
<code>        pop</code>
<code>    } def</code>
<code></code>
<code>    /lintcouponposoffer {</code>
<code>        dup true exch {</code>
<code>            dup 48 lt exch 57 gt or { pop false exit } if</code>
<code>        } forall</code>
<code>        not { pop pop /bwipp.GS1couponNotNumeric (Coupon not numeric) false exit } if</code>
<code>        % Format Code</code>
<code>        dup length 1 lt {</code>
<code>            pop pop /bwipp.GS1couponTooShortFormatCode (Coupon too short: Missing Format Code) false exit</code>
<code>        } if</code>
<code>        dup 0 1 getinterval dup (0) ne exch (1) ne and {</code>
<code>            pop pop /bwipp.GS1couponBadFormatCode (Coupon format must be 0 or 1) false exit</code>
<code>        } if</code>
<code>        dup length 1 sub 1 exch getinterval</code>
<code>        % Funder ID VLI and Funder ID</code>
<code>        dup length 1 lt {</code>
<code>            pop pop /bwipp.GS1couponTooShortFunderVLI (Coupon too short: Missing Funder VLI) false exit</code>
<code>        } if</code>
<code>        dup 0 1 getinterval cvi dup 6 gt {</code>
<code>            pop pop pop /bwipp.GS1couponBadFunderVLI (Coupon Funder length indicator must be 0-6) false exit</code>
<code>        } if</code>
<code>        6 add 1 add</code>
<code>        2 copy exch length gt {</code>
<code>            pop pop pop /bwipp.GS1couponTooShortFunder (Coupon too short: Truncated Funder ID) false exit</code>
<code>        } if</code>
<code>        dup 2 index length exch sub getinterval</code>
<code>        % Offer Code</code>
<code>        dup length 6 lt {</code>
<code>            pop pop /bwipp.GS1couponTooShortOfferCode (Coupon too short: Truncated Offer Code) false exit</code>
<code>        } if</code>
<code>        dup length 6 sub 6 exch getinterval</code>
<code>        % Serial Number VLI and Serial Number</code>
<code>        dup length 1 lt {</code>
<code>            pop pop /bwipp.GS1couponTooShortSnVLI (Coupon too short: Missing SN VLI) false exit</code>
<code>        } if</code>
<code>        dup 0 1 getinterval cvi</code>
<code>        6 add 1 add</code>
<code>        2 copy exch length gt {</code>
<code>            pop pop pop /bwipp.GS1couponTooShortSn (Coupon too short: Truncated SN) false exit</code>
<code>        } if</code>
<code>        dup 2 index length exch sub getinterval</code>
<code>        dup length 0 ne {</code>
<code>            pop pop /bwipp.GS1couponTooLong (Coupon too long) false exit</code>
<code>        } if</code>
<code>        pop</code>
<code>    } def</code>
<code></code>
<code>    /lintlatitude {</code>
<code>        dup length 10 ne {</code>
<code>            pop /bwipp.GS1badLatitudeLength (Invalid length for a latitude) false exit</code>
<code>        } if</code>
<code>        cvi</code>
<code>        (1800000000) cvi  % Workaround issue with packager</code>
<code>        gt { pop /bwipp.GS1badLatitude (Invalid value for latitude) false exit } if</code>
<code>    } def</code>
<code></code>
<code>    /lintlongitude {</code>
<code>        dup length 10 ne {</code>
<code>            pop /bwipp.GS1badLongitudeLength (Invalid length for a longitude) false exit</code>
<code>        } if</code>
<code>        % Workaround issue with packager</code>
<code>        cvi</code>
<code>        (3600000000) cvi  % Workaround issue with packager</code>
<code>        gt { pop /bwipp.GS1badLongitude (Invalid value for longitude) false exit } if</code>
<code>    } def</code>
<code></code>
<code>{</code>
<code>    /aidcmediatype &lt;&lt; [</code>
<code>        /01 /02 /03 /04 /05 /06 /07 /08 /09 /10</code>
<code>        /80 /81 /82 /83 /84 /85 /86 /87 /88 /89</code>
<code>        /90 /91 /92 /93 /94 /95 /96 /97 /98 /99</code>
<code>    ] {dup} forall &gt;&gt; def</code>
<code>} ctxdef</code>
<code></code>
<code>    /lintmediatype {</code>
<code>        aidcmediatype exch known not { pop /bwipp.GS1UnknownMediaType (Unknown AIDC media type) false exit } if</code>
<code>    } def</code>
<code></code>
<code>    dontlint not {</code>
<code></code>
<code>        % Validate AI contents</code>
<code>        true</code>
<code>        0 1 vals length 1 sub {</code>
<code>            dup ais exch get /ai exch def</code>
<code>            vals exch get /val exch def</code>
<code>            gs1syntax ai known {</code>
<code>                gs1syntax ai get /parts get</code>
<code>                % Overall length checks, e.g. to report "too long", not "checksum failure"</code>
<code>                dup 0 exch {dup /opt get {pop 0} {/min get} ifelse add} forall val length gt {</code>
<code>                    pop /bwipp.GS1valueTooShort (Too short) false exit</code>
<code>                } if</code>
<code>                dup 0 exch {/max get add} forall val length lt {</code>
<code>                    pop /bwipp.GS1valueTooLong (Too long) false exit</code>
<code>                } if</code>
<code>                {  % Checks for each component of the AI</code>
<code>                    /props exch def</code>
<code>                    props /max get val length 2 copy gt {exch} if pop</code>
<code>                    val exch 0 exch getinterval /eval exch def</code>
<code>                    /val val eval length dup val length exch sub getinterval def</code>
<code>                    eval length 0 eq {</code>
<code>                        props /opt get not {</code>
<code>                            pop /bwipp.GS1valueTooShort (Too short) false exit</code>
<code>                        } if</code>
<code>                    } {</code>
<code>                        eval length props /min get lt {</code>
<code>                            pop /bwipp.GS1valueTooShort (Too short) false exit</code>
<code>                        } if</code>
<code>                        &lt;&lt; /N /lintnumeric  /X /lintcset82  /Y /lintcset39  /Z /lintcset64 &gt;&gt;</code>
<code>                        props /cset get get eval exch load exec</code>
<code>                        props /linters get { eval exch load exec } forall</code>
<code>                    } ifelse</code>
<code>                } forall</code>
<code>                dup not {exit} if</code>
<code>                val length 0 ne {  % Not all data consumed by components</code>
<code>                    pop /bwipp.GS1valueTooLong (Too long) false exit</code>
<code>                } if</code>
<code>            } {</code>
<code>                pop /bwipp.GS1unknownAI (Unrecognised AI) false exit</code>
<code>            } ifelse</code>
<code>        } for</code>
<code>        not {</code>
<code>            dup length ai length add 5 add string</code>
<code>            dup 0 (AI ) putinterval</code>
<code>            dup 3 ai putinterval</code>
<code>            dup 3 ai length add (: ) putinterval</code>
<code>            dup 5 ai length add 4 -1 roll putinterval</code>
<code>            //raiseerror exec</code>
<code>        } if</code>
<code></code>
<code>        % Search for "patt" matching an AIs, excluding "this" AI</code>
<code>        /aiexists {</code>
<code>            /this exch def</code>
<code>            /patt exch def</code>
<code>            1 {  % common exit</code>
<code>                aivals patt known {true exit} if  % Fast path</code>
<code>                patt length 4 eq {</code>
<code>                    patt 3 1 getinterval (n) eq {</code>
<code>                        /pfxlen patt 2 1 getinterval (n) eq {2} {3} ifelse def</code>
<code>                        false</code>
<code>                        ais {</code>
<code>                            dup dup this ne exch length 4 eq and {</code>
<code>                                0 pfxlen getinterval patt 0 pfxlen getinterval eq {</code>
<code>                                    pop true</code>
<code>                                } if</code>
<code>                            } {</code>
<code>                                pop</code>
<code>                            } ifelse</code>
<code>                        } forall</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    false exit</code>
<code>                } if</code>
<code>                false exit</code>
<code>            } repeat</code>
<code>        } def</code>
<code></code>
<code>        % Build AI dict and validate repeats</code>
<code>        /aivals vals length dict def</code>
<code>        0 1 vals length 1 sub {</code>
<code>            dup ais exch get /ai exch def</code>
<code>            vals exch get /val exch def</code>
<code>            aivals ai known {</code>
<code>                aivals ai get val ne {</code>
<code>                    ai length 40 add string</code>
<code>                    dup 0 (Repeated AIs \() putinterval</code>
<code>                    dup 14 ai putinterval</code>
<code>                    dup 14 ai length add (\) must have the same value) putinterval</code>
<code>                    /bwipp.GS1repeatedDifferingAIs exch //raiseerror exec</code>
<code>                } if</code>
<code>            } {</code>
<code>                aivals ai val put</code>
<code>            } ifelse</code>
<code>        } for</code>
<code></code>
<code>        % Validate ex and req pairings</code>
<code>        0 1 vals length 1 sub {</code>
<code>            ais exch get /ai exch def</code>
<code>            gs1syntax ai get /ex 2 copy known {</code>
<code>                get {</code>
<code>                    /patt exch def</code>
<code>                    patt ai aiexists {</code>
<code>                        ai length patt length add 36 add string</code>
<code>                        dup 0 (AIs \() putinterval</code>
<code>                        dup 5 ai putinterval</code>
<code>                        dup 5 ai length add (\) and \() putinterval</code>
<code>                        dup 12 ai length add patt putinterval</code>
<code>                        dup 12 ai length add patt length add (\) are mutually exclusive) putinterval</code>
<code>                        /bwipp.GS1exclusiveAIs exch //raiseerror exec</code>
<code>                    } if</code>
<code>                } forall</code>
<code>            } {</code>
<code>                pop pop</code>
<code>            } ifelse</code>
<code>            lintreqs {</code>
<code>                gs1syntax ai get /req 2 copy known {</code>
<code>                    get {                % For each req attribute instance</code>
<code>                        false exch {     % And each AI sequence alternative</code>
<code>                            true exch {  % Check whether all AIs in the sequence are present</code>
<code>                                ai aiexists not {pop false} if</code>
<code>                            } forall</code>
<code>                            { pop true exit } if  % Wholly matching any of the alternatives is sufficient</code>
<code>                        } forall</code>
<code>                        not {</code>
<code>                            ai length 47 add string</code>
<code>                            dup 0 (One of more requisite AIs for AI \() putinterval</code>
<code>                            dup 34 ai putinterval</code>
<code>                            dup 34 ai length add (\) are missing) putinterval</code>
<code>                            /bwipp.GS1missingAIs exch //raiseerror exec</code>
<code>                        } if</code>
<code>                    } forall</code>
<code>                } {</code>
<code>                    pop pop</code>
<code>                } ifelse</code>
<code>            } if</code>
<code>        } for</code>
<code></code>
<code>    } if  % dontlint</code>
<code></code>
<code>    ais vals fncs</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /gs1process dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END RESOURCE gs1process--</code>
<code></code>
<code>% --BEGIN RENDERER renlinear--</code>
<code>% --REQUIRES preamble raiseerror processoptions--</code>
<code>%%BeginResource: uk.co.terryburton.bwipp renlinear 0.0 2024010300 83313 82223</code>
<code>%%BeginData:        245 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>%psc /renlinear {</code>
<code>%psc </code>
<code>%psc     20 dict begin          % Confine variables to local scope</code>
<code>%psc </code>
<code>%psc     % Default options</code>
<code>%psc     /sbs [] def</code>
<code>%psc     /bhs [] def</code>
<code>%psc     /bbs [] def</code>
<code>%psc     /txt [] def</code>
<code>%psc     /barcolor (unset) def</code>
<code>%psc     /includetext false def</code>
<code>%psc     /textcolor (unset) def</code>
<code>%psc     /textxalign (unset) def</code>
<code>%psc     /textyalign (unset) def</code>
<code>%psc     /textfont (OCR-B) def</code>
<code>%psc     /textsize 10.0 def</code>
<code>%psc     /textxoffset 0.0 def</code>
<code>%psc     /textyoffset 0.0 def</code>
<code>%psc     /textgaps 0.0 def</code>
<code>%psc     /alttext () def</code>
<code>%psc     /bordercolor (unset) def</code>
<code>%psc     /backgroundcolor (unset) def</code>
<code>%psc     /inkspread 0 def</code>
<code>%psc     /width 0.0 def</code>
<code>%psc     /barratio 1.0 def</code>
<code>%psc     /spaceratio 1.0 def</code>
<code>%psc     /showborder false def</code>
<code>%psc     /showbearer false def</code>
<code>%psc     /borderleft 10.0 def</code>
<code>%psc     /borderright 10.0 def</code>
<code>%psc     /bordertop 0.0 def</code>
<code>%psc     /borderbottom 0.0 def</code>
<code>%psc     /borderwidth 0.5 def</code>
<code>%psc     /guardwhitespace false def</code>
<code>%psc     /guardleftpos 0.0 def</code>
<code>%psc     /guardleftypos 0.0 def</code>
<code>%psc     /guardrightpos 0.0 def</code>
<code>%psc     /guardrightypos 0.0 def</code>
<code>%psc     /guardwidth 5.0 def</code>
<code>%psc     /guardheight 7.0 def</code>
<code>%psc </code>
<code>%psc     {def} forall</code>
<code>%psc     opt currentdict /opt undef currentdict //processoptions exec pop</code>
<code>%psc </code>
<code>%psc     textsize 0 le {</code>
<code>%psc         /bwipp.renlinearBadTextsize (The font size must be greater than zero) //raiseerror exec</code>
<code>%psc     } if</code>
<code>%psc </code>
<code>%psc     % Create bar elements and put them into the bars array</code>
<code>%psc     /bars sbs length 1 add 2 idiv array def</code>
<code>%psc     /pixx 0 def /pixy 0 def</code>
<code>%psc     0 1 sbs length 1 add 2 idiv 2 mul 2 sub {</code>
<code>%psc         /i exch def</code>
<code>%psc         i 2 mod 0 eq {           % i is even</code>
<code>%psc             /d sbs i get barratio mul barratio sub 1 add def  % d = digit*r-r+1</code>
<code>%psc             sbs i get 0 ne {</code>
<code>%psc                 /h bhs i 2 idiv get 72 mul def  % Height from bhs</code>
<code>%psc                 /c d 2 div pixx add def         % Centre of the bar = pixx + d/2</code>
<code>%psc                 /y bbs i 2 idiv get 72 mul def  % Baseline from bbs</code>
<code>%psc                 /w d inkspread sub def          % bar width = digit - inkspread</code>
<code>%psc                 bars i 2 idiv [h c y w] put     % Add the bar entry</code>
<code>%psc                 h y add pixy gt {/pixy h y add def} if</code>
<code>%psc             } {</code>
<code>%psc                 bars i 2 idiv -1 put            % Dummy entry</code>
<code>%psc             } ifelse</code>
<code>%psc         } {</code>
<code>%psc             /d sbs i get spaceratio mul spaceratio sub 1 add def  % d = digit*r-r+1</code>
<code>%psc         } ifelse</code>
<code>%psc         /pixx pixx d add def  % pixx += d</code>
<code>%psc     } for</code>
<code>%psc </code>
<code>%psc     gsave</code>
<code>%psc </code>
<code>%psc     currentpoint translate</code>
<code>%psc </code>
<code>%psc     % Force symbol to given width</code>
<code>%psc     width 0 ne {</code>
<code>%psc         width 72 mul pixx div 1 scale</code>
<code>%psc     } if</code>
<code>%psc </code>
<code>%psc     % Set RGB or CMYK color depending on length of given hex string</code>
<code>%psc     /setanycolor {</code>
<code>%psc         /anycolor exch def</code>
<code>%psc         anycolor length dup 6 ne exch 8 ne and {</code>
<code>%psc             /bwipp.renlinearBadColorLength (Colors must be 6 or 8 characters) //raiseerror exec</code>
<code>%psc         } if</code>
<code>%psc         anycolor {</code>
<code>%psc             dup     dup 48 ge exch  59 le and  % 0-9</code>
<code>%psc             1 index dup 65 ge exch  70 le and  % A-F</code>
<code>%psc             2 index dup 97 ge exch 102 le and  % a-f</code>
<code>%psc             or or exch pop not {</code>
<code>%psc                 /bwipp.renlinearBadColorCharacter (Colors must be in hexadecimal notation) //raiseerror exec</code>
<code>%psc             } if</code>
<code>%psc         } forall</code>
<code>%psc         anycolor length 6 eq { (&lt;      &gt;) } { (&lt;        &gt;) } ifelse dup length string copy</code>
<code>%psc         dup 1 anycolor putinterval cvx exec {255 div} forall</code>
<code>%psc         anycolor length 6 eq { setrgbcolor } { setcmykcolor } ifelse</code>
<code>%psc     } def</code>
<code>%psc </code>
<code>%psc     % Display the border and background</code>
<code>%psc     /tl [ borderleft borderwidth 2 div add neg        pixy bordertop add borderwidth 2 div add ] def</code>
<code>%psc     /tr [ pixx borderright add borderwidth 2 div add  pixy bordertop add borderwidth 2 div add ] def</code>
<code>%psc     /bl [ borderleft borderwidth 2 div add neg        borderbottom borderwidth 2 div add neg   ] def</code>
<code>%psc     /br [ pixx borderright add borderwidth 2 div add  borderbottom borderwidth 2 div add neg   ] def</code>
<code>%psc     backgroundcolor (unset) ne {</code>
<code>%psc         gsave</code>
<code>%psc         newpath bl aload pop moveto [ br tr tl ] { aload pop lineto } forall closepath</code>
<code>%psc         backgroundcolor setanycolor fill</code>
<code>%psc         grestore</code>
<code>%psc     } if</code>
<code>%psc     showbearer {  % Overrides showborder</code>
<code>%psc         gsave</code>
<code>%psc         newpath</code>
<code>%psc         bl aload pop moveto br aload pop lineto</code>
<code>%psc         tl aload pop moveto tr aload pop lineto</code>
<code>%psc         bordercolor (unset) ne { bordercolor setanycolor } if</code>
<code>%psc         borderwidth inkspread 2 mul sub setlinewidth stroke</code>
<code>%psc         grestore</code>
<code>%psc     } {</code>
<code>%psc     showborder {</code>
<code>%psc         gsave</code>
<code>%psc         newpath bl aload pop moveto [ br tr tl ] { aload pop lineto } forall closepath</code>
<code>%psc         bordercolor (unset) ne { bordercolor setanycolor } if</code>
<code>%psc         borderwidth inkspread 2 mul sub setlinewidth stroke</code>
<code>%psc         grestore</code>
<code>%psc     } if } ifelse</code>
<code>%psc </code>
<code>%psc     % Display the bars for elements in the bars array</code>
<code>%psc     gsave</code>
<code>%psc     barcolor (unset) ne { barcolor setanycolor } if</code>
<code>%psc     newpath</code>
<code>%psc     bars {</code>
<code>%psc         dup -1 ne {</code>
<code>%psc             aload pop  % h x y w</code>
<code>%psc             2 index 1 index 2 div sub 2 index moveto</code>
<code>%psc             0 4 index rlineto</code>
<code>%psc             dup 0 rlineto</code>
<code>%psc             0 4 index neg rlineto</code>
<code>%psc             closepath</code>
<code>%psc             pop pop pop pop</code>
<code>%psc         } {</code>
<code>%psc             pop</code>
<code>%psc         } ifelse</code>
<code>%psc     } forall</code>
<code>%psc     fill</code>
<code>%psc     grestore</code>
<code>%psc </code>
<code>%psc     % Display the text for elements in the text array</code>
<code>%psc     textcolor (unset) ne { textcolor setanycolor } if</code>
<code>%psc     includetext {</code>
<code>%psc         textxalign (unset) eq textyalign (unset) eq and alttext () eq and {</code>
<code>%psc             /s 0 def /fn () def</code>
<code>%psc             txt {</code>
<code>%psc                 aload pop</code>
<code>%psc                 2 copy s ne exch fn ne or {</code>
<code>%psc                     dup 0 le {</code>
<code>%psc                         pop pop pop pop pop</code>
<code>%psc                         /bwipp.renlinearFontTooSmall (The font size is too small) //raiseerror exec</code>
<code>%psc                     } if</code>
<code>%psc                     2 copy /s exch def /fn exch def</code>
<code>%psc                     selectfont</code>
<code>%psc                 } {</code>
<code>%psc                     pop pop</code>
<code>%psc                 } ifelse</code>
<code>%psc                 moveto show</code>
<code>%psc             } forall</code>
<code>%psc         } {</code>
<code>%psc             textfont textsize selectfont</code>
<code>%psc             alttext () eq {</code>
<code>%psc                 /txt [ txt { 0 get {} forall } forall ] def</code>
<code>%psc                 /tstr txt length string def</code>
<code>%psc                 0 1 txt length 1 sub { dup txt exch get tstr 3 1 roll put } for</code>
<code>%psc             } {</code>
<code>%psc                 /tstr alttext def</code>
<code>%psc             } ifelse</code>
<code>%psc </code>
<code>%psc             % Find true ascent of font</code>
<code>%psc             tstr length 0 eq {</code>
<code>%psc                 0</code>
<code>%psc             } {</code>
<code>%psc                 gsave</code>
<code>%psc                 newpath 0 0 moveto (0) false charpath pathbbox</code>
<code>%psc                 4 1 roll pop pop pop</code>
<code>%psc                 grestore</code>
<code>%psc                 currentfont /PaintType known {currentfont /PaintType get 2 eq} {false} ifelse</code>
<code>%psc                 currentfont /StrokeWidth known and {</code>
<code>%psc                     currentfont /StrokeWidth get 2 div 0 exch</code>
<code>%psc                     currentfont /FontMatrix get dtransform</code>
<code>%psc                     dup mul exch dup mul add sqrt</code>
<code>%psc                     add</code>
<code>%psc                 } if</code>
<code>%psc             } ifelse</code>
<code>%psc             /textascent exch def</code>
<code>%psc             /textwidth tstr stringwidth pop tstr length 1 sub textgaps mul add def</code>
<code>%psc </code>
<code>%psc             /textxpos textxoffset pixx textwidth sub 2 div add def</code>
<code>%psc             textxalign (left) eq { /textxpos textxoffset def } if</code>
<code>%psc             textxalign (right) eq { /textxpos pixx textxoffset sub textwidth sub def } if</code>
<code>%psc             textxalign (offleft) eq { /textxpos textwidth textxoffset add neg def } if</code>
<code>%psc             textxalign (offright) eq { /textxpos pixx textxoffset add def } if</code>
<code>%psc             textxalign (justify) eq textwidth pixx lt and {</code>
<code>%psc                 /textxpos 0 def</code>
<code>%psc                 /textgaps pixx textwidth sub tstr length 1 sub div def</code>
<code>%psc             } if</code>
<code>%psc             /textypos textyoffset textascent add 1 add neg def</code>
<code>%psc             textyalign (above) eq { /textypos textyoffset pixy add 1 add def } if</code>
<code>%psc             textyalign (center) eq { /textypos textyoffset pixy textascent sub 2 div add def } if</code>
<code>%psc             textxpos textypos moveto textgaps 0 tstr ashow</code>
<code>%psc         } ifelse</code>
<code>%psc     } if</code>
<code>%psc </code>
<code>%psc     % Display the guard elements</code>
<code>%psc     guardwhitespace {</code>
<code>%psc         0.75 setlinewidth</code>
<code>%psc         guardleftpos 0 ne {</code>
<code>%psc             newpath</code>
<code>%psc             guardleftpos neg guardwidth add guardleftypos guardheight 2 div add moveto</code>
<code>%psc             guardwidth neg guardheight -2 div rlineto</code>
<code>%psc             guardwidth guardheight -2 div rlineto</code>
<code>%psc             stroke</code>
<code>%psc         } if</code>
<code>%psc         guardrightpos 0 ne {</code>
<code>%psc             newpath</code>
<code>%psc             guardrightpos pixx add guardwidth sub guardrightypos guardheight 2 div add moveto</code>
<code>%psc             guardwidth guardheight -2 div rlineto</code>
<code>%psc             guardwidth neg guardheight -2 div rlineto</code>
<code>%psc             stroke</code>
<code>%psc         } if</code>
<code>%psc     } if</code>
<code>%psc </code>
<code>%psc     grestore</code>
<code>%psc </code>
<code>%psc     end</code>
<code>%psc </code>
<code>%psc }</code>
<code>%psc [/barcode] {null def} forall</code>
<code>%psc bind def</code>
<code>%psc /renlinear dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END RENDERER renlinear--</code>
<code></code>
<code>% --BEGIN RENDERER renmatrix--</code>
<code>% --REQUIRES preamble raiseerror processoptions--</code>
<code>%%BeginResource: uk.co.terryburton.bwipp renmatrix 0.0 2024010300 100126 98828</code>
<code>%%BeginData:        331 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/renmatrix {</code>
<code>bwipjs_dontdraw { return } if</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    % Default options</code>
<code>    /width 1.0 def</code>
<code>    /height 1.0 def</code>
<code>    /bordercolor (unset) def</code>
<code>    /barcolor (unset) def</code>
<code>    /backgroundcolor (unset) def</code>
<code>    /colormap (unset) def</code>
<code>    /dotty false def</code>
<code>    /inkspread null def    % real sentinal</code>
<code>    /inkspreadh null def   % real sentinal</code>
<code>    /inkspreadv null def   % real sentinal</code>
<code>    /includetext false def</code>
<code>    /txt [] def</code>
<code>    /textcolor (unset) def</code>
<code>    /textxalign (unset) def</code>
<code>    /textyalign (unset) def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textxoffset 0.0 def</code>
<code>    /textyoffset 0.0 def</code>
<code>    /textgaps 0.0 def</code>
<code>    /alttext () def</code>
<code>    /showborder false def</code>
<code>    /borderleft 0.0 def</code>
<code>    /borderright 0.0 def</code>
<code>    /bordertop 0.0 def</code>
<code>    /borderbottom 0.0 def</code>
<code>    /borderwidth 0.25 def</code>
<code></code>
<code>    {def} forall</code>
<code>    opt currentdict /opt undef currentdict //processoptions exec pop</code>
<code></code>
<code>    inkspread null eq {/inkspread 0 def} if</code>
<code>    inkspreadh null eq {/inkspreadh inkspread def} if</code>
<code>    inkspreadv null eq {/inkspreadv inkspread def} if</code>
<code></code>
<code>    textsize 0 le {</code>
<code>        /bwipp.renmatrixBadTextsize (The font size must be greater than zero) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /xyget { pixx mul add pixs exch get} def</code>
<code>    /cget { pixx mul add cache exch get and} def</code>
<code>    /cput {  % Optimise by only storing "stem" corners</code>
<code>        dup 4 mod 0 eq { % dir is up or left</code>
<code>            3 1 roll pixx mul add cache exch 2 copy get 4 -1 roll or put</code>
<code>        } {</code>
<code>            pop pop pop</code>
<code>        } ifelse</code>
<code>    } def</code>
<code></code>
<code>    /abcd {</code>
<code>        4 string 0 [</code>
<code>            5 -2 roll</code>
<code>            pixx mul add dup</code>
<code>            pixs exch 2 getinterval aload pop 3 -1 roll  % A B</code>
<code>            pixs exch pixx add 2 getinterval aload pop   % C D</code>
<code>        ] {3 copy 48 add put pop 1 add} forall pop</code>
<code>    } def</code>
<code></code>
<code>    /right {dir 1 ne {x y dir cput [x y]} if  /x x 1 add def  /dir 1 def} def</code>
<code>    /down  {dir 2 ne {x y dir cput [x y]} if  /y y 1 add def  /dir 2 def} def</code>
<code>    /left  {dir 4 ne {x y dir cput [x y]} if  /x x 1 sub def  /dir 4 def} def</code>
<code>    /up    {dir 8 ne {x y dir cput [x y]} if  /y y 1 sub def  /dir 8 def} def</code>
<code></code>
<code>    /trace {</code>
<code>        % Walk the outline of a region emitting edge coordinates of the path</code>
<code>        /y exch def  /x exch def</code>
<code>        % dir 1:right 2:down 4:left 8:up</code>
<code>        /dir x 1 add y 1 add xyget 1 eq {8} {4} ifelse def</code>
<code>        /sx x def  /sy y def  /sdir dir def</code>
<code></code>
<code>        % A B</code>
<code>        % C D</code>
<code>        mark {</code>
<code>            x y abcd</code>
<code>            1 {  % Common exit</code>
<code>                dup dup (0001) eq exch dup (0011) eq exch (1011) eq or or {pop right exit} if</code>
<code>                dup dup (0010) eq exch dup (1010) eq exch (1110) eq or or {pop down  exit} if</code>
<code>                dup dup (1000) eq exch dup (1100) eq exch (1101) eq or or {pop left  exit} if</code>
<code>                dup dup (0100) eq exch dup (0101) eq exch (0111) eq or or {pop up    exit} if</code>
<code>                dup (1001) eq {</code>
<code>                    dir 2 eq {pop left exit} {pop right exit} ifelse</code>
<code>                } {  % 0110</code>
<code>                    dir 1 eq {pop down exit} {pop up exit} ifelse</code>
<code>                } ifelse</code>
<code>            } repeat</code>
<code>            x sx eq y sy eq and dir sdir eq and {exit} if</code>
<code>        } loop</code>
<code>        counttomark array astore exch pop</code>
<code></code>
<code>    } def</code>
<code></code>
<code>    % Set RGB or CMYK color depending on length of given hex string</code>
<code>%psc     /setanycolor {</code>
<code>%psc         /anycolor exch def</code>
<code>%psc         anycolor length dup 6 ne exch 8 ne and {</code>
<code>%psc             /bwipp.renmatrixBadColorLength (Colors must be 6 or 8 characters) //raiseerror exec</code>
<code>%psc         } if</code>
<code>%psc         anycolor {</code>
<code>%psc             dup     dup 48 ge exch  59 le and  % 0-9</code>
<code>%psc             1 index dup 65 ge exch  70 le and  % A-F</code>
<code>%psc             2 index dup 97 ge exch 102 le and  % a-f</code>
<code>%psc             or or exch pop not {</code>
<code>%psc                 /bwipp.renmatrixBadColorCharacter (Colors must be in hexadecimal notation) //raiseerror exec</code>
<code>%psc             } if</code>
<code>%psc         } forall</code>
<code>%psc         anycolor length 6 eq { (&lt;      &gt;) } { (&lt;        &gt;) } ifelse dup length string copy</code>
<code>%psc         dup 1 anycolor putinterval cvx exec {255 div} forall</code>
<code>%psc         anycolor length 6 eq { setrgbcolor } { setcmykcolor } ifelse</code>
<code>%psc     } def</code>
<code></code>
<code>    % Plot a layer of single colour</code>
<code>    /drawlayer {</code>
<code></code>
<code>        /pixsorig pixs def</code>
<code>        /pixs exch def</code>
<code></code>
<code>        % Pad the bitmap on all sides</code>
<code>        /pixs [</code>
<code>            pixx 2 add {0} repeat</code>
<code>            0 pixx pixs length 1 sub {</code>
<code>                0 exch</code>
<code>                pixs exch pixx getinterval aload pop</code>
<code>                0</code>
<code>            } for</code>
<code>            pixx 2 add {0} repeat</code>
<code>        ] def</code>
<code>        /pixx pixx 2 add def</code>
<code>        /pixy pixy 2 add def</code>
<code></code>
<code>        % Cache of visited corners for each direction</code>
<code>        /cache [ pixs length {0} repeat ] def</code>
<code></code>
<code>        % Construct paths by tracing regions avoiding duplication by using the cache</code>
<code>        /paths [</code>
<code>            0 1 pixy 2 sub {</code>
<code>                /j exch def</code>
<code>                0 1 pixx 2 sub {</code>
<code>                    /i exch def</code>
<code>                    /k i j abcd def</code>
<code>                    k (0001) eq k (1001) eq or {  % Black region stem corners</code>
<code>                        8 i j cget 0 eq {</code>
<code>                            i j trace</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    k (1110) eq {  % White region stem corner</code>
<code>                        4 i j cget 0 eq {</code>
<code>                            i j trace</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                } for</code>
<code>            } for</code>
<code>        ] def</code>
<code></code>
<code>        % Revert the bitmap size</code>
<code>        /pixx pixx 2 sub def</code>
<code>        /pixy pixy 2 sub def</code>
<code></code>
<code>        % Draw the image</code>
<code>        newpath</code>
<code>        paths {</code>
<code>            /p exch def</code>
<code>            /len p length def</code>
<code>            p len 1 sub get aload pop</code>
<code>            p 0 get aload pop</code>
<code>            0 1 len 1 sub {                                % x1 y1 x2 y2</code>
<code>                /i exch def</code>
<code>                p i 1 add len mod get aload pop 6 -2 roll  % x3 y3 x1 y1 x2 y2</code>
<code>                5 index inkspreadh</code>
<code>                4 index 4 -1 roll lt {add} {sub} ifelse    % y3&lt;y1 ? x2+i : x2-i</code>
<code>                4 1 roll</code>
<code>                4 index inkspreadv</code>
<code>                4 index 4 -1 roll gt {add} {sub} ifelse    % x3&gt;x1 ? y2+i : y2-i</code>
<code>                4 -1 roll exch pixy exch sub</code>
<code>                i 0 eq {moveto} {lineto} ifelse</code>
<code>            } for                                          % x2 y2 x3 y3</code>
<code>            closepath</code>
<code>            pop pop pop pop</code>
<code>        } forall</code>
<code>        fill</code>
<code></code>
<code>        /pixs pixsorig def</code>
<code></code>
<code>    } def</code>
<code></code>
<code>    /drawlayerdots {</code>
<code></code>
<code>        /pixsorig pixs def</code>
<code>        /pixs exch def</code>
<code></code>
<code>        newpath</code>
<code>        0 1 pixs length 1 sub {</code>
<code>            dup pixx mod /x exch def</code>
<code>            pixx idiv /y exch def</code>
<code>            x y xyget 1 eq {</code>
<code>               x 0.5 add pixy y sub 0.5 sub moveto</code>
<code>               x 0.5 add pixy y sub 0.5 sub 0.5 inkspread sub 0 360 arc</code>
<code>            } if</code>
<code>        } for</code>
<code>        fill</code>
<code></code>
<code>        /pixs pixsorig def</code>
<code></code>
<code>    } def</code>
<code></code>
<code>    gsave</code>
<code></code>
<code>    currentpoint translate</code>
<code></code>
<code>    /inkspread  inkspread  2 div def</code>
<code>    /inkspreadh inkspreadh 2 div def</code>
<code>    /inkspreadv inkspreadv 2 div def</code>
<code></code>
<code>    % Force symbol to given width</code>
<code>    width pixx div 72 mul height pixy div 72 mul scale</code>
<code></code>
<code>    % Display the border and background</code>
<code>    /tl [ borderleft borderwidth 2 div add neg        pixy bordertop add borderwidth 2 div add ] def</code>
<code>    /tr [ pixx borderright add borderwidth 2 div add  pixy bordertop add borderwidth 2 div add ] def</code>
<code>    /bl [ borderleft borderwidth 2 div add neg        borderbottom borderwidth 2 div add neg   ] def</code>
<code>    /br [ pixx borderright add borderwidth 2 div add  borderbottom borderwidth 2 div add neg   ] def</code>
<code>    backgroundcolor (unset) ne {</code>
<code>        gsave</code>
<code>        newpath bl aload pop moveto [ br tr tl ] { aload pop lineto } forall closepath</code>
<code>        backgroundcolor setanycolor fill</code>
<code>        grestore</code>
<code>    } if</code>
<code>    showborder {</code>
<code>        gsave</code>
<code>        newpath bl aload pop moveto [ br tr tl ] { aload pop lineto } forall closepath</code>
<code>        bordercolor (unset) ne { bordercolor setanycolor } if</code>
<code>        borderwidth inkspread 2 mul sub setlinewidth stroke</code>
<code>        grestore</code>
<code>    } if</code>
<code></code>
<code>    % Display the matrix</code>
<code>    colormap (unset) eq {</code>
<code>        /colormap &lt;&lt; 1 barcolor &gt;&gt; def</code>
<code>    } if</code>
<code></code>
<code>    colormap {</code>
<code>        dup (unset) ne { setanycolor } { pop } ifelse</code>
<code>        /key exch def</code>
<code>        [</code>
<code>            pixs { key eq {1} {0} ifelse } forall</code>
<code>        ] dotty {drawlayerdots} {drawlayer} ifelse</code>
<code>    } forall</code>
<code></code>
<code>    % Display the text for elements in the text array</code>
<code>    textcolor (unset) ne { textcolor setanycolor } if</code>
<code>    includetext {</code>
<code>        textxalign (unset) eq textyalign (unset) eq and alttext () eq and {</code>
<code>            /s 0 def /fn () def</code>
<code>            txt {</code>
<code>                {} forall</code>
<code>                2 copy s ne exch fn ne or {</code>
<code>                    dup 0 le {</code>
<code>                        pop pop pop pop pop</code>
<code>                        /bwipp.renmatrixFontTooSmall (The font size is too small) //raiseerror exec</code>
<code>                    } if</code>
<code>                    2 copy /s exch def /fn exch def</code>
<code>                    selectfont</code>
<code>                } {</code>
<code>                    pop pop</code>
<code>                } ifelse</code>
<code>                moveto show</code>
<code>            } forall</code>
<code>        } {</code>
<code>            textfont textsize selectfont</code>
<code>            alttext () eq {</code>
<code>                /txt [ txt { 0 get {} forall } forall ] def</code>
<code>                /tstr txt length string def</code>
<code>                0 1 txt length 1 sub { dup txt exch get tstr 3 1 roll put } for</code>
<code>            } {</code>
<code>                /tstr alttext def</code>
<code>            } ifelse</code>
<code></code>
<code>            % Find true ascent of font</code>
<code>            tstr length 0 eq {</code>
<code>                0</code>
<code>            } {</code>
<code>                gsave</code>
<code>                newpath 0 0 moveto (0) false charpath pathbbox</code>
<code>                4 1 roll pop pop pop</code>
<code>                grestore</code>
<code>%psc                 currentfont /PaintType known {currentfont /PaintType get 2 eq} {false} ifelse</code>
<code>%psc                 currentfont /StrokeWidth known and {</code>
<code>%psc                     currentfont /StrokeWidth get 2 div 0 exch</code>
<code>%psc                     currentfont /FontMatrix get dtransform</code>
<code>%psc                     dup mul exch dup mul add sqrt</code>
<code>%psc                     add</code>
<code>%psc                 } if</code>
<code>            } ifelse</code>
<code>            /textascent exch def</code>
<code>            /textwidth tstr stringwidth pop tstr length 1 sub textgaps mul add def</code>
<code></code>
<code>            /textxpos textxoffset pixx textwidth sub 2 div add def</code>
<code>            textxalign (left) eq { /textxpos textxoffset def } if</code>
<code>            textxalign (right) eq { /textxpos pixx textxoffset sub textwidth sub def } if</code>
<code>            textxalign (offleft) eq { /textxpos textwidth textxoffset add neg def } if</code>
<code>            textxalign (offright) eq { /textxpos pixx textxoffset add def } if</code>
<code>            textxalign (justify) eq textwidth pixx lt and {</code>
<code>                /textxpos 0.0 def</code>
<code>                /textgaps pixx textwidth sub tstr length 1 sub div def</code>
<code>            } if</code>
<code>            /textypos textyoffset textascent add 1 add neg def</code>
<code>            textyalign (above) eq { /textypos textyoffset pixy add 1 add def } if</code>
<code>            textyalign (center) eq { /textypos textyoffset pixy textascent sub 2 div add def } if</code>
<code>            textxpos textypos moveto textgaps 0 tstr ashow</code>
<code>        } ifelse</code>
<code>    } if</code>
<code></code>
<code>    grestore</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /renmatrix dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END RENDERER renmatrix--</code>
<code></code>
<code>% --BEGIN RENDERER renmaximatrix--</code>
<code>% --REQUIRES preamble raiseerror processoptions--</code>
<code>%%BeginResource: uk.co.terryburton.bwipp renmaximatrix 0.0 2024010300 62291 61901</code>
<code>%%BeginData:        110 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>%psc /renmaximatrix {</code>
<code>%psc </code>
<code>%psc     20 dict begin</code>
<code>%psc </code>
<code>%psc     % Default options</code>
<code>%psc     /bordercolor (unset) def</code>
<code>%psc     /barcolor (unset) def</code>
<code>%psc     /backgroundcolor (unset) def</code>
<code>%psc     /inkspread 0 def</code>
<code>%psc     /showborder false def</code>
<code>%psc     /borderleft 0.0 def</code>
<code>%psc     /borderright 0.0 def</code>
<code>%psc     /bordertop 0.0 def</code>
<code>%psc     /borderbottom 0.0 def</code>
<code>%psc     /borderwidth 0.25 def</code>
<code>%psc </code>
<code>%psc     {def} forall</code>
<code>%psc     opt currentdict /opt undef currentdict //processoptions exec pop</code>
<code>%psc </code>
<code>%psc     % Set RGB or CMYK color depending on length of given hex string</code>
<code>%psc     /setanycolor {</code>
<code>%psc         /anycolor exch def</code>
<code>%psc         anycolor length dup 6 ne exch 8 ne and {</code>
<code>%psc             /bwipp.renmaximatrixBadColorLength (Colors must be 6 or 8 characters) //raiseerror exec</code>
<code>%psc         } if</code>
<code>%psc         anycolor {</code>
<code>%psc             dup     dup 48 ge exch  59 le and  % 0-9</code>
<code>%psc             1 index dup 65 ge exch  70 le and  % A-F</code>
<code>%psc             2 index dup 97 ge exch 102 le and  % a-f</code>
<code>%psc             or or exch pop not {</code>
<code>%psc                 /bwipp.renmaximatrixBadColorCharacter (Colors must be in hexadecimal notation) //raiseerror exec</code>
<code>%psc             } if</code>
<code>%psc         } forall</code>
<code>%psc         anycolor length 6 eq { (&lt;      &gt;) } { (&lt;        &gt;) } ifelse dup length string copy</code>
<code>%psc         dup 1 anycolor putinterval cvx exec {255 div} forall</code>
<code>%psc         anycolor length 6 eq { setrgbcolor } { setcmykcolor } ifelse</code>
<code>%psc     } def</code>
<code>%psc </code>
<code>%psc     gsave</code>
<code>%psc </code>
<code>%psc     currentpoint translate</code>
<code>%psc </code>
<code>%psc     2.4945 dup scale  % from 1pt to 0.88mm</code>
<code>%psc </code>
<code>%psc     /tl [ borderleft borderwidth 2 div add neg      29 bordertop add borderwidth 2 div add ] def</code>
<code>%psc     /tr [ 30 borderright add borderwidth 2 div add  29 bordertop add borderwidth 2 div add ] def</code>
<code>%psc     /bl [ borderleft borderwidth 2 div add neg      borderbottom borderwidth 2 div add neg ] def</code>
<code>%psc     /br [ 30 borderright add borderwidth 2 div add  borderbottom borderwidth 2 div add neg ] def</code>
<code>%psc     backgroundcolor (unset) ne {</code>
<code>%psc         gsave</code>
<code>%psc         newpath bl aload pop moveto [ br tr tl ] { aload pop lineto } forall closepath</code>
<code>%psc         backgroundcolor setanycolor fill</code>
<code>%psc         grestore</code>
<code>%psc     } if</code>
<code>%psc     showborder {</code>
<code>%psc         gsave</code>
<code>%psc         newpath bl aload pop moveto [ br tr tl ] { aload pop lineto } forall closepath</code>
<code>%psc         bordercolor (unset) ne { bordercolor setanycolor } if</code>
<code>%psc         borderwidth inkspread 2 mul sub setlinewidth stroke</code>
<code>%psc         grestore</code>
<code>%psc     } if</code>
<code>%psc </code>
<code>%psc     barcolor (unset) ne { barcolor setanycolor } if</code>
<code>%psc </code>
<code>%psc     /g 0.06 inkspread add def</code>
<code>%psc </code>
<code>%psc     0.5 0.5774 translate</code>
<code>%psc </code>
<code>%psc     newpath</code>
<code>%psc     pixs {</code>
<code>%psc         dup</code>
<code>%psc         /x exch 30 mod def</code>
<code>%psc         /y exch 30 idiv def</code>
<code>%psc         y 2 mod 0 eq {x} {x 0.5 add} ifelse</code>
<code>%psc         32 y sub 0.8661 mul</code>
<code>%psc         moveto</code>
<code>%psc         0              0.5774 g       sub rmoveto</code>
<code>%psc        -0.5 g add     -0.2887 g 2 div add rlineto</code>
<code>%psc         0             -0.5774 g       add rlineto</code>
<code>%psc         0.5 g sub     -0.2887 g 2 div add rlineto</code>
<code>%psc         0.5 g sub      0.2887 g 2 div sub rlineto</code>
<code>%psc         0              0.5774 g       sub rlineto</code>
<code>%psc        -0.5 g add      0.2887 g 2 div sub rlineto</code>
<code>%psc         closepath</code>
<code>%psc     } forall</code>
<code>%psc     fill</code>
<code>%psc </code>
<code>%psc     % Plot the locator symbol</code>
<code>%psc     newpath 14 13.8576 0.5774 inkspread add 0 360 arc closepath</code>
<code>%psc             14 13.8576 1.3359 inkspread sub 360 0 arcn closepath fill</code>
<code>%psc     newpath 14 13.8576 2.1058 inkspread add 0 360 arc closepath</code>
<code>%psc             14 13.8576 2.8644 inkspread sub 360 0 arcn closepath fill</code>
<code>%psc     newpath 14 13.8576 3.6229 inkspread add 0 360 arc closepath</code>
<code>%psc             14 13.8576 4.3814 inkspread sub 360 0 arcn closepath fill</code>
<code>%psc </code>
<code>%psc     grestore</code>
<code>%psc </code>
<code>%psc     end</code>
<code>%psc </code>
<code>%psc }</code>
<code>%psc [/barcode] {null def} forall</code>
<code>%psc bind def</code>
<code>%psc /renmaximatrix dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END RENDERER renmaximatrix--</code>
<code></code>
<code>% --BEGIN ENCODER ean5--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear--</code>
<code>% --DESC: EAN-5 (5 digit addon)</code>
<code>% --EXAM: 90200</code>
<code>% --EXOP: includetext guardwhitespace</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp ean5 0.0 2024010300 67628 67436</code>
<code>%%BeginData:        133 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/ean5 {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 12.0 def</code>
<code>    /textxoffset 0.0 def</code>
<code>    /textyoffset null def  % realtype sentinal</code>
<code>    /height 0.7 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    textyoffset null eq {</code>
<code>        /textyoffset height 72 mul 1 add def</code>
<code>    } if</code>
<code></code>
<code>    /ean5 //loadctx exec</code>
<code></code>
<code>    % Validate input</code>
<code>    barcode length 5 ne {</code>
<code>        /bwipp.ean5badLength (EAN-5 add-on must be 5 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.ean5badCharacter (EAN-5 add-on must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>{</code>
<code>    % Create an array containing the character mappings</code>
<code>    /encs</code>
<code>    [ (3211) (2221) (2122) (1411) (1132)</code>
<code>      (1231) (1114) (1312) (1213) (3112)</code>
<code>      (112) (11)</code>
<code>    ] def</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>    /barchars (0123456789) def</code>
<code></code>
<code>    % Determine the mirror map based on mod 10 checksum</code>
<code>    /mirrormaps</code>
<code>    [ (11000) (10100) (10010) (10001) (01100)</code>
<code>      (00110) (00011) (01010) (01001) (00101)</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /checksum 0 def</code>
<code>    0 1 4 {</code>
<code>        /i exch def</code>
<code>        /barchar barcode i get 48 sub def</code>
<code>        i 2 mod 0 eq {</code>
<code>            /checksum barchar 3 mul checksum add def</code>
<code>        } {</code>
<code>            /checksum barchar 9 mul checksum add def</code>
<code>        } ifelse</code>
<code>    } for</code>
<code>    /checksum checksum 10 mod def</code>
<code>    /mirrormap mirrormaps checksum get def</code>
<code></code>
<code>    /sbs 31 string def</code>
<code>    /txt 5 array def</code>
<code></code>
<code>    0 1 4 {</code>
<code>        /i exch def</code>
<code></code>
<code>        % Prefix with either a start character or separator character</code>
<code>        i 0 eq {</code>
<code>            sbs 0 encs 10 get putinterval</code>
<code>        } {</code>
<code>            sbs i 1 sub 6 mul 7 add encs 11 get putinterval</code>
<code>        } ifelse</code>
<code></code>
<code>        % Lookup the encoding for the barcode character</code>
<code>        barcode i 1 getinterval barchars exch search</code>
<code>        pop                     % Discard true leaving pre</code>
<code>        length /indx exch def   % indx is the length of pre</code>
<code>        pop pop                 % Discard seek and post</code>
<code>        /enc encs indx get def  % Get the indxth encoding</code>
<code>        mirrormap i get 49 eq { % Reverse enc if 1 in this position in mirrormap</code>
<code>            /enclen enc length def</code>
<code>            /revenc enclen string def</code>
<code>            0 1 enclen 1 sub {</code>
<code>                /j exch def</code>
<code>                /char enc j get def</code>
<code>                revenc enclen j sub 1 sub char put</code>
<code>            } for</code>
<code>            /enc revenc def</code>
<code>        } if</code>
<code>        sbs i 6 mul 3 add enc putinterval   % Put encoded digit into sbs</code>
<code>        txt i [barcode i 1 getinterval i 1 sub 9 mul 10 add textxoffset add textyoffset textfont textsize] put</code>
<code>    } for</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs [sbs {48 sub} forall]</code>
<code>    /bhs [16{height}repeat]</code>
<code>    /bbs [16{0}repeat]</code>
<code>    includetext {</code>
<code>        /txt txt</code>
<code>    } if</code>
<code>    /opt options</code>
<code>    /guardrightpos 5.0</code>
<code>    /guardrightypos textyoffset 4 add</code>
<code>    /borderleft 12.0</code>
<code>    /borderright 5.0</code>
<code>    /bordertop 10.0</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /ean5 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER ean5--</code>
<code></code>
<code>% --BEGIN ENCODER ean2--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear--</code>
<code>% --DESC: EAN-2 (2 digit addon)</code>
<code>% --EXAM: 05</code>
<code>% --EXOP: includetext guardwhitespace</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp ean2 0.0 2024010300 66275 66010</code>
<code>%%BeginData:        119 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/ean2 {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 12.0 def</code>
<code>    /textxoffset 0.0 def</code>
<code>    /textyoffset null def  % sentinal realtype</code>
<code>    /height 0.7 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    textyoffset null eq {</code>
<code>        /textyoffset height 72 mul 1 add def</code>
<code>    } if</code>
<code></code>
<code>    /ean2 //loadctx exec</code>
<code></code>
<code>    % Validate input</code>
<code>    barcode length 2 ne {</code>
<code>      /bwipp.ean2badLength (EAN-2 add-on must be 2 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.ean2badCharacter (EAN-2 add-on must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>{</code>
<code>    % Create an array containing the character mappings</code>
<code>    /encs</code>
<code>    [ (3211) (2221) (2122) (1411) (1132)</code>
<code>      (1231) (1114) (1312) (1213) (3112)</code>
<code>      (112) (11)</code>
<code>    ] def</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>    /barchars (0123456789) def</code>
<code></code>
<code>    % Determine the mirror map based on mod 4 checksum</code>
<code>    /mirrormaps [(00) (01) (10) (11)] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /mirrormap mirrormaps barcode 0 2 getinterval cvi 4 mod get def</code>
<code></code>
<code>    /sbs 13 string def</code>
<code>    /txt 2 array def</code>
<code></code>
<code>    0 1 1 {</code>
<code>        /i exch def</code>
<code></code>
<code>        % Prefix with either a start character or separator character</code>
<code>        i 0 eq {</code>
<code>            sbs 0 encs 10 get putinterval</code>
<code>        } {</code>
<code>            sbs i 1 sub 6 mul 7 add encs 11 get putinterval</code>
<code>        } ifelse</code>
<code></code>
<code>        % Lookup the encoding for the barcode character</code>
<code>        barcode i 1 getinterval barchars exch search</code>
<code>        pop                     % Discard true leaving pre</code>
<code>        length /indx exch def   % indx is the length of pre</code>
<code>        pop pop                 % Discard seek and post</code>
<code>        /enc encs indx get def  % Get the indxth encoding</code>
<code>        mirrormap i get 49 eq { % Reverse enc if 1 in this position in mirrormap</code>
<code>            /enclen enc length def</code>
<code>            /revenc enclen string def</code>
<code>            0 1 enclen 1 sub {</code>
<code>                /j exch def</code>
<code>                /char enc j get def</code>
<code>                revenc enclen j sub 1 sub char put</code>
<code>            } for</code>
<code>            /enc revenc def</code>
<code>        } if</code>
<code>        sbs i 6 mul 3 add enc putinterval   % Put encoded digit into sbs</code>
<code>        txt i [barcode i 1 getinterval i 1 sub 9 mul 10 add textxoffset add textyoffset textfont textsize] put</code>
<code>    } for</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs [sbs {48 sub} forall]</code>
<code>    /bhs [12{height}repeat]</code>
<code>    /bbs [12{0}repeat]</code>
<code>    includetext {</code>
<code>        /txt txt</code>
<code>    } if</code>
<code>    /opt options</code>
<code>    /guardrightpos 5.0</code>
<code>    /guardrightypos textyoffset 4 add</code>
<code>    /borderleft 12.0</code>
<code>    /borderright 5.0</code>
<code>    /bordertop 10.0</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /ean2 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER ean2--</code>
<code></code>
<code>% --BEGIN ENCODER ean13--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear ean5 ean2--</code>
<code>% --DESC: EAN-13</code>
<code>% --EXAM: 9520123456788</code>
<code>% --EXOP: includetext guardwhitespace</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp ean13 0.0 2024010300 85896 82167</code>
<code>%%BeginData:        208 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /ean2 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /ean5 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/ean13 {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 12.0 def</code>
<code>    /textxoffset -11.0 def</code>
<code>    /textyoffset -4.0 def</code>
<code>    /height 1.0 def</code>
<code>    /addongap 12.0 def</code>
<code>    /addontextfont (unset) def</code>
<code>    /addontextsize null def     % realtype sentinal</code>
<code>    /addontextxoffset null def  % realtype sentinal</code>
<code>    /addontextyoffset null def  % realtype sentinal</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /ean13 //loadctx exec</code>
<code></code>
<code>    % Split off the addon</code>
<code>    barcode ( ) search {</code>
<code>        /barcode exch def</code>
<code>        pop</code>
<code>        /addon exch def</code>
<code>    } {</code>
<code>        pop</code>
<code>        /addon () def</code>
<code>    } ifelse</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode length 12 ne barcode length 13 ne and {</code>
<code>        /bwipp.ean13badLength (EAN-13 must be 12 or 13 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.ean13badCharacter (EAN-13 must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code>    addon length 0 ne addon length 2 ne and addon length 5 ne and {</code>
<code>        /bwipp.ean13badAddOnLength (Add-on for EAN-13 must be 2 or 5 digits) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Add checksum digit</code>
<code>    /pad 13 string def</code>
<code>    /checksum 0 def</code>
<code>    0 1 11 {</code>
<code>        /i exch def</code>
<code>        /barchar barcode i get 48 sub def</code>
<code>        i 2 mod 0 eq {</code>
<code>            /checksum barchar checksum add def</code>
<code>        } {</code>
<code>            /checksum barchar 3 mul checksum add def</code>
<code>        } ifelse</code>
<code>    } for</code>
<code>    /checksum 10 checksum 10 mod sub 10 mod def</code>
<code>    barcode length 13 eq {</code>
<code>        barcode 12 get checksum 48 add ne {</code>
<code>            /bwipp.ean13badCheckDigit (Incorrect EAN-13 check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code>    pad 0 barcode putinterval       % Add barcode to the start of the pad</code>
<code>    pad 12 checksum 48 add put      % Put ascii for checksum at end of pad</code>
<code>    /barcode pad def</code>
<code></code>
<code>{</code>
<code>    % Create an array containing the character mappings</code>
<code>    /encs</code>
<code>    [ (3211) (2221) (2122) (1411) (1132)</code>
<code>      (1231) (1114) (1312) (1213) (3112)</code>
<code>      (111) (11111) (111)</code>
<code>    ] def</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>    /barchars (0123456789) def</code>
<code></code>
<code>    % Digits to mirror on left side</code>
<code>    /mirrormaps</code>
<code>    [ (000000) (001011) (001101) (001110) (010011)</code>
<code>      (011001) (011100) (010101) (010110) (011010)</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /sbs 59 string def</code>
<code>    /txt 13 array def</code>
<code></code>
<code>    % Put the start character</code>
<code>    sbs 0 encs 10 get putinterval</code>
<code></code>
<code>    % First digit - determine mirrormap by this and show before guard bars</code>
<code>    /mirrormap mirrormaps barcode 0 get 48 sub get def</code>
<code>    txt 0 [barcode 0 1 getinterval textxoffset textyoffset textfont textsize] put</code>
<code></code>
<code>    % Left side - performs mirroring</code>
<code>    1 1 6 {</code>
<code>        % Lookup the encoding for the each barcode character</code>
<code>        /i exch def</code>
<code>        barcode i 1 getinterval barchars exch search</code>
<code>        pop                            % Discard true leaving pre</code>
<code>        length /indx exch def          % indx is the length of pre</code>
<code>        pop pop                        % Discard seek and post</code>
<code>        /enc encs indx get def         % Get the indxth encoding</code>
<code>        mirrormap i 1 sub get 49 eq {   % Reverse enc if 1 in this position in mirrormap</code>
<code>            /enclen enc length def</code>
<code>            /revenc enclen string def</code>
<code>            0 1 enclen 1 sub {</code>
<code>                /j exch def</code>
<code>                /char enc j get def</code>
<code>                revenc enclen j sub 1 sub char put</code>
<code>            } for</code>
<code>            /enc revenc def</code>
<code>        } if</code>
<code>        sbs i 1 sub 4 mul 3 add enc putinterval   % Put encoded digit into sbs</code>
<code>        txt i [barcode i 1 getinterval i 1 sub 7 mul 15 add textxoffset add textyoffset textfont textsize] put</code>
<code>    } for</code>
<code></code>
<code>    % Put the middle character</code>
<code>    sbs 7 1 sub 4 mul 3 add encs 11 get putinterval</code>
<code></code>
<code>    % Right side</code>
<code>    7 1 12 {</code>
<code>        % Lookup the encoding for the each barcode character</code>
<code>        /i exch def</code>
<code>        barcode i 1 getinterval barchars exch search</code>
<code>        pop                            % Discard true leaving pre</code>
<code>        length /indx exch def          % indx is the length of pre</code>
<code>        pop pop                        % Discard seek and post</code>
<code>        /enc encs indx get def         % Get the indxth encoding</code>
<code>        sbs i 1 sub 4 mul 8 add enc putinterval  % Put encoded digit into sbs</code>
<code>        txt i [barcode i 1 getinterval i 1 sub 7 mul 19 add textxoffset add textyoffset textfont textsize] put</code>
<code>    } for</code>
<code></code>
<code>    % Put the end character</code>
<code>    sbs 56 encs 12 get putinterval</code>
<code></code>
<code>    /sbs [sbs {48 sub} forall] def</code>
<code>    includetext {</code>
<code>        /bhs [height height 12{height .075 sub}repeat height height 12{height .075 sub}repeat height height] def</code>
<code>        /bbs [0 0 12{.075}repeat 0 0 12{.075}repeat 0 0] def</code>
<code>    } {</code>
<code>        /bhs [30{height}repeat] def</code>
<code>        /bbs [30{0}repeat] def</code>
<code>        /txt [] def</code>
<code>    } ifelse</code>
<code>    /guardrightypos 0.0 def</code>
<code></code>
<code>    % Append the addon</code>
<code>    addon () ne {</code>
<code>        /addopts &lt;&lt;</code>
<code>            /dontdraw true</code>
<code>            /includetext true</code>
<code>            /height height 0.15 sub</code>
<code>            /textxoffset addontextxoffset null ne {addontextxoffset} {95 addongap add} ifelse</code>
<code>            addontextyoffset null ne {/textyoffset addontextyoffset} if</code>
<code>            /textsize addontextsize null ne {addontextsize} {textsize} ifelse</code>
<code>            /textfont addontextfont (unset) ne {addontextfont} {textfont} ifelse</code>
<code>        &gt;&gt; def</code>
<code>        addon length 2 eq {addon addopts //ean2 exec} if</code>
<code>        addon length 5 eq {addon addopts //ean5 exec} if</code>
<code>        /addcode exch def</code>
<code>        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def</code>
<code>        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def</code>
<code>        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def</code>
<code>        /txt [txt aload pop addcode (txt) get aload pop] def</code>
<code>        /guardrightypos height 72 mul 6 sub def</code>
<code>    } if</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs sbs</code>
<code>    /bhs bhs</code>
<code>    /bbs bbs</code>
<code>    /txt txt</code>
<code>    /opt options</code>
<code>    /guardrightpos addon () eq {7.0} {5.0} ifelse</code>
<code>    /guardrightypos guardrightypos</code>
<code>    /borderleft 11.0</code>
<code>    /borderright addon () eq {7.0} {5.0} ifelse</code>
<code>    /bordertop 0.0</code>
<code>    /borderbottom 5.0</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /ean13 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER ean13--</code>
<code></code>
<code>% --BEGIN ENCODER ean8--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear ean5 ean2--</code>
<code>% --DESC: EAN-8</code>
<code>% --EXAM: 95200002</code>
<code>% --EXOP: includetext guardwhitespace</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp ean8 0.0 2024010300 83246 79418</code>
<code>%%BeginData:        189 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /ean2 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /ean5 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/ean8 {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def              % Enable/disable text</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 12.0 def</code>
<code>    /textxoffset 4.0 def</code>
<code>    /textyoffset -4.0 def</code>
<code>    /height 1.0 def</code>
<code>    /addongap 12.0 def</code>
<code>    /addontextfont (unset) def</code>
<code>    /addontextsize null def</code>
<code>    /addontextxoffset null def  % realtype sentinal</code>
<code>    /addontextyoffset null def  % realtype sentinal</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /ean8 //loadctx exec</code>
<code></code>
<code>    % Split off the addon</code>
<code>    barcode ( ) search {</code>
<code>        /barcode exch def</code>
<code>        pop</code>
<code>        /addon exch def</code>
<code>    } {</code>
<code>        pop</code>
<code>        /addon () def</code>
<code>    } ifelse</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode length 7 ne barcode length 8 ne and {</code>
<code>        /bwipp.ean8badLength (EAN-8 must be 7 or 8 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.ean8badCharacter (EAN-8 must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code>    addon length 0 ne addon length 2 ne and addon length 5 ne and {</code>
<code>        /bwipp.ean8badAddOnLength (Add-on for EAN-8 must be 2 or 5 digits) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Add checksum digit</code>
<code>    /pad 8 string def</code>
<code>    /checksum 0 def</code>
<code>    0 1 6 {</code>
<code>        /i exch def</code>
<code>        /barchar barcode i get 48 sub def</code>
<code>        i 2 mod 0 ne {</code>
<code>            /checksum barchar checksum add def</code>
<code>        } {</code>
<code>            /checksum barchar 3 mul checksum add def</code>
<code>        } ifelse</code>
<code>    } for</code>
<code>    /checksum 10 checksum 10 mod sub 10 mod def</code>
<code>    barcode length 8 eq {</code>
<code>        barcode 7 get checksum 48 add ne {</code>
<code>            /bwipp.ean8badCheckDigit (Incorrect EAN-8 check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code>    pad 0 barcode putinterval      % Add barcode to the start of the pad</code>
<code>    pad 7 checksum 48 add put      % Put ascii for checksum at end of pad</code>
<code>    /barcode pad def</code>
<code></code>
<code>    % Create an array containing the character mappings</code>
<code>{</code>
<code>    /encs</code>
<code>    [ (3211) (2221) (2122) (1411) (1132)</code>
<code>      (1231) (1114) (1312) (1213) (3112)</code>
<code>      (111) (11111) (111)</code>
<code>    ] def</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>    /barchars (0123456789) def</code>
<code>} ctxdef</code>
<code></code>
<code>    /sbs 43 string def</code>
<code>    /txt 8 array def</code>
<code></code>
<code>    % Put the start character</code>
<code>    sbs 0 encs 10 get putinterval</code>
<code></code>
<code>    % Left side</code>
<code>    0 1 3 {</code>
<code>        % Lookup the encoding for the each barcode character</code>
<code>        /i exch def</code>
<code>        barcode i 1 getinterval barchars exch search</code>
<code>        pop                                % Discard true leaving pre</code>
<code>        length /indx exch def              % indx is the length of pre</code>
<code>        pop pop                            % Discard seek and post</code>
<code>        /enc encs indx get def             % Get the indxth encoding</code>
<code>        sbs i 4 mul 3 add enc putinterval  % Put encoded digit into sbs</code>
<code>        txt i [barcode i 1 getinterval i 7 mul textxoffset add textyoffset textfont textsize] put</code>
<code>    } for</code>
<code></code>
<code>    % Put the middle character</code>
<code>    sbs 4 4 mul 3 add encs 11 get putinterval</code>
<code></code>
<code>    % Right side</code>
<code>    4 1 7 {</code>
<code>        % Lookup the encoding for the each barcode character</code>
<code>        /i exch def</code>
<code>        barcode i 1 getinterval barchars exch search</code>
<code>        pop                                % Discard true leaving pre</code>
<code>        length /indx exch def              % indx is the length of pre</code>
<code>        pop pop                            % Discard seek and post</code>
<code>        /enc encs indx get def             % Get the indxth encoding</code>
<code>        sbs i 4 mul 8 add enc putinterval  % Put encoded digit into sbs</code>
<code>        txt i [barcode i 1 getinterval i 7 mul textxoffset add 4 add textyoffset textfont textsize] put</code>
<code>    } for</code>
<code></code>
<code>    % Put the end character</code>
<code>    sbs 40 encs 12 get putinterval</code>
<code></code>
<code>    /sbs [sbs {48 sub} forall] def</code>
<code>    includetext {</code>
<code>        /bhs [height height 8{height .075 sub}repeat height height 8{height .075 sub}repeat height height] def</code>
<code>        /bbs [0 0 8{.075}repeat 0 0 8{.075}repeat 0 0] def</code>
<code>    } {</code>
<code>        /bhs [22{height}repeat] def</code>
<code>        /bbs [22{0}repeat] def</code>
<code>        /txt [] def</code>
<code>    } ifelse</code>
<code>    /guardrightypos 0.0 def</code>
<code></code>
<code>    % Append the addon</code>
<code>    addon () ne {</code>
<code>        /addopts &lt;&lt;</code>
<code>            /dontdraw true</code>
<code>            /includetext true</code>
<code>            /height height 0.15 sub</code>
<code>            /textxoffset addontextxoffset null ne {addontextxoffset} {67 addongap add} ifelse</code>
<code>            addontextyoffset null ne {/textyoffset addontextyoffset} if</code>
<code>            /textsize addontextsize null ne {addontextsize} {textsize} ifelse</code>
<code>            /textfont addontextfont (unset) ne {addontextfont} {textfont} ifelse</code>
<code>        &gt;&gt; def</code>
<code>        addon length 2 eq {addon addopts //ean2 exec} if</code>
<code>        addon length 5 eq {addon addopts //ean5 exec} if</code>
<code>        /addcode exch def</code>
<code>        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def</code>
<code>        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def</code>
<code>        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def</code>
<code>        /txt [txt aload pop addcode (txt) get aload pop] def</code>
<code>        /guardrightypos height 72 mul 6 sub def</code>
<code>    } if</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs sbs</code>
<code>    /bhs bhs</code>
<code>    /bbs bbs</code>
<code>    /txt txt</code>
<code>    /opt options</code>
<code>    /guardleftpos 7.0</code>
<code>    /guardrightpos addon () eq {7.0} {5.0} ifelse</code>
<code>    /guardrightypos guardrightypos</code>
<code>    /borderleft 7.0</code>
<code>    /borderright addon () eq {7.0} {5.0} ifelse</code>
<code>    /bordertop 0.0</code>
<code>    /borderbottom 5.0</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /ean8 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER ean8--</code>
<code></code>
<code>% --BEGIN ENCODER upca--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear ean5 ean2--</code>
<code>% --DESC: UPC-A</code>
<code>% --EXAM: 012345000058</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp upca 0.0 2024010300 90873 87086</code>
<code>%%BeginData:        241 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /ean2 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /ean5 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/upca {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 12.0 def</code>
<code>    /textxoffset -9.0 def</code>
<code>    /textyoffset -4.0 def</code>
<code>    /height 1.0 def</code>
<code>    /addongap 12.0 def</code>
<code>    /addontextfont (unset) def</code>
<code>    /addontextsize null def     % sentinal realtype</code>
<code>    /addontextxoffset null def  % sentinal realtype</code>
<code>    /addontextyoffset null def  % sentinal realtype</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /upca //loadctx exec</code>
<code></code>
<code>    % Split off the addon</code>
<code>    barcode ( ) search {</code>
<code>        /barcode exch def</code>
<code>        pop</code>
<code>        /addon exch def</code>
<code>    } {</code>
<code>        pop</code>
<code>        /addon () def</code>
<code>    } ifelse</code>
<code></code>
<code>    % Expand a given UPC-E</code>
<code>    barcode length 7 eq barcode length 8 eq or {</code>
<code>        % Validate the input</code>
<code>        barcode {</code>
<code>            dup 48 lt exch 57 gt or {</code>
<code>                /bwipp.upcAupcEbadCharacter (UPC-E must contain only digits) //raiseerror exec</code>
<code>            } if</code>
<code>        } forall</code>
<code>        barcode 0 get dup 48 ne exch 49 ne and {</code>
<code>            /bwipp.upcAupcEbadNumberSystem (UPC-E must have number system 0 or 1) //raiseerror exec</code>
<code>        } if</code>
<code>        1 {  % Common exit</code>
<code>            /upcacode barcode length 8 eq {12} {11} ifelse string def</code>
<code>            barcode 6 get 48 sub 2 le {</code>
<code>                upcacode 0 barcode 0 3 getinterval putinterval</code>
<code>                upcacode 3 barcode 6 1 getinterval putinterval</code>
<code>                upcacode 4 (0000) putinterval</code>
<code>                upcacode 8 barcode 3 3 getinterval putinterval</code>
<code>                exit</code>
<code>            } if</code>
<code>            barcode 6 get 48 sub 3 eq {</code>
<code>                upcacode 0 barcode 0 4 getinterval putinterval</code>
<code>                upcacode 4 (00000) putinterval</code>
<code>                upcacode 9 barcode 4 2 getinterval putinterval</code>
<code>                exit</code>
<code>            } if</code>
<code>            barcode 6 get 48 sub 4 eq {</code>
<code>                upcacode 0 barcode 0 5 getinterval putinterval</code>
<code>                upcacode 5 (00000) putinterval</code>
<code>                upcacode 10 barcode 5 1 getinterval putinterval</code>
<code>                exit</code>
<code>            } if</code>
<code>            barcode 6 get 48 sub 5 ge {</code>
<code>                upcacode 0 barcode 0 6 getinterval putinterval</code>
<code>                upcacode 6 (0000) putinterval</code>
<code>                upcacode 10 barcode 6 1 getinterval putinterval</code>
<code>                exit</code>
<code>            } if</code>
<code>        } repeat</code>
<code>        barcode length 8 eq {</code>
<code>            upcacode 11 barcode 7 1 getinterval putinterval</code>
<code>        } if</code>
<code>        /barcode upcacode def</code>
<code>    } if</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode length 11 ne barcode length 12 ne and {</code>
<code>        /bwipp.upcAbadLength (UPC-A must be 11 or 12 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.upcAbadCharacter (UPC-A must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code>    addon length 0 ne addon length 2 ne and addon length 5 ne and {</code>
<code>        /bwipp.upcAbadAddOnLength (Add-on for UPC-A must be 2 or 5 digits) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Add checksum digit to barcode</code>
<code>    /pad 12 string def   % Create pad one bigger than barcode</code>
<code>    /checksum 0 def</code>
<code>    0 1 10 {</code>
<code>        /i exch def</code>
<code>        /barchar barcode i get 48 sub def</code>
<code>        i 2 mod 0 ne {</code>
<code>            /checksum checksum barchar add def</code>
<code>        } {</code>
<code>            /checksum checksum barchar 3 mul add def</code>
<code>        } ifelse</code>
<code>    } for</code>
<code>    /checksum 10 checksum 10 mod sub 10 mod def</code>
<code>    barcode length 12 eq {</code>
<code>        barcode 11 get checksum 48 add ne {</code>
<code>            /bwipp.upcAbadCheckDigit (Incorrect UPC check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code>    pad 0 barcode putinterval       % Add barcode to the start of the pad</code>
<code>    pad 11 checksum 48 add put      % Put ascii for checksum at end of pad</code>
<code>    /barcode pad def</code>
<code></code>
<code>    % Create an array containing the character mappings</code>
<code>{</code>
<code>    /encs</code>
<code>    [ (3211) (2221) (2122) (1411) (1132)</code>
<code>      (1231) (1114) (1312) (1213) (3112)</code>
<code>      (111) (11111) (111)</code>
<code>    ] def</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>    /barchars (0123456789) def</code>
<code>} ctxdef</code>
<code></code>
<code>    /sbs 59 string def</code>
<code>    /txt 12 array def</code>
<code></code>
<code>    % Put the start character</code>
<code>    sbs 0 encs 10 get putinterval</code>
<code></code>
<code>    % Left side</code>
<code>    0 1 5 {</code>
<code>        % Lookup the encoding for the each barcode character</code>
<code>        /i exch def</code>
<code>        barcode i 1 getinterval barchars exch search</code>
<code>        pop                                % Discard true leaving pre</code>
<code>        length /indx exch def              % indx is the length of pre</code>
<code>        pop pop                            % Discard seek and post</code>
<code>        /enc encs indx get def             % Get the indxth encoding</code>
<code>        sbs i 4 mul 3 add enc putinterval  % Put encoded digit into sbs</code>
<code>        i 0 eq {      % First digit is before the guard bars</code>
<code>            txt 0 [barcode 0 1 getinterval textxoffset textyoffset textfont textsize 2 sub] put</code>
<code>        } {</code>
<code>            txt i [barcode i 1 getinterval i 7 mul 13 add textxoffset add textyoffset textfont textsize] put</code>
<code>        } ifelse</code>
<code>    } for</code>
<code></code>
<code>    % Put the middle character</code>
<code>    sbs 6 4 mul 3 add encs 11 get putinterval</code>
<code></code>
<code>    % Right side</code>
<code>    6 1 11 {</code>
<code>        % Lookup the encoding for the each barcode character</code>
<code>        /i exch def</code>
<code>        barcode i 1 getinterval barchars exch search</code>
<code>        pop                                % Discard true leaving pre</code>
<code>        length /indx exch def              % indx is the length of pre</code>
<code>        pop pop                            % Discard seek and post</code>
<code>        /enc encs indx get def             % Get the indxth encoding</code>
<code>        sbs i 4 mul 8 add enc putinterval  % Put encoded digit into sbs</code>
<code>        i 11 eq {       % Last digit is after guard bars</code>
<code>            txt 11 [barcode 11 1 getinterval textxoffset 107 add textyoffset textfont textsize 2 sub] put</code>
<code>        } {</code>
<code>            txt i [barcode i 1 getinterval i 7 mul textxoffset add 17 add textyoffset textfont textsize] put</code>
<code>        } ifelse</code>
<code>    } for</code>
<code></code>
<code>    % Put the end character</code>
<code>    sbs 56 encs 12 get putinterval</code>
<code></code>
<code>    /sbs [sbs {48 sub} forall] def</code>
<code>    includetext {</code>
<code>        /bhs [4{height}repeat 10{height .075 sub}repeat height height 10{height .075 sub}repeat 4{height}repeat] def</code>
<code>        /bbs [0 0 0 0 10{.075}repeat 0 0 10{.075}repeat 0 0 0 0] def</code>
<code>    } {</code>
<code>        /bhs [30{height}repeat] def</code>
<code>        /bbs [30{0}repeat] def</code>
<code>        /txt [] def</code>
<code>    } ifelse</code>
<code>    /guardrightypos 0.0 def</code>
<code></code>
<code>    % Append the addon</code>
<code>    addon () ne {</code>
<code>        /addopts &lt;&lt;</code>
<code>            /dontdraw true</code>
<code>            /includetext true</code>
<code>            /height height 0.15 sub</code>
<code>            /textxoffset addontextxoffset null ne {addontextxoffset} {95 addongap add} ifelse</code>
<code>            addontextyoffset null ne {/textyoffset addontextyoffset} if</code>
<code>            /textsize addontextsize null ne {addontextsize} {textsize} ifelse</code>
<code>            /textfont addontextfont (unset) ne {addontextfont} {textfont} ifelse</code>
<code>        &gt;&gt; def</code>
<code>        addon length 2 eq {addon addopts //ean2 exec} if</code>
<code>        addon length 5 eq {addon addopts //ean5 exec} if</code>
<code>        /addcode exch def</code>
<code>        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def</code>
<code>        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def</code>
<code>        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def</code>
<code>        /txt [txt aload pop addcode (txt) get aload pop] def</code>
<code>        /guardrightypos height 72 mul 6 sub def</code>
<code>    } if</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs sbs</code>
<code>    /bhs bhs</code>
<code>    /bbs bbs</code>
<code>    /txt txt</code>
<code>    /opt options</code>
<code>    /guardrightpos addon () eq {9.0} {5.0} ifelse</code>
<code>    /guardrightypos guardrightypos</code>
<code>    /borderleft 9.0</code>
<code>    /borderright addon () eq {9.0} {5.0} ifelse</code>
<code>    /bordertop 0.0</code>
<code>    /borderbottom 5.0</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /upca dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER upca--</code>
<code></code>
<code>% --BEGIN ENCODER upce--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear ean5 ean2--</code>
<code>% --DESC: UPC-E</code>
<code>% --EXAM: 01234558</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp upce 0.0 2024010300 95502 91734</code>
<code>%%BeginData:        280 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /ean2 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /ean5 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/upce {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def               % Enable/disable text</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 12.0 def</code>
<code>    /textxoffset -9.0 def</code>
<code>    /textyoffset -4.0 def</code>
<code>    /height 1.0 def</code>
<code>    /addongap 12.0 def</code>
<code>    /addontextfont (unset) def</code>
<code>    /addontextsize null def     % sentinal realtype</code>
<code>    /addontextxoffset null def  % sentinal realtype</code>
<code>    /addontextyoffset null def  % sentinal realtype</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /upce //loadctx exec</code>
<code></code>
<code>    % Split off the addon</code>
<code>    barcode ( ) search {</code>
<code>        /barcode exch def</code>
<code>        pop</code>
<code>        /addon exch def</code>
<code>    } {</code>
<code>        pop</code>
<code>        /addon () def</code>
<code>    } ifelse</code>
<code></code>
<code>    % Compress a given UPC-A</code>
<code>    barcode length 11 eq barcode length 12 eq or {</code>
<code>        % Validate the input</code>
<code>        barcode {</code>
<code>            dup 48 lt exch 57 gt or {</code>
<code>                /bwipp.upcEupcAbadCharacter (UPC-A must contain only digits) //raiseerror exec</code>
<code>            } if</code>
<code>        } forall</code>
<code>        1 {  % Common exit</code>
<code>            /upcecode barcode length 12 eq {8} {7} ifelse string def</code>
<code>            barcode 3 get 48 sub 2 le barcode 4 4 getinterval (0000) eq and {</code>
<code>                upcecode 0 barcode  0 3 getinterval putinterval</code>
<code>                upcecode 3 barcode  8 3 getinterval putinterval</code>
<code>                upcecode 6 barcode  3 1 getinterval putinterval</code>
<code>                exit</code>
<code>            } if</code>
<code>            barcode 4 5 getinterval (00000) eq {</code>
<code>                upcecode 0 barcode  0 4 getinterval putinterval</code>
<code>                upcecode 4 barcode  9 2 getinterval putinterval</code>
<code>                upcecode 6 (3) putinterval</code>
<code>                exit</code>
<code>            } if</code>
<code>            barcode 5 5 getinterval (00000) eq {</code>
<code>                upcecode 0 barcode  0 5 getinterval putinterval</code>
<code>                upcecode 5 barcode 10 1 getinterval putinterval</code>
<code>                upcecode 6 (4) putinterval</code>
<code>                exit</code>
<code>            } if</code>
<code>            barcode 10 get 48 sub 5 ge barcode 6 4 getinterval (0000) eq and {</code>
<code>                upcecode 0 barcode  0 6 getinterval putinterval</code>
<code>                upcecode 6 barcode 10 1 getinterval putinterval</code>
<code>                exit</code>
<code>            } if</code>
<code>            /bwipp.upcEupcAnotCompressible (UPC-A cannot be converted to a UPC-E) //raiseerror exec</code>
<code>        } repeat</code>
<code>        barcode length 12 eq {</code>
<code>            upcecode 7 barcode 11 1 getinterval putinterval</code>
<code>        } if</code>
<code>        /barcode upcecode def</code>
<code>    } if</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode length 7 ne barcode length 8 ne and {</code>
<code>        /bwipp.upcEbadLength (UPC-E must be 7 or 8 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.upcEbadCharacter (UPC-E must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code>    addon length 0 ne addon length 2 ne and addon length 5 ne and {</code>
<code>        /bwipp.upcEbadAddOnLength (Add-on for UPC-E must be 2 or 5 digits) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Ensure 0 or 1 number systems</code>
<code>    barcode 0 get dup 48 ne exch 49 ne and {</code>
<code>        /bwipp.upcEbadNumberSystem (UPC-E must have number system 0 or 1) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>{</code>
<code>    % Create an array containing the character mappings</code>
<code>    /encs</code>
<code>    [ (3211) (2221) (2122) (1411) (1132)</code>
<code>      (1231) (1114) (1312) (1213) (3112)</code>
<code>      (111) (111111)</code>
<code>    ] def</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>    /barchars (0123456789) def</code>
<code></code>
<code>    /mirrormaps</code>
<code>    [ (000111) (001011) (001101) (001110) (010011)</code>
<code>      (011001) (011100) (010101) (010110) (011010)</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Derive the equivalent UPC-A for its checksum</code>
<code>    1 {  % Common exit</code>
<code>        /upcacode 11 string def</code>
<code>        barcode 6 get 48 sub 2 le {</code>
<code>            upcacode 0 barcode 0 3 getinterval putinterval</code>
<code>            upcacode 3 barcode 6 1 getinterval putinterval</code>
<code>            upcacode 4 (0000) putinterval</code>
<code>            upcacode 8 barcode 3 3 getinterval putinterval</code>
<code>            exit</code>
<code>        } if</code>
<code>        barcode 6 get 48 sub 3 eq {</code>
<code>            upcacode 0 barcode 0 4 getinterval putinterval</code>
<code>            upcacode 4 (00000) putinterval</code>
<code>            upcacode 9 barcode 4 2 getinterval putinterval</code>
<code>            exit</code>
<code>        } if</code>
<code>        barcode 6 get 48 sub 4 eq {</code>
<code>            upcacode 0 barcode 0 5 getinterval putinterval</code>
<code>            upcacode 5 (00000) putinterval</code>
<code>            upcacode 10 barcode 5 1 getinterval putinterval</code>
<code>            exit</code>
<code>        } if</code>
<code>        barcode 6 get 48 sub 5 ge {</code>
<code>            upcacode 0 barcode 0 6 getinterval putinterval</code>
<code>            upcacode 6 (0000) putinterval</code>
<code>            upcacode 10 barcode 6 1 getinterval putinterval</code>
<code>            exit</code>
<code>        } if</code>
<code>    } repeat</code>
<code>    /checksum 0 def</code>
<code>    0 1 10 {</code>
<code>       /i exch def</code>
<code>       /barchar upcacode i get 48 sub def</code>
<code>       i 2 mod 0 ne {</code>
<code>           /checksum checksum barchar add def</code>
<code>       } {</code>
<code>           /checksum checksum barchar 3 mul add def</code>
<code>       } ifelse</code>
<code>    } for</code>
<code>    /checksum 10 checksum 10 mod sub 10 mod def</code>
<code>    barcode length 8 eq {</code>
<code>        barcode 7 get checksum 48 add ne {</code>
<code>            /bwipp.upcEbadCheckDigit (Incorrect UPC check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code>    /pad 8 string def</code>
<code>    pad 0 barcode putinterval       % Add barcode to the start of the pad</code>
<code>    pad 7 checksum 48 add put       % Put ascii for checksum at end of pad</code>
<code>    /barcode pad def</code>
<code>    /txt 8 array def</code>
<code>    txt 0 [barcode 0 1 getinterval textxoffset textyoffset textfont textsize 2 sub] put</code>
<code></code>
<code>    % Determine the mirror map based on checksum</code>
<code>    /mirrormap mirrormaps checksum get def</code>
<code></code>
<code>    % Invert the mirrormap if we are using a non-zero number system</code>
<code>    barcode 0 get 48 eq {</code>
<code>        /invt mirrormap length string def</code>
<code>        0 1 mirrormap length 1 sub {</code>
<code>            /i exch def</code>
<code>            mirrormap i get 48 eq {</code>
<code>                invt i 49 put</code>
<code>            } {</code>
<code>                invt i 48 put</code>
<code>            } ifelse</code>
<code>        } for</code>
<code>        /mirrormap invt def</code>
<code>    } if</code>
<code></code>
<code>    /sbs 33 string def</code>
<code></code>
<code>    % Put the start character</code>
<code>    sbs 0 encs 10 get putinterval</code>
<code></code>
<code>    1 1 6 {</code>
<code>        /i exch def</code>
<code>        % Lookup the encoding for the each barcode character</code>
<code>        barcode i 1 getinterval barchars exch search</code>
<code>        pop                            % Discard true leaving pre</code>
<code>        length /indx exch def          % indx is the length of pre</code>
<code>        pop pop                        % Discard seek and post</code>
<code>        /enc encs indx get def         % Get the indxth encoding</code>
<code>        mirrormap i 1 sub get 49 eq {  % Reverse enc if 1 in this position in mirrormap</code>
<code>            /enclen enc length def</code>
<code>            /revenc enclen string def</code>
<code>            0 1 enclen 1 sub {</code>
<code>                /j exch def</code>
<code>                /char enc j get def</code>
<code>                revenc enclen j sub 1 sub char put</code>
<code>            } for</code>
<code>            /enc revenc def</code>
<code>        } if</code>
<code>        sbs i 1 sub 4 mul 3 add enc putinterval   % Put encoded digit into sbs</code>
<code>        txt i [barcode i 1 getinterval i 1 sub 7 mul 13 add textxoffset add textyoffset textfont textsize] put</code>
<code>    } for</code>
<code></code>
<code>    txt 7 [barcode 7 1 getinterval 6 7 mul 21 add textxoffset add textyoffset textfont textsize 2 sub] put</code>
<code></code>
<code>    % Put the end character</code>
<code>    sbs 27 encs 11 get putinterval</code>
<code></code>
<code>    /sbs [sbs {48 sub} forall] def</code>
<code>    includetext {</code>
<code>        /bhs [height height 12{height .075 sub}repeat height height height] def</code>
<code>        /bbs [0 0 12{.075}repeat 0 0 0] def</code>
<code>    } {</code>
<code>        /bhs [17{height}repeat] def</code>
<code>        /bbs [17{0}repeat] def</code>
<code>        /txt [] def</code>
<code>    } ifelse</code>
<code>    /guardrightypos 0.0 def</code>
<code></code>
<code>    % Append the addon</code>
<code>    addon () ne {</code>
<code>        /addopts &lt;&lt;</code>
<code>            /dontdraw true</code>
<code>            /includetext true</code>
<code>            /height height 0.15 sub</code>
<code>            /textxoffset addontextxoffset null ne {addontextxoffset} {51 addongap add} ifelse</code>
<code>            addontextyoffset null ne {/textyoffset addontextyoffset} if</code>
<code>            /textsize addontextsize null ne {addontextsize} {textsize} ifelse</code>
<code>            /textfont addontextfont (unset) ne {addontextfont} {textfont} ifelse</code>
<code>        &gt;&gt; def</code>
<code>        addon length 2 eq {addon addopts //ean2 exec} if</code>
<code>        addon length 5 eq {addon addopts //ean5 exec} if</code>
<code>        /addcode exch def</code>
<code>        /sbs [sbs aload pop addongap addcode (sbs) get aload pop] def</code>
<code>        /bhs [bhs aload pop addcode (bhs) get {.075 sub} forall] def</code>
<code>        /bbs [bbs aload pop addcode (bbs) get {.075 add} forall] def</code>
<code>        /txt [txt aload pop addcode (txt) get aload pop] def</code>
<code>        /guardrightypos height 72 mul 6 sub def</code>
<code>    } if</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs sbs</code>
<code>    /bhs bhs</code>
<code>    /bbs bbs</code>
<code>    /txt txt</code>
<code>    /opt options</code>
<code>    /guardrightpos addon () eq {9.0} {5.0} ifelse</code>
<code>    /guardrightypos guardrightypos</code>
<code>    /borderleft 9.0</code>
<code>    /borderright addon () eq {9.0} {5.0} ifelse</code>
<code>    /bordertop 0.0</code>
<code>    /borderbottom 5.0</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /upce dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER upce--</code>
<code></code>
<code>% --BEGIN ENCODER isbn--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear ean5 ean2 ean13--</code>
<code>% --DESC: ISBN</code>
<code>% --EXAM: 978-1-56581-231-4 90000</code>
<code>% --EXOP: includetext guardwhitespace</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp isbn 0.0 2024010300 94606 93597</code>
<code>%%BeginData:        238 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /ean13 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/isbn {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def  % Enable/disable ISBN text</code>
<code>    /isbntextfont /OCR-A def</code>
<code>    /isbntextsize 8.0 def</code>
<code>    /isbntextxoffset null def  % sentinal realtype</code>
<code>    /isbntextyoffset null def  % sentinal realtype</code>
<code>    /height 1.0 def</code>
<code>    /addongap 12.0 def</code>
<code>    /legacy false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Split off the addon</code>
<code>    barcode ( ) search {</code>
<code>        /barcode exch def</code>
<code>        pop</code>
<code>        /addon exch def</code>
<code>    } {</code>
<code>        pop</code>
<code>        /addon () def</code>
<code>    } ifelse</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode length 15 ne barcode length 17 ne and</code>
<code>    barcode length 11 ne barcode length 13 ne and and {</code>
<code>        /bwipp.isbnBadLength (ISBN-13 must be 15 or 17 characters including dashes. ISBN-10 must be 11 or 13 characters including dashes) //raiseerror exec</code>
<code>    } if</code>
<code>    addon length 0 ne addon length 2 ne and addon length 5 ne and {</code>
<code>        /bwipp.isbnBadAddOnLength (Add-on for ISBN must be 2 or 5 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode length 15 ge {  % ISBN-13</code>
<code>        barcode 0 4 getinterval dup (978-) ne exch (979-) ne and {</code>
<code>            /bwipp.isbn13badPrefix (ISBN-13 prefix must be 978- or 979-) //raiseerror exec</code>
<code>        } if</code>
<code>        /wasdash false def /numdash 0 def /numdigit 0 def</code>
<code>        barcode 5 9 getinterval {</code>
<code>            dup</code>
<code>            45 eq {</code>
<code>                wasdash {</code>
<code>                    /bwipp.isbn13adjacentDashes (ISBN-13 does not permit adjacent dashes) //raiseerror exec</code>
<code>                } if</code>
<code>                /wasdash true def</code>
<code>                /numdash numdash 1 add def</code>
<code>            } if</code>
<code>            dup 48 ge exch 57 le and {</code>
<code>                /wasdash false def</code>
<code>                /numdigit numdigit 1 add def</code>
<code>            } if</code>
<code>        } forall</code>
<code>        numdash 2 ne numdigit 7 ne or {</code>
<code>            /bwipp.isbn13numDashesDigits (Incorrect number of dashes and digits for ISBN-13) //raiseerror exec</code>
<code>        } if</code>
<code>        barcode 14 get dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.isbn13character15 (ISBN-13 character 15 must be a digit) //raiseerror exec</code>
<code>        } if</code>
<code>        barcode length 17 eq {</code>
<code>            barcode 15 1 getinterval (-) ne {</code>
<code>                /bwipp.isbn13character16 (ISBN-13 penultimate character must be a dash) //raiseerror exec</code>
<code>            } if</code>
<code>            barcode 16 get dup 48 lt exch 57 gt or {</code>
<code>                /bwipp.isbn13character17 (ISBN-13 final character must be a digit) //raiseerror exec</code>
<code>            } if</code>
<code>        } if</code>
<code>    } {  % ISBN-10</code>
<code>        barcode 0 get dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.isbn10FirstDigit (ISBN-10 first character must be a digit) //raiseerror exec</code>
<code>        } if</code>
<code>        /wasdash false def /numdash 0 def /numdigit 0 def</code>
<code>        barcode 1 9 getinterval {</code>
<code>            dup</code>
<code>            45 eq {</code>
<code>                wasdash {</code>
<code>                    /bwipp.isbn10adjacentDashes (ISBN-10 does not permit adjacent dashes) //raiseerror exec</code>
<code>                } if</code>
<code>                /wasdash true def</code>
<code>                /numdash numdash 1 add def</code>
<code>            } if</code>
<code>            dup 48 ge exch 57 le and {</code>
<code>                /wasdash false def</code>
<code>                /numdigit numdigit 1 add def</code>
<code>            } if</code>
<code>        } forall</code>
<code>        numdash 2 ne numdigit 7 ne or {</code>
<code>            /bwipp.isbn10numDashesDigits (Incorrect number of dashes and digits for ISBN-10) //raiseerror exec</code>
<code>        } if</code>
<code>        barcode 10 get dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.isbn10character11 (ISBN-10 character 11 must be a digit) //raiseerror exec</code>
<code>        } if</code>
<code>        barcode length 13 eq {</code>
<code>            barcode 11 1 getinterval (-) ne {</code>
<code>                /bwipp.isbn10character12 (ISBN-10 penultimate character must be a dash) //raiseerror exec</code>
<code>            } if</code>
<code>            barcode 12 get dup dup 48 lt exch 57 gt or exch 88 ne and {</code>
<code>                /bwipp.isbn10character13 (ISBN-10 final character must be a digit or X) //raiseerror exec</code>
<code>            } if</code>
<code>        } if</code>
<code>    } ifelse</code>
<code></code>
<code>    /isbntxt barcode def</code>
<code></code>
<code>    % Read the digits from isbntxt and validate checksum for ISBN-10</code>
<code>    isbntxt length 13 le {</code>
<code>        /isbn 10 string def</code>
<code>        /checksum 0 def</code>
<code>        /i 0 def /n 0 def</code>
<code>        { % loop</code>
<code>            /isbnchar isbntxt i get 48 sub def</code>
<code>            isbnchar -3 ne {     % Ignore dashes</code>
<code>                isbn n isbnchar 48 add put</code>
<code>                n 9 lt {</code>
<code>                    /checksum checksum 10 n sub isbnchar mul add def</code>
<code>                } if</code>
<code>                /n n 1 add def</code>
<code>            } if</code>
<code>            /i i 1 add def</code>
<code>            i isbntxt length eq {exit} if</code>
<code>        } loop</code>
<code>        /checksum 11 checksum 11 mod sub 11 mod dup 10 eq {pop 40} if 48 add def</code>
<code>        /isbn isbn 0 9 getinterval def</code>
<code>        isbntxt length 13 eq {</code>
<code>            isbntxt 12 get checksum ne {</code>
<code>                /bwipp.isbn10badCheckDigit (Incorrect ISBN-10 check digit provided) //raiseerror exec</code>
<code>            } if</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    legacy not isbntxt length 15 ge or {</code>
<code></code>
<code>        % Convert ISBN-10 to ISBN-13</code>
<code>        isbntxt length 13 le {</code>
<code>            /pad 15 string def</code>
<code>            pad 0 (978-) putinterval</code>
<code>            pad 4 isbntxt 0 11 getinterval putinterval</code>
<code>            /isbntxt pad def</code>
<code>        } if</code>
<code></code>
<code>        % Read the digits from isbntxt and validate checksum for ISBN-13</code>
<code>        /isbn 13 string def</code>
<code>        /checksum 0 def</code>
<code>        /i 0 def /n 0 def</code>
<code>        { % loop</code>
<code>            /isbnchar isbntxt i get 48 sub def</code>
<code>            isbnchar -3 ne {     % Ignore dashes</code>
<code>                isbn n isbnchar 48 add put</code>
<code>                n 12 lt {</code>
<code>                    /checksum isbnchar n 2 mod 0 ne {3 mul} if checksum add def</code>
<code>                } if</code>
<code>                /n n 1 add def</code>
<code>            } if</code>
<code>            /i i 1 add def</code>
<code>            i isbntxt length eq {exit} if</code>
<code>        } loop</code>
<code>        /checksum 10 checksum 10 mod sub 10 mod 48 add def</code>
<code>        /isbn isbn 0 12 getinterval def</code>
<code>        isbntxt length 17 eq {</code>
<code>            isbntxt 16 get checksum ne {</code>
<code>                /bwipp.isbn13badCheckDigit (Incorrect ISBN-13 check digit provided) //raiseerror exec</code>
<code>            } if</code>
<code>        } if</code>
<code></code>
<code>    } if</code>
<code></code>
<code>    % Add the ISBN header to the isbntxt</code>
<code>    /pad isbn length 12 eq {22} {18} ifelse string def</code>
<code>    pad 0 (ISBN ) putinterval</code>
<code>    pad 5 isbntxt putinterval</code>
<code>    pad pad length 2 sub 45 put</code>
<code>    pad pad length 1 sub checksum put</code>
<code>    /isbntxt pad def</code>
<code></code>
<code>    % Convert ISBN digits to EAN-13</code>
<code>    /barcode 12 string def</code>
<code>    isbn length 9 eq {</code>
<code>        barcode 0 (978) putinterval</code>
<code>        barcode 3 isbn putinterval</code>
<code>    } {</code>
<code>        barcode 0 isbn putinterval</code>
<code>    } ifelse</code>
<code></code>
<code>    % Append the addon</code>
<code>    addon () ne {</code>
<code>        12 addon length add 1 add string</code>
<code>        dup 0 barcode putinterval</code>
<code>        dup 12 ( ) putinterval</code>
<code>        dup 13 addon putinterval</code>
<code>        /barcode exch def</code>
<code>    } if</code>
<code></code>
<code>    % Get the result of encoding with ean13</code>
<code>    options (dontdraw) true put</code>
<code>    options (addongap) addongap put</code>
<code>    /args barcode options //ean13 exec def</code>
<code></code>
<code>    % Add the ISBN text</code>
<code>    includetext {</code>
<code>        isbntextxoffset null eq {</code>
<code>            /isbntextxoffset isbn length 9 eq {-1.0} {-12.0} ifelse def</code>
<code>        } if</code>
<code>        isbntextyoffset null eq {</code>
<code>            /isbntextyoffset height 72 mul 3 add def</code>
<code>        } if</code>
<code>        args (txt) known {</code>
<code>            /txt args (txt) get def</code>
<code>            /newtxt txt length 1 add array def</code>
<code>            newtxt 0 txt putinterval</code>
<code>            newtxt newtxt length 1 sub [isbntxt isbntextxoffset isbntextyoffset isbntextfont isbntextsize] put</code>
<code>            args (txt) newtxt put</code>
<code>        } {</code>
<code>            args (txt) [ [isbntxt isbntextxoffset isbntextyoffset isbntextfont isbntextsize] ] put</code>
<code>        } ifelse</code>
<code>    } if</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /isbn dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER isbn--</code>
<code></code>
<code>% --BEGIN ENCODER ismn--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear ean5 ean2 ean13--</code>
<code>% --DESC: ISMN</code>
<code>% --EXAM: 979-0-2605-3211-3</code>
<code>% --EXOP: includetext guardwhitespace</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp ismn 0.0 2024010300 91050 90286</code>
<code>%%BeginData:        217 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /ean13 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/ismn {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def</code>
<code>    /ismntextfont /OCR-A def</code>
<code>    /ismntextsize 8.0 def</code>
<code>    /ismntextxoffset null def  % sentinal realtype</code>
<code>    /ismntextyoffset null def  % sentinal realtype</code>
<code>    /height 1.0 def</code>
<code>    /addongap 12.0 def</code>
<code>    /legacy false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Split off the addon</code>
<code>    barcode ( ) search {</code>
<code>        /barcode exch def</code>
<code>        pop</code>
<code>        /addon exch def</code>
<code>    } {</code>
<code>        pop</code>
<code>        /addon () def</code>
<code>    } ifelse</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode length 15 ne barcode length 17 ne and</code>
<code>    barcode length 11 ne barcode length 13 ne and and {</code>
<code>        /bwipp.ismnBadLength (ISMN-13 must be 15 or 17 characters including dashes. ISMN-10 must be 11 or 13 characters including dashes) //raiseerror exec</code>
<code>    } if</code>
<code>    addon length 0 ne addon length 2 ne and addon length 5 ne and {</code>
<code>        /bwipp.ismnBadAddOnLength (Add-on for ISMN must be 2 or 5 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode length 15 ge {  % ISMN-13</code>
<code>        barcode 0 4 getinterval (979-) ne {</code>
<code>            /bwipp.ismn13badPrefix (ISMN-13 prefix must be 979-) //raiseerror exec</code>
<code>        } if</code>
<code>        /wasdash false def /numdash 0 def /numdigit 0 def</code>
<code>        barcode 5 9 getinterval {</code>
<code>            dup</code>
<code>            45 eq {</code>
<code>                wasdash {</code>
<code>                    /bwipp.ismn13adjacentDashes (ISMN-13 does not permit adjacent dashes) //raiseerror exec</code>
<code>                } if</code>
<code>                /wasdash true def</code>
<code>                /numdash numdash 1 add def</code>
<code>            } if</code>
<code>            dup 48 ge exch 57 le and {</code>
<code>                /wasdash false def</code>
<code>                /numdigit numdigit 1 add def</code>
<code>            } if</code>
<code>        } forall</code>
<code>        numdash 2 ne numdigit 7 ne or {</code>
<code>            /bwipp.ismn13numDashesDigits (Incorrect number of dashes and digits for ISMN-13) //raiseerror exec</code>
<code>        } if</code>
<code>        barcode 14 get dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.ismn13character15 (ISMN-13 character 15 must be a digit) //raiseerror exec</code>
<code>        } if</code>
<code>        barcode length 17 eq {</code>
<code>            barcode 15 1 getinterval (-) ne {</code>
<code>                /bwipp.ismn13character16 (ISMN-13 penultimate character must be a dash) //raiseerror exec</code>
<code>            } if</code>
<code>            barcode 16 get dup 48 lt exch 57 gt or {</code>
<code>                /bwipp.ismn13character17 (ISMN-13 final character must be a digit) //raiseerror exec</code>
<code>            } if</code>
<code>        } if</code>
<code>    } {  % ISMN-10</code>
<code>        barcode 0 2 getinterval (M-) ne {</code>
<code>            /bwipp.ismn10badPrefix (ISMN-10 prefix must be M-) //raiseerror exec</code>
<code>        } if</code>
<code>        barcode 2 get dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.ismn10character3 (ISMN-10 character 3 must be a digit) //raiseerror exec</code>
<code>        } if</code>
<code>        /wasdash false def /numdash 0 def /numdigit 0 def</code>
<code>        barcode 3 7 getinterval {</code>
<code>            dup</code>
<code>            45 eq {</code>
<code>                wasdash {</code>
<code>                    /bwipp.ismn10adjacentDashes (ISMN-10 does not permit adjacent dashes) //raiseerror exec</code>
<code>                } if</code>
<code>                /wasdash true def</code>
<code>                /numdash numdash 1 add def</code>
<code>            } if</code>
<code>            dup 48 ge exch 57 le and {</code>
<code>                /wasdash false def</code>
<code>                /numdigit numdigit 1 add def</code>
<code>            } if</code>
<code>        } forall</code>
<code>        numdash 1 ne numdigit 6 ne or {</code>
<code>            /bwipp.ismn10numDashesDigits (Incorrect number of dashes and digits for ISMN-10) //raiseerror exec</code>
<code>        } if</code>
<code>        barcode 10 get dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.ismn10character11 (ISMN-10 character 11 must be a digit) //raiseerror exec</code>
<code>        } if</code>
<code>        barcode length 13 eq {</code>
<code>            barcode 11 1 getinterval (-) ne {</code>
<code>                /bwipp.ismn10character12 (ISMN-10 penultimate character must be a dash) //raiseerror exec</code>
<code>            } if</code>
<code>            barcode 12 get dup dup 48 lt exch 57 gt or exch 88 ne and {</code>
<code>                /bwipp.ismn10character13 (ISMN-10 final character must be a digit or X) //raiseerror exec</code>
<code>            } if</code>
<code>        } if</code>
<code>    } ifelse</code>
<code></code>
<code>    /ismntxt barcode def</code>
<code></code>
<code>    % Convert old ISMN to ISMN-13</code>
<code>    /legacytxt () def</code>
<code>    ismntxt length 13 le {</code>
<code>        /legacytxt ismntxt def</code>
<code>        /pad ismntxt length 4 add string def</code>
<code>        pad 0 (979-0-) putinterval</code>
<code>        pad 6 ismntxt 2 ismntxt length 2 sub getinterval putinterval</code>
<code>        /ismntxt pad def</code>
<code>    } if</code>
<code></code>
<code>    % Read the digits from ismntxt and calculate checksums</code>
<code>    /ismn 13 string def</code>
<code>    /checksum 0 def</code>
<code>    /i 0 def /n 0 def</code>
<code>    { % loop</code>
<code>        /ismnchar ismntxt i get 48 sub def</code>
<code>        ismnchar -3 ne {           % Ignore dashes</code>
<code>            ismn n ismnchar 48 add put</code>
<code>            n 12 lt {</code>
<code>                n 2 mod 0 eq {</code>
<code>                    /checksum ismnchar checksum add def</code>
<code>                } {</code>
<code>                    /checksum ismnchar 3 mul checksum add def</code>
<code>                } ifelse</code>
<code>            } if</code>
<code>            /n n 1 add def</code>
<code>        } if</code>
<code>        /i i 1 add def</code>
<code>        i ismntxt length eq {exit} if</code>
<code>    } loop</code>
<code>    /checksum 10 checksum 10 mod sub 10 mod 48 add def</code>
<code></code>
<code>    % Validate the checksum</code>
<code>    barcode length 13 eq barcode length 17 eq or {</code>
<code>        barcode dup length 1 sub get checksum ne {</code>
<code>            /bwipp.ismnBadCheckDigit (Incorrect ISMN check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    % Add the ISMN header and checksum to the ismntxt</code>
<code>    legacy legacytxt () ne and {</code>
<code>        /ismntxt legacytxt def</code>
<code>        /pad 18 string def</code>
<code>    } {</code>
<code>        /pad 22 string def</code>
<code>    } ifelse</code>
<code>    pad 0 (ISMN ) putinterval</code>
<code>    pad 5 ismntxt putinterval</code>
<code>    pad pad length 2 sub 45 put</code>
<code>    pad pad length 1 sub checksum put</code>
<code>    /ismntxt pad def</code>
<code></code>
<code>    % Convert ISMN digits to EAN-13</code>
<code>    /barcode ismn 0 12 getinterval def</code>
<code></code>
<code>    % Append the addon</code>
<code>    addon () ne {</code>
<code>        12 addon length add 1 add string</code>
<code>        dup 0 barcode putinterval</code>
<code>        dup 12 ( ) putinterval</code>
<code>        dup 13 addon putinterval</code>
<code>        /barcode exch def</code>
<code>    } if</code>
<code></code>
<code>    % Get the result of encoding with ean13</code>
<code>    options (dontdraw) true put</code>
<code>    options (addongap) addongap put</code>
<code>    /args barcode options //ean13 exec def</code>
<code></code>
<code>    % Add the ISMN text</code>
<code>    includetext {</code>
<code>        ismntextxoffset null eq {</code>
<code>            /ismntextxoffset ismntxt length 18 eq {-1.0} {-12.0} ifelse def</code>
<code>        } if</code>
<code>        ismntextyoffset null eq {</code>
<code>            /ismntextyoffset height 72 mul 3 add def</code>
<code>        } if</code>
<code>        args (txt) known {</code>
<code>            /txt args (txt) get def</code>
<code>            /newtxt txt length 1 add array def</code>
<code>            newtxt 0 txt putinterval</code>
<code>            newtxt newtxt length 1 sub [ismntxt ismntextxoffset ismntextyoffset ismntextfont ismntextsize] put</code>
<code>            args (txt) newtxt put</code>
<code>        } {</code>
<code>            args (txt) [ [ismntxt ismntextxoffset ismntextyoffset ismntextfont ismntextsize] ] put</code>
<code>        } ifelse</code>
<code>    } if</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /ismn dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER ismn--</code>
<code></code>
<code>% --BEGIN ENCODER issn--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear ean2 ean5 ean13--</code>
<code>% --DESC: ISSN</code>
<code>% --EXAM: 0311-175X 00 17</code>
<code>% --EXOP: includetext guardwhitespace</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp issn 0.0 2024010300 82522 81834</code>
<code>%%BeginData:        160 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /ean13 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/issn {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def</code>
<code>    /issntextfont /OCR-A def</code>
<code>    /issntextsize 8.0 def</code>
<code>    /issntextxoffset null def  % sentinal realtype</code>
<code>    /issntextyoffset null def  % sentinal realtype</code>
<code>    /height 1.0 def</code>
<code>    /addongap 12.0 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /issntxt exch def</code>
<code></code>
<code>    % Split off the ISSN</code>
<code>    issntxt ( ) search {</code>
<code>        /issntxt exch def</code>
<code>        pop</code>
<code>        /seqvar exch def</code>
<code>    } {</code>
<code>        pop</code>
<code>        /seqvar (00) def</code>
<code>    } ifelse</code>
<code></code>
<code>    % Split off the sequence variant and addon</code>
<code>    seqvar ( ) search {</code>
<code>        /seqvar exch def</code>
<code>        pop</code>
<code>        /addon exch def</code>
<code>    } {</code>
<code>        pop</code>
<code>        /addon () def</code>
<code>    } ifelse</code>
<code></code>
<code>    % Validate the input</code>
<code>    issntxt length 8 ne issntxt length 9 ne and {</code>
<code>        /bwipp.issnBadLength (ISSN must be 8 or 9 characters including dash, in the format XXXX-XXXX) //raiseerror exec</code>
<code>    } if</code>
<code>    issntxt 0 4 getinterval {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.issnFirstThroughFourthNotNumeric (ISSN first four characters must be numeral characters) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code>    issntxt 4 1 getinterval (-) ne {</code>
<code>        /bwipp.issnNeedsDash (ISSN fifth character must be a dash) //raiseerror exec</code>
<code>    } if</code>
<code>    issntxt 5 3 getinterval {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.issnSixthThroughEighthNotNumeric (ISSN sixth through eighth characters must be numerals) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code>    issntxt length 9 eq {</code>
<code>        issntxt 8 get dup dup 48 lt exch 57 gt or exch 88 ne and {  % Digits or X</code>
<code>            /bwipp.issnNinthCharacterBadFormat (ISSN ninth character must be a number or the character X) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code>    seqvar length 2 ne {</code>
<code>        /bwipp.issnBadSequenceVariantLength (Sequence variant for ISSN must be 2 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    seqvar {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>           /bwipp.issnSequenceVariantBadCharacter (Sequence variant for ISSN must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code>    addon length 0 ne addon length 2 ne and addon length 5 ne and {</code>
<code>        /bwipp.issnBadAddOnLength (Add-on for ISSN must be 2 or 5 digits) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Read the digits from issntxt and calculate checksums</code>
<code>    /issn 8 string def</code>
<code>    /checksum 0 def</code>
<code>    /i 0 def /n 0 def</code>
<code>    { % loop</code>
<code>        /issnchar issntxt i get 48 sub def</code>
<code>        issnchar -3 ne {           % Ignore dashes</code>
<code>            issn n issnchar 48 add put</code>
<code>            n 7 lt {</code>
<code>                /checksum checksum issnchar 8 n sub mul add def</code>
<code>            } if</code>
<code>            /n n 1 add def</code>
<code>        } if</code>
<code>        /i i 1 add def</code>
<code>        i issntxt length eq {exit} if</code>
<code>    } loop</code>
<code>    /checksum 11 checksum 11 mod sub 11 mod def</code>
<code>    /checksum checksum 48 add dup 58 eq {pop 88} if def</code>
<code>    issntxt length 9 eq {</code>
<code>        issntxt 8 get checksum ne {</code>
<code>            /bwipp.issnBadCheckDigit (Incorrect ISSN check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    % Add the ISSN header and checksum to the issntxt</code>
<code>    /pad 14 string def</code>
<code>    pad 0 (ISSN ) putinterval</code>
<code>    pad 5 issntxt putinterval  % Add issntxt to the pad</code>
<code>    pad 13 checksum put</code>
<code>    /issntxt pad def</code>
<code></code>
<code>    % Convert ISSN digits to EAN-13</code>
<code>    /barcode issn 0 7 getinterval def</code>
<code></code>
<code>    % Append the sequence variant</code>
<code>    /barcode 12 string def</code>
<code>    barcode 0 (977) putinterval</code>
<code>    barcode 3 issn putinterval</code>
<code>    barcode 10 seqvar putinterval</code>
<code></code>
<code>    % Append the addon</code>
<code>    addon () ne {</code>
<code>        12 addon length add 1 add string</code>
<code>        dup 0 barcode putinterval</code>
<code>        dup 12 ( ) putinterval</code>
<code>        dup 13 addon putinterval</code>
<code>        /barcode exch def</code>
<code>    } if</code>
<code></code>
<code>    % Get the result of encoding with ean13</code>
<code>    options (dontdraw) true put</code>
<code>    options (addongap) addongap put</code>
<code>    /args barcode options //ean13 exec def</code>
<code></code>
<code>    % Add the ISSN text</code>
<code>    includetext {</code>
<code>        issntextxoffset null eq {/issntextxoffset 10.0 def} if</code>
<code>        issntextyoffset null eq {/issntextyoffset height 72 mul 3 add def} if</code>
<code>        args (txt) known {</code>
<code>            /txt args (txt) get def</code>
<code>            /newtxt txt length 1 add array def</code>
<code>            newtxt 0 txt putinterval</code>
<code>            newtxt newtxt length 1 sub [issntxt issntextxoffset issntextyoffset issntextfont issntextsize] put</code>
<code>            args (txt) newtxt put</code>
<code>        } {</code>
<code>            args (txt) [ [issntxt issntextxoffset issntextyoffset issntextfont issntextsize] ] put</code>
<code>        } ifelse</code>
<code>    } if</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /issn dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER issn--</code>
<code></code>
<code>% --BEGIN ENCODER mands--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear ean2 ean5 ean8--</code>
<code>% --DESC: Marks &amp; Spencer</code>
<code>% --EXAM: 0642118</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp mands 0.0 2024010300 72503 72406</code>
<code>%%BeginData:         73 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /ean8 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/mands {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /barlen barcode length def</code>
<code></code>
<code>    % Validate the input</code>
<code>    barlen 7 ne barlen 8 ne and {</code>
<code>        /bwipp.MandSbadLength (M&amp;S barcode must be 7 or 8 characters) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    barlen 7 eq {</code>
<code>        /barcode (00000000) 8 string copy dup 1 barcode putinterval def</code>
<code>    } if</code>
<code></code>
<code>    % Get the result of encoding with ean8</code>
<code>    options (dontdraw) true put</code>
<code>    /args barcode options //ean8 exec def</code>
<code></code>
<code>    % Remove the centre guard</code>
<code>    args (bbs) get dup</code>
<code>    dup 2 get 10 exch put</code>
<code>    dup 2 get 11 exch put</code>
<code>    args (bhs) get dup</code>
<code>    dup 2 get 10 exch put</code>
<code>    dup 2 get 11 exch put</code>
<code></code>
<code>    % Fix up the text for 7-digit inputs</code>
<code>    /txt args (txt) get def</code>
<code>    barlen 7 eq {</code>
<code>        0 1 6 {</code>
<code>            txt exch 2 copy</code>
<code>            1 add get 0 get 3 1 roll get</code>
<code>            0 get exch 0 exch putinterval</code>
<code>        } for</code>
<code>        txt 7 get 0 get 0 ( ) putinterval</code>
<code>    } if</code>
<code></code>
<code>    % Add the M and S guards</code>
<code>    10 array dup 0 txt putinterval /txt exch def</code>
<code>    txt 0 get dup length array copy txt exch 8 exch put</code>
<code>    txt 0 get dup length array copy txt exch 9 exch put</code>
<code>    txt 8 get 0 (M) put txt 8 get 1 -12 put</code>
<code>    txt 9 get 0 (S) put txt 9 get 1 69 put</code>
<code></code>
<code>    args (txt) txt put</code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /mands dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER mands--</code>
<code></code>
<code>% --BEGIN ENCODER code128--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renlinear--</code>
<code>% --DESC: Code 128</code>
<code>% --EXAM: Count01234567!</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp code128 0.0 2024010300 126393 129397</code>
<code>%%BeginData:        424 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/code128 {</code>
<code></code>
<code>    20 dict begin                  % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def    % Enable/disable text</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textxoffset 0.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 1.0 def</code>
<code>    /encoding (auto) def</code>
<code>    /raw false def</code>
<code>    /parse false def</code>
<code>    /parsefnc false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /code128 //loadctx exec</code>
<code></code>
<code>    % Special function characters</code>
<code>{</code>
<code>    /sta  -1 def  /stb  -2 def  /stc  -3 def</code>
<code>    /swa  -4 def  /swb  -5 def  /swc  -6 def</code>
<code>    /fn1  -7 def  /fn2  -8 def  /fn3  -9 def</code>
<code>    /fn4 -10 def  /sft -11 def  /stp -12 def</code>
<code>    /lka -13 def  /lkc -14 def  % CC-A/B and CC-C linkage</code>
<code>} ctxdef</code>
<code></code>
<code>    % Parse the input</code>
<code>    /fncvals &lt;&lt;</code>
<code>        /parse parse</code>
<code>        /parsefnc parsefnc</code>
<code>        (FNC1) fn1</code>
<code>        (FNC1) fn1</code>
<code>        (FNC2) fn2</code>
<code>        (FNC3) fn3</code>
<code>%        (FNC4) fn4    Not user accessible as encoded automatically</code>
<code>        (LNKA) lka</code>
<code>        (LNKC) lkc</code>
<code>    &gt;&gt; def</code>
<code>    /msg barcode fncvals //parseinput exec def</code>
<code>    /msglen msg length def</code>
<code></code>
<code>    % Character maps for each state</code>
<code>{</code>
<code>    /charmaps [</code>
<code>      %  A    B    C         A    B    C         A    B    C</code>
<code>      [  32   32  (00) ]  [ (!)  (!)  (01) ]  [ (")  (")  (02) ]  % 0-2</code>
<code>      [ (#)  (#)  (03) ]  [ ($)  ($)  (04) ]  [ (%)  (%)  (05) ]  % 3-5</code>
<code>      [ (&amp;)  (&amp;)  (06) ]  [ (')  (')  (07) ]  [  40   40  (08) ]  % 6-8</code>
<code>      [  41   41  (09) ]  [ (*)  (*)  (10) ]  [ (+)  (+)  (11) ]  % 9-11</code>
<code>      [ (,)  (,)  (12) ]  [ (-)  (-)  (13) ]  [ (.)  (.)  (14) ]  % 12-14</code>
<code>      [ (/)  (/)  (15) ]  [ (0)  (0)  (16) ]  [ (1)  (1)  (17) ]  % 15-17</code>
<code>      [ (2)  (2)  (18) ]  [ (3)  (3)  (19) ]  [ (4)  (4)  (20) ]  % 18-20</code>
<code>      [ (5)  (5)  (21) ]  [ (6)  (6)  (22) ]  [ (7)  (7)  (23) ]  % 21-23</code>
<code>      [ (8)  (8)  (24) ]  [ (9)  (9)  (25) ]  [ (:)  (:)  (26) ]  % 24-26</code>
<code>      [ (;)  (;)  (27) ]  [ (&lt;)  (&lt;)  (28) ]  [ (=)  (=)  (29) ]  % 27-29</code>
<code>      [ (&gt;)  (&gt;)  (30) ]  [ (?)  (?)  (31) ]  [ (@)  (@)  (32) ]  % 30-32</code>
<code>      [ (A)  (A)  (33) ]  [ (B)  (B)  (34) ]  [ (C)  (C)  (35) ]  % 33-35</code>
<code>      [ (D)  (D)  (36) ]  [ (E)  (E)  (37) ]  [ (F)  (F)  (38) ]  % 36-38</code>
<code>      [ (G)  (G)  (39) ]  [ (H)  (H)  (40) ]  [ (I)  (I)  (41) ]  % 39-41</code>
<code>      [ (J)  (J)  (42) ]  [ (K)  (K)  (43) ]  [ (L)  (L)  (44) ]  % 42-44</code>
<code>      [ (M)  (M)  (45) ]  [ (N)  (N)  (46) ]  [ (O)  (O)  (47) ]  % 45-47</code>
<code>      [ (P)  (P)  (48) ]  [ (Q)  (Q)  (49) ]  [ (R)  (R)  (50) ]  % 48-50</code>
<code>      [ (S)  (S)  (51) ]  [ (T)  (T)  (52) ]  [ (U)  (U)  (53) ]  % 51-53</code>
<code>      [ (V)  (V)  (54) ]  [ (W)  (W)  (55) ]  [ (X)  (X)  (56) ]  % 54-56</code>
<code>      [ (Y)  (Y)  (57) ]  [ (Z)  (Z)  (58) ]  [ ([)  ([)  (59) ]  % 57-59</code>
<code>      [  92   92  (60) ]  [ (])  (])  (61) ]  [ (^)  (^)  (62) ]  % 60-62</code>
<code>      [ (_)  (_)  (63) ]  [   0  (`)  (64) ]  [   1  (a)  (65) ]  % 63-65</code>
<code>      [   2  (b)  (66) ]  [   3  (c)  (67) ]  [   4  (d)  (68) ]  % 66-68</code>
<code>      [   5  (e)  (69) ]  [   6  (f)  (70) ]  [   7  (g)  (71) ]  % 69-71</code>
<code>      [   8  (h)  (72) ]  [   9  (i)  (73) ]  [  10  (j)  (74) ]  % 72-74</code>
<code>      [  11  (k)  (75) ]  [  12  (l)  (76) ]  [  13  (m)  (77) ]  % 75-77</code>
<code>      [  14  (n)  (78) ]  [  15  (o)  (79) ]  [  16  (p)  (80) ]  % 78-80</code>
<code>      [  17  (q)  (81) ]  [  18  (r)  (82) ]  [  19  (s)  (83) ]  % 81-83</code>
<code>      [  20  (t)  (84) ]  [  21  (u)  (85) ]  [  22  (v)  (86) ]  % 84-86</code>
<code>      [  23  (w)  (87) ]  [  24  (x)  (88) ]  [  25  (y)  (89) ]  % 87-89</code>
<code>      [  26  (z)  (90) ]  [  27  ({)  (91) ]  [  28  (|)  (92) ]  % 90-92</code>
<code>      [  29  (})  (93) ]  [  30  (~)  (94) ]  [  31  127  (95) ]  % 93-95</code>
<code>      [ fn3  fn3  (96) ]  [ fn2  fn2  (97) ]  [ sft  sft  (98) ]  % 96-98</code>
<code>      [ swc  swc  (99) ]  [ swb  fn4  swb  ]  [ fn4  swa  swa  ]  % 99-101</code>
<code>      [ fn1  fn1  fn1  ]  [ sta  sta  sta  ]  [ stb  stb  stb  ]  % 102-104</code>
<code>      [ stc  stc  stc  ]  [ stp  stp  stp  ]                      % 105-106</code>
<code>    ] def</code>
<code></code>
<code>    % Invert charmaps to give character to value maps for each state</code>
<code>    /charvals [ 109 dict 109 dict 109 dict ] def</code>
<code>    0 1 charmaps length 1 sub {</code>
<code>        /i exch def</code>
<code>        /encs charmaps i get def</code>
<code>        0 1 2 {</code>
<code>            /j exch def</code>
<code>            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required</code>
<code>            charvals j get exch i put</code>
<code>        } for</code>
<code>    } for</code>
<code>    /seta charvals 0 get def</code>
<code>    /setb charvals 1 get def</code>
<code>    /setc charvals 2 get def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Include pseudo characters for GS1-128 Composite linkage identifiers</code>
<code>    seta lka seta swb get put  seta lkc seta swc get put</code>
<code>    setb lka setb swc get put  setb lkc setb swa get put</code>
<code>    setc lka setc swa get put  setc lkc setc swb get put</code>
<code></code>
<code>    raw {/encoding (raw) def} if</code>
<code></code>
<code>    encoding (raw) eq {</code>
<code>        /cws barcode length array def</code>
<code>        /i 0 def /j 0 def</code>
<code>        { % loop</code>
<code>            i barcode length eq {exit} if</code>
<code>            /cw barcode i 1 add 3 getinterval cvi def</code>
<code>            cws j cw put</code>
<code>            /i i 4 add def</code>
<code>            /j j 1 add def</code>
<code>        } loop</code>
<code>        /cws cws 0 j getinterval def</code>
<code>        /text () def</code>
<code>    } if</code>
<code></code>
<code>    encoding (auto) eq {</code>
<code></code>
<code>        /text msglen string def</code>
<code>        0 1 msglen 1 sub {</code>
<code>            /i exch def</code>
<code>            text i msg i get dup 0 lt { pop 32 } if put</code>
<code>        } for</code>
<code></code>
<code>        % Standard and extended ASCII runlength at position</code>
<code>        /numSA [ msglen {0} repeat 0 ] def</code>
<code>        /numEA [ msglen {0} repeat 0 ] def</code>
<code>        msglen 1 sub -1 0 {</code>
<code>            /i exch def</code>
<code>            msg i get 0 ge {</code>
<code>                msg i get 128 ge {</code>
<code>                    numEA i numEA i 1 add get 1 add put</code>
<code>                } {</code>
<code>                    numSA i numSA i 1 add get 1 add put</code>
<code>                } ifelse</code>
<code>            } if</code>
<code>        } for</code>
<code></code>
<code>        % FNC4 codeword insertion for extended ASCII</code>
<code>        /ea false def /msgtmp [] def</code>
<code>        0 1 msglen 1 sub {</code>
<code>            /i exch def</code>
<code>            /c msg i get def</code>
<code>            ea c 128 lt xor not c 0 ge and {  % Other mode required</code>
<code>                ea {numSA} {numEA} ifelse i get dup  % Runlength of other mode</code>
<code>                i add msglen eq {3} {5} ifelse       % Does run terminate symbol</code>
<code>                lt {  % Shift</code>
<code>                    /msgtmp [ msgtmp aload pop fn4 ] def</code>
<code>                } {   % Latch</code>
<code>                    /msgtmp [ msgtmp aload pop fn4 fn4 ] def</code>
<code>                    /ea ea not def</code>
<code>                } ifelse</code>
<code>            } if</code>
<code>            /msgtmp [ msgtmp aload pop c 0 ge {c 127 and} {c} ifelse ] def</code>
<code>        } for</code>
<code>        /msg msgtmp def</code>
<code>        /msglen msg length def</code>
<code></code>
<code>        % Determine digit runlength and characters from given position</code>
<code>        /numsscr {</code>
<code>            /n 0 def /s 0 def</code>
<code>            /p exch def {</code>
<code>                p msglen ge {exit} if</code>
<code>                msg p get</code>
<code>                dup setc exch known not {pop exit} if</code>
<code>                dup -1 le {</code>
<code>                    % FNC1 in odd position of run like two digits</code>
<code>                    fn1 eq s 2 mod 0 eq and {/s s 1 add def} {exit} ifelse</code>
<code>                } {</code>
<code>                    pop</code>
<code>                } ifelse</code>
<code>                /n n 1 add def</code>
<code>                /s s 1 add def</code>
<code>                /p p 1 add def</code>
<code>            } loop</code>
<code>            n s</code>
<code>        } def</code>
<code></code>
<code>        % Encoding for each alphabet</code>
<code>        /enca {</code>
<code>            seta exch get cws exch j exch put</code>
<code>            /j j 1 add def</code>
<code>        } def</code>
<code>        /encb {</code>
<code>            setb exch get cws exch j exch put</code>
<code>            /j j 1 add def</code>
<code>        } def</code>
<code>        /encc {</code>
<code>            dup type /arraytype ne {</code>
<code>                setc exch get</code>
<code>            } {</code>
<code>                aload pop 48 sub exch 48 sub 10 mul add</code>
<code>            } ifelse</code>
<code>            cws exch j exch put</code>
<code>            /j j 1 add def</code>
<code>        } def</code>
<code></code>
<code>        % Character exclusively in either alphabet A or B</code>
<code>        /anotb {dup seta exch known exch setb exch known not and} def</code>
<code>        /bnota {dup setb exch known exch seta exch known not and} def</code>
<code></code>
<code>        % Pre-compute relative position of next anotb and next bnota characters</code>
<code>        /nextanotb [ msg length {0} repeat 9999 ] def</code>
<code>        /nextbnota [ msg length {0} repeat 9999 ] def</code>
<code>        msg length 1 sub -1 0 {</code>
<code>            /i exch def</code>
<code>            msg i get anotb {</code>
<code>                nextanotb i 0 put</code>
<code>            } {</code>
<code>                nextanotb i nextanotb i 1 add get 1 add put</code>
<code>            } ifelse</code>
<code>            msg i get bnota {</code>
<code>                nextbnota i 0 put</code>
<code>            } {</code>
<code>                nextbnota i nextbnota i 1 add get 1 add put</code>
<code>            } ifelse</code>
<code>        } for</code>
<code></code>
<code>        % Does a-only come before b-only after given position and vice versa</code>
<code>        /abeforeb {dup nextanotb exch get exch nextbnota exch get lt} def</code>
<code>        /bbeforea {dup nextbnota exch get exch nextanotb exch get lt} def</code>
<code></code>
<code>        /cws barcode length 2 mul 3 add array def</code>
<code></code>
<code>        % Select start character</code>
<code>        /j 0 def</code>
<code>        msglen 0 gt {0 numsscr} {-1 -1} ifelse /nums exch def /nchars exch def</code>
<code>        {  % common exit</code>
<code>            msglen 0 eq {</code>
<code>                stb enca</code>
<code>                /cset (setb) def</code>
<code>                exit</code>
<code>            } if</code>
<code>            msglen 2 eq nums 2 eq and {</code>
<code>                stc enca</code>
<code>                /cset (setc) def</code>
<code>                exit</code>
<code>            } if</code>
<code>            nums 4 ge {</code>
<code>                stc enca</code>
<code>                /cset (setc) def</code>
<code>                exit</code>
<code>            } if</code>
<code>            0 abeforeb {</code>
<code>                sta enca</code>
<code>                /cset (seta) def</code>
<code>                exit</code>
<code>            } if</code>
<code>            stb enca</code>
<code>            /cset (setb) def</code>
<code>            exit</code>
<code>        } loop</code>
<code></code>
<code>        % Main encoding loop</code>
<code>        /i 0 def {</code>
<code>            i msglen eq {exit} if</code>
<code></code>
<code>            i numsscr /nums exch def /nchars exch def</code>
<code></code>
<code>            % Determine switches and shifts</code>
<code>            {  % common exit</code>
<code>                cset (seta) eq cset (setb) eq or nums 4 ge and</code>
<code>                msg i get fn1 ne and {</code>
<code>                    nums 2 mod 0 eq {</code>
<code>                        swc cset (seta) eq {enca} {encb} ifelse</code>
<code>                        /cset (setc) def</code>
<code>                        exit</code>
<code>                    } {</code>
<code>                        msg i get cset (seta) eq {enca} {encb} ifelse</code>
<code>                        /i i 1 add def</code>
<code>                        swc cset (seta) eq {enca} {encb} ifelse</code>
<code>                        /cset (setc) def</code>
<code>                        exit</code>
<code>                    } ifelse</code>
<code>                } if</code>
<code>                cset (setb) eq msg i get anotb and {</code>
<code>                    i msglen 1 sub lt {</code>
<code>                        i 1 add bbeforea {</code>
<code>                            sft encb</code>
<code>                            msg i get enca</code>
<code>                            /i i 1 add def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    swa encb</code>
<code>                    /cset (seta) def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                cset (seta) eq msg i get bnota and {</code>
<code>                    i msglen 1 sub lt {</code>
<code>                        i 1 add abeforeb {</code>
<code>                            sft enca</code>
<code>                            msg i get encb</code>
<code>                            /i i 1 add def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    swb enca</code>
<code>                    /cset (setb) def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                cset (setc) eq nums 2 lt and msg i get -1 gt msg i get fn4 eq or and {</code>
<code>                    i abeforeb {</code>
<code>                        swa encc</code>
<code>                        /cset (seta) def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    swb encc</code>
<code>                    /cset (setb) def</code>
<code>                    exit</code>
<code>                } if</code>
<code></code>
<code>                % No switches or latches so encode</code>
<code>                cset (seta) eq {</code>
<code>                    msg i get enca</code>
<code>                    /i i 1 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                cset (setb) eq {</code>
<code>                    msg i get encb</code>
<code>                    /i i 1 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                cset (setc) eq {</code>
<code>                    msg i get -1 le {</code>
<code>                        msg i get encc</code>
<code>                        /i i 1 add def</code>
<code>                    } {</code>
<code>                        msg i 2 getinterval encc</code>
<code>                        /i i 2 add def</code>
<code>                    } ifelse</code>
<code>                    exit</code>
<code>                } if</code>
<code></code>
<code>                exit</code>
<code>            } loop</code>
<code></code>
<code>        } loop</code>
<code>        /cws cws 0 j getinterval def</code>
<code>    } if  % auto encoding</code>
<code></code>
<code>    % Derive checksum and place stop character</code>
<code>    /cws j 2 add array dup 0 cws putinterval def</code>
<code>    /csum cws 0 get def</code>
<code>    1 1 j 1 sub {</code>
<code>        /i exch def</code>
<code>        /csum csum cws i get i mul add def</code>
<code>    } for</code>
<code>    /csum csum 103 mod def</code>
<code>    cws j csum put</code>
<code>    cws j 1 add seta stp get put</code>
<code></code>
<code>    options /debugcws known { /bwipp.debugcws cws //raiseerror exec } if</code>
<code></code>
<code>    % Create an array containing the character mappings</code>
<code>{</code>
<code>    /encs</code>
<code>    [ (212222) (222122) (222221) (121223) (121322) (131222) (122213)</code>
<code>      (122312) (132212) (221213) (221312) (231212) (112232) (122132)</code>
<code>      (122231) (113222) (123122) (123221) (223211) (221132) (221231)</code>
<code>      (213212) (223112) (312131) (311222) (321122) (321221) (312212)</code>
<code>      (322112) (322211) (212123) (212321) (232121) (111323) (131123)</code>
<code>      (131321) (112313) (132113) (132311) (211313) (231113) (231311)</code>
<code>      (112133) (112331) (132131) (113123) (113321) (133121) (313121)</code>
<code>      (211331) (231131) (213113) (213311) (213131) (311123) (311321)</code>
<code>      (331121) (312113) (312311) (332111) (314111) (221411) (431111)</code>
<code>      (111224) (111422) (121124) (121421) (141122) (141221) (112214)</code>
<code>      (112412) (122114) (122411) (142112) (142211) (241211) (221114)</code>
<code>      (413111) (241112) (134111) (111242) (121142) (121241) (114212)</code>
<code>      (124112) (124211) (411212) (421112) (421211) (212141) (214121)</code>
<code>      (412121) (111143) (111341) (131141) (114113) (114311) (411113)</code>
<code>      (411311) (113141) (114131) (311141) (411131) (211412) (211214)</code>
<code>      (211232) (2331112)</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Derive space bar succession</code>
<code>    /sbs cws length 6 mul 1 add string def</code>
<code>    0 1 cws length 1 sub {</code>
<code>        /i exch def</code>
<code>        sbs i 6 mul encs cws i get get putinterval</code>
<code>    } for</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs [sbs {48 sub} forall]</code>
<code>    /bhs [sbs length 1 add 2 idiv {height} repeat]</code>
<code>    /bbs [sbs length 1 add 2 idiv {0} repeat]</code>
<code>    /txt [ [text textxoffset textyoffset textfont textsize] ]</code>
<code>    /textxalign (center)</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /code128 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER code128--</code>
<code></code>
<code>% --BEGIN ENCODER gs1-128--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renlinear code128--</code>
<code>% --DESC: GS1-128</code>
<code>% --EXAM: (01)09521234543213(3103)000123</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp gs1-128 0.0 2024010300 80703 80334</code>
<code>%%BeginData:        102 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /code128 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/gs1-128 {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def    % Enable/disable text</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textxoffset 0.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 0.5 def</code>
<code>    /linkagea false def</code>
<code>    /linkagec false def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    linkagea linkagec and {</code>
<code>        /bwipp.gs1128badLinkage (linkagea and linkagec cannot be used together) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /text barcode def</code>
<code></code>
<code>    barcode /ai //gs1process exec</code>
<code>    /fncs exch def</code>
<code>    /vals exch def</code>
<code>    /ais exch def</code>
<code></code>
<code>    % Create the code128 data</code>
<code>    /fnc1 -1 def</code>
<code>    /c128 [ fnc1 ] def</code>
<code>    0 1 ais length 1 sub {</code>
<code>        /i exch def</code>
<code>        /ai ais i get def</code>
<code>        /val vals i get def</code>
<code>        c128 length ai length add val length add array</code>
<code>        dup 0 c128 putinterval</code>
<code>        dup c128 length ai [ exch {} forall ] putinterval</code>
<code>        dup c128 length ai length add val [ exch {} forall ] putinterval</code>
<code>        /c128 exch def</code>
<code>        i ais length 1 sub ne fncs i get and {  % Append FNC1</code>
<code>            c128 length 1 add array</code>
<code>            dup 0 c128 putinterval</code>
<code>            dup c128 length fnc1 put</code>
<code>            /c128 exch def</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    % Compose input to code128</code>
<code>    /barcode c128 length 1 add 5 mul string def</code>
<code>    /i 0 def /j 0 def {</code>
<code>        i c128 length eq {exit} if</code>
<code>        c128 i get dup fnc1 eq {</code>
<code>            pop barcode j (^FNC1) putinterval</code>
<code>            /j j 4 add def</code>
<code>        } {</code>
<code>            barcode exch j exch put</code>
<code>        } ifelse</code>
<code>        /i i 1 add def</code>
<code>        /j j 1 add def</code>
<code>    } loop</code>
<code>    linkagea linkagec or {</code>
<code>        barcode j linkagea {(^LNKA)} {(^LNKC)} ifelse putinterval</code>
<code>        /j j 5 add def</code>
<code>    } if</code>
<code>    /barcode barcode 0 j getinterval def</code>
<code></code>
<code>    % Get the result of encoding with code128</code>
<code>    options (parse) undef</code>
<code>    options (height) height put</code>
<code>    options (dontdraw) true put</code>
<code>    options (parsefnc) true put</code>
<code>    /args barcode options //code128 exec def</code>
<code></code>
<code>    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put</code>
<code>    args (textxalign) (center) put</code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /gs1-128 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER gs1-128--</code>
<code></code>
<code>% --BEGIN ENCODER ean14--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renlinear code128--</code>
<code>% --DESC: GS1-14</code>
<code>% --EXAM: (01) 0 952 8765 43210 8</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp ean14 0.0 2024010300 72646 72462</code>
<code>%%BeginData:         92 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /code128 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/ean14 {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def    % Enable/disable text</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textxoffset 0.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 1.0 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Strip spaces from the given data</code>
<code>    /text barcode def</code>
<code>    barcode dup length string exch 0 exch</code>
<code>    {dup 32 ne {3 copy put pop 1 add} {pop} ifelse} forall</code>
<code>    0 exch getinterval /barcode exch def</code>
<code>    /hasspace text length barcode length ne def</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode length 17 ne barcode length 18 ne and {</code>
<code>        /bwipp.ean14badLength (GS1-14 must be 13 or 14 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode 0 4 getinterval (\(01\)) ne {</code>
<code>        /bwipp.ean14badAI (GS1-14 must begin with (01) application identifier) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode 4 barcode length 4 sub getinterval {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.ean14badCharacter (GS1-14 must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>    % Calculate checksum and add to end of barcode</code>
<code>    /checksum 0 def</code>
<code>    0 1 12 {</code>
<code>        /i exch def</code>
<code>        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def</code>
<code>    } for</code>
<code>    /checksum 10 checksum 10 mod sub 10 mod def</code>
<code>    barcode length 18 eq {</code>
<code>        barcode 17 get checksum 48 add ne {</code>
<code>            /bwipp.ean14badCheckDigit (Incorrect GS1-14 check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>    } {</code>
<code>        18 string</code>
<code>        dup 0 barcode putinterval</code>
<code>        dup 17 checksum 48 add put</code>
<code>        /barcode exch def</code>
<code>        text length hasspace {2} {1} ifelse add string</code>
<code>        dup dup length 2 sub ( ) putinterval</code>
<code>        dup dup length 1 sub checksum 48 add put</code>
<code>        dup 0 text putinterval</code>
<code>        /text exch def</code>
<code>    } ifelse</code>
<code>    /gtin barcode 4 14 getinterval def</code>
<code></code>
<code>    % Compose input to code128</code>
<code>    /barcode 21 string def</code>
<code>    barcode 0 (^FNC101) putinterval</code>
<code>    barcode 7 gtin putinterval</code>
<code></code>
<code>    % Get the result of encoding with code128</code>
<code>    options (dontdraw) true put</code>
<code>    options (parsefnc) true put</code>
<code>    /args barcode options //code128 exec def</code>
<code></code>
<code>    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put</code>
<code>    args (textxalign) (center) put</code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /ean14 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER ean14--</code>
<code></code>
<code>% --BEGIN ENCODER sscc18--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renlinear code128--</code>
<code>% --DESC: SSCC-18</code>
<code>% --EXAM: (00) 0 9528765 432101234 6</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp sscc18 0.0 2024010300 72658 72469</code>
<code>%%BeginData:         92 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /code128 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/sscc18 {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def    % Enable/disable text</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textxoffset 0.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 1.0 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Strip spaces from the given data</code>
<code>    /text barcode def</code>
<code>    barcode dup length string exch 0 exch</code>
<code>    {dup 32 ne {3 copy put pop 1 add} {pop} ifelse} forall</code>
<code>    0 exch getinterval /barcode exch def</code>
<code>    /hasspace text length barcode length ne def</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode length 21 ne barcode length 22 ne and {</code>
<code>        /bwipp.sscc18badLength (SSCC-18 must be 17 or 18 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode 0 4 getinterval (\(00\)) ne {</code>
<code>        /bwipp.sscc18badAI (SSCC-18 must begin with (00) application identifier) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode 4 barcode length 4 sub getinterval {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.sscc18badCharacter (SSCC-18 must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>    % Calculate checksum and add to end of barcode</code>
<code>    /checksum 0 def</code>
<code>    0 1 16 {</code>
<code>        /i exch def</code>
<code>        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def</code>
<code>    } for</code>
<code>    /checksum 10 checksum 10 mod sub 10 mod def</code>
<code>    barcode length 22 eq {</code>
<code>        barcode 21 get checksum 48 add ne {</code>
<code>            /bwipp.sscc18badCheckDigit (Incorrect SSCC-18 check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>    } {</code>
<code>        22 string</code>
<code>        dup 0 barcode putinterval</code>
<code>        dup 21 checksum 48 add put</code>
<code>        /barcode exch def</code>
<code>        text length hasspace {2} {1} ifelse add string</code>
<code>        dup dup length 2 sub ( ) putinterval</code>
<code>        dup dup length 1 sub checksum 48 add put</code>
<code>        dup 0 text putinterval</code>
<code>        /text exch def</code>
<code>    } ifelse</code>
<code>    /sscc barcode 4 18 getinterval def</code>
<code></code>
<code>    % Compose input to code128</code>
<code>    /barcode 25 string def</code>
<code>    barcode 0 (^FNC100) putinterval</code>
<code>    barcode 7 sscc putinterval</code>
<code></code>
<code>    % Get the result of encoding with code128</code>
<code>    options (dontdraw) true put</code>
<code>    options (parsefnc) true put</code>
<code>    /args barcode options //code128 exec def</code>
<code></code>
<code>    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put</code>
<code>    args (textxalign) (center) put</code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /sscc18 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER sscc18--</code>
<code></code>
<code>% --BEGIN ENCODER code39--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear--</code>
<code>% --DESC: Code 39</code>
<code>% --EXAM: THIS IS CODE 39</code>
<code>% --EXOP: includetext includecheck includecheckintext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp code39 0.0 2024010300 73033 72709</code>
<code>%%BeginData:        141 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/code39 {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includecheck false def</code>
<code>    /validatecheck false def</code>
<code>    /includetext false def</code>
<code>    /includecheckintext false def</code>
<code>    /hidestars false def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 1.0 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.code39emptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /code39 //loadctx exec</code>
<code></code>
<code>{</code>
<code>    % Create an array containing the character mappings</code>
<code>    /encs</code>
<code>    [ (1113313111) (3113111131) (1133111131) (3133111111) (1113311131)</code>
<code>      (3113311111) (1133311111) (1113113131) (3113113111) (1133113111)</code>
<code>      (3111131131) (1131131131) (3131131111) (1111331131) (3111331111)</code>
<code>      (1131331111) (1111133131) (3111133111) (1131133111) (1111333111)</code>
<code>      (3111111331) (1131111331) (3131111311) (1111311331) (3111311311)</code>
<code>      (1131311311) (1111113331) (3111113311) (1131113311) (1111313311)</code>
<code>      (3311111131) (1331111131) (3331111111) (1311311131) (3311311111)</code>
<code>      (1331311111) (1311113131) (3311113111) (1331113111) (1313131111)</code>
<code>      (1313111311) (1311131311) (1113131311) (1311313111)</code>
<code>    ] def</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def</code>
<code>    /charvals 43 dict def</code>
<code>    0 1 42 {charvals exch dup barchars exch 1 getinterval exch put} for</code>
<code>} ctxdef</code>
<code></code>
<code>    % Validate the input</code>
<code>    0 1 barcode length 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch known not {</code>
<code>            /bwipp.code39badCharacter (Code 39 must contain only digits, capital letters, spaces and the symbols -.$/+%) //raiseerror exec</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    /barlen barcode length validatecheck {1 sub} if def</code>
<code></code>
<code>    /checksum 0 def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch get</code>
<code>        checksum add /checksum exch def</code>
<code>    } for</code>
<code>    /checksum checksum 43 mod def</code>
<code>    validatecheck {</code>
<code>        barcode barlen get barchars checksum get ne {</code>
<code>            /bwipp.code39badCheckDigit (Incorrect Code 39 check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>        /barcode barcode 0 barlen getinterval def</code>
<code>        /includecheck true def</code>
<code>    } if</code>
<code></code>
<code>    /sbs barlen includecheck {3} {2} ifelse add 10 mul string def</code>
<code>    /txt barlen includecheck {3} {2} ifelse add array def</code>
<code></code>
<code>    % Put the start character</code>
<code>    sbs 0 encs 43 get putinterval</code>
<code>    hidestars not {</code>
<code>        txt 0 [(*) 0 textyoffset textfont textsize] put</code>
<code>    } {</code>
<code>        txt 0 [() 0 textyoffset textfont textsize] put</code>
<code>    } ifelse</code>
<code></code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        /indx charvals barcode i 1 getinterval get def</code>
<code>        sbs i 10 mul 10 add encs indx get putinterval</code>
<code>        txt i 1 add [barcode i 1 getinterval i 1 add 16 mul textyoffset textfont textsize] put</code>
<code>    } for</code>
<code></code>
<code>    % Put the checksum and end characters</code>
<code>    includecheck {</code>
<code>        sbs barlen 10 mul 10 add encs checksum get putinterval</code>
<code>        includecheckintext {</code>
<code>            txt barlen 1 add [barchars checksum 1 getinterval barlen 1 add 16 mul textyoffset textfont textsize] put</code>
<code>        } {</code>
<code>            txt barlen 1 add [() barlen 1 add 16 mul textyoffset textfont textsize] put</code>
<code>        } ifelse</code>
<code>        sbs barlen 10 mul 20 add encs 43 get putinterval</code>
<code>        hidestars not {</code>
<code>            txt barlen 2 add [(*) barlen 2 add 16 mul textyoffset textfont textsize] put</code>
<code>        } {</code>
<code>            txt barlen 2 add [() barlen 2 add 16 mul textyoffset textfont textsize] put</code>
<code>        } ifelse</code>
<code>    } {</code>
<code>        sbs barlen 10 mul 10 add encs 43 get putinterval</code>
<code>        hidestars not {</code>
<code>            txt barlen 1 add [(*) barlen 1 add 16 mul textyoffset textfont textsize] put</code>
<code>        } {</code>
<code>            txt barlen 1 add [() barlen 1 add 16 mul textyoffset textfont textsize] put</code>
<code>        } ifelse</code>
<code>    } ifelse</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs [sbs {48 sub} forall]</code>
<code>    /bhs [sbs length 1 add 2 idiv {height} repeat]</code>
<code>    /bbs [sbs length 1 add 2 idiv {0} repeat]</code>
<code>    includetext {</code>
<code>        /txt txt</code>
<code>    } if</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /code39 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER code39--</code>
<code></code>
<code>% --BEGIN ENCODER code39ext--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renlinear code39--</code>
<code>% --DESC: Code 39 Extended</code>
<code>% --EXAM: Code39 Ext!</code>
<code>% --EXOP: includetext includecheck includecheckintext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp code39ext 0.0 2024010300 72240 72124</code>
<code>%%BeginData:         99 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /code39 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/code39ext {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def</code>
<code>    /parse false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /code39ext //loadctx exec</code>
<code></code>
<code>    % Parse ordinals of the form ^NNN to ASCII</code>
<code>    /fncvals &lt;&lt;</code>
<code>        /parse parse</code>
<code>        /parseonly true</code>
<code>        /parsefnc false</code>
<code>    &gt;&gt; def</code>
<code>    /barcode barcode fncvals //parseinput exec def</code>
<code>    /barlen barcode length def</code>
<code>    options (parse) undef</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode {</code>
<code>        128 ge {</code>
<code>            /bwipp.code39extBadCharacter (Code 39 Extended must contain only ASCII characters) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>    % Extended alphabet to non-extended alphabet</code>
<code>{</code>
<code>    /extencs</code>
<code>    [ (%U) ($A) ($B) ($C) ($D) ($E) ($F) ($G) ($H) ($I) ($J) ($K) ($L) ($M) ($N) ($O)</code>
<code>      ($P) ($Q) ($R) ($S) ($T) ($U) ($V) ($W) ($X) ($Y) ($Z) (%A) (%B) (%C) (%D) (%E)</code>
<code>      ( )  (/A) (/B) (/C) (/D) (/E) (/F) (/G) (/H) (/I) (/J) (/K) (/L) (-)  (.)  (/O)</code>
<code>      (0)  (1)  (2)  (3)  (4)  (5)  (6)  (7)  (8)  (9)  (/Z) (%F) (%G) (%H) (%I) (%J)</code>
<code>      (%V) (A)  (B)  (C)  (D)  (E)  (F)  (G)  (H)  (I)  (J)  (K)  (L)  (M)  (N)  (O)</code>
<code>      (P)  (Q)  (R)  (S)  (T)  (U)  (V)  (W)  (X)  (Y)  (Z)  (%K) (%L) (%M) (%N) (%O)</code>
<code>      (%W) (+A) (+B) (+C) (+D) (+E) (+F) (+G) (+H) (+I) (+J) (+K) (+L) (+M) (+N) (+O)</code>
<code>      (+P) (+Q) (+R) (+S) (+T) (+U) (+V) (+W) (+X) (+Y) (+Z) (%P) (%Q) (%R) (%S) (%T)</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /newcode barlen 2 mul string def</code>
<code>    /newtext barlen 2 mul string def</code>
<code>    /j 0 def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        /extchar extencs barcode i get get def</code>
<code>        newcode j extchar putinterval</code>
<code>        newtext j barcode i get dup dup 32 lt exch 127 eq or { pop 32 } if put</code>
<code>        extchar length 1 ne { newtext j 1 add 32 put } if</code>
<code>        /j j extchar length add def</code>
<code>    } for</code>
<code>    /newcode newcode 0 j getinterval def</code>
<code>    /newtext newtext 0 j getinterval def</code>
<code></code>
<code>    % Get the result of encoding with code39</code>
<code>    options (dontdraw) true put</code>
<code>    /args newcode options //code39 exec def</code>
<code></code>
<code>    % Replace chars in /txt with chars in newtext</code>
<code>    includetext {</code>
<code>        /txt args (txt) get def</code>
<code>        0 1 newtext length 1 sub {</code>
<code>            /i exch def</code>
<code>            /txtentry txt i 1 add get def</code>
<code>            txtentry 0 newtext i 1 getinterval put</code>
<code>            txt i 1 add txtentry put</code>
<code>        } for</code>
<code>        args (txt) txt put</code>
<code>    } if</code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /code39ext dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER code39ext--</code>
<code></code>
<code>% --BEGIN ENCODER code32--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear code39--</code>
<code>% --DESC: Italian Pharmacode</code>
<code>% --EXAM: 01234567</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp code32 0.0 2024010300 67769 67498</code>
<code>%%BeginData:         87 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /code39 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/code32 {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def  % Enable/disable code32 text</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /textxoffset 0.0 def</code>
<code>    /height 1.0 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode length 8 ne barcode length 9 ne and {</code>
<code>        /bwipp.code32badLength (Italian Pharmacode must be 8 or 9 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.code32badCharacter (Italian Pharmacode must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>    % Calculate check digit</code>
<code>    /checksum 0 def</code>
<code>    0 1 7 {</code>
<code>        /i exch def</code>
<code>        barcode i get 48 sub i 2 mod 0 ne {2 mul} if dup 9 gt {9 sub} if</code>
<code>        checksum add /checksum exch def</code>
<code>    } for</code>
<code>    /checksum checksum 10 mod def</code>
<code>    barcode length 9 eq {</code>
<code>        barcode 8 get checksum 48 add ne {</code>
<code>            /bwipp.code32badCheckDigit (Incorrect Italian Pharmacode check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code>    10 string</code>
<code>    dup 0 barcode putinterval</code>
<code>    dup 8 checksum 48 add put</code>
<code>    /text exch def</code>
<code></code>
<code>    % convert number from base10 to base32</code>
<code>    /val text cvi 32 6 string cvrs def</code>
<code>    /barcode 6 string def</code>
<code>    0 1 5 {barcode exch 48 put} for</code>
<code>    barcode 6 val length sub val putinterval</code>
<code></code>
<code>    % convert base32 number to specified character set</code>
<code>    0 1 5 {</code>
<code>        dup barcode exch get</code>
<code>        dup (AEIO) {ge {1 add} if dup} forall pop</code>
<code>        barcode 3 1 roll put</code>
<code>    } for</code>
<code></code>
<code>    % format HRI</code>
<code>    text 1 text 0 9 getinterval putinterval</code>
<code>    text 0 65 put</code>
<code></code>
<code>    % Get the result of encoding with code39</code>
<code>    options (dontdraw) true put</code>
<code>    /args barcode options //code39 exec def</code>
<code></code>
<code>    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put</code>
<code>    args (textxalign) (center) put</code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /code32 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER code32--</code>
<code></code>
<code>% --BEGIN ENCODER pzn--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear code39--</code>
<code>% --DESC: Pharmazentralnummer (PZN)</code>
<code>% --EXAM: 123456</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp pzn 0.0 2024010300 67616 67270</code>
<code>%%BeginData:         87 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /code39 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/pzn {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def  % Enable/disable code32 text</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /textxoffset 0.0 def</code>
<code>    /height 1.0 def</code>
<code>    /pzn8 false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Validate the input</code>
<code>    pzn8 {</code>
<code>        barcode length 7 ne barcode length 8 ne and {</code>
<code>            /bwipp.pzn8badLength (PZN8 must be 7 or 8 digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } {</code>
<code>        barcode length 6 ne barcode length 7 ne and {</code>
<code>            /bwipp.pzn7badLength (PZN7 must be 6 or 7 digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } ifelse</code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.pznBadCharacter (PZN must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>    % Calculate check digit</code>
<code>    /msglen pzn8 {9} {8} ifelse def</code>
<code>    /checksum 0 def</code>
<code>    0 1 msglen 3 sub {</code>
<code>        /i exch def</code>
<code>        barcode i get 48 sub i pzn8 {1} {2} ifelse add mul</code>
<code>        checksum add /checksum exch def</code>
<code>    } for</code>
<code>    /checksum checksum 11 mod def</code>
<code>    checksum 10 eq {</code>
<code>        /bwipp.pznBadInputSequence (Incorrect PZN input sequence provided) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode length msglen 1 sub eq {</code>
<code>        barcode msglen 2 sub get checksum 48 add ne {</code>
<code>            /bwipp.pznBadCheckDigit (Incorrect PZN check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code>    msglen string</code>
<code>    dup 0 45 put</code>
<code>    dup 1 barcode putinterval</code>
<code>    dup msglen 1 sub checksum 48 add put</code>
<code>    /msg exch def</code>
<code></code>
<code>    % Get the result of encoding with code39</code>
<code>    options (dontdraw) true put</code>
<code>    /args msg options //code39 exec def</code>
<code></code>
<code>    % format HRI</code>
<code>    /text msglen 5 add string def</code>
<code>    text 0 (PZN - ) putinterval</code>
<code>    text 6 msg 1 msglen 1 sub getinterval putinterval</code>
<code></code>
<code>    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put</code>
<code>    args (textxalign) (center) put</code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /pzn dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER pzn--</code>
<code></code>
<code>% --BEGIN ENCODER code93--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renlinear--</code>
<code>% --DESC: Code 93</code>
<code>% --EXAM: THIS IS CODE 93</code>
<code>% --EXOP: includetext includecheck</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp code93 0.0 2024010300 69335 72377</code>
<code>%%BeginData:        134 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/code93 {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includecheck false def  % Enable/disable checkdigit</code>
<code>    /includetext false def   % Enable/disable text</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 1.0 def</code>
<code>    /parse false def</code>
<code>    /parsefnc false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /code93 //loadctx exec</code>
<code></code>
<code>{</code>
<code>    /encs</code>
<code>    [ (131112) (111213) (111312) (111411) (121113)  % 0-4</code>
<code>      (121212) (121311) (111114) (131211) (141111)  % 5-9</code>
<code>      (211113) (211212) (211311) (221112) (221211)  % A-E</code>
<code>      (231111) (112113) (112212) (112311) (122112)  % F-J</code>
<code>      (132111) (111123) (111222) (111321) (121122)  % K-O</code>
<code>      (131121) (212112) (212211) (211122) (211221)  % P-T</code>
<code>      (221121) (222111) (112122) (112221) (122121)  % U-Y</code>
<code>      (123111) (121131) (311112) (311211) (321111)  % "Z" "-" "." " " "$"</code>
<code>      (112131) (113121) (211131) (121221) (312111)  % "/" "+" "%" ($) (%)</code>
<code>      (311121) (122211) (111141) (1111411)          % (/) (+) STA END</code>
<code>    ] def</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def</code>
<code>    /charvals 47 dict def</code>
<code>    0 1 42 {charvals exch dup barchars exch get exch put} for</code>
<code></code>
<code>    /sft1 -1 def  /sft2 -2 def  /sft3 -3 def  /sft4 -4 def</code>
<code></code>
<code>    charvals sft1 43 put</code>
<code>    charvals sft2 44 put</code>
<code>    charvals sft3 45 put</code>
<code>    charvals sft4 46 put</code>
<code></code>
<code>} ctxdef</code>
<code></code>
<code>    % Special function characters</code>
<code>    /fncvals &lt;&lt;</code>
<code>        /parse parse</code>
<code>        /parsefnc parsefnc</code>
<code>        (SFT$) sft1</code>
<code>        (SFT%) sft2</code>
<code>        (SFT/) sft3</code>
<code>        (SFT+) sft4</code>
<code>    &gt;&gt; def</code>
<code>    /msg barcode fncvals //parseinput exec def</code>
<code>    /msglen msg length def</code>
<code></code>
<code>    % Validate the input</code>
<code>    msg {</code>
<code>        charvals exch known not {</code>
<code>            /bwipp.code93BadCharacter (Code 93 must only contain digits, capital letters, spaces, the symbols -.$/+ and shift non-data characters) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>    includecheck {</code>
<code>        /sbs msglen 6 mul 25 add string def</code>
<code>    } {</code>
<code>        /sbs msglen 6 mul 13 add string def</code>
<code>    } ifelse</code>
<code>    /txt msglen array def</code>
<code></code>
<code>    % Put the start character</code>
<code>    sbs 0 encs 47 get putinterval</code>
<code></code>
<code>    /checksum1 0 def /checksum2 0 def</code>
<code>    0 1 msglen 1 sub {</code>
<code>        /i exch def</code>
<code>        /indx charvals msg i get get def</code>
<code>        sbs i 6 mul 6 add encs indx get putinterval</code>
<code>        /char msg i get dup 0 lt { pop ( ) } { 1 string dup 0 4 -1 roll put } ifelse def</code>
<code>        txt i [char i 9 mul 9 add textyoffset textfont textsize] put</code>
<code>        /checksum1 checksum1 msglen i sub 1 sub 20 mod 1 add indx mul add def</code>
<code>        /checksum2 checksum2 msglen i sub 15 mod 1 add indx mul add def</code>
<code>    } for</code>
<code></code>
<code>    includecheck {</code>
<code>        % Put the first checksum character</code>
<code>        /checksum1 checksum1 47 mod def</code>
<code>        /checksum2 checksum2 checksum1 add 47 mod def</code>
<code>        sbs msglen 6 mul 6 add encs checksum1 get putinterval</code>
<code>        sbs msglen 6 mul 12 add encs checksum2 get putinterval</code>
<code>        % Put the end character</code>
<code>        sbs msglen 6 mul 18 add encs 48 get putinterval</code>
<code>    } {</code>
<code>        % Put the end character</code>
<code>        sbs msglen 6 mul 6 add encs 48 get putinterval</code>
<code>    } ifelse</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs [sbs {48 sub} forall]</code>
<code>    /bhs [sbs length 1 add 2 idiv {height} repeat]</code>
<code>    /bbs [sbs length 1 add 2 idiv {0} repeat]</code>
<code>    includetext {</code>
<code>        /txt txt</code>
<code>    } if</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /code93 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER code93--</code>
<code></code>
<code>% --BEGIN ENCODER code93ext--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renlinear code93--</code>
<code>% --DESC: Code 93 Extended</code>
<code>% --EXAM: Code93 Ext!</code>
<code>% --EXOP: includetext includecheck</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp code93ext 0.0 2024010300 73092 72924</code>
<code>%%BeginData:        107 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /code93 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/code93ext {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def</code>
<code>    /parse false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /code93ext //loadctx exec</code>
<code></code>
<code>    % Parse ordinals of the form ^NNN to ASCII</code>
<code>    /fncvals &lt;&lt;</code>
<code>        /parse parse</code>
<code>        /parseonly true</code>
<code>        /parsefnc false</code>
<code>    &gt;&gt; def</code>
<code>    /barcode barcode fncvals //parseinput exec def</code>
<code>    /barlen barcode length def</code>
<code>    options (parse) undef</code>
<code></code>
<code>    % Extended alphabet to non-extended alphabet</code>
<code>{</code>
<code>    /extencs</code>
<code>    [ (^SFT%U) (^SFT$A) (^SFT$B) (^SFT$C) (^SFT$D) (^SFT$E) (^SFT$F) (^SFT$G)</code>
<code>      (^SFT$H) (^SFT$I) (^SFT$J) (^SFT$K) (^SFT$L) (^SFT$M) (^SFT$N) (^SFT$O)</code>
<code>      (^SFT$P) (^SFT$Q) (^SFT$R) (^SFT$S) (^SFT$T) (^SFT$U) (^SFT$V) (^SFT$W)</code>
<code>      (^SFT$X) (^SFT$Y) (^SFT$Z) (^SFT%A) (^SFT%B) (^SFT%C) (^SFT%D) (^SFT%E)</code>
<code>      ( )      (^SFT/A) (^SFT/B) (^SFT/C) ($)      (%)      (^SFT/F) (^SFT/G)</code>
<code>      (^SFT/H) (^SFT/I) (^SFT/J) (+)      (^SFT/L) (-)      (.)      (/)</code>
<code>      (0)      (1)      (2)      (3)      (4)      (5)      (6)      (7)</code>
<code>      (8)      (9)      (^SFT/Z) (^SFT%F) (^SFT%G) (^SFT%H) (^SFT%I) (^SFT%J)</code>
<code>      (^SFT%V) (A)      (B)      (C)      (D)      (E)      (F)      (G)</code>
<code>      (H)      (I)      (J)      (K)      (L)      (M)      (N)      (O)</code>
<code>      (P)      (Q)      (R)      (S)      (T)      (U)      (V)      (W)</code>
<code>      (X)      (Y)      (Z)      (^SFT%K) (^SFT%L) (^SFT%M) (^SFT%N) (^SFT%O)</code>
<code>      (^SFT%W) (^SFT+A) (^SFT+B) (^SFT+C) (^SFT+D) (^SFT+E) (^SFT+F) (^SFT+G)</code>
<code>      (^SFT+H) (^SFT+I) (^SFT+J) (^SFT+K) (^SFT+L) (^SFT+M) (^SFT+N) (^SFT+O)</code>
<code>      (^SFT+P) (^SFT+Q) (^SFT+R) (^SFT+S) (^SFT+T) (^SFT+U) (^SFT+V) (^SFT+W)</code>
<code>      (^SFT+X) (^SFT+Y) (^SFT+Z) (^SFT%P) (^SFT%Q) (^SFT%R) (^SFT%S) (^SFT%T)</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /newcode barlen 6 mul string def</code>
<code>    /newtext barlen 6 mul string def</code>
<code>    /j 0 def /k 0 def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        barcode i get</code>
<code>        dup 127 gt {</code>
<code>            pop /bwipp.code93extbadCharacter (Code 93 Extended only support ASCII characters with values 0 to 127) //raiseerror exec</code>
<code>        } if</code>
<code>        extencs exch get /extchar exch def</code>
<code>        /extlen extchar length def</code>
<code>        newcode j extchar putinterval</code>
<code>        newtext k barcode i get dup dup 32 lt exch 127 eq or { pop 32 } if put</code>
<code>        extlen 1 ne { newtext k 1 add 32 put } if</code>
<code>        /j j extlen add def</code>
<code>        /k k extlen 1 eq {1} {2} ifelse add def</code>
<code>    } for</code>
<code>    /newcode newcode 0 j getinterval def</code>
<code>    /newtext newtext 0 k getinterval def</code>
<code></code>
<code>    % Get the result of encoding with code93</code>
<code>    options (dontdraw) true put</code>
<code>    options (parsefnc) true put</code>
<code>    /args newcode options //code93 exec def</code>
<code></code>
<code>    % Replace chars in /txt with chars in newtext</code>
<code>    includetext {</code>
<code>        /txt args (txt) get def</code>
<code>        0 1 newtext length 1 sub {</code>
<code>            /i exch def</code>
<code>            /txtentry txt i get def</code>
<code>            txtentry 0 newtext i 1 getinterval put</code>
<code>            txt i txtentry put</code>
<code>        } for</code>
<code>        args (txt) txt put</code>
<code>    } if</code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /code93ext dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER code93ext--</code>
<code></code>
<code>% --BEGIN ENCODER interleaved2of5--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear--</code>
<code>% --DESC: Interleaved 2 of 5 (ITF)</code>
<code>% --EXAM: 2401234567</code>
<code>% --EXOP: height=0.5 includecheck includetext includecheckintext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp interleaved2of5 0.0 2024010300 71069 70746</code>
<code>%%BeginData:        147 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/interleaved2of5 {</code>
<code></code>
<code>    20 dict begin         % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includecheck false def         % Enable/disable checkdigit</code>
<code>    /includetext false def          % Enable/disable text</code>
<code>    /includecheckintext false def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 1.0 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /interleaved2of5 //loadctx exec</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.interleaved2of5badCharacter (Interleaved 2 of 5 must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>    /barlen barcode length def      % Length of the code</code>
<code></code>
<code>    % Prefix 0 to barcode if length is even and including checkdigit</code>
<code>    % or length is odd and not including checkdigit</code>
<code>    barlen 2 mod 0 eq includecheck and          % even &amp; includecheck</code>
<code>    barlen 2 mod 0 ne includecheck not and or { % odd  &amp; !includecheck</code>
<code>        /pad barlen 1 add string def  % Create pad one bigger than barcode</code>
<code>        pad 0 48 put                  % Put ascii 0 at start of pad</code>
<code>        pad 1 barcode putinterval     % Add barcode to the end of pad</code>
<code>        /barcode pad def              % barcode=pad</code>
<code>        /barlen barlen 1 add def      % barlen++</code>
<code>    } if</code>
<code></code>
<code>    % Add checksum to end of barcode</code>
<code>    includecheck {</code>
<code>        /checksum 0 def</code>
<code>        0 1 barlen 1 sub {</code>
<code>            /i exch def</code>
<code>            i 2 mod 0 eq {</code>
<code>                /checksum checksum barcode i get 48 sub 3 mul add def</code>
<code>            } {</code>
<code>                /checksum checksum barcode i get 48 sub add def</code>
<code>            } ifelse</code>
<code>        } for</code>
<code>        /checksum 10 checksum 10 mod sub 10 mod def</code>
<code>        /pad barlen 1 add string def    % Create pad one bigger than barcode</code>
<code>        pad 0 barcode putinterval       % Add barcode to the start of pad</code>
<code>        pad barlen checksum 48 add put  % Add checksum to end of pad</code>
<code>        /barcode pad def                % barcode=pad</code>
<code>        /barlen barlen 1 add def        % barlen++</code>
<code>    } if</code>
<code></code>
<code>    % Create an array containing the character mappings</code>
<code>{</code>
<code>    /encs</code>
<code>    [ (11221) (21112) (12112) (22111) (11212)</code>
<code>      (21211) (12211) (11122) (21121) (12121)</code>
<code>      (1111)  (2111)</code>
<code>    ] def</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>    /barchars (0123456789) def</code>
<code>} ctxdef</code>
<code></code>
<code>    /sbs barlen 5 mul 8 add string def</code>
<code>    /txt barlen array def</code>
<code></code>
<code>    % Put the start character</code>
<code>    sbs 0 encs 10 get putinterval</code>
<code></code>
<code>    0 2 barlen 1 sub {</code>
<code>    /i exch def</code>
<code>        % Lookup the encodings for two consecutive barcode characters</code>
<code>        barcode i 1 getinterval barchars exch search</code>
<code>        pop                           % Discard true leaving pre</code>
<code>        length /indx exch def         % indx is the length of pre</code>
<code>        pop pop                       % Discard seek and post</code>
<code>        /enca encs indx get def       % Get the indxth encoding</code>
<code></code>
<code>        barcode i 1 add 1 getinterval barchars exch search</code>
<code>        pop                           % Discard true leaving pre</code>
<code>        length /indx exch def         % indx is the length of pre</code>
<code>        pop pop                       % Discard seek and post</code>
<code>        /encb encs indx get def       % Get the indxth encoding</code>
<code></code>
<code>        % Interleave the two character encodings</code>
<code>        /intl enca length 2 mul string def</code>
<code>        0 1 enca length 1 sub {</code>
<code>            /j exch def</code>
<code>            /achar enca j get def</code>
<code>            /bchar encb j get def</code>
<code>            intl j 2 mul achar put</code>
<code>            intl j 2 mul 1 add bchar put</code>
<code>        } for</code>
<code></code>
<code>        sbs i 5 mul 4 add intl putinterval   % Put encoded digit into sbs</code>
<code>        txt i [barcode i 1 getinterval i 9 mul 4 add textyoffset textfont textsize] put</code>
<code>        includecheck includecheckintext not and barlen 2 sub i eq and {</code>
<code>            txt i 1 add [( ) i 1 add 9 mul 4 add textyoffset textfont textsize] put</code>
<code>        } {</code>
<code>            txt i 1 add [barcode i 1 add 1 getinterval i 1 add 9 mul 4 add textyoffset textfont textsize] put</code>
<code>        } ifelse</code>
<code>    } for</code>
<code></code>
<code>    % Put the end character</code>
<code>    sbs barlen 5 mul 4 add encs 11 get putinterval</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs [sbs {48 sub} forall]</code>
<code>    /bhs [sbs length 1 add 2 idiv {height} repeat]</code>
<code>    /bbs [sbs length 1 add 2 idiv {0} repeat]</code>
<code>    includetext {</code>
<code>        /txt txt</code>
<code>    } if</code>
<code>    /barratio 2.0</code>
<code>    /spaceratio 2.0</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /interleaved2of5 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER interleaved2of5--</code>
<code></code>
<code>% --BEGIN ENCODER itf14--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear interleaved2of5--</code>
<code>% --DESC: ITF-14</code>
<code>% --EXAM: 0 952 1234 54321 3</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp itf14 0.0 2024010300 70300 70052</code>
<code>%%BeginData:         97 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /interleaved2of5 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/itf14 {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def</code>
<code>    /includecheckintext true def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textxoffset 0.0 def</code>
<code>    /textyoffset 3.5 def</code>
<code>    /height 0.5 def</code>
<code>    /showborder true def</code>
<code>    /borderwidth 4.0 def</code>
<code>    /borderleft 10.0 def</code>
<code>    /borderright 10.0 def</code>
<code>    /bordertop -0.55 def     % Ensure border/bearer touches bars with default inkspread</code>
<code>    /borderbottom -0.55 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Strip spaces from the given data</code>
<code>    /text barcode def</code>
<code>    barcode dup length string exch 0 exch</code>
<code>    {dup 32 ne {3 copy put pop 1 add} {pop} ifelse} forall</code>
<code>    0 exch getinterval /barcode exch def</code>
<code>    /hasspace text length barcode length ne def</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode length 13 ne barcode length 14 ne and {</code>
<code>        /bwipp.itf14badLength (ITF-14 must be 13 or 14 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.itf14badCharacter (ITF-14 must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>    % Calculate ITF checksum and add to end of barcode</code>
<code>    /checksum 0 def</code>
<code>    0 1 12 {</code>
<code>        /i exch def</code>
<code>        /checksum checksum barcode i get 48 sub i 2 mod 0 eq {3 mul} if add def</code>
<code>    } for</code>
<code>    /checksum 10 checksum 10 mod sub 10 mod def</code>
<code>    barcode length 14 eq {</code>
<code>        barcode 13 get checksum 48 add ne {</code>
<code>            /bwipp.itf14badCheckDigit (Incorrect ITF-14 check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>    } {</code>
<code>        14 string</code>
<code>        dup 0 barcode putinterval</code>
<code>        dup 13 checksum 48 add put</code>
<code>        /barcode exch def</code>
<code>        text length hasspace {2} {1} ifelse add string</code>
<code>        dup dup length 2 sub ( ) putinterval</code>
<code>        dup dup length 1 sub checksum 48 add put</code>
<code>        dup 0 text putinterval</code>
<code>        /text exch def</code>
<code>    } ifelse</code>
<code></code>
<code>    % Get the result of encoding with interleaved2of5</code>
<code>    options (dontdraw) true put</code>
<code>    options (showborder) showborder put</code>
<code>    options (borderwidth) borderwidth put</code>
<code>    options (borderleft) borderleft put</code>
<code>    options (borderright) borderright put</code>
<code>    options (bordertop) bordertop put</code>
<code>    options (borderbottom) borderbottom put</code>
<code>    options (height) height put</code>
<code>    options (textyoffset) textyoffset put</code>
<code>    /args barcode options //interleaved2of5 exec def</code>
<code></code>
<code>    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put</code>
<code>    args (textxalign) (center) put</code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /itf14 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER itf14--</code>
<code></code>
<code>% --BEGIN ENCODER identcode--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear interleaved2of5--</code>
<code>% --DESC: Deutsche Post Identcode</code>
<code>% --EXAM: 563102430313</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp identcode 0.0 2024010300 66534 66390</code>
<code>%%BeginData:         78 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /interleaved2of5 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/identcode {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def    % Enable/disable text</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textxoffset 0.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 1.0 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode length 11 ne barcode length 12 ne and {</code>
<code>        /bwipp.identcodeBadLength (Deutsche Post Identcode must be 11 or 12 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.identcodeBadCharacter (Deutsche Post Identcode must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>    % Calculate checksum and add to end of barcode</code>
<code>    /checksum 0 def</code>
<code>    0 1 10 {</code>
<code>        /i exch def</code>
<code>        /checksum checksum barcode i get 48 sub i 2 mod 0 eq {4 mul} {9 mul} ifelse add def</code>
<code>    } for</code>
<code>    /checksum 10 checksum 10 mod sub 10 mod def</code>
<code>    barcode length 12 eq {</code>
<code>        barcode 11 get checksum 48 add ne {</code>
<code>            /bwipp.identcodeBadCheckDigit (Incorrect Deutsche Post Identcode check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code>    12 string</code>
<code>    dup 0 barcode putinterval</code>
<code>    dup 11 checksum 48 add put</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Compose the human readable text</code>
<code>    /text (  .       .     ) 16 string copy def</code>
<code>    text  0 barcode  0 2 getinterval putinterval</code>
<code>    text  3 barcode  2 3 getinterval putinterval</code>
<code>    text  7 barcode  5 3 getinterval putinterval</code>
<code>    text 11 barcode  8 3 getinterval putinterval</code>
<code>    text 15 barcode 11 1 getinterval putinterval</code>
<code></code>
<code>    % Get the result of encoding with interleaved2of5</code>
<code>    options (dontdraw) true put</code>
<code>    options (includecheck) false put</code>
<code>    /args barcode options //interleaved2of5 exec def</code>
<code></code>
<code>    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put</code>
<code>    args (textxalign) (center) put</code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /identcode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER identcode--</code>
<code></code>
<code>% --BEGIN ENCODER leitcode--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear interleaved2of5--</code>
<code>% --DESC: Deutsche Post Leitcode</code>
<code>% --EXAM: 21348075016401</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp leitcode 0.0 2024010300 66526 66386</code>
<code>%%BeginData:         78 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /interleaved2of5 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/leitcode {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def    % Enable/disable text</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textxoffset 0.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 1.0 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode length 13 ne barcode length 14 ne and {</code>
<code>        /bwipp.leitcodeBadLength (Deutsche Post Leitcode must be 13 or 14 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.leitcodeBadCharacter (Deutsche Post Leitcode must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>    % Calculate checksum and add to end of barcode</code>
<code>    /checksum 0 def</code>
<code>    0 1 12 {</code>
<code>        /i exch def</code>
<code>        /checksum checksum barcode i get 48 sub i 2 mod 0 eq {4 mul} {9 mul} ifelse add def</code>
<code>    } for</code>
<code>    /checksum 10 checksum 10 mod sub 10 mod def</code>
<code>    barcode length 14 eq {</code>
<code>        barcode 13 get checksum 48 add ne {</code>
<code>            /bwipp.leitcodeBadCheckDigit (Incorrect Deutsche Post Leitcode check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code>    14 string</code>
<code>    dup 0 barcode putinterval</code>
<code>    dup 13 checksum 48 add put</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Compose the human readable text</code>
<code>    /text (     .   .   .    ) 18 string copy def</code>
<code>    text  0 barcode  0 5 getinterval putinterval</code>
<code>    text  6 barcode  5 3 getinterval putinterval</code>
<code>    text 10 barcode  8 3 getinterval putinterval</code>
<code>    text 14 barcode 11 2 getinterval putinterval</code>
<code>    text 17 barcode 13 1 getinterval putinterval</code>
<code></code>
<code>    % Get the result of encoding with interleaved2of5</code>
<code>    options (dontdraw) true put</code>
<code>    options (includecheck) false put</code>
<code>    /args barcode options //interleaved2of5 exec def</code>
<code></code>
<code>    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put</code>
<code>    args (textxalign) (center) put</code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /leitcode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER leitcode--</code>
<code></code>
<code>% --BEGIN ENCODER databaromni--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear renmatrix--</code>
<code>% --DESC: GS1 DataBar Omnidirectional</code>
<code>% --EXAM: (01)09521234543213</code>
<code>% --EXOP:</code>
<code>% --RNDR: renlinear renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp databaromni 0.0 2024010300 117143 116039</code>
<code>%%BeginData:        437 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 20 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/databaromni {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /height 33.0 72 div def</code>
<code>    /linkage false def</code>
<code>    /format (omni) def</code>
<code>    /barxmult 33 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode length 17 ne barcode length 18 ne and {</code>
<code>        /bwipp.databaromniBadLength (GS1 DataBar Omnidirectional must be 13 or 14 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode 0 4 getinterval (\(01\)) ne {</code>
<code>        /bwipp.databaromniBadAI (GS1 DataBar Omnidirectional must begin with (01) application identifier) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode 4 barcode length 4 sub getinterval {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.databaromniBadCharacter (GS1 DataBar Omnidirectional must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>    barxmult 33 lt {</code>
<code>        /bwipp.databarStackedOmniBarXmult (GS1 DataBar Stacked Omnidirectional must have a barxmult of at least 33) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    format (omni) ne format (stacked) ne and format (stackedomni) ne and format (truncated) ne and {</code>
<code>        /bwipp.databaromniBadFormat (Valid formats are omni, stacked, stackedomni and truncated) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    format (truncated) eq {/height 13.0 72 div def} if</code>
<code></code>
<code>    /databaromni //loadctx exec</code>
<code></code>
<code>    % Calculate checksum and add to end of barcode</code>
<code>    /checksum 0 def</code>
<code>    0 1 12 {</code>
<code>        /i exch def</code>
<code>        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def</code>
<code>    } for</code>
<code>    /checksum 10 checksum 10 mod sub 10 mod def</code>
<code>    barcode length 18 eq {</code>
<code>        barcode 17 get checksum 48 add ne {</code>
<code>            /bwipp.databaromniBadCheckDigit (Incorrect GS1 DataBar Omnidirectional check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code>    18 string</code>
<code>    dup 0 barcode putinterval</code>
<code>    dup 17 checksum 48 add put</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Create the human readable text</code>
<code>    /txt barcode length array def</code>
<code>    0 1 barcode length 1 sub {</code>
<code>        /i exch def</code>
<code>        txt i [barcode i 1 getinterval 0 0 () 0] put</code>
<code>    } for</code>
<code></code>
<code>    /ncr {  % n r</code>
<code>        2 copy sub 2 copy lt {exch} if  % n r maxd mind</code>
<code>        1 1 5 3 roll  % mind j=1 v=1 n maxd</code>
<code>        1 add -1 exch {  % mind j v  n -1 maxd+1</code>
<code>            mul  % mind j v*i</code>
<code>            1 index 3 index le {</code>
<code>                1 index idiv exch 1 add exch</code>
<code>            } if</code>
<code>        } for</code>
<code>        {  % mind j v</code>
<code>            1 index 3 index gt {exit} if</code>
<code>            1 index idiv exch 1 add exch</code>
<code>        } loop</code>
<code>        exch pop exch pop</code>
<code>    } def</code>
<code></code>
<code>    /getRSSwidths {</code>
<code>        /oe exch def</code>
<code>        /el exch def</code>
<code>        /mw exch def</code>
<code>        /nm exch def</code>
<code>        /val exch def</code>
<code>        /out el array def</code>
<code>        /mask 0 def</code>
<code>        0 1 el 2 sub {</code>
<code>            /bar exch def</code>
<code>            /ew 1 def</code>
<code>            /mask mask 1 bar bitshift or def {</code>
<code>                /sval nm ew sub 1 sub el bar sub 2 sub ncr def</code>
<code>                oe mask 0 eq and nm ew sub el 2 mul sub bar 2 mul add -2 ge and {</code>
<code>                    /sval sval nm ew sub el sub bar add el bar sub 2 sub ncr sub def</code>
<code>                } if</code>
<code>                el bar sub 2 gt {</code>
<code>                    /lval 0 def</code>
<code>                    nm ew sub el sub bar add 2 add -1 mw 1 add {</code>
<code>                        nm exch sub ew sub 1 sub el bar sub 3 sub ncr</code>
<code>                        /lval exch lval add def</code>
<code>                    } for</code>
<code>                    /sval sval lval el bar sub 1 sub mul sub def</code>
<code>                } {</code>
<code>                    nm ew sub mw gt {/sval sval 1 sub def} if</code>
<code>                } ifelse</code>
<code>                /val val sval sub def</code>
<code>                val 0 lt {exit} if</code>
<code>                /ew ew 1 add def</code>
<code>                /mask mask 1 bar bitshift not and def</code>
<code>            } loop</code>
<code>            /val val sval add def</code>
<code>            /nm nm ew sub def</code>
<code>            out bar ew put</code>
<code>        } for</code>
<code>        out el 1 sub nm put</code>
<code>        out</code>
<code>    } def</code>
<code></code>
<code>    /binval [</code>
<code>        linkage {1} {0} ifelse</code>
<code>        barcode 4 13 getinterval {48 sub} forall</code>
<code>    ] def</code>
<code></code>
<code>    0 1 12 {</code>
<code>        /i exch def</code>
<code>        binval i 1 add 2 copy get binval i get 4537077 mod 10 mul add put</code>
<code>        binval i binval i get 4537077 idiv put</code>
<code>    } for</code>
<code>    /right binval 13 get 4537077 mod def</code>
<code>    binval 13 2 copy get 4537077 idiv put</code>
<code></code>
<code>    /left 0 def</code>
<code>    /i true def</code>
<code>    0 1 13 {</code>
<code>        /j exch def</code>
<code>        binval j get</code>
<code>        dup 0 eq i and {</code>
<code>            pop</code>
<code>        } {</code>
<code>            /i false def</code>
<code>            /left left 3 -1 roll 10 13 j sub exp cvi mul add def</code>
<code>        } ifelse</code>
<code>    } for</code>
<code></code>
<code>    /d1 left 1597 idiv def</code>
<code>    /d2 left 1597 mod def</code>
<code>    /d3 right 1597 idiv def</code>
<code>    /d4 right 1597 mod def</code>
<code></code>
<code>{</code>
<code>    /tab164 [</code>
<code>        160   0     12 4   8 1  161   1</code>
<code>        960   161   10 6   6 3  80   10</code>
<code>        2014  961   8  8   4 5  31   34</code>
<code>        2714  2015  6  10  3 6  10   70</code>
<code>        2840  2715  4  12  1 8  1    126</code>
<code>    ] def</code>
<code></code>
<code>    /tab154 [</code>
<code>        335   0     5  10  2 7  4   84</code>
<code>        1035  336   7  8   4 5  20  35</code>
<code>        1515  1036  9  6   6 3  48  10</code>
<code>        1596  1516  11 4   8 1  81  1</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /i 0 def {</code>
<code>        d1 tab164 i get le {</code>
<code>            tab164 i 1 add 7 getinterval {} forall</code>
<code>            /d1te exch def /d1to exch def</code>
<code>            /d1mwe exch def /d1mwo exch def</code>
<code>            /d1ele exch def /d1elo exch def</code>
<code>            /d1gs exch def</code>
<code>            exit</code>
<code>        } if</code>
<code>        /i i 8 add def</code>
<code>    } loop</code>
<code></code>
<code>    /i 0 def {</code>
<code>        d2 tab154 i get le {</code>
<code>            tab154 i 1 add 7 getinterval {} forall</code>
<code>            /d2te exch def /d2to exch def</code>
<code>            /d2mwe exch def /d2mwo exch def</code>
<code>            /d2ele exch def /d2elo exch def</code>
<code>            /d2gs exch def</code>
<code>            exit</code>
<code>        } if</code>
<code>        /i i 8 add def</code>
<code>    } loop</code>
<code></code>
<code>    /i 0 def {</code>
<code>        d3 tab164 i get le {</code>
<code>            tab164 i 1 add 7 getinterval {} forall</code>
<code>            /d3te exch def /d3to exch def</code>
<code>            /d3mwe exch def /d3mwo exch def</code>
<code>            /d3ele exch def /d3elo exch def</code>
<code>            /d3gs exch def</code>
<code>            exit</code>
<code>        } if</code>
<code>        /i i 8 add def</code>
<code>    } loop</code>
<code></code>
<code>    /i 0 def {</code>
<code>        d4 tab154 i get le {</code>
<code>            tab154 i 1 add 7 getinterval {} forall</code>
<code>            /d4te exch def /d4to exch def</code>
<code>            /d4mwe exch def /d4mwo exch def</code>
<code>            /d4ele exch def /d4elo exch def</code>
<code>            /d4gs exch def</code>
<code>            exit</code>
<code>        } if</code>
<code>        /i i 8 add def</code>
<code>    } loop</code>
<code></code>
<code>    /d1wo d1 d1gs sub d1te idiv d1elo d1mwo 4 false getRSSwidths def</code>
<code>    /d1we d1 d1gs sub d1te mod  d1ele d1mwe 4 true  getRSSwidths def</code>
<code>    /d2wo d2 d2gs sub d2to mod  d2elo d2mwo 4 true  getRSSwidths def</code>
<code>    /d2we d2 d2gs sub d2to idiv d2ele d2mwe 4 false getRSSwidths def</code>
<code>    /d3wo d3 d3gs sub d3te idiv d3elo d3mwo 4 false getRSSwidths def</code>
<code>    /d3we d3 d3gs sub d3te mod  d3ele d3mwe 4 true  getRSSwidths def</code>
<code>    /d4wo d4 d4gs sub d4to mod  d4elo d4mwo 4 true  getRSSwidths def</code>
<code>    /d4we d4 d4gs sub d4to idiv d4ele d4mwe 4 false getRSSwidths def</code>
<code></code>
<code>    /d1w 8 array def</code>
<code>    0 1 3 {</code>
<code>        /i exch def</code>
<code>        d1w i 2 mul d1wo i get put</code>
<code>        d1w i 2 mul 1 add d1we i get put</code>
<code>    } for</code>
<code></code>
<code>    /d2w 8 array def</code>
<code>    0 1 3 {</code>
<code>        /i exch def</code>
<code>        d2w 7 i 2 mul sub d2wo i get put</code>
<code>        d2w 6 i 2 mul sub d2we i get put</code>
<code>    } for</code>
<code></code>
<code>    /d3w 8 array def</code>
<code>    0 1 3 {</code>
<code>        /i exch def</code>
<code>        d3w 7 i 2 mul sub d3wo i get put</code>
<code>        d3w 6 i 2 mul sub d3we i get put</code>
<code>    } for</code>
<code></code>
<code>    /d4w 8 array def</code>
<code>    0 1 3 {</code>
<code>        /i exch def</code>
<code>        d4w i 2 mul d4wo i get put</code>
<code>        d4w i 2 mul 1 add d4we i get put</code>
<code>    } for</code>
<code></code>
<code>    /widths [</code>
<code>        d1w {} forall</code>
<code>        d2w {} forall</code>
<code>        d3w {} forall</code>
<code>        d4w {} forall</code>
<code>    ] def</code>
<code></code>
<code>{</code>
<code>    /checkweights [</code>
<code>        1   3   9   27  2   6   18  54</code>
<code>        58  72  24  8   29  36  12  4</code>
<code>        74  51  17  32  37  65  48  16</code>
<code>        64  34  23  69  49  68  46  59</code>
<code>    ] def</code>
<code></code>
<code>    /checkwidths [</code>
<code>        3 8 2 1 1   3 5 5 1 1   3 3 7 1 1</code>
<code>        3 1 9 1 1   2 7 4 1 1   2 5 6 1 1</code>
<code>        2 3 8 1 1   1 5 7 1 1   1 3 9 1 1</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /checksum 0 def</code>
<code>    0 1 31 {</code>
<code>        /i exch def</code>
<code>        /checksum checksum widths i get checkweights i get mul add def</code>
<code>    } for</code>
<code>    /checksum checksum 79 mod def</code>
<code>    checksum 8 ge {/checksum checksum 1 add def} if</code>
<code>    checksum 72 ge {/checksum checksum 1 add def} if</code>
<code>    /checklt checkwidths checksum 9 idiv 5 mul 5 getinterval def</code>
<code>    /checkrtrev checkwidths checksum 9 mod 5 mul 5 getinterval def</code>
<code>    /checkrt 5 array def</code>
<code>    0 1 4 {</code>
<code>        /i exch def</code>
<code>        checkrt i checkrtrev 4 i sub get put</code>
<code>    } for</code>
<code></code>
<code>    % Stacked format</code>
<code>    format (omni) eq format (truncated) eq or {  % linear</code>
<code></code>
<code>        /sbs [</code>
<code>            1 d1w {} forall checklt {} forall d2w {} forall</code>
<code>            d4w {} forall checkrt {} forall d3w {} forall 1 1</code>
<code>        ] def</code>
<code></code>
<code>        &lt;&lt;</code>
<code>        /ren //renlinear</code>
<code>        /sbs sbs</code>
<code>        /bhs [sbs length 1 add 2 idiv {height} repeat]</code>
<code>        /bbs [sbs length 1 add 2 idiv {0} repeat]</code>
<code>        /txt txt</code>
<code>        /textxalign (center)</code>
<code>        /borderleft 0.0</code>
<code>        /borderright 0.0</code>
<code>        /opt options</code>
<code>        &gt;&gt;</code>
<code></code>
<code>        dontdraw not //renlinear if</code>
<code></code>
<code>    } {  % 2D - stacked or stackedomni</code>
<code></code>
<code>        /top [ 1 1 d1w {} forall checklt {} forall d2w {} forall 1 1 0 ] def</code>
<code>        /bot [ 1 1 d4w {} forall checkrt {} forall d3w {} forall 1 1 0 ] def</code>
<code>        0 2 24 {</code>
<code>            /i exch def</code>
<code>            top i get {0} repeat</code>
<code>            top i 1 add get {1} repeat</code>
<code>        } for</code>
<code>        50 array astore /top exch def</code>
<code>        0 2 24 {</code>
<code>            /i exch def</code>
<code>            bot i get {1} repeat</code>
<code>            bot i 1 add get {0} repeat</code>
<code>        } for</code>
<code>        50 array astore /bot exch def</code>
<code></code>
<code>        % Stacked</code>
<code>        format (stacked) eq {</code>
<code>            /sep 50 array def</code>
<code>            sep 0 0 put</code>
<code>            1 1 49 {</code>
<code>                /i exch def</code>
<code>                top i get bot i get eq {</code>
<code>                    sep i 1 top i get sub put</code>
<code>                } {</code>
<code>                    sep i 1 sep i 1 sub get sub put</code>
<code>                } ifelse</code>
<code>            } for</code>
<code>            sep 0  [ 0 0 0 0 ] putinterval</code>
<code>            sep 46 [ 0 0 0 0 ] putinterval</code>
<code>            /pixs [</code>
<code>                5 {top aload pop} repeat</code>
<code>                sep aload pop</code>
<code>                7 {bot aload pop} repeat</code>
<code>            ] def</code>
<code>            /pixy pixs length 50 idiv def</code>
<code>        } if</code>
<code></code>
<code>        % Stacked omnidirectional</code>
<code>        format (stackedomni) eq {</code>
<code>            /sep1 [ top {1 exch sub} forall ] def</code>
<code>            sep1 0  [ 0 0 0 0 ] putinterval</code>
<code>            sep1 46 [ 0 0 0 0 ] putinterval</code>
<code>            18 1 30 {</code>
<code>                /i exch def</code>
<code>                top i get 0 eq {</code>
<code>                    top i 1 sub get 1 eq {</code>
<code>                        1</code>
<code>                    } {</code>
<code>                        sep1 i 1 sub get 0 eq {1} {0} ifelse</code>
<code>                    } ifelse</code>
<code>                } {</code>
<code>                    0</code>
<code>                } ifelse</code>
<code>                sep1 exch i exch put</code>
<code>            } for</code>
<code>            /sep2 [ 0 0 0 0 21 { 0 1 } repeat 0 0 0 0 ] def</code>
<code>            /sep3 [ bot {1 exch sub} forall ] def</code>
<code>            sep3 0  [ 0 0 0 0 ] putinterval</code>
<code>            sep3 46 [ 0 0 0 0 ] putinterval</code>
<code>            19 1 31 {</code>
<code>                /i exch def</code>
<code>                bot i get 0 eq {</code>
<code>                    bot i 1 sub get 1 eq {</code>
<code>                        1</code>
<code>                    } {</code>
<code>                        sep3 i 1 sub get 0 eq {1} {0} ifelse</code>
<code>                    } ifelse</code>
<code>                } {</code>
<code>                    0</code>
<code>                } ifelse</code>
<code>                sep3 exch i exch put</code>
<code>            } for</code>
<code>            /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def</code>
<code>            true 0 1 12 {dup bot exch 19 add get exch f3 exch get eq and} for {</code>
<code>                % Right shifted module for value 3 finder</code>
<code>                sep3 19 [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval</code>
<code>            } if</code>
<code>            /pixs [</code>
<code>                barxmult {top aload pop} repeat</code>
<code>                sep1 aload pop</code>
<code>                sep2 aload pop</code>
<code>                sep3 aload pop</code>
<code>                barxmult {bot aload pop} repeat</code>
<code>            ] def</code>
<code>            /pixy pixs length 50 idiv def</code>
<code>        } if</code>
<code></code>
<code>        % Return the arguments</code>
<code>        &lt;&lt;</code>
<code>        /ren //renmatrix</code>
<code>        /pixs pixs</code>
<code>        /pixx 50</code>
<code>        /pixy pixy</code>
<code>        /height pixy 72 div</code>
<code>        /width 50 72 div</code>
<code>        /borderleft 0.0</code>
<code>        /borderright 0.0</code>
<code>        /bordertop 0.0</code>
<code>        /borderbottom 0.0</code>
<code>        /opt options</code>
<code>        &gt;&gt;</code>
<code></code>
<code>        dontdraw not //renmatrix if</code>
<code></code>
<code>    } ifelse</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /databaromni dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER databaromni--</code>
<code></code>
<code>% --BEGIN ENCODER databarstacked--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear renmatrix databaromni--</code>
<code>% --DESC: GS1 DataBar Stacked</code>
<code>% --EXAM: (01)09521234543213</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp databarstacked 0.0 2024010300 67838 67653</code>
<code>%%BeginData:         66 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /databaromni dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/databarstacked {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode length 17 ne barcode length 18 ne and {</code>
<code>        /bwipp.databarstackedBadLength (GS1 DataBar Stacked must be 13 or 14 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode 0 4 getinterval (\(01\)) ne {</code>
<code>        /bwipp.databarstackedBadAI (GS1 DataBar Stacked must begin with (01) application identifier) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode 4 barcode length 4 sub getinterval {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.databarstackedBadCharacter (GS1 DataBar Stacked must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>    % Calculate checksum and add to end of barcode</code>
<code>    /checksum 0 def</code>
<code>    0 1 12 {</code>
<code>        /i exch def</code>
<code>        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def</code>
<code>    } for</code>
<code>    /checksum 10 checksum 10 mod sub 10 mod def</code>
<code>    barcode length 18 eq {</code>
<code>        barcode 17 get checksum 48 add ne {</code>
<code>            /bwipp.databarstackedBadCheckDigit (Incorrect GS1 DataBar Stacked check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code>    18 string</code>
<code>    dup 0 barcode putinterval</code>
<code>    dup 17 checksum 48 add put</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Get the result of encoding with databaromni with format=stacked</code>
<code>    options (dontdraw) true put</code>
<code>    options (format) (stacked) put</code>
<code></code>
<code>    /args barcode options //databaromni exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /databarstacked dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER databarstacked--</code>
<code></code>
<code>% --BEGIN ENCODER databarstackedomni--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear renmatrix databaromni--</code>
<code>% --DESC: GS1 DataBar Stacked Omnidirectional</code>
<code>% --EXAM: (01)24012345678905</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp databarstackedomni 0.0 2024010300 67986 67781</code>
<code>%%BeginData:         66 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /databaromni dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/databarstackedomni {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode 0 4 getinterval (\(01\)) ne {</code>
<code>        /bwipp.databarstackedomniBadAI (GS1 DataBar Stacked Omnidirectional must begin with (01) application identifier) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode length 17 ne barcode length 18 ne and {</code>
<code>        /bwipp.databarstackedomniBadLength (GS1 DataBar Stacked Omnidirectional must be 13 or 14 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode 4 barcode length 4 sub getinterval {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.databarstackedomniBadCharacter (GS1 DataBar Stacked Omnidirectional must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>    % Calculate checksum and add to end of barcode</code>
<code>    /checksum 0 def</code>
<code>    0 1 12 {</code>
<code>        /i exch def</code>
<code>        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def</code>
<code>    } for</code>
<code>    /checksum 10 checksum 10 mod sub 10 mod def</code>
<code>    barcode length 18 eq {</code>
<code>        barcode 17 get checksum 48 add ne {</code>
<code>            /bwipp.databarstackedomniBadCheckDigit (Incorrect GS1 DataBar Stacked Omnidirectional check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code>    18 string</code>
<code>    dup 0 barcode putinterval</code>
<code>    dup 17 checksum 48 add put</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Get the result of encoding with databaromni with format=stackedomni</code>
<code>    options (dontdraw) true put</code>
<code>    options (format) (stackedomni) put</code>
<code></code>
<code>    /args barcode options //databaromni exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /databarstackedomni dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER databarstackedomni--</code>
<code></code>
<code>% --BEGIN ENCODER databartruncated--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear renmatrix databaromni--</code>
<code>% --DESC: GS1 DataBar Truncated</code>
<code>% --EXAM: (01)09521234543213</code>
<code>% --EXOP:</code>
<code>% --RNDR: renlinear renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp databartruncated 0.0 2024010300 67864 67669</code>
<code>%%BeginData:         66 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /databaromni dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/databartruncated {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode length 17 ne barcode length 18 ne and {</code>
<code>        /bwipp.databartruncatedBadLength (GS1 DataBar Truncated must be 13 or 14 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode 0 4 getinterval (\(01\)) ne {</code>
<code>        /bwipp.databartruncatedBadAI (GS1 DataBar Truncated must begin with (01) application identifier) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode 4 barcode length 4 sub getinterval {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.databartruncatedBadCharacter (GS1 DataBar Truncated must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>    % Calculate checksum and add to end of barcode</code>
<code>    /checksum 0 def</code>
<code>    0 1 12 {</code>
<code>        /i exch def</code>
<code>        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def</code>
<code>    } for</code>
<code>    /checksum 10 checksum 10 mod sub 10 mod def</code>
<code>    barcode length 18 eq {</code>
<code>        barcode 17 get checksum 48 add ne {</code>
<code>            /bwipp.databartruncatedBadCheckDigit (Incorrect GS1 DataBar Truncated check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code>    18 string</code>
<code>    dup 0 barcode putinterval</code>
<code>    dup 17 checksum 48 add put</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Get the result of encoding with databaromni with format=truncated</code>
<code>    options (dontdraw) true put</code>
<code>    options (format) (truncated) put</code>
<code></code>
<code>    /args barcode options //databaromni exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /databartruncated dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER databartruncated--</code>
<code></code>
<code>% --BEGIN ENCODER databarlimited--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear--</code>
<code>% --DESC: GS1 DataBar Limited</code>
<code>% --EXAM: (01)09521234543213</code>
<code>% --EXOP:</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp databarlimited 0.0 2024010300 91408 90555</code>
<code>%%BeginData:        281 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 20 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/databarlimited {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /height 10.0 72 div def</code>
<code>    /linkage false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /databarlimited //loadctx exec</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode length 17 ne barcode length 18 ne and {</code>
<code>        /bwipp.databarlimitedBadLength (GS1 DataBar Limited must be 13 or 14 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode 0 4 getinterval (\(01\)) ne {</code>
<code>        /bwipp.databarlimitedBadAI (GS1 DataBar Limited must begin with (01) application identifier) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode 4 get dup 48 lt exch 49 gt or {</code>
<code>        /bwipp.databarlimitedBadStartDigit (GS1 DataBar Limited must begin with 0 or 1) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode 5 barcode length 5 sub getinterval {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.databarlimitedBadCharacter (GS1 DataBar Limited must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>    % Calculate checksum and add to end of barcode</code>
<code>    /checksum 0 def</code>
<code>    0 1 12 {</code>
<code>        /i exch def</code>
<code>        /checksum checksum barcode i 4 add get 48 sub i 2 mod 0 eq {3 mul} if add def</code>
<code>    } for</code>
<code>    /checksum 10 checksum 10 mod sub 10 mod def</code>
<code>    barcode length 18 eq {</code>
<code>        barcode 17 get checksum 48 add ne {</code>
<code>            /bwipp.databarlimitedBadCheckDigit (Incorrect GS1 DataBar Limited check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code>    18 string</code>
<code>    dup 0 barcode putinterval</code>
<code>    dup 17 checksum 48 add put</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Strip the AI and optional check digit</code>
<code>{</code>
<code>    /linkval [ 2 0 1 5 1 3 3 5 3 1 0 9 6 ] def</code>
<code>} ctxdef</code>
<code>    /binval [</code>
<code>        barcode 4 13 getinterval {48 sub} forall</code>
<code>    ] def</code>
<code>    linkage {</code>
<code>        0 1 binval length 1 sub {</code>
<code>            /i exch def</code>
<code>            binval i binval i get linkval i get add put</code>
<code>        } for</code>
<code>    } if</code>
<code></code>
<code>    % Create the human readable text</code>
<code>    /txt barcode length array def</code>
<code>    0 1 barcode length 1 sub {</code>
<code>        /i exch def</code>
<code>        txt i [barcode i 1 getinterval 0 0 () 0] put</code>
<code>    } for</code>
<code></code>
<code>    /ncr {  % n r</code>
<code>        2 copy sub 2 copy lt {exch} if  % n r maxd mind</code>
<code>        1 1 5 3 roll  % mind j=1 v=1 n maxd</code>
<code>        1 add -1 exch {  % mind j v  n -1 maxd+1</code>
<code>            mul  % mind j v*i</code>
<code>            1 index 3 index le {</code>
<code>                1 index idiv exch 1 add exch</code>
<code>            } if</code>
<code>        } for</code>
<code>        {  % mind j v</code>
<code>            1 index 3 index gt {exit} if</code>
<code>            1 index idiv exch 1 add exch</code>
<code>        } loop</code>
<code>        exch pop exch pop</code>
<code>    } def</code>
<code></code>
<code>    /getRSSwidths {</code>
<code>        /oe exch def</code>
<code>        /el exch def</code>
<code>        /mw exch def</code>
<code>        /nm exch def</code>
<code>        /val exch def</code>
<code>        /out el array def</code>
<code>        /mask 0 def</code>
<code>        0 1 el 2 sub {</code>
<code>            /bar exch def</code>
<code>            /ew 1 def</code>
<code>            /mask mask 1 bar bitshift or def {</code>
<code>                /sval nm ew sub 1 sub el bar sub 2 sub ncr def</code>
<code>                oe mask 0 eq and nm ew sub el 2 mul sub bar 2 mul add -2 ge and {</code>
<code>                    /sval sval nm ew sub el sub bar add el bar sub 2 sub ncr sub def</code>
<code>                } if</code>
<code>                el bar sub 2 gt {</code>
<code>                    /lval 0 def</code>
<code>                    nm ew sub el sub bar add 2 add -1 mw 1 add {</code>
<code>                        nm exch sub ew sub 1 sub el bar sub 3 sub ncr</code>
<code>                        /lval exch lval add def</code>
<code>                    } for</code>
<code>                    /sval sval lval el bar sub 1 sub mul sub def</code>
<code>                } {</code>
<code>                    nm ew sub mw gt {/sval sval 1 sub def} if</code>
<code>                } ifelse</code>
<code>                /val val sval sub def</code>
<code>                val 0 lt {exit} if</code>
<code>                /ew ew 1 add def</code>
<code>                /mask mask 1 bar bitshift not and def</code>
<code>            } loop</code>
<code>            /val val sval add def</code>
<code>            /nm nm ew sub def</code>
<code>            out bar ew put</code>
<code>        } for</code>
<code>        out el 1 sub nm put</code>
<code>        out</code>
<code>    } def</code>
<code></code>
<code>    0 1 11 {</code>
<code>        /i exch def</code>
<code>        binval i 1 add 2 copy get binval i get 2013571 mod 10 mul add put</code>
<code>        binval i binval i get 2013571 idiv put</code>
<code>    } for</code>
<code>    /d2 binval 12 get 2013571 mod def</code>
<code>    binval 12 2 copy get 2013571 idiv put</code>
<code></code>
<code>    /d1 0 def</code>
<code>    /i true def</code>
<code>    0 1 12 {</code>
<code>        /j exch def</code>
<code>        binval j get</code>
<code>        dup 0 eq i and {</code>
<code>            pop</code>
<code>        } {</code>
<code>            /i false def</code>
<code>            /d1 d1 3 -1 roll 10 12 j sub exp cvi mul add def</code>
<code>        } ifelse</code>
<code>    } for</code>
<code></code>
<code>{</code>
<code>    /tab267 [</code>
<code>        183063   0        17 9   6 3  6538   28</code>
<code>        820063   183064   13 13  5 4  875    728</code>
<code>        1000775  820064   9  17  3 6  28     6454</code>
<code>        1491020  1000776  15 11  5 4  2415   203</code>
<code>        1979844  1491021  11 15  4 5  203    2408</code>
<code>        1996938  1979845  19 7   8 1  17094  1</code>
<code>        2013570  1996939  7  19  1 8  1      16632</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /i 0 def {</code>
<code>        d1 tab267 i get le {</code>
<code>            tab267 i 1 add 7 getinterval {} forall</code>
<code>            /d1te exch def /d1to exch def</code>
<code>            /d1mwe exch def /d1mwo exch def</code>
<code>            /d1ele exch def /d1elo exch def</code>
<code>            /d1gs exch def</code>
<code>            exit</code>
<code>        } if</code>
<code>        /i i 8 add def</code>
<code>    } loop</code>
<code></code>
<code>    /i 0 def {</code>
<code>        d2 tab267 i get le {</code>
<code>            tab267 i 1 add 7 getinterval {} forall</code>
<code>            /d2te exch def /d2to exch def</code>
<code>            /d2mwe exch def /d2mwo exch def</code>
<code>            /d2ele exch def /d2elo exch def</code>
<code>            /d2gs exch def</code>
<code>            exit</code>
<code>        } if</code>
<code>        /i i 8 add def</code>
<code>    } loop</code>
<code></code>
<code>    /d1wo d1 d1gs sub d1te idiv d1elo d1mwo 7 false getRSSwidths def</code>
<code>    /d1we d1 d1gs sub d1te mod  d1ele d1mwe 7 true  getRSSwidths def</code>
<code>    /d2wo d2 d2gs sub d2te idiv d2elo d2mwo 7 false getRSSwidths def</code>
<code>    /d2we d2 d2gs sub d2te mod  d2ele d2mwe 7 true  getRSSwidths def</code>
<code></code>
<code>    /d1w 14 array def</code>
<code>    0 1 6 {</code>
<code>        /i exch def</code>
<code>        d1w i 2 mul d1wo i get put</code>
<code>        d1w i 2 mul 1 add d1we i get put</code>
<code>    } for</code>
<code></code>
<code>    /d2w 14 array def</code>
<code>    0 1 6 {</code>
<code>        /i exch def</code>
<code>        d2w i 2 mul d2wo i get put</code>
<code>        d2w i 2 mul 1 add d2we i get put</code>
<code>    } for</code>
<code></code>
<code>    /widths [</code>
<code>        d1w {} forall</code>
<code>        d2w {} forall</code>
<code>    ] def</code>
<code></code>
<code>{</code>
<code>    /checkweights [</code>
<code>        1  3  9  27 81 65 17 51 64 14 42 37 22 66</code>
<code>        20 60 2  6  18 54 73 41 34 13 39 28 84 74</code>
<code>    ] def</code>
<code></code>
<code>    /checkseq [</code>
<code>        0 1 43 {} for</code>
<code>        45 52 57</code>
<code>        63 1 66 {} for</code>
<code>        73 1 79 {} for</code>
<code>        82</code>
<code>        126 1 130 {} for</code>
<code>        132</code>
<code>        141 1 146 {} for</code>
<code>        210 1 217 {} for</code>
<code>        220</code>
<code>        316 1 320 {} for</code>
<code>        322 323</code>
<code>        326 337</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /checksum 0 def</code>
<code>    0 1 27 {</code>
<code>        /i exch def</code>
<code>        /checksum checksum widths i get checkweights i get mul add def</code>
<code>    } for</code>
<code>    /checksum checksum 89 mod def</code>
<code>    /seq checkseq checksum get def</code>
<code>    /swidths seq 21 idiv 8 3 6 false getRSSwidths def</code>
<code>    /bwidths seq 21 mod  8 3 6 false getRSSwidths def</code>
<code></code>
<code>    /checkwidths [0 0 0 0 0 0 0 0 0 0 0 0 1 1] def</code>
<code>    0 1 5 {</code>
<code>        /i exch def</code>
<code>        checkwidths i 2 mul swidths i get put</code>
<code>        checkwidths i 2 mul 1 add bwidths i get put</code>
<code>    } for</code>
<code></code>
<code>    /sbs [</code>
<code>        1 d1w {} forall checkwidths {} forall d2w {} forall 1 1 5</code>
<code>    ] def</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs sbs</code>
<code>    /bhs [sbs length 1 add 2 idiv {height} repeat]</code>
<code>    /bbs [sbs length 1 add 2 idiv {0} repeat]</code>
<code>    /txt txt</code>
<code>    /textxalign (center)</code>
<code>    /borderleft 0.0</code>
<code>    /borderright 0.0</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /databarlimited dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER databarlimited--</code>
<code></code>
<code>% --BEGIN ENCODER databarexpanded--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renlinear renmatrix--</code>
<code>% --DESC: GS1 DataBar Expanded</code>
<code>% --EXAM: (01)09521234543213(3103)000123</code>
<code>% --EXOP:</code>
<code>% --RNDR: renlinear renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp databarexpanded 0.0 2024010300 248343 246629</code>
<code>%%BeginData:        864 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/databarexpanded {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs true def</code>
<code>    /dontdraw false def</code>
<code>    /height 34.0 72 div def</code>
<code>    /format (expanded) def</code>
<code>    /segments -1 def</code>
<code>    /linkage false def</code>
<code>    /barxmult 34 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /databarexpanded //loadctx exec</code>
<code></code>
<code>    barxmult 34 lt {</code>
<code>        /bwipp.databarStackedOmniBarXmult (GS1 DataBar Expanded Stacked must have a barxmult of at least 34) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    format (expanded) ne format (expandedstacked) ne and {</code>
<code>        /bwipp.databarexpandedBadFormat (Valid formats are expanded and expandedstacked) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    segments -1 eq {</code>
<code>        /segments format (expandedstacked) eq {4} {22} ifelse def</code>
<code>    } {</code>
<code>        segments 2 lt segments 22 gt or segments 2 mod 0 ne or {</code>
<code>            /bwipp.gs1databarexpandedBadSegments (The number of segments must be even from 2 to 22) //raiseerror exec</code>
<code>        } if</code>
<code>    } ifelse</code>
<code></code>
<code>    barcode /ai //gs1process exec</code>
<code>    /fncs exch def</code>
<code>    /vals exch def</code>
<code>    /ais exch def</code>
<code></code>
<code>    % Method selection</code>
<code>    {  % common exit</code>
<code></code>
<code>        % (01)9...(3103)...</code>
<code>        ais length 2 eq {</code>
<code>            ais 0 get (01) eq ais 1 get (3103) eq and {</code>
<code>                vals 0 get 0 1 getinterval (9) eq vals 1 get cvi 32767 le and {</code>
<code>                   (0100) false exit</code>
<code>                } if</code>
<code>            } if</code>
<code>        } if</code>
<code></code>
<code>        % (01)9...(3202)...</code>
<code>        ais length 2 eq {</code>
<code>            ais 0 get (01) eq ais 1 get (3202) eq and {</code>
<code>                vals 0 get 0 1 getinterval (9) eq vals 1 get cvi 9999 le and {</code>
<code>                    (0101) false exit</code>
<code>                } if</code>
<code>            } if</code>
<code>        } if</code>
<code></code>
<code>        % (01)9...(3203)...</code>
<code>        ais length 2 eq {</code>
<code>            ais 0 get (01) eq ais 1 get (3203) eq and {</code>
<code>                vals 0 get 0 1 getinterval (9) eq vals 1 get cvi 22767 le and {</code>
<code>                    (0101) false exit</code>
<code>                } if</code>
<code>            } if</code>
<code>        } if</code>
<code></code>
<code>        % (01)9...(310x/320x)...[(11/13/15/17)...]</code>
<code>        ais length dup 2 eq exch 3 eq or {</code>
<code>           /ai310x false 3100 1 3109 {10 4 string cvrs ais 1 get eq or} for def</code>
<code>           /ai320x false 3200 1 3209 {10 4 string cvrs ais 1 get eq or} for def</code>
<code>           ais length 3 eq {</code>
<code>               /aibad true [ (11) (13) (15) (17) ] {ais 2 get ne and} forall def</code>
<code>           } {</code>
<code>               /aibad false def</code>
<code>           } ifelse</code>
<code>           ais 0 get (01) eq ai310x ai320x or and aibad not and {</code>
<code>               ais length 3 eq {</code>
<code>                   vals 0 get 0 1 getinterval (9) eq</code>
<code>                   vals 1 get cvi 99999 le and</code>
<code>                   vals 2 get 2 2 getinterval cvi dup 1 ge exch 12 le and and  % Month 1-12</code>
<code>                   vals 2 get 4 2 getinterval cvi dup 0 ge exch 31 le and and {  % Day 0-31</code>
<code>                       ai310x ais 2 get (11) eq and { (0111000) false exit } if</code>
<code>                       ai320x ais 2 get (11) eq and { (0111001) false exit } if</code>
<code>                       ai310x ais 2 get (13) eq and { (0111010) false exit } if</code>
<code>                       ai320x ais 2 get (13) eq and { (0111011) false exit } if</code>
<code>                       ai310x ais 2 get (15) eq and { (0111100) false exit } if</code>
<code>                       ai320x ais 2 get (15) eq and { (0111101) false exit } if</code>
<code>                       ai310x ais 2 get (17) eq and { (0111110) false exit } if</code>
<code>                       ai320x ais 2 get (17) eq and { (0111111) false exit } if</code>
<code>                   } if</code>
<code>               } {</code>
<code>                   vals 0 get 0 1 getinterval (9) eq</code>
<code>                   vals 1 get cvi 99999 le and {</code>
<code>                       ai310x { (0111000) false exit } if</code>
<code>                       ai320x { (0111001) false exit } if</code>
<code>                   } if</code>
<code>               } ifelse</code>
<code>           } if</code>
<code>        } if</code>
<code></code>
<code>        % (01)9...(392x)...</code>
<code>        ais length 2 ge {</code>
<code>            /ai392x false 3920 1 3923 {10 4 string cvrs ais 1 get eq or} for def</code>
<code>            ais 0 get (01) eq ai392x and {</code>
<code>                vals 0 get 0 1 getinterval (9) eq { (01100) true exit } if</code>
<code>            } if</code>
<code>        } if</code>
<code></code>
<code>        % (01)9...(393x)...</code>
<code>        ais length 2 ge {</code>
<code>            /ai393x false 3930 1 3933 {10 4 string cvrs ais 1 get eq or} for def</code>
<code>            ais 0 get (01) eq ai393x and {</code>
<code>                vals 0 get 0 1 getinterval (9) eq { (01101) true exit } if</code>
<code>            } if</code>
<code>        } if</code>
<code></code>
<code>        % (01)...</code>
<code>        ais 0 get (01) eq { (1) true exit } if</code>
<code></code>
<code>        % Freeform</code>
<code>        (00) true exit</code>
<code></code>
<code>    } loop</code>
<code>    /gpfallow exch def</code>
<code>    /method exch def</code>
<code></code>
<code>    /conv12to40 {</code>
<code>        (0000000000000000000000000000000000000000) 40 string copy</code>
<code>        2 copy  0 10 getinterval exch 0 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval</code>
<code>        2 copy 10 10 getinterval exch 3 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval</code>
<code>        2 copy 20 10 getinterval exch 6 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval</code>
<code>        2 copy 30 10 getinterval exch 9 3 getinterval cvi 2 10 string cvrs dup length 10 exch sub exch putinterval</code>
<code>        exch pop</code>
<code>    } def</code>
<code></code>
<code>    /conv13to44 {</code>
<code>        (00000000000000000000000000000000000000000000) 44 string copy</code>
<code>        2 copy 0 4 getinterval exch 0 1 getinterval cvi 2 4 string cvrs dup length 4 exch sub exch putinterval</code>
<code>        dup 3 -1 roll 1 12 getinterval conv12to40 4 exch putinterval</code>
<code>    } def</code>
<code></code>
<code>    /tobin {</code>
<code>        string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for</code>
<code>        dup 3 -1 roll 2 2 index length string cvrs dup length 2 index length exch sub exch putinterval</code>
<code>    } def</code>
<code></code>
<code>    /fnc1 -1 def /lnumeric -2 def /lalphanumeric -3 def /liso646 -4 def</code>
<code></code>
<code>    method (00) eq {</code>
<code>        /cdf [] def</code>
<code>        /gpf [] def</code>
<code>    } if</code>
<code></code>
<code>    method (1) eq {</code>
<code>        /cdf vals 0 get 0 13 getinterval conv13to44 def</code>
<code>        /cdf [ cdf {48 sub} forall ] def</code>
<code>        /gpf [] def</code>
<code>        /ais  ais  1 ais  length 1 sub getinterval def</code>
<code>        /vals vals 1 vals length 1 sub getinterval def</code>
<code>        /fncs fncs 1 fncs length 1 sub getinterval def</code>
<code>    } if</code>
<code></code>
<code>    method (0100) eq {</code>
<code>        /cdf 55 string def</code>
<code>        cdf  0 vals 0 get 1 12 getinterval conv12to40 putinterval</code>
<code>        cdf 40 vals 1 get cvi 15 tobin putinterval</code>
<code>        /cdf [ cdf {48 sub} forall ] def</code>
<code>        /gpf [] def</code>
<code>        /ais [] def</code>
<code>        /vals [] def</code>
<code>        /fncs [] def</code>
<code>    } if</code>
<code></code>
<code>    method (0101) eq {</code>
<code>        /cdf 55 string def</code>
<code>        cdf 0 vals 0 get 1 12 getinterval conv12to40 putinterval</code>
<code>        ais 1 get (3202) eq {</code>
<code>            vals 1 get cvi 15 tobin</code>
<code>        } {</code>
<code>            vals 1 get cvi 10000 add 15 tobin</code>
<code>        } ifelse</code>
<code>        cdf exch 40 exch putinterval</code>
<code>        /cdf [ cdf {48 sub} forall ] def</code>
<code>        /gpf [] def</code>
<code>        /ais [] def</code>
<code>        /vals [] def</code>
<code>        /fncs [] def</code>
<code>    } if</code>
<code></code>
<code>    method length 7 eq {</code>
<code>        /cdf 76 string def</code>
<code>        cdf 0 vals 0 get 1 12 getinterval conv12to40 putinterval</code>
<code>        6 string dup 0 ais 1 get 3 1 getinterval putinterval</code>
<code>        dup vals 1 get 1 5 getinterval 1 exch putinterval cvi 20 tobin</code>
<code>        cdf exch 40 exch putinterval</code>
<code>        ais length 3 eq {</code>
<code>            vals 2 get</code>
<code>            dup 0 2 getinterval cvi 384 mul exch</code>
<code>            dup 2 2 getinterval cvi 1 sub 32 mul exch</code>
<code>            4 2 getinterval cvi add add</code>
<code>        } {</code>
<code>            38400</code>
<code>        } ifelse</code>
<code>        16 tobin cdf exch 60 exch putinterval</code>
<code>        /cdf [ cdf {48 sub} forall ] def</code>
<code>        /gpf [] def</code>
<code>        /ais [] def</code>
<code>        /vals [] def</code>
<code>        /fncs [] def</code>
<code>    } if</code>
<code></code>
<code>    method (01100) eq {</code>
<code>        /cdf 42 string def</code>
<code>        cdf  0 vals 0 get 1 12 getinterval conv12to40 putinterval</code>
<code>        cdf 40 ais  1 get 3  1 getinterval cvi 2 tobin putinterval</code>
<code>        /cdf [ cdf {48 sub} forall ] def</code>
<code>        /gpf [ vals 1 get {} forall ais length 2 gt { fnc1 } if ] def</code>
<code>        /ais  ais  2 ais  length 2 sub getinterval def</code>
<code>        /vals vals 2 vals length 2 sub getinterval def</code>
<code>        /fncs fncs 2 fncs length 2 sub getinterval def</code>
<code>    } if</code>
<code></code>
<code>    method (01101) eq {</code>
<code>        /cdf 52 string def</code>
<code>        cdf  0 vals 0 get 1 12 getinterval conv12to40 putinterval</code>
<code>        cdf 40 ais  1 get 3  1 getinterval cvi 2 tobin putinterval</code>
<code>        cdf 42 vals 1 get 0  3 getinterval cvi 10 tobin putinterval</code>
<code>        /cdf [ cdf {48 sub} forall ] def</code>
<code>        /gpf [ vals 1 get dup length 3 sub 3 exch getinterval {} forall ais length 2 gt { fnc1 } if ] def</code>
<code>        /ais  ais  2 ais  length 2 sub getinterval def</code>
<code>        /vals vals 2 vals length 2 sub getinterval def</code>
<code>        /fncs fncs 2 fncs length 2 sub getinterval def</code>
<code>    } if</code>
<code></code>
<code>    % Variable length symbol field</code>
<code>    gpfallow {</code>
<code>        /vlf 2 array def</code>
<code>    } {</code>
<code>        /vlf [] def</code>
<code>    } ifelse</code>
<code></code>
<code>{</code>
<code>    /numeric &lt;&lt;</code>
<code>        0 1 119 {</code>
<code>            dup (00) 2 string copy dup 3 -1 roll 11 2 string cvrs</code>
<code>            dup length 2 exch sub exch putinterval</code>
<code>            dup 0 get 65 eq {dup 0 94 put} if</code>
<code>            dup 1 get 65 eq {dup 1 94 put} if</code>
<code>            exch 8 add</code>
<code>            (0000000) 7 string copy dup 3 -1 roll 2 7 string cvrs</code>
<code>            dup length 7 exch sub exch putinterval</code>
<code>        } for</code>
<code>        lalphanumeric (0000)</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /alphanumeric &lt;&lt;</code>
<code>        48 1 57 {dup 43 sub 5 tobin} for</code>
<code>        fnc1 (01111)</code>
<code>        65 1 90 {dup 33 sub 6 tobin} for</code>
<code>        42 (111010)</code>
<code>        44 1 47 {dup 15 add 6 tobin} for</code>
<code>        lnumeric (000)</code>
<code>        liso646 (00100)</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /iso646 &lt;&lt;</code>
<code>        48 1 57 {dup 43 sub 5 tobin} for</code>
<code>        fnc1 (01111)</code>
<code>        65 1 90 {dup 1 sub 7 tobin} for</code>
<code>        97 1 122 {dup 7 sub 7 tobin} for</code>
<code>        33 (11101000)</code>
<code>        34 (11101001)</code>
<code>        37 1 47 {dup 197 add 8 tobin} for</code>
<code>        58 1 63 {dup 187 add 8 tobin} for</code>
<code>        95 (11111011)</code>
<code>        32 (11111100)</code>
<code>        lnumeric (000)</code>
<code>        lalphanumeric (00100)</code>
<code>    &gt;&gt; def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Append the remaining AI data</code>
<code>    0 1 ais length 1 sub {</code>
<code>        /i exch def</code>
<code>        /ai ais i get def</code>
<code>        /val vals i get def</code>
<code>        gpf length ai length add val length add array</code>
<code>        dup 0 gpf putinterval</code>
<code>        dup gpf length ai [ exch {} forall ] putinterval</code>
<code>        dup gpf length ai length add val [ exch {} forall ] putinterval</code>
<code>        /gpf exch def</code>
<code>        i ais length 1 sub ne fncs i get and {  % Append FNC1</code>
<code>            gpf length 1 add array</code>
<code>            dup 0 gpf putinterval</code>
<code>            dup gpf length fnc1 put</code>
<code>            /gpf exch def</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    % Calculate the number of bits remaining to the next valid symbol size</code>
<code>    /rembits {</code>
<code>        dup</code>
<code>        12 div ceiling cvi 12 mul            % Round up to multiple of 12</code>
<code>        48 2 copy lt {exch} if pop           % At least 4 symbols</code>
<code>        dup 12 idiv dup segments mod 1 eq {  % At least 2 symbols on last row of stacked symbol</code>
<code>            1 add 12 mul exch pop</code>
<code>        } {</code>
<code>            pop</code>
<code>        } ifelse</code>
<code>        exch sub</code>
<code>    } def</code>
<code></code>
<code>    /encode {</code>
<code>        dup /raw ne {exch get} {pop} ifelse</code>
<code>        dup length j add 252 ge {</code>
<code>            pop /bwipp.gs1databarexpandedTooLong (Maximum length exceeded) //raiseerror exec</code>
<code>        } if</code>
<code>        [ exch {48 sub} forall ]</code>
<code>        dup length exch</code>
<code>        gpfenc exch j exch putinterval</code>
<code>        /j exch j add def</code>
<code>    } def</code>
<code></code>
<code>    % Pre-compute alphanumeric and numeric runlengths and position of next ISO646-only characters</code>
<code>    /numericruns [ gpf length {0} repeat 0 -1 ] def</code>
<code>    /alphanumericruns [ gpf length {0} repeat 0 ] def</code>
<code>    /nextiso646only [ gpf length {0} repeat 9999 ] def</code>
<code>    gpf length 1 sub -1 0 {</code>
<code>        /i exch def</code>
<code>        gpf i get</code>
<code>        (00) 2 string copy</code>
<code>        dup 0 gpf i get dup fnc1 eq {pop 94} if put</code>
<code>        i gpf length 1 sub lt {dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put} if</code>
<code>        numeric exch known {</code>
<code>            numericruns i numericruns i 2 add get 2 add put</code>
<code>        } {</code>
<code>            numericruns i 0 put</code>
<code>        } ifelse</code>
<code>        dup alphanumeric exch known {</code>
<code>            alphanumericruns i alphanumericruns i 1 add get 1 add put</code>
<code>        } {</code>
<code>            alphanumericruns i 0 put</code>
<code>        } ifelse</code>
<code>        dup iso646 exch known exch alphanumeric exch known not and {</code>
<code>            nextiso646only i 0 put</code>
<code>        } {</code>
<code>            nextiso646only i nextiso646only i 1 add get 1 add put</code>
<code>        } ifelse</code>
<code>    } for</code>
<code></code>
<code>    % Encode the general purpose field</code>
<code>    /gpfenc 252 array def</code>
<code>    /i 0 def /j 0 def /mode (numeric) def</code>
<code>    {  % loop</code>
<code>        i gpf length eq {exit} if</code>
<code>        {  % not a loop but common exit point</code>
<code></code>
<code>            mode (numeric) eq {</code>
<code>                i gpf length 2 sub le {</code>
<code>                    2 string</code>
<code>                    dup 0 gpf i get dup fnc1 eq {pop 94} if put</code>
<code>                    dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put</code>
<code>                    dup numeric exch known {</code>
<code>                        numeric encode</code>
<code>                        /i i 2 add def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    pop</code>
<code>                    lalphanumeric numeric encode</code>
<code>                    /mode (alphanumeric) def</code>
<code>                    exit</code>
<code>                } {</code>
<code>                    gpf i get dup 48 lt exch 57 gt or {</code>
<code>                        lalphanumeric numeric encode</code>
<code>                        /mode (alphanumeric) def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    /rem 12 1 add method length add vlf length add cdf length add j add rembits def</code>
<code>                    rem 4 ge rem 6 le and {  % C1 + 1 into 4 to 6 bits</code>
<code>                        (000000) 6 string copy 0 rem getinterval</code>
<code>                        dup gpf i get 47 sub 2 4 string cvrs</code>
<code>                        dup length 4 exch sub exch putinterval /raw encode</code>
<code>                        /i i 1 add def</code>
<code>                        exit</code>
<code>                    } {  % C1.FNC1</code>
<code>                        2 string dup 0 gpf i get put dup 1 94 put numeric encode</code>
<code>                        /i i 1 add def</code>
<code>                        exit</code>
<code>                    } ifelse</code>
<code>                } ifelse</code>
<code>            } if</code>
<code></code>
<code>            mode (alphanumeric) eq {</code>
<code>                gpf i get fnc1 eq {</code>
<code>                    fnc1 alphanumeric encode</code>
<code>                    /mode (numeric) def</code>
<code>                    /i i 1 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                gpf i get dup iso646 exch known exch alphanumeric exch known not and {</code>
<code>                     liso646 alphanumeric encode</code>
<code>                     /mode (iso646) def</code>
<code>                     exit</code>
<code>                } if</code>
<code>                numericruns i get 6 ge {</code>
<code>                    lnumeric alphanumeric encode</code>
<code>                    /mode (numeric) def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                numericruns i get dup 4 ge exch i add gpf length eq and {</code>
<code>                    lnumeric alphanumeric encode</code>
<code>                    /mode (numeric) def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                gpf i get alphanumeric encode</code>
<code>                /i i 1 add def</code>
<code>                exit</code>
<code>            } if</code>
<code></code>
<code>            mode (iso646) eq {</code>
<code>                gpf i get fnc1 eq {</code>
<code>                    fnc1 iso646 encode</code>
<code>                    /mode (numeric) def</code>
<code>                    /i i 1 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                numericruns i get 4 ge nextiso646only i get 10 ge and {</code>
<code>                    lnumeric iso646 encode</code>
<code>                    /mode (numeric) def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                alphanumericruns i get 5 ge nextiso646only i get 10 ge and {</code>
<code>                    lalphanumeric iso646 encode</code>
<code>                    /mode (alphanumeric) def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                gpf i get iso646 encode</code>
<code>                /i i 1 add def</code>
<code>                exit</code>
<code>            } if</code>
<code></code>
<code>        } loop</code>
<code>    } loop</code>
<code>    /gpf gpfenc 0 j getinterval def</code>
<code></code>
<code>    % Complete the variable length field and create pad</code>
<code>    1 12 add method length add vlf length add cdf length add gpf length add</code>
<code>    dup rembits dup array /pad exch def</code>
<code>    vlf length 0 ne {</code>
<code>        add 12 idiv</code>
<code>        dup 2 mod vlf exch 0 exch put</code>
<code>        14 le {0} {1} ifelse vlf exch 1 exch put</code>
<code>    } {</code>
<code>        pop pop</code>
<code>    } ifelse</code>
<code>    pad length 0 gt {</code>
<code>        0 5 pad length 1 sub {  % Fill with 00100</code>
<code>            /i exch def</code>
<code>            pad i [ 0 0 1 0 0 ] 0 pad length i sub 5 2 copy gt {exch} if pop getinterval putinterval</code>
<code>        } for</code>
<code>        mode (numeric) eq {  % Prefix shift from numeric to ASCII</code>
<code>            /pad [ 0 0 0 0 pad aload pop ] 0 pad length getinterval def</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    % Concatenate fields</code>
<code>    /binval [</code>
<code>        linkage {1} {0} ifelse</code>
<code>        method {48 sub} forall</code>
<code>        vlf aload pop</code>
<code>        cdf aload pop</code>
<code>        gpf aload pop</code>
<code>        pad aload pop</code>
<code>    ] def</code>
<code>    /datalen binval length 12 idiv def</code>
<code></code>
<code>    /ncr {  % n r</code>
<code>        2 copy sub 2 copy lt {exch} if  % n r maxd mind</code>
<code>        1 1 5 3 roll  % mind j=1 v=1 n maxd</code>
<code>        1 add -1 exch {  % mind j v  n -1 maxd+1</code>
<code>            mul  % mind j v*i</code>
<code>            1 index 3 index le {</code>
<code>                1 index idiv exch 1 add exch</code>
<code>            } if</code>
<code>        } for</code>
<code>        {  % mind j v</code>
<code>            1 index 3 index gt {exit} if</code>
<code>            1 index idiv exch 1 add exch</code>
<code>        } loop</code>
<code>        exch pop exch pop</code>
<code>    } def</code>
<code></code>
<code>    /getRSSwidths {</code>
<code>        /oe exch def</code>
<code>        /el exch def</code>
<code>        /mw exch def</code>
<code>        /nm exch def</code>
<code>        /val exch def</code>
<code>        /out el array def</code>
<code>        /mask 0 def</code>
<code>        0 1 el 2 sub {</code>
<code>            /bar exch def</code>
<code>            /ew 1 def</code>
<code>            /mask mask 1 bar bitshift or def {</code>
<code>                /sval nm ew sub 1 sub el bar sub 2 sub ncr def</code>
<code>                oe mask 0 eq and nm ew sub el 2 mul sub bar 2 mul add -2 ge and {</code>
<code>                    /sval sval nm ew sub el sub bar add el bar sub 2 sub ncr sub def</code>
<code>                } if</code>
<code>                el bar sub 2 gt {</code>
<code>                    /lval 0 def</code>
<code>                    nm ew sub el sub bar add 2 add -1 mw 1 add {</code>
<code>                        nm exch sub ew sub 1 sub el bar sub 3 sub ncr</code>
<code>                        /lval exch lval add def</code>
<code>                    } for</code>
<code>                    /sval sval lval el bar sub 1 sub mul sub def</code>
<code>                } {</code>
<code>                    nm ew sub mw gt {/sval sval 1 sub def} if</code>
<code>                } ifelse</code>
<code>                /val val sval sub def</code>
<code>                val 0 lt {exit} if</code>
<code>                /ew ew 1 add def</code>
<code>                /mask mask 1 bar bitshift not and def</code>
<code>            } loop</code>
<code>            /val val sval add def</code>
<code>            /nm nm ew sub def</code>
<code>            out bar ew put</code>
<code>        } for</code>
<code>        out el 1 sub nm put</code>
<code>        out</code>
<code>    } def</code>
<code></code>
<code>{</code>
<code>    /tab174 [</code>
<code>        347   0     12 5   7 2  87  4</code>
<code>        1387  348   10 7   5 4  52  20</code>
<code>        2947  1388  8  9   4 5  30  52</code>
<code>        3987  2948  6  11  3 6  10  104</code>
<code>        4191  3988  4  13  1 8  1   204</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /dxw datalen array def</code>
<code></code>
<code>    0 1 datalen 1 sub {</code>
<code></code>
<code>        /x exch def</code>
<code></code>
<code>        /d binval x 12 mul 12 getinterval def</code>
<code>        /d 0 0 1 11 {/j exch def 2 11 j sub exp cvi d j get mul add} for def</code>
<code></code>
<code>        /j 0 def {</code>
<code>            d tab174 j get le {</code>
<code>                tab174 j 1 add 7 getinterval {} forall</code>
<code>                /dte exch def /dto exch def</code>
<code>                /dmwe exch def /dmwo exch def</code>
<code>                /dele exch def /delo exch def</code>
<code>                /dgs exch def</code>
<code>                exit</code>
<code>            } if</code>
<code>            /j j 8 add def</code>
<code>        } loop</code>
<code></code>
<code>        /dwo d dgs sub dte idiv delo dmwo 4 true  getRSSwidths def</code>
<code>        /dwe d dgs sub dte mod  dele dmwe 4 false getRSSwidths def</code>
<code></code>
<code>        /dw 8 array def</code>
<code>        x 2 mod 0 eq {</code>
<code>            0 1 3 {</code>
<code>                /j exch def</code>
<code>                dw 7 j 2 mul sub dwo j get put</code>
<code>                dw 6 j 2 mul sub dwe j get put</code>
<code>            } for</code>
<code>        } {</code>
<code>            0 1 3 {</code>
<code>                /j exch def</code>
<code>                dw j 2 mul dwo j get put</code>
<code>                dw j 2 mul 1 add dwe j get put</code>
<code>            } for</code>
<code>        } ifelse</code>
<code></code>
<code>        dxw x dw put</code>
<code></code>
<code>    } for</code>
<code></code>
<code>{</code>
<code>    /finderwidths [</code>
<code>        1 8 4 1 1    1 1 4 8 1</code>
<code>        3 6 4 1 1    1 1 4 6 3</code>
<code>        3 4 6 1 1    1 1 6 4 3</code>
<code>        3 2 8 1 1    1 1 8 2 3</code>
<code>        2 6 5 1 1    1 1 5 6 2</code>
<code>        2 2 9 1 1    1 1 9 2 2</code>
<code>    ] def</code>
<code></code>
<code>    /finderseq [</code>
<code>        [0 1]</code>
<code>        [0 3 2]</code>
<code>        [0 5 2 7]</code>
<code>        [0 9 2 7 4]</code>
<code>        [0 9 2 7 6 11]</code>
<code>        [0 9 2 7 8 11 10]</code>
<code>        [0 1 2 3 4 5 6 7]</code>
<code>        [0 1 2 3 4 5 6 9 8]</code>
<code>        [0 1 2 3 4 5 6 9 10 11]</code>
<code>        [0 1 2 3 4 7 6 9 8 11 10]</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /seq finderseq datalen 2 sub 2 idiv get def</code>
<code>    /fxw seq length array def</code>
<code>    0 1 seq length 1 sub {</code>
<code>        /x exch def</code>
<code>        fxw x finderwidths seq x get 5 mul 5 getinterval put</code>
<code>    } for</code>
<code></code>
<code>{</code>
<code>    /checkweights [</code>
<code>        -1   -1   -1   -1   -1   -1   -1   -1   % A1L</code>
<code>        77   96   32   81   27   9    3    1    % A1R</code>
<code>        20   60   180  118  143  7    21   63   % A2L</code>
<code>        205  209  140  117  39   13   145  189  % A2R</code>
<code>        193  157  49   147  19   57   171  91   % B1L</code>
<code>        132  44   85   169  197  136  186  62   % B1R</code>
<code>        185  133  188  142  4    12   36   108  % B2L</code>
<code>        50   87   29   80   97   173  128  113  % B2R</code>
<code>        150  28   84   41   123  158  52   156  % C1L</code>
<code>        166  196  206  139  187  203  138  46   % C1R</code>
<code>        76   17   51   153  37   111  122  155  % C2L</code>
<code>        146  119  110  107  106  176  129  43   % C2R</code>
<code>        16   48   144  10   30   90   59   177  % D1L</code>
<code>        164  125  112  178  200  137  116  109  % D1R</code>
<code>        70   210  208  202  184  130  179  115  % D2L</code>
<code>        190  204  68   93   31   151  191  134  % D2R</code>
<code>        148  22   66   198  172  94   71   2    % E1L</code>
<code>        40   154  192  64   162  54   18   6    % E1R</code>
<code>        120  149  25   75   14   42   126  167  % E2L</code>
<code>        175  199  207  69   23   78   26   79   % E2R</code>
<code>        103  98   83   38   114  131  182  124  % F1L</code>
<code>        159  53   88   170  127  183  61   161  % F1R</code>
<code>        55   165  73   8    24   72   5    15   % F2L</code>
<code>        89   100  174  58   160  194  135  45   % F2R</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /checkweightseq [</code>
<code>       seq {16 mul checkweights exch 16 getinterval aload pop} forall</code>
<code>    ] dup length 8 sub 8 exch getinterval def</code>
<code></code>
<code>    /widths [</code>
<code>        dxw {{} forall} forall</code>
<code>    ] def</code>
<code></code>
<code>    /checksum 0 def</code>
<code>    0 1 widths length 1 sub {</code>
<code>        /i exch def</code>
<code>        /checksum checksum widths i get checkweightseq i get mul add def</code>
<code>    } for</code>
<code>    /checksum checksum 211 mod datalen 3 sub 211 mul add def</code>
<code></code>
<code>    /i 0 def {</code>
<code>        checksum tab174 i get le {</code>
<code>            tab174 i 1 add 7 getinterval {} forall</code>
<code>            /cte exch def /cto exch def</code>
<code>            /cmwe exch def /cmwo exch def</code>
<code>            /cele exch def /celo exch def</code>
<code>            /cgs exch def</code>
<code>            exit</code>
<code>        } if</code>
<code>        /i i 8 add def</code>
<code>    } loop</code>
<code></code>
<code>    /cwo checksum cgs sub cte idiv celo cmwo 4 true  getRSSwidths def</code>
<code>    /cwe checksum cgs sub cte mod  cele cmwe 4 false getRSSwidths def</code>
<code></code>
<code>    /cw 8 array def</code>
<code>    0 1 3 {</code>
<code>        /i exch def</code>
<code>        cw i 2 mul cwo i get put</code>
<code>        cw i 2 mul 1 add cwe i get put</code>
<code>    } for</code>
<code></code>
<code>    22 array dup dup</code>
<code>    0 cw put 1 dxw putinterval 0 datalen 1 add getinterval</code>
<code>    /dxw exch def</code>
<code>    /datalen dxw length def</code>
<code></code>
<code>    % Encode row runlengths</code>
<code>    /rows datalen segments div ceiling cvi array def</code>
<code>    /numrows rows length def</code>
<code>    0 1 numrows 1 sub {</code>
<code>        /r exch def</code>
<code>        mark</code>
<code>        segments 4 mod 0 ne r 2 mod 1 eq and {0} if</code>
<code>        1 1</code>
<code>        0 1 segments 1 sub {</code>
<code>            /pos exch r segments mul add def</code>
<code>            pos datalen lt {</code>
<code>                dxw pos get {} forall</code>
<code>                pos 2 mod 0 eq {fxw pos 2 idiv get {} forall} if</code>
<code>            } if</code>
<code>        } for</code>
<code>        1 1</code>
<code>        counttomark array astore rows exch r exch put pop</code>
<code>    } for</code>
<code></code>
<code>    format (expandedstacked) ne {  % Linear</code>
<code></code>
<code>        % Remove leading space</code>
<code>        /sbs rows 0 get dup length 1 sub 1 exch getinterval def</code>
<code></code>
<code>        /sbs [</code>
<code>            1</code>
<code>            0 1 datalen 1 sub {</code>
<code>                /i exch def</code>
<code>                dxw i get {} forall</code>
<code>                i 2 mod 0 eq {fxw i 2 idiv get {} forall} if</code>
<code>            } for</code>
<code>            1 1</code>
<code>        ] def</code>
<code></code>
<code>        &lt;&lt;</code>
<code>        /ren //renlinear</code>
<code>        /sbs sbs</code>
<code>        /bhs [sbs length 1 add 2 idiv {height} repeat]</code>
<code>        /bbs [sbs length 1 add 2 idiv {0} repeat]</code>
<code>        /borderleft 0.0</code>
<code>        /borderright 0.0</code>
<code>        /bordertop 0.0</code>
<code>        /borderbottom 0.0</code>
<code>        /opt options</code>
<code>        &gt;&gt;</code>
<code></code>
<code>        dontdraw not //renlinear if</code>
<code></code>
<code>    } {  % expandedstacked</code>
<code></code>
<code>        /seps numrows array def</code>
<code>        0 1 numrows 1 sub {</code>
<code></code>
<code>            /r exch def</code>
<code>            /row rows r get def</code>
<code></code>
<code>            % Sample runlengths into bitmap</code>
<code>            mark</code>
<code>            0 2 row length 1 sub {</code>
<code>                /i exch def</code>
<code>                row i get {0} repeat</code>
<code>                i row length 1 sub lt {row i 1 add get {1} repeat} if</code>
<code>            } for</code>
<code>            counttomark array astore /row exch def pop</code>
<code></code>
<code>            % Derive the separator pattern</code>
<code>            /sep [ row {1 exch sub} forall ] def</code>
<code>            /finderpos [  % Finder pattern module positions</code>
<code>                19 98 row length 13 sub {} for</code>
<code>                68 98 row length 13 sub {} for</code>
<code>            ] def</code>
<code>            finderpos {</code>
<code>                dup 14 add 1 exch {</code>
<code>                    /i exch def</code>
<code>                    row i get 0 eq {</code>
<code>                        row i 1 sub get 1 eq {</code>
<code>                            1</code>
<code>                        } {</code>
<code>                            sep i 1 sub get 0 eq {1} {0} ifelse</code>
<code>                        } ifelse</code>
<code>                    } {</code>
<code>                        0</code>
<code>                    } ifelse</code>
<code>                    sep exch i exch put</code>
<code>                } for</code>
<code>            } forall</code>
<code>            sep 0 [ 0 0 0 0 ] putinterval</code>
<code>            sep row length 4 sub [ 0 0 0 0 ] putinterval</code>
<code></code>
<code>            % For even segment-pair symbols reverse alternate rows</code>
<code>            segments 4 mod 0 eq r 2 mod 1 eq and {</code>
<code>                rows r get length rows 0 get length ne  % Except partial width last row</code>
<code>                finderpos length 2 mod 1 eq and {       % with odd finders</code>
<code>                    /row [ 0 row aload pop ] def</code>
<code>                    /sep [ 0 sep aload pop ] def</code>
<code>                } {</code>
<code>                    row length 1 sub -1 0 {row exch get} for</code>
<code>                    row astore pop</code>
<code>                    sep length 1 sub -1 0 {sep exch get} for</code>
<code>                    sep astore pop</code>
<code>                } ifelse</code>
<code>            } if</code>
<code></code>
<code>            rows r row put</code>
<code>            seps r sep put</code>
<code></code>
<code>        } for</code>
<code></code>
<code>        % Extend last row and separator to fill width of symbol</code>
<code>        /pixx rows 0 get length def</code>
<code>        [ pixx {0} repeat ] dup 0 rows numrows 1 sub get putinterval</code>
<code>        rows exch numrows 1 sub exch put</code>
<code>        [ pixx {0} repeat ] dup 0 seps numrows 1 sub get putinterval</code>
<code>        seps exch numrows 1 sub exch put</code>
<code></code>
<code>        % Middle separator pattern</code>
<code>        /sep [ pixx 2 idiv 1 add { 0 1 } repeat ] 0 pixx getinterval def</code>
<code>        sep 0 [0 0 0 0] putinterval</code>
<code>        sep pixx 4 sub [0 0 0 0] putinterval</code>
<code></code>
<code>        % Compose the symbol</code>
<code>        /pixs [</code>
<code>            0 1 numrows 1 sub {</code>
<code>                /r exch def</code>
<code>                r 0 ne {</code>
<code>                    seps r get aload pop</code>
<code>                } if</code>
<code>                barxmult {rows r get aload pop} repeat</code>
<code>                r numrows 1 sub ne {</code>
<code>                    seps r get aload pop</code>
<code>                    sep aload pop</code>
<code>                } if</code>
<code>            } for</code>
<code>        ] def</code>
<code></code>
<code>        &lt;&lt;</code>
<code>        /ren //renmatrix</code>
<code>        /pixs pixs</code>
<code>        /pixx pixx</code>
<code>        /pixy pixs length pixx idiv</code>
<code>        /height pixs length pixx idiv 72 div</code>
<code>        /width pixx 72 div</code>
<code>        /borderleft 0.0</code>
<code>        /borderright 0.0</code>
<code>        /bordertop 0.0</code>
<code>        /borderbottom 0.0</code>
<code>        /opt options</code>
<code>        &gt;&gt;</code>
<code></code>
<code>        dontdraw not //renmatrix if</code>
<code></code>
<code>    } ifelse</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /databarexpanded dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER databarexpanded--</code>
<code></code>
<code>% --BEGIN ENCODER databarexpandedstacked--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renlinear renmatrix databarexpanded--</code>
<code>% --DESC: GS1 DataBar Expanded Stacked</code>
<code>% --EXAM: (01)09521234543213(3103)000123</code>
<code>% --EXOP: segments=4</code>
<code>% --RNDR: renlinear renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp databarexpandedstacked 0.0 2024010300 72851 72833</code>
<code>%%BeginData:         36 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /databarexpanded dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/databarexpandedstacked {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Get the result of encoding with databarexpanded with format=expandedstacked</code>
<code>    options (dontdraw) true put</code>
<code>    options (format) (expandedstacked) put</code>
<code></code>
<code>    /args barcode options //databarexpanded exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /databarexpandedstacked dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER databarexpandedstacked--</code>
<code></code>
<code>% --BEGIN ENCODER gs1northamericancoupon--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renlinear renmatrix databarexpanded databarexpandedstacked--</code>
<code>% --DESC: GS1 North American Coupon</code>
<code>% --EXAM: (8110)106141416543213500110000310123196000</code>
<code>% --EXOP: includetext segments=8</code>
<code>% --RNDR: renlinear renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp gs1northamericancoupon 0.0 2024010300 83739 86866</code>
<code>%%BeginData:         89 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /databarexpandedstacked dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/gs1northamericancoupon {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def  % Enable/disable coupon text</code>
<code>    /coupontextfont (OCR-B) def</code>
<code>    /coupontextsize 9.0 def</code>
<code>    /coupontextxoffset null def</code>
<code>    /coupontextyoffset null def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs true def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode /ai //gs1process exec</code>
<code>    pop</code>
<code>    /vals exch def</code>
<code>    /ais exch def</code>
<code></code>
<code>    % Validate the AI structure</code>
<code>    ais length 1 ne {</code>
<code>      /bwipp.gs1northamericancouponBadAIStructure (A GS1 North American Coupon should consist of a single AI (8110)) //raiseerror exec</code>
<code>    } if</code>
<code>    ais 0 get (8110) ne {</code>
<code>      /bwipp.gs1northamericancouponBadAIStructure (A GS1 North American Coupon should consist of a single AI (8110)) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Parse out the Company Prefix and Offer Code</code>
<code>    /val vals 0 get def</code>
<code>    /vli val 0 get 48 sub def</code>
<code>    vli 0 lt vli 6 gt or {</code>
<code>      /bwipp.gs1northamericancouponBadVLI (The AI (8110) data should start with a Company Prefix length indicator in the range 0 to 6) //raiseerror exec</code>
<code>    } if</code>
<code>    /gcp val 1 vli 6 add getinterval def</code>
<code>    /cod val vli 7 add 6 getinterval def</code>
<code>    /coupontext gcp length 7 add string def</code>
<code>    coupontext 0 gcp putinterval</code>
<code>    coupontext gcp length (-) putinterval</code>
<code>    coupontext gcp length 1 add cod putinterval</code>
<code></code>
<code>    % Get the result of encoding with databarexpandedstacked</code>
<code>    options (dontdraw) true put</code>
<code></code>
<code>    /args barcode options //databarexpandedstacked exec def</code>
<code></code>
<code>    % Add the coupon text</code>
<code>    includetext {</code>
<code>        coupontextxoffset null eq {</code>
<code>            /coupontextxoffset 0.0 def</code>
<code>        } if</code>
<code>        coupontextyoffset null eq {</code>
<code>            /coupontextyoffset args (height) get 72 mul 3 add def</code>
<code>        } if</code>
<code>        args (txt) known {</code>
<code>            /txt args (txt) get def</code>
<code>            /newtxt txt length 1 add array def</code>
<code>            newtxt 0 txt putinterval</code>
<code>            newtxt newtxt length 1 sub [coupontext coupontextxoffset coupontextyoffset coupontextfont coupontextsize] put</code>
<code>            args (txt) newtxt put</code>
<code>        } {</code>
<code>            args (txt) [ [coupontext coupontextxoffset coupontextyoffset coupontextfont coupontextsize] ] put</code>
<code>        } ifelse</code>
<code>    } if</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /gs1northamericancoupon dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER gs1northamericancoupon--</code>
<code></code>
<code>% --BEGIN ENCODER pharmacode--</code>
<code>% --REQUIRES preamble raiseerror processoptions renlinear--</code>
<code>% --DESC: Pharmaceutical Binary Code</code>
<code>% --EXAM: 117480</code>
<code>% --EXOP: showborder</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp pharmacode 0.0 2024010300 55259 54920</code>
<code>%%BeginData:         79 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/pharmacode {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /height 8.0 2.835 mul 72 div def</code>
<code>    /nwidth 0.5 2.835 mul def</code>
<code>    /wwidth 1.5 2.835 mul def</code>
<code>    /swidth 1.0 2.835 mul def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode length 1 lt barcode length 6 gt or {</code>
<code>        /bwipp.pharmacodeBadLength (Pharmacode must be 1 to 6 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.pharmacodeBadCharacter (Pharmacode must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code>    barcode cvi dup 3 lt exch 131070 gt or {</code>
<code>        /bwipp.pharmacodeBadValue (Pharmacode value must be between 3 and 131070) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Create the human readable text</code>
<code>    /txt barcode length array def</code>
<code>    0 1 barcode length 1 sub {</code>
<code>        /i exch def</code>
<code>        txt i [barcode i 1 getinterval 0 0 () 0] put</code>
<code>    } for</code>
<code></code>
<code>    % Convert the integer into the paramacode string</code>
<code>    /barcode barcode cvi 1 add 2 17 string cvrs def</code>
<code>    /barcode barcode 1 barcode length 1 sub getinterval def</code>
<code></code>
<code>    /barlen barcode length def  % Length of the code</code>
<code>    /sbs barlen 2 mul array def</code>
<code></code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        /enc barcode i 1 getinterval def</code>
<code>        enc (0) eq {</code>
<code>            sbs i 2 mul nwidth put</code>
<code>        } {</code>
<code>            sbs i 2 mul wwidth put</code>
<code>        } ifelse</code>
<code>        sbs i 2 mul 1 add swidth put</code>
<code>    } for</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs sbs</code>
<code>    /bhs [sbs length 1 add 2 idiv {height} repeat]</code>
<code>    /bbs [sbs length 1 add 2 idiv {0} repeat]</code>
<code>    /txt txt</code>
<code>    /textxalign (center)</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /pharmacode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER pharmacode--</code>
<code></code>
<code>% --BEGIN ENCODER pharmacode2--</code>
<code>% --REQUIRES preamble raiseerror processoptions renlinear--</code>
<code>% --DESC: Two-track Pharmacode</code>
<code>% --EXAM: 117480</code>
<code>% --EXOP: includetext showborder</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp pharmacode2 0.0 2024010300 56506 56298</code>
<code>%%BeginData:         87 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/pharmacode2 {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def      % Enable/disable text</code>
<code>    /height 4.0 def             % Height of short bars in millimetres</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode length 1 lt barcode length 8 gt or {</code>
<code>        /bwipp.pharmacode2BadLength (Two-track Pharmacode must be 1 to 6 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.pharmacode2badCharacter (Two-track Pharmacode must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code>    barcode cvi dup 4 lt exch 64570080 gt or {</code>
<code>        /bwipp.pharmacode2badValue (Two-track Pharmacode value must be between 4 and 64570080) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Create the human readable text</code>
<code>    /txt barcode length array def</code>
<code>    0 1 barcode length 1 sub {</code>
<code>        /i exch def</code>
<code>        txt i [barcode i 1 getinterval 0 0 () 0] put</code>
<code>    } for</code>
<code></code>
<code>    /encstr 16 string def</code>
<code>    /sbs 32 array def</code>
<code>    /bar 1 25.4 div height mul def     % bar height (mm)</code>
<code>    /spc 1 25.4 div 72 mul def         % bar width &amp; spacing (1mm)</code>
<code></code>
<code>    % Convert number into a base3 representation</code>
<code>    /i 15 def</code>
<code>    /val barcode cvi def</code>
<code>    {  % loop</code>
<code>        val 0 eq {exit} if</code>
<code>        val 3 mod dup</code>
<code>        [3 1 2] exch get val exch sub 3 idiv /val exch def</code>
<code>        encstr i [2 0 1] 4 -1 roll get put</code>
<code>        /i i 1 sub def</code>
<code>    } loop</code>
<code>    /encstr encstr i 1 add 15 i sub getinterval def</code>
<code></code>
<code>    % Generate the bar pattern</code>
<code>    /bhs encstr length array def</code>
<code>    /bbs encstr length array def</code>
<code>    0 1 encstr length 1 sub {</code>
<code>        /i exch def</code>
<code>        encstr i get dup</code>
<code>        bhs i bar [1 1 2] 5 -1 roll get mul put</code>
<code>        bbs i [0 bar 0] 4 -1 roll get put</code>
<code>    } for</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /bhs bhs</code>
<code>    /bbs bbs</code>
<code>    /sbs [encstr length 2 mul {spc} repeat]</code>
<code>    /txt txt</code>
<code>    /textxalign (center)</code>
<code>    /textyoffset 4.0</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /pharmacode2 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER pharmacode2--</code>
<code></code>
<code>% --BEGIN ENCODER code2of5--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear--</code>
<code>% --DESC: Code 25</code>
<code>% --EXAM: 01234567</code>
<code>% --EXOP: includetext includecheck includecheckintext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp code2of5 0.0 2024010300 73534 73053</code>
<code>%%BeginData:        154 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/code2of5 {</code>
<code></code>
<code>    20 dict begin                 % Confine variable to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includecheck false def</code>
<code>    /validatecheck false def</code>
<code>    /includetext false def   % Enable/disable text</code>
<code>    /includecheckintext false def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 1.0 def</code>
<code>    /version (industrial) def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.code2of5emptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /code2of5 //loadctx exec</code>
<code></code>
<code>    % Validate input</code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.code2of5badCharacter (Code 25 must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>    /barlen barcode length validatecheck {1 sub} if def</code>
<code></code>
<code>    /checksum 0 def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        /checksum checksum barcode i get 48 sub barlen i sub 2 mod 0 ne {3 mul} if add def</code>
<code>    } for</code>
<code>    /checksum 10 checksum 10 mod sub 10 mod def</code>
<code>    validatecheck {</code>
<code>        barcode barlen get checksum 48 add ne {</code>
<code>            /bwipp.code2of5badCheckDigit (Incorrect Code 25 check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>        /barcode barcode 0 barlen getinterval def</code>
<code>        /includecheck true def</code>
<code>    } if</code>
<code></code>
<code>    % Create an array containing the character mappings</code>
<code>{</code>
<code>    /versions &lt;&lt;</code>
<code>    /industrial</code>
<code>        [ (1111313111) (3111111131) (1131111131) (3131111111)</code>
<code>          (1111311131) (3111311111) (1131311111) (1111113131)</code>
<code>          (3111113111) (1131113111) (313111)     (31113)</code>
<code>        ]</code>
<code>    /iata</code>
<code>        [ (1111313111) (3111111131) (1131111131) (3131111111)</code>
<code>          (1111311131) (3111311111) (1131311111) (1111113131)</code>
<code>          (3111113111) (1131113111) (1111)       (311)</code>
<code>        ]</code>
<code>    /matrix</code>
<code>        [ (113311) (311131) (131131) (331111) (113131) (313111)</code>
<code>          (133111) (111331) (311311) (131311) (311111) (31111)</code>
<code>        ]</code>
<code>    /coop</code>
<code>        [ (331111) (111331) (113131) (113311) (131131) (131311)</code>
<code>          (133111) (311131) (311311) (313111) (3131)   (133)</code>
<code>        ]</code>
<code>    /datalogic</code>
<code>        [ (113311) (311131) (131131) (331111) (113131) (313111)</code>
<code>          (133111) (111331) (311311) (131311) (1111)   (311)</code>
<code>        ]</code>
<code>    &gt;&gt; def</code>
<code>} ctxdef</code>
<code></code>
<code>    versions version known not {</code>
<code>        /bwipp.code2of5badVersion (Unrecognised Code 25 version) //raiseerror exec</code>
<code>    } if</code>
<code>    /encs versions version get def</code>
<code></code>
<code>    /cs encs 0 get length def</code>
<code>    /cw 0 encs 0 get {48 sub add} forall def</code>
<code>    /ss encs 10 get length def</code>
<code>    /sw 0 encs 10 get {48 sub add} forall def</code>
<code>    /es encs 11 get length def</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>{</code>
<code>    /barchars (0123456789) def</code>
<code>} ctxdef</code>
<code></code>
<code>    /sbs barlen includecheck {1 add} if cs mul ss add es add string def</code>
<code>    /txt barlen includecheck {1 add} if array def</code>
<code></code>
<code>    % Put the start character</code>
<code>    sbs 0 encs 10 get putinterval</code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        % Lookup the encoding for the each barcode character</code>
<code>        barcode i 1 getinterval barchars exch search</code>
<code>        pop                                 % Discard true leaving pre</code>
<code>        length /indx exch def               % indx is the length of pre</code>
<code>        pop pop                             % Discard seek and post</code>
<code>        /enc encs indx get def              % Get the indxth encoding</code>
<code>        sbs i cs mul ss add enc putinterval % Put encoded digit into sbs</code>
<code>        txt i [barcode i 1 getinterval i cw mul sw add textyoffset textfont textsize] put</code>
<code>    } for</code>
<code></code>
<code>    % Put the checksum and end characters</code>
<code>    includecheck {</code>
<code>        sbs barlen cs mul ss add encs checksum get putinterval</code>
<code>        sbs barlen cs mul cs add ss add encs 11 get putinterval</code>
<code>        includecheckintext {</code>
<code>            txt barlen [barchars checksum 1 getinterval barlen cw mul sw add textyoffset textfont textsize] put</code>
<code>        } {</code>
<code>            txt barlen [( ) barlen cw mul sw add textyoffset textfont textsize] put</code>
<code>        } ifelse</code>
<code>    } {</code>
<code>        sbs barlen cs mul ss add encs 11 get putinterval</code>
<code>    } ifelse</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs [sbs {48 sub} forall]</code>
<code>    /bhs [sbs length 1 add 2 idiv {height} repeat]</code>
<code>    /bbs [sbs length 1 add 2 idiv {0} repeat]</code>
<code>    includetext {</code>
<code>        /txt txt</code>
<code>    } if</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /code2of5 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER code2of5--</code>
<code></code>
<code>% --BEGIN ENCODER industrial2of5--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear code2of5--</code>
<code>% --DESC: Industrial 2 of 5</code>
<code>% --EXAM: 01234567</code>
<code>% --EXOP: includetext includecheck includecheckintext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp industrial2of5 0.0 2024010300 60390 60228</code>
<code>%%BeginData:         36 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /code2of5 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/industrial2of5 {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Get the result of encoding with code2of5 with version=industrial</code>
<code>    options (dontdraw) true put</code>
<code>    options (version) (industrial) put</code>
<code></code>
<code>    /args barcode options //code2of5 exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /industrial2of5 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER industrial2of5--</code>
<code></code>
<code>% --BEGIN ENCODER iata2of5--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear code2of5--</code>
<code>% --DESC: IATA 2 of 5</code>
<code>% --EXAM: 01234567</code>
<code>% --EXOP: includetext includecheck includecheckintext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp iata2of5 0.0 2024010300 60360 60204</code>
<code>%%BeginData:         36 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /code2of5 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/iata2of5 {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Get the result of encoding with code2of5 with version=iata</code>
<code>    options (dontdraw) true put</code>
<code>    options (version) (iata) put</code>
<code></code>
<code>    /args barcode options //code2of5 exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /iata2of5 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER iata2of5--</code>
<code></code>
<code>% --BEGIN ENCODER matrix2of5--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear code2of5--</code>
<code>% --DESC: Matrix 2 of 5</code>
<code>% --EXAM: 01234567</code>
<code>% --EXOP: includetext includecheck includecheckintext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp matrix2of5 0.0 2024010300 60370 60212</code>
<code>%%BeginData:         36 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /code2of5 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/matrix2of5 {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Get the result of encoding with code2of5 with version=matrix</code>
<code>    options (dontdraw) true put</code>
<code>    options (version) (matrix) put</code>
<code></code>
<code>    /args barcode options //code2of5 exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /matrix2of5 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER matrix2of5--</code>
<code></code>
<code>% --BEGIN ENCODER coop2of5--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear code2of5--</code>
<code>% --DESC: COOP 2 of 5</code>
<code>% --EXAM: 01234567</code>
<code>% --EXOP: includetext includecheck includecheckintext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp coop2of5 0.0 2024010300 60360 60204</code>
<code>%%BeginData:         36 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /code2of5 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/coop2of5 {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Get the result of encoding with code2of5 with version=coop</code>
<code>    options (dontdraw) true put</code>
<code>    options (version) (coop) put</code>
<code></code>
<code>    /args barcode options //code2of5 exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /coop2of5 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER coop2of5--</code>
<code></code>
<code>% --BEGIN ENCODER datalogic2of5--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear code2of5--</code>
<code>% --DESC: Datalogic 2 of 5</code>
<code>% --EXAM: 01234567</code>
<code>% --EXOP: includetext includecheck includecheckintext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp datalogic2of5 0.0 2024010300 60385 60224</code>
<code>%%BeginData:         36 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /code2of5 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/datalogic2of5 {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Get the result of encoding with code2of5 with version=datalogic</code>
<code>    options (dontdraw) true put</code>
<code>    options (version) (datalogic) put</code>
<code></code>
<code>    /args barcode options //code2of5 exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /datalogic2of5 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER datalogic2of5--</code>
<code></code>
<code>% --BEGIN ENCODER code11--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear--</code>
<code>% --DESC: Code 11</code>
<code>% --EXAM: 0123456789</code>
<code>% --EXOP: includetext includecheck includecheckintext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp code11 0.0 2024010300 74842 74390</code>
<code>%%BeginData:        158 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/code11 {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includecheck false def</code>
<code>    /validatecheck false def</code>
<code>    /includetext false def</code>
<code>    /includecheckintext false def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 1.0 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.code11emptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /code11 //loadctx exec</code>
<code></code>
<code>    % Create an array containing the character mappings</code>
<code>{</code>
<code>    /encs</code>
<code>    [ (111131) (311131) (131131) (331111) (113131)</code>
<code>      (313111) (133111) (111331) (311311) (311111)</code>
<code>      (113111) (113311)</code>
<code>    ] def</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>    /barchars (0123456789-) def</code>
<code>    /charvals 11 dict def</code>
<code>    0 1 10 {charvals exch dup barchars exch 1 getinterval exch put} for</code>
<code>} ctxdef</code>
<code></code>
<code>    % Validate the input</code>
<code>    0 1 barcode length 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch known not {</code>
<code>            /bwipp.code11badCharacter (Code 11 must contain only digits and dashes) //raiseerror exec</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    /barlen barcode length def</code>
<code>    validatecheck {</code>
<code>        barlen 11 eq {</code>
<code>            /bwipp.code11badLength (Code 11 cannot be 11 characters using check digits) //raiseerror exec</code>
<code>        } if</code>
<code>        /barlen barlen barlen 10 le {1} {2} ifelse sub def</code>
<code>    } if</code>
<code></code>
<code>    /numchecks includecheck validatecheck or {barlen 10 ge {2} {1} ifelse} {0} ifelse def</code>
<code>    /checksum1 0 def /checksum2 0 def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        /indx charvals barcode i 1 getinterval get def</code>
<code>        /checksum1 checksum1 barlen i sub 1 sub 10 mod 1 add indx mul add def</code>
<code>        /checksum2 checksum2 barlen i sub 9 mod 1 add indx mul add def</code>
<code>    } for</code>
<code>    /checksum1 checksum1 11 mod def</code>
<code>    /checksum2 checksum2 checksum1 add 11 mod def</code>
<code>    validatecheck {</code>
<code>        numchecks 1 eq {</code>
<code>            barcode barlen get barchars checksum1 get ne {</code>
<code>                /bwipp.code11badCheckDigit (Incorrect Code 11 check digit provided) //raiseerror exec</code>
<code>            } if</code>
<code>        } {</code>
<code>            barcode barlen get barchars checksum1 get ne</code>
<code>            barcode barlen 1 add get barchars checksum2 get ne or {</code>
<code>                /bwipp.code11badCheckDigits (Incorrect Code 11 check digits provided) //raiseerror exec</code>
<code>            } if</code>
<code>        } ifelse</code>
<code>        /barcode barcode 0 barlen getinterval def</code>
<code>        /includecheck true def</code>
<code>    } if</code>
<code></code>
<code>    /sbs barlen numchecks add 6 mul 12 add string def</code>
<code>    /txt barlen numchecks add array def</code>
<code></code>
<code>    % Put the start character</code>
<code>    sbs 0 encs 11 get putinterval</code>
<code></code>
<code>    /xpos 8 def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        /indx charvals barcode i 1 getinterval get def</code>
<code>        /enc encs indx get def</code>
<code>        sbs i 6 mul 6 add enc putinterval</code>
<code>        txt i [barcode i 1 getinterval xpos textyoffset textfont textsize] put</code>
<code>        0 1 5 {       % xpos+=width of the character</code>
<code>            /xpos exch enc exch get 48 sub xpos add def</code>
<code>        } for</code>
<code>    } for</code>
<code></code>
<code>    % Put the checksum and end characters</code>
<code>    includecheck {</code>
<code>        barlen 10 ge {</code>
<code>            sbs barlen 6 mul 6 add encs checksum1 get putinterval</code>
<code>            sbs barlen 6 mul 12 add encs checksum2 get putinterval</code>
<code>            includecheckintext {</code>
<code>                txt barlen [barchars checksum1 1 getinterval xpos textyoffset textfont textsize] put</code>
<code>                /enc encs checksum1 get def</code>
<code>                0 1 5 {       % xpos+=width of the character</code>
<code>                    /xpos exch enc exch get 48 sub xpos add def</code>
<code>                } for</code>
<code>                txt barlen 1 add [barchars checksum2 1 getinterval xpos textyoffset textfont textsize] put</code>
<code>            } {</code>
<code>                txt barlen [() xpos textyoffset textfont textsize] put</code>
<code>                txt barlen 1 add [() xpos textyoffset textfont textsize] put</code>
<code>            } ifelse</code>
<code>            sbs barlen 6 mul 18 add encs 11 get putinterval</code>
<code>        } {</code>
<code>            sbs barlen 6 mul 6 add encs checksum1 get putinterval</code>
<code>            includecheckintext {</code>
<code>                txt barlen [barchars checksum1 1 getinterval xpos textyoffset textfont textsize] put</code>
<code>            } {</code>
<code>                txt barlen [() xpos textyoffset textfont textsize] put</code>
<code>            } ifelse</code>
<code>            sbs barlen 6 mul 12 add encs 11 get putinterval</code>
<code>        } ifelse</code>
<code>    } {</code>
<code>        sbs barlen 6 mul 6 add encs 11 get putinterval</code>
<code>    } ifelse</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs [sbs {48 sub} forall]</code>
<code>    /bhs [sbs length 1 add 2 idiv {height} repeat]</code>
<code>    /bbs [sbs length 1 add 2 idiv {0} repeat]</code>
<code>    includetext {</code>
<code>        /txt txt</code>
<code>    } if</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /code11 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER code11--</code>
<code></code>
<code>% --BEGIN ENCODER bc412--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear--</code>
<code>% --DESC: BC412</code>
<code>% --EXAM: BC412SEMI</code>
<code>% --EXOP: semi includetext includecheckintext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp bc412 0.0 2024010300 76005 75371</code>
<code>%%BeginData:        192 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/bc412 {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includecheck false def</code>
<code>    /validatecheck false def</code>
<code>    /includetext false def</code>
<code>    /includecheckintext false def</code>
<code>    /includestartstop false def</code>
<code>    /semi false def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 1.0 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.bc412emptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    semi {</code>
<code>        % Implies includecheck and includecheckintext also</code>
<code>        /includestartstop true def</code>
<code>    } if</code>
<code></code>
<code>    /bc412 //loadctx exec</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>{</code>
<code>    /barchars (0R9GLVHA8EZ4NTS1J2Q6C7DYKBUIX3FWP5M) def</code>
<code>    /charvals 35 dict def</code>
<code>    0 1 34 {charvals exch dup barchars exch 1 getinterval exch put} for</code>
<code>} ctxdef</code>
<code></code>
<code>    % Validate the input</code>
<code>    0 1 barcode length 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch known not {</code>
<code>            /bwipp.bc412badCharacter (BC412 must contain only digits and capital letters except O) //raiseerror exec</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    semi {</code>
<code>        % Validate length</code>
<code>        validatecheck {</code>
<code>            barcode length 8 lt barcode length 19 gt or {</code>
<code>                /bwipp.bc412semivalidateBadLength (BC412 semi with check digit must be 8 to 19 characters long) //raiseerror exec</code>
<code>            } if</code>
<code>        } {</code>
<code>            barcode length 7 lt barcode length 18 gt or {</code>
<code>                /bwipp.bc412semiBadLength (BC412 semi must be 7 to 18 characters long) //raiseerror exec</code>
<code>            } if</code>
<code>        } ifelse</code>
<code></code>
<code>        /barlen barcode length def</code>
<code>        validatecheck not {  % Place dummy (0) in checksum position (1-based 2nd)</code>
<code>            /barlen barlen 1 add def</code>
<code>            /sbarcode barlen string def</code>
<code>            sbarcode 0 barcode 0 get put</code>
<code>            sbarcode 1 48 put  % (0)</code>
<code>            sbarcode 2 barcode 1 barlen 2 sub getinterval putinterval</code>
<code>            /barcode sbarcode def</code>
<code>        } if</code>
<code>        /sumodd 0 def /sumeven 0 def</code>
<code>        0 1 barlen 1 sub {</code>
<code>            /i exch def</code>
<code>            barcode i 1 getinterval charvals exch get</code>
<code>            i 2 mod 0 eq {  % 1-based odd</code>
<code>                sumodd add /sumodd exch def</code>
<code>            } {</code>
<code>                sumeven add /sumeven exch def</code>
<code>            } ifelse</code>
<code>        } for</code>
<code>        /checksum sumodd 35 mod sumeven 35 mod 2 mul add 35 mod def  % F = Mod35( Mod35( Fodd ) + 2 * Mod35( Feven ) )</code>
<code>        validatecheck {</code>
<code>            checksum 0 ne {</code>
<code>                /bwipp.bc412semiBadCheckDigit (Incorrect BC412 semi check digit provided) //raiseerror exec</code>
<code>            } if</code>
<code>        } {</code>
<code>            /checksum checksum 17 mul 35 mod def  % CD = Mod35( 17 * F )</code>
<code>            barcode 1 barchars checksum get put</code>
<code>        } ifelse</code>
<code>    } {</code>
<code>        /barlen barcode length validatecheck {1 sub} if def</code>
<code></code>
<code>        /checksum 0 def</code>
<code>        0 1 barlen 1 sub {</code>
<code>            barcode exch 1 getinterval charvals exch get</code>
<code>            checksum add /checksum exch def</code>
<code>        } for</code>
<code>        /checksum checksum 35 mod def</code>
<code>        validatecheck {</code>
<code>            barcode barlen get barchars checksum get ne {</code>
<code>                /bwipp.bc412badCheckDigit (Incorrect BC412 check digit provided) //raiseerror exec</code>
<code>            } if</code>
<code>            /barcode barcode 0 barlen getinterval def</code>
<code>            /includecheck true def</code>
<code>        } if</code>
<code>    } ifelse</code>
<code></code>
<code>    % Create an array containing the character mappings</code>
<code>{</code>
<code>    /encs</code>
<code>    [ (11111115) (13111212) (11131113) (12111213) (12121311)  % 0R9GL</code>
<code>      (13131111) (12111312) (11131212) (11121411) (11151111)  % VHA8E</code>
<code>      (15111111) (11111511) (12131211) (13121112) (13111311)  % Z4NTS</code>
<code>      (11111214) (12121113) (11111313) (13111113) (11121213)  % 1J2Q6</code>
<code>      (11141112) (11121312) (11141211) (14121111) (12121212)  % C7DYK</code>
<code>      (11131311) (13121211) (12111411) (14111211) (11111412)  % BUIX3</code>
<code>      (12111114) (14111112) (12141111) (11121114) (12131112)  % FWP5M</code>
<code>      (12) (111)  % Start Stop</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /sbs barlen 1 add 8 mul 5 add string def</code>
<code>    includecheck {</code>
<code>        /txt barlen 1 add array def</code>
<code>    } {</code>
<code>        /txt barlen array def</code>
<code>    } ifelse</code>
<code></code>
<code>    % Put the start character</code>
<code>    includestartstop {</code>
<code>        sbs 0 encs 35 get putinterval</code>
<code>        /pos 2 def</code>
<code>        /txtpos 3.0 def</code>
<code>    } {</code>
<code>        /pos 0 def</code>
<code>        /txtpos 0.0 def</code>
<code>    } ifelse</code>
<code></code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        /indx charvals barcode i 1 getinterval get def</code>
<code>        sbs pos encs indx get putinterval</code>
<code>        txt i [barcode i 1 getinterval i 12 mul txtpos add textyoffset textfont textsize] put</code>
<code>        /pos pos 8 add def</code>
<code>    } for</code>
<code></code>
<code>    % Put the checksum</code>
<code>    includecheck {</code>
<code>        sbs pos encs checksum get putinterval</code>
<code>        includecheckintext {</code>
<code>            txt barlen [barchars checksum 1 getinterval barlen 12 mul txtpos add textyoffset textfont textsize] put</code>
<code>        } {</code>
<code>            txt barlen [() barlen 12 mul txtpos add textyoffset textfont textsize] put</code>
<code>        } ifelse</code>
<code>        /pos pos 8 add def</code>
<code>    } if</code>
<code></code>
<code>    % Put the stop character</code>
<code>    includestartstop {</code>
<code>        sbs pos encs 36 get putinterval</code>
<code>        /pos pos 3 add def</code>
<code>    } if</code>
<code></code>
<code>    % Return the arguments</code>
<code>    /sbs sbs 0 pos getinterval def</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs [sbs {48 sub} forall]</code>
<code>    /bhs [sbs length 1 add 2 idiv {height} repeat]</code>
<code>    /bbs [sbs length 1 add 2 idiv {0} repeat]</code>
<code>    includetext {</code>
<code>        /txt txt</code>
<code>    } if</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /bc412 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER bc412--</code>
<code></code>
<code>% --BEGIN ENCODER rationalizedCodabar--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear--</code>
<code>% --DESC: Codabar</code>
<code>% --EXAM: A0123456789B</code>
<code>% --EXOP: includetext includecheck includecheckintext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp rationalizedCodabar 0.0 2024010300 76015 75425</code>
<code>%%BeginData:        156 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/rationalizedCodabar {</code>
<code></code>
<code>    20 dict begin                    % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /altstartstop false def</code>
<code>    /includecheck false def     % Enable/disable checkdigit</code>
<code>    /validatecheck false def</code>
<code>    /includetext false def      % Enable/disable text</code>
<code>    /includecheckintext false def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 1.0 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode length 2 lt barcode length 3 lt validatecheck and or {</code>
<code>        /bwipp.rationalizedCodabarBadLength (Codabar must be at least 2 characters in length excluding any check digit) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /rationalizedCodabar //loadctx exec</code>
<code></code>
<code>{</code>
<code>    % Create an array containing the character mappings</code>
<code>    /encs</code>
<code>    [ (11111331) (11113311) (11131131) (33111111) (11311311)</code>
<code>      (31111311) (13111131) (13113111) (13311111) (31131111)</code>
<code>      (11133111) (11331111) (31113131) (31311131) (31313111)</code>
<code>      (11313131) (11331311) (13131131) (11131331) (11133311)</code>
<code>    ] def</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>    /barcharsnormal (0123456789-$:/.+ABCD) def</code>
<code>    /barcharsalt (0123456789-$:/.+TN*E) def</code>
<code>} ctxdef</code>
<code></code>
<code>    /barchars altstartstop {barcharsalt} {barcharsnormal} ifelse def</code>
<code></code>
<code>    /charvals 20 dict def</code>
<code>    0 1 19 {charvals exch dup barchars exch 1 getinterval exch put} for</code>
<code>    /bodyvals 16 dict def</code>
<code>    0 1 15 {bodyvals exch dup barchars exch 1 getinterval exch put} for</code>
<code>    /ssvals 4 dict def</code>
<code>    16 1 19 {ssvals exch dup barchars exch 1 getinterval exch put} for</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode 0 1 getinterval ssvals exch known not</code>
<code>    barcode barcode length 1 sub 1 getinterval ssvals exch known not or {</code>
<code>        altstartstop {</code>
<code>            /bwipp.rationalizedCodabarBadAltStartStop (Codabar start and stop characters must be one of E N T or *) //raiseerror exec</code>
<code>        } {</code>
<code>            /bwipp.rationalizedCodabarBadStartStop (Codabar start and stop characters must be one of A B C or D) //raiseerror exec</code>
<code>        } ifelse</code>
<code>    } if</code>
<code>    1 1 barcode length 2 sub {</code>
<code>        barcode exch 1 getinterval bodyvals exch known not {</code>
<code>            /bwipp.rationalizedCodabarBadCharacter (Codabar body must contain only digits and symbols - $ : / . +) //raiseerror exec</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    /barlen barcode length validatecheck {1 sub} if def</code>
<code></code>
<code>    /checksum 0 def</code>
<code>    0 1 barlen 2 sub {</code>
<code>        barcode exch 1 getinterval charvals exch get</code>
<code>        checksum add /checksum exch def</code>
<code>    } for</code>
<code>    barcode barcode length 1 sub 1 getinterval charvals exch get</code>
<code>    checksum add /checksum exch def</code>
<code>    /checksum 16 checksum 16 mod sub 16 mod def</code>
<code>    validatecheck {</code>
<code>        barcode barlen 1 sub get barchars checksum get ne {</code>
<code>            /bwipp.rationalizedCodabarBadCheckDigit (Incorrect Codabar check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>        barlen string</code>
<code>        dup 0 barcode 0 barlen 1 sub getinterval putinterval</code>
<code>        dup barlen 1 sub barcode barlen 1 getinterval putinterval</code>
<code>        /barcode exch def</code>
<code>        /includecheck true def</code>
<code>    } if</code>
<code></code>
<code>    /sbs barlen includecheck {1 add} if 8 mul string def</code>
<code>    /txt barlen includecheck {1 add} if array def</code>
<code></code>
<code>    /xpos 0 def</code>
<code>    0 1 barlen 2 sub {</code>
<code>        /i exch def</code>
<code>        /indx charvals barcode i 1 getinterval get def</code>
<code>        /enc encs indx get def</code>
<code>        sbs i 8 mul enc putinterval  % Put encoded digit into sbs</code>
<code>        txt i [barcode i 1 getinterval xpos textyoffset textfont textsize] put</code>
<code>        0 1 7 {       % xpos+=width of the character</code>
<code>            /xpos exch enc exch get 48 sub xpos add def</code>
<code>        } for</code>
<code>    } for</code>
<code></code>
<code>    % Put the checksum character and stop character</code>
<code>    includecheck {</code>
<code>        % Put the checksum character</code>
<code>        sbs barlen 8 mul 8 sub encs checksum get putinterval</code>
<code>        includecheckintext {</code>
<code>            txt barlen 1 sub [barchars checksum 1 getinterval xpos textyoffset textfont textsize] put</code>
<code>        } {</code>
<code>            txt barlen 1 sub [( ) xpos textyoffset textfont textsize] put</code>
<code>        } ifelse</code>
<code>        0 1 7 {       % xpos+=width of the character</code>
<code>            /xpos exch encs checksum get exch get 48 sub xpos add def</code>
<code>        } for</code>
<code>        % Put the end character</code>
<code>        /indx charvals barcode barlen 1 sub 1 getinterval get def</code>
<code>        /enc encs indx get def            % Get the indxth encoding</code>
<code>        sbs barlen 8 mul enc putinterval  % Put encoded digit into sbs</code>
<code>        txt barlen [barcode barlen 1 sub 1 getinterval xpos textyoffset textfont textsize] put</code>
<code>    } {</code>
<code>        % Put the end character</code>
<code>        /indx charvals barcode barlen 1 sub 1 getinterval get def</code>
<code>        /enc encs indx get def                  % Get the indxth encoding</code>
<code>        sbs barlen 8 mul 8 sub enc putinterval  % Put encoded digit into sbs</code>
<code>        txt barlen 1 sub [barcode barlen 1 sub 1 getinterval xpos textyoffset textfont textsize] put</code>
<code>    } ifelse</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs [sbs {48 sub} forall]</code>
<code>    /bhs [sbs length 1 add 2 idiv {height} repeat]</code>
<code>    /bbs [sbs length 1 add 2 idiv {0} repeat]</code>
<code>    includetext {</code>
<code>        /txt txt</code>
<code>    } if</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /rationalizedCodabar dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER rationalizedCodabar--</code>
<code></code>
<code>% --BEGIN ENCODER onecode--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear--</code>
<code>% --DESC: USPS Intelligent Mail</code>
<code>% --EXAM: 0123456709498765432101234567891</code>
<code>% --EXOP: barcolor=FF0000</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp onecode 0.0 2024010300 110314 109785</code>
<code>%%BeginData:        347 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/onecode {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /height 0.15 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /onecode //loadctx exec</code>
<code></code>
<code>    /barlen barcode length def</code>
<code></code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.onecodeBadCharacter (The data must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>    barlen 20 ne barlen 25 ne and barlen 29 ne and barlen 31 ne and {</code>
<code>        /bwipp.onecodeInvalidLength (The data must be 20, 25, 29 or 31 digits) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Create the human readable text</code>
<code>    /txtdict &lt;&lt;</code>
<code>        2 dup</code>
<code>        5 dup</code>
<code>        barcode 5 1 getinterval (9) eq {14} {11} ifelse dup</code>
<code>        20 dup</code>
<code>        25 dup</code>
<code>        29 dup</code>
<code>    &gt;&gt; def</code>
<code>    /txt barlen 6 add array def</code>
<code>    /spacecnt 0 def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        txtdict i known {</code>
<code>            txt i spacecnt add [( ) 0 0 () 0] put</code>
<code>            /spacecnt spacecnt 1 add def</code>
<code>        } if</code>
<code>        txt i spacecnt add [barcode i 1 getinterval 0 0 () 0] put</code>
<code>    } for</code>
<code>    /txt txt 0 barcode length spacecnt add getinterval def</code>
<code></code>
<code>    /normalize {</code>
<code>        /base exch def</code>
<code>        /num exch def</code>
<code>        num length 1 sub -1 1 {</code>
<code>            /i exch def</code>
<code>            num i 1 sub 2 copy get num i get base idiv add put</code>
<code>            num i num i get base mod put</code>
<code>        } for</code>
<code>        { %loop - extend input as necessary</code>
<code>            num 0 get base lt {exit} if</code>
<code>            /num [ 0 num aload pop ] def</code>
<code>            num 0 num 0 get num 1 get base idiv add put</code>
<code>            num 1 num 1 get base mod put</code>
<code>        } loop</code>
<code>        % Trim leading zeros</code>
<code>        /num [/i true def num {dup 0 eq i and {pop} {/i false def} ifelse} forall] def</code>
<code>        num length 0 eq {/num [0] def} if</code>
<code>        num</code>
<code>    } def</code>
<code></code>
<code>    /bigadd {</code>
<code>        2 copy length exch length</code>
<code>        2 copy sub abs /offset exch def</code>
<code>        lt {exch} if</code>
<code>        /a exch def /b exch def</code>
<code>        0 1 b length 1 sub {</code>
<code>            dup a exch offset add 2 copy get b 5 -1 roll get add put</code>
<code>        } for</code>
<code>        a</code>
<code>    } def</code>
<code></code>
<code>    % Conversion of data fields into binary data</code>
<code>{</code>
<code>    /startvals &lt;&lt;</code>
<code>        20 [0]</code>
<code>        25 [1]</code>
<code>        29 [1 0 0 0 0 1]</code>
<code>        31 [1 0 0 0 1 0 0 0 0 1]</code>
<code>    &gt;&gt; def</code>
<code>} ctxdef</code>
<code></code>
<code>    /binval startvals barlen get [barcode 20 barlen 20 sub getinterval {48 sub} forall] bigadd def</code>
<code>    /binval [binval aload pop barcode 0 get 48 sub] def</code>
<code>    /binval [binval {5 mul} forall] [barcode 1 get 48 sub] bigadd 10 normalize def</code>
<code>    /binval [binval aload pop barcode 2 18 getinterval {48 sub} forall] def</code>
<code></code>
<code>    % Conversion of binary data into byte array</code>
<code>    /bytes 13 array def</code>
<code>    /bintmp binval dup length array copy def</code>
<code>    12 -1 0 {</code>
<code>        /i exch def</code>
<code>        0 1 bintmp length 2 sub {</code>
<code>            /j exch def</code>
<code>            bintmp j 1 add 2 copy get bintmp j get 256 mod 10 mul add put</code>
<code>            bintmp j bintmp j get 256 idiv put</code>
<code>        } for</code>
<code>        bytes i bintmp bintmp length 1 sub get 256 mod put</code>
<code>        bintmp bintmp length 1 sub 2 copy get 256 idiv put</code>
<code>    } for</code>
<code></code>
<code>    % Generation of 11-bit CRC on byte array</code>
<code>    /fcs 2047 def</code>
<code>    /dat bytes 0 get 5 bitshift def</code>
<code>    6 {</code>
<code>        fcs dat xor 1024 and 0 ne {</code>
<code>            /fcs fcs 1 bitshift 3893 xor def</code>
<code>        } {</code>
<code>            /fcs fcs 1 bitshift def</code>
<code>        } ifelse</code>
<code>        /fcs fcs 2047 and def</code>
<code>        /dat dat 1 bitshift def</code>
<code>    } repeat</code>
<code>    1 1 12 {</code>
<code>        bytes exch get 3 bitshift /dat exch def</code>
<code>        8 {</code>
<code>            fcs dat xor 1024 and 0 ne {</code>
<code>                /fcs fcs 1 bitshift 3893 xor def</code>
<code>            } {</code>
<code>                /fcs fcs 1 bitshift def</code>
<code>            } ifelse</code>
<code>            /fcs fcs 2047 and def</code>
<code>            /dat dat 1 bitshift def</code>
<code>        } repeat</code>
<code>    } for</code>
<code></code>
<code>    % Conversion from binary data to codewords</code>
<code>    /codewords 10 array def</code>
<code>    9 -1 0 {</code>
<code>        /i exch def</code>
<code>        /b i 9 eq { 636 } { 1365 } ifelse def</code>
<code>        0 1 binval length 2 sub {</code>
<code>            /j exch def</code>
<code>            binval j 1 add 2 copy get binval j get b mod 10 mul add put</code>
<code>            binval j binval j get b idiv put</code>
<code>        } for</code>
<code>        codewords i binval binval length 1 sub get b mod put</code>
<code>        binval binval length 1 sub 2 copy get b idiv put</code>
<code>    } for</code>
<code></code>
<code>    % Inserting additional information into codewords</code>
<code>    codewords 9 codewords 9 get 2 mul put</code>
<code>    fcs 1024 and 0 ne {</code>
<code>        codewords 0 codewords 0 get 659 add put</code>
<code>    } if</code>
<code></code>
<code>    % Conversion from codewords to characters</code>
<code>{</code>
<code>    /tab513 [</code>
<code>        31 7936   47 7808   55 7552   59 7040   61 6016   62 3968   79 7744   87</code>
<code>      7488   91 6976   93 5952   94 3904  103 7360  107 6848  109 5824  110 3776</code>
<code>       115 6592  117 5568  118 3520  121 5056  122 3008  124 1984  143 7712  151</code>
<code>      7456  155 6944  157 5920  158 3872  167 7328  171 6816  173 5792  174 3744</code>
<code>       179 6560  181 5536  182 3488  185 5024  186 2976  188 1952  199 7264  203</code>
<code>      6752  205 5728  206 3680  211 6496  213 5472  214 3424  217 4960  218 2912</code>
<code>       220 1888  227 6368  229 5344  230 3296  233 4832  234 2784  236 1760  241</code>
<code>      4576  242 2528  244 1504  248  992  271 7696  279 7440  283 6928  285 5904</code>
<code>       286 3856  295 7312  299 6800  301 5776  302 3728  307 6544  309 5520  310</code>
<code>      3472  313 5008  314 2960  316 1936  327 7248  331 6736  333 5712  334 3664</code>
<code>       339 6480  341 5456  342 3408  345 4944  346 2896  348 1872  355 6352  357</code>
<code>      5328  358 3280  361 4816  362 2768  364 1744  369 4560  370 2512  372 1488</code>
<code>       376  976  391 7216  395 6704  397 5680  398 3632  403 6448  405 5424  406</code>
<code>      3376  409 4912  410 2864  412 1840  419 6320  421 5296  422 3248  425 4784</code>
<code>       426 2736  428 1712  433 4528  434 2480  436 1456  440  944  451 6256  453</code>
<code>      5232  454 3184  457 4720  458 2672  460 1648  465 4464  466 2416  468 1392</code>
<code>       472  880  481 4336  482 2288  484 1264  488  752  527 7688  535 7432  539</code>
<code>      6920  541 5896  542 3848  551 7304  555 6792  557 5768  558 3720  563 6536</code>
<code>       565 5512  566 3464  569 5000  570 2952  572 1928  583 7240  587 6728  589</code>
<code>      5704  590 3656  595 6472  597 5448  598 3400  601 4936  602 2888  604 1864</code>
<code>       611 6344  613 5320  614 3272  617 4808  618 2760  620 1736  625 4552  626</code>
<code>      2504  628 1480  632  968  647 7208  651 6696  653 5672  654 3624  659 6440</code>
<code>       661 5416  662 3368  665 4904  666 2856  668 1832  675 6312  677 5288  678</code>
<code>      3240  681 4776  682 2728  684 1704  689 4520  690 2472  692 1448  696  936</code>
<code>       707 6248  709 5224  710 3176  713 4712  714 2664  716 1640  721 4456  722</code>
<code>      2408  724 1384  728  872  737 4328  738 2280  740 1256  775 7192  779 6680</code>
<code>       781 5656  782 3608  787 6424  789 5400  790 3352  793 4888  794 2840  796</code>
<code>      1816  803 6296  805 5272  806 3224  809 4760  810 2712  812 1688  817 4504</code>
<code>       818 2456  820 1432  824  920  835 6232  837 5208  838 3160  841 4696  842</code>
<code>      2648  844 1624  849 4440  850 2392  852 1368  865 4312  866 2264  868 1240</code>
<code>       899 6200  901 5176  902 3128  905 4664  906 2616  908 1592  913 4408  914</code>
<code>      2360  916 1336  929 4280  930 2232  932 1208  961 4216  962 2168  964 1144</code>
<code>      1039 7684 1047 7428 1051 6916 1053 5892 1054 3844 1063 7300 1067 6788 1069</code>
<code>      5764 1070 3716 1075 6532 1077 5508 1078 3460 1081 4996 1082 2948 1084 1924</code>
<code>      1095 7236 1099 6724 1101 5700 1102 3652 1107 6468 1109 5444 1110 3396 1113</code>
<code>      4932 1114 2884 1116 1860 1123 6340 1125 5316 1126 3268 1129 4804 1130 2756</code>
<code>      1132 1732 1137 4548 1138 2500 1140 1476 1159 7204 1163 6692 1165 5668 1166</code>
<code>      3620 1171 6436 1173 5412 1174 3364 1177 4900 1178 2852 1180 1828 1187 6308</code>
<code>      1189 5284 1190 3236 1193 4772 1194 2724 1196 1700 1201 4516 1202 2468 1204</code>
<code>      1444 1219 6244 1221 5220 1222 3172 1225 4708 1226 2660 1228 1636 1233 4452</code>
<code>      1234 2404 1236 1380 1249 4324 1250 2276 1287 7188 1291 6676 1293 5652 1294</code>
<code>      3604 1299 6420 1301 5396 1302 3348 1305 4884 1306 2836 1308 1812 1315 6292</code>
<code>      1317 5268 1318 3220 1321 4756 1322 2708 1324 1684 1329 4500 1330 2452 1332</code>
<code>      1428 1347 6228 1349 5204 1350 3156 1353 4692 1354 2644 1356 1620 1361 4436</code>
<code>      1362 2388 1377 4308 1378 2260 1411 6196 1413 5172 1414 3124 1417 4660 1418</code>
<code>      2612 1420 1588 1425 4404 1426 2356 1441 4276 1442 2228 1473 4212 1474 2164</code>
<code>      1543 7180 1547 6668 1549 5644 1550 3596 1555 6412 1557 5388 1558 3340 1561</code>
<code>      4876 1562 2828 1564 1804 1571 6284 1573 5260 1574 3212 1577 4748 1578 2700</code>
<code>      1580 1676 1585 4492 1586 2444 1603 6220 1605 5196 1606 3148 1609 4684 1610</code>
<code>      2636 1617 4428 1618 2380 1633 4300 1634 2252 1667 6188 1669 5164 1670 3116</code>
<code>      1673 4652 1674 2604 1681 4396 1682 2348 1697 4268 1698 2220 1729 4204 1730</code>
<code>      2156 1795 6172 1797 5148 1798 3100 1801 4636 1802 2588 1809 4380 1810 2332</code>
<code>      1825 4252 1826 2204 1857 4188 1858 2140 1921 4156 1922 2108 2063 7682 2071</code>
<code>      7426 2075 6914 2077 5890 2078 3842 2087 7298 2091 6786 2093 5762 2094 3714</code>
<code>      2099 6530 2101 5506 2102 3458 2105 4994 2106 2946 2119 7234 2123 6722 2125</code>
<code>      5698 2126 3650 2131 6466 2133 5442 2134 3394 2137 4930 2138 2882 2147 6338</code>
<code>      2149 5314 2150 3266 2153 4802 2154 2754 2161 4546 2162 2498 2183 7202 2187</code>
<code>      6690 2189 5666 2190 3618 2195 6434 2197 5410 2198 3362 2201 4898 2202 2850</code>
<code>      2211 6306 2213 5282 2214 3234 2217 4770 2218 2722 2225 4514 2226 2466 2243</code>
<code>      6242 2245 5218 2246 3170 2249 4706 2250 2658 2257 4450 2258 2402 2273 4322</code>
<code>      2311 7186 2315 6674 2317 5650 2318 3602 2323 6418 2325 5394 2326 3346 2329</code>
<code>      4882 2330 2834 2339 6290 2341 5266 2342 3218 2345 4754 2346 2706 2353 4498</code>
<code>      2354 2450 2371 6226 2373 5202 2374 3154 2377 4690 2378 2642 2385 4434 2401</code>
<code>      4306 2435 6194 2437 5170 2438 3122 2441 4658 2442 2610 2449 4402 2465 4274</code>
<code>      2497 4210 2567 7178 2571 6666 2573 5642 2574 3594 2579 6410 2581 5386 2582</code>
<code>      3338 2585 4874 2586 2826 2595 6282 2597 5258 2598 3210 2601 4746 2602 2698</code>
<code>      2609 4490 2627 6218 2629 5194 2630 3146 2633 4682 2641 4426 2657 4298 2691</code>
<code>      6186 2693 5162 2694 3114 2697 4650 2705 4394 2721 4266 2753 4202 2819 6170</code>
<code>      2821 5146 2822 3098 2825 4634 2833 4378 2849 4250 2881 4186 2945 4154 3079</code>
<code>      7174 3083 6662 3085 5638 3086 3590 3091 6406 3093 5382 3094 3334 3097 4870</code>
<code>      3107 6278 3109 5254 3110 3206 3113 4742 3121 4486 3139 6214 3141 5190 3145</code>
<code>      4678 3153 4422 3169 4294 3203 6182 3205 5158 3209 4646 3217 4390 3233 4262</code>
<code>      3265 4198 3331 6166 3333 5142 3337 4630 3345 4374 3361 4246 3393 4182 3457</code>
<code>      4150 3587 6158 3589 5134 3593 4622 3601 4366 3617 4238 3649 4174 3713 4142</code>
<code>      3841 4126 4111 7681 4119 7425 4123 6913 4125 5889 4135 7297 4139 6785 4141</code>
<code>      5761 4147 6529 4149 5505 4153 4993 4167 7233 4171 6721 4173 5697 4179 6465</code>
<code>      4181 5441 4185 4929 4195 6337 4197 5313 4201 4801 4209 4545 4231 7201 4235</code>
<code>      6689 4237 5665 4243 6433 4245 5409 4249 4897 4259 6305 4261 5281 4265 4769</code>
<code>      4273 4513 4291 6241 4293 5217 4297 4705 4305 4449 4359 7185 4363 6673 4365</code>
<code>      5649 4371 6417 4373 5393 4377 4881 4387 6289 4389 5265 4393 4753 4401 4497</code>
<code>      4419 6225 4421 5201 4425 4689 4483 6193 4485 5169 4489 4657 4615 7177 4619</code>
<code>      6665 4621 5641 4627 6409 4629 5385 4633 4873 4643 6281 4645 5257 4649 4745</code>
<code>      4675 6217 4677 5193 4739 6185 4741 5161 4867 6169 4869 5145 5127 7173 5131</code>
<code>      6661 5133 5637 5139 6405 5141 5381 5155 6277 5157 5253 5187 6213 5251 6181</code>
<code>      5379 6165 5635 6157 6151 7171 6155 6659 6163 6403 6179 6275 6211 5189 4681</code>
<code>      4433 4321 3142 2634 2386 2274 1612 1364 1252  856  744  496</code>
<code>    ] def</code>
<code></code>
<code>    /tab213 [</code>
<code>         3 6144    5 5120    6 3072    9 4608   10 2560   12 1536   17 4352   18</code>
<code>      2304   20 1280   24  768   33 4224   34 2176   36 1152   40  640   48  384</code>
<code>        65 4160   66 2112   68 1088   72  576   80  320   96  192  129 4128  130</code>
<code>      2080  132 1056  136  544  144  288  257 4112  258 2064  260 1040  264  528</code>
<code>       513 4104  514 2056  516 1032 1025 4100 1026 2052 2049 4098 4097 2050 1028</code>
<code>       520  272  160</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /chars 10 array def</code>
<code>    0 1 9 {</code>
<code>        /i exch def</code>
<code>        codewords i get dup 1286 le {</code>
<code>            tab513 exch get</code>
<code>        } {</code>
<code>            tab213 exch 1287 sub get</code>
<code>        } ifelse</code>
<code>        chars i 3 -1 roll put</code>
<code>    } for</code>
<code></code>
<code>    9 -1 0 {</code>
<code>        /i exch def</code>
<code>        2 i exp cvi fcs and 0 ne {</code>
<code>            chars i chars i get 8191 xor put</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    % Conversion from characters to the OneCode encoding</code>
<code>{</code>
<code>    /barmap [</code>
<code>        7 2 4 3    1 10 0 0   9 12 2 8   5 5 6 11   8 9 3 1</code>
<code>        0 1 5 12   2 5 1 8    4 4 9 11   6 3 8 10   3 9 7 6</code>
<code>        5 11 1 4   8 5 2 12   9 10 0 2   7 1 6 7    3 6 4 9</code>
<code>        0 3 8 6    6 4 2 7    1 1 9 9    7 10 5 2   4 0 3 8</code>
<code>        6 2 0 4    8 11 1 0   9 8 3 12   2 6 7 7    5 1 4 10</code>
<code>        1 12 6 9   7 3 8 0    5 8 9 7    4 6 2 10   3 4 0 5</code>
<code>        8 4 5 7    7 11 1 9   6 0 9 6    0 6 4 8    2 1 3 2</code>
<code>        5 9 8 12   4 11 6 1   9 5 7 4    3 3 1 2    0 7 2 0</code>
<code>        1 3 4 1    6 10 3 5   8 7 9 4    2 11 5 6   0 8 7 12</code>
<code>        4 2 8 1    5 10 3 0   9 3 0 9    6 5 2 4    7 8 1 7</code>
<code>        5 0 4 5    2 3 0 10   6 12 9 2   3 11 1 6   8 8 7 9</code>
<code>        5 4 0 11   1 5 2 2    9 1 4 12   8 3 6 6    7 0 3 7</code>
<code>        4 7 7 5    0 12 1 11  2 9 9 0    6 8 5 3    3 10 8 2</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /bbs 65 array def</code>
<code>    /bhs 65 array def</code>
<code>    0 1 64 {</code>
<code>        /i exch def</code>
<code>        /dec chars barmap i 4 mul get get 2 barmap i 4 mul 1 add get exp cvi and 0 ne def</code>
<code>        /asc chars barmap i 4 mul 2 add get get 2 barmap i 4 mul 3 add get exp cvi and 0 ne def</code>
<code>        dec not asc not and {</code>
<code>            bbs i 3 height mul 8 div put</code>
<code>            bhs i 2 height mul 8 div put</code>
<code>        } if</code>
<code>        dec not asc and {</code>
<code>            bbs i 3 height mul 8 div put</code>
<code>            bhs i 5 height mul 8 div put</code>
<code>        } if</code>
<code>        dec asc not and {</code>
<code>            bbs i 0 height mul 8 div put</code>
<code>            bhs i 5 height mul 8 div put</code>
<code>        } if</code>
<code>        dec asc and {</code>
<code>            bbs i 0 height mul 8 div put</code>
<code>            bhs i 8 height mul 8 div put</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /bbs bbs</code>
<code>    /bhs bhs</code>
<code>    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]</code>
<code>    /txt txt</code>
<code>    /textxalign (left)</code>
<code>    /textfont (OCR-B)</code>
<code>    /textyoffset 1.0</code>
<code>    /textxoffset -0.3</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /onecode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER onecode--</code>
<code></code>
<code>% --BEGIN ENCODER postnet--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear--</code>
<code>% --DESC: USPS POSTNET</code>
<code>% --EXAM: 01234</code>
<code>% --EXOP: includetext includecheckintext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp postnet 0.0 2024010300 70838 70525</code>
<code>%%BeginData:        136 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/postnet {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def          % Enable/disable text</code>
<code>    /validatecheck false def</code>
<code>    /includecheckintext false def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 0.125 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /postnet //loadctx exec</code>
<code></code>
<code>    /barlen barcode length validatecheck {1 sub} if def</code>
<code></code>
<code>    % Validate the input</code>
<code>    barlen 5 ne barlen 9 ne and barlen 11 ne and {</code>
<code>        /bwipp.postnetBadLength (USPS POSTNET must be 5, 9 or 11 digits excluding check digit) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.postnetBadCharacter (USPS POSTNET must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>{</code>
<code>    % Create a string of the available characters</code>
<code>    /barchars (0123456789) def</code>
<code></code>
<code>    % Create an array containing the character mappings</code>
<code>    /encs</code>
<code>    [ (55222) (22255) (22525) (22552) (25225)</code>
<code>      (25252) (25522) (52225) (52252) (52522)</code>
<code>      (5) (5)</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /checksum 0 def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        /checksum checksum barcode i get 48 sub add def</code>
<code>    } for</code>
<code>    /checksum 10 checksum 10 mod sub 10 mod def</code>
<code>    validatecheck {</code>
<code>        barcode barlen get barchars checksum get ne {</code>
<code>            /bwipp.postnetBadCheckDigit (Incorrect USPS POSTNET check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>        /barcode barcode 0 barlen getinterval def</code>
<code>    } if</code>
<code></code>
<code>    /bhs barlen 5 mul 7 add array def</code>
<code>    /txt barlen 1 add array def</code>
<code></code>
<code>    % Put start character</code>
<code>    /enc encs 10 get def</code>
<code>    /heights enc length array def</code>
<code>    0 1 enc length 1 sub {</code>
<code>        /j exch def</code>
<code>        heights j enc j 1 getinterval cvi height mul 5 div put</code>
<code>    } for</code>
<code>    bhs 0 heights putinterval   % Put encoded digit into sbs</code>
<code></code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        /enc encs barcode i get 48 sub get def</code>
<code>        /heights enc length array def</code>
<code>        0 1 enc length 1 sub {</code>
<code>            /j exch def</code>
<code>            heights j enc j 1 getinterval cvi height mul 5 div put</code>
<code>        } for</code>
<code>        bhs i 5 mul 1 add heights putinterval   % Put encoded digit into sbs</code>
<code>        txt i [barcode i 1 getinterval i 5 mul 1 add 3.312 mul textyoffset textfont textsize] put</code>
<code>    } for</code>
<code></code>
<code>    % Put the checksum character</code>
<code>    /enc encs checksum get def</code>
<code>    /heights enc length array def</code>
<code>    0 1 enc length 1 sub {</code>
<code>        /j exch def</code>
<code>        heights j enc j 1 getinterval cvi height mul 5 div put</code>
<code>    } for</code>
<code>    bhs barlen 5 mul 1 add heights putinterval</code>
<code></code>
<code>    includecheckintext {</code>
<code>        txt barlen [barchars checksum 1 getinterval barlen 5 mul 1 add 3.312 mul textyoffset textfont textsize] put</code>
<code>    } {</code>
<code>        txt barlen [( ) barlen 5 mul 1 add 72 mul 25 div textyoffset textfont textsize] put</code>
<code>    } ifelse</code>
<code></code>
<code>    % Put end character</code>
<code>    /enc encs 11 get def</code>
<code>    /heights enc length array def</code>
<code>    0 1 enc length 1 sub {</code>
<code>        /j exch def</code>
<code>        heights j enc j 1 getinterval cvi height mul 5 div put</code>
<code>    } for</code>
<code>    bhs barlen 5 mul 6 add heights putinterval</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /bhs bhs</code>
<code>    /bbs [bhs length {0} repeat]</code>
<code>    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]</code>
<code>    includetext {</code>
<code>        /txt txt</code>
<code>    } if</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /postnet dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER postnet--</code>
<code></code>
<code>% --BEGIN ENCODER planet--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear--</code>
<code>% --DESC: USPS PLANET</code>
<code>% --EXAM: 01234567890</code>
<code>% --EXOP: includetext includecheckintext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp planet 0.0 2024010300 70698 70389</code>
<code>%%BeginData:        137 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/planet {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def          % Enable/disable text</code>
<code>    /validatecheck false def</code>
<code>    /includecheckintext false def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 0.125 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /planet //loadctx exec</code>
<code></code>
<code>    /barlen barcode length validatecheck {1 sub} if def</code>
<code></code>
<code>    % Validate the input</code>
<code>    barlen 11 ne barlen 13 ne and {</code>
<code>        /bwipp.planetBadLength (USPS PLANET must be 11 or 13 digits excluding check digit) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.planetBadCharacter (USPS PLANET must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>{</code>
<code>    % Create a string of the available characters</code>
<code>    /barchars (0123456789) def</code>
<code></code>
<code>    % Create an array containing the character mappings</code>
<code>    /encs</code>
<code>    [ (22555) (55522) (55252) (55225) (52552)</code>
<code>      (52525) (52255) (25552) (25525) (25255)</code>
<code>      (5) (5)</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Calculate the checksum</code>
<code>    /checksum 0 def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        /checksum checksum barcode i get 48 sub add def</code>
<code>    } for</code>
<code>    /checksum 10 checksum 10 mod sub 10 mod def</code>
<code>    validatecheck {</code>
<code>        barcode barlen get barchars checksum get ne {</code>
<code>            /bwipp.planetBadCheckDigit (Incorrect USPS PLANET check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>        /barcode barcode 0 barlen getinterval def</code>
<code>    } if</code>
<code></code>
<code>    /bhs barlen 5 mul 7 add array def</code>
<code>    /txt barlen 1 add array def</code>
<code></code>
<code>    % Put start character</code>
<code>    /enc encs 10 get def</code>
<code>    /heights enc length array def</code>
<code>    0 1 enc length 1 sub {</code>
<code>        /j exch def</code>
<code>        heights j enc j 1 getinterval cvi height mul 5 div put</code>
<code>    } for</code>
<code>    bhs 0 heights putinterval   % Put encoded digit into sbs</code>
<code></code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        /enc encs barcode i get 48 sub get def</code>
<code>        /heights enc length array def</code>
<code>        0 1 enc length 1 sub {</code>
<code>            /j exch def</code>
<code>            heights j enc j 1 getinterval cvi height mul 5 div put</code>
<code>        } for</code>
<code>        bhs i 5 mul 1 add heights putinterval   % Put encoded digit into sbs</code>
<code>        txt i [barcode i 1 getinterval i 5 mul 1 add 3.312 mul textyoffset textfont textsize] put</code>
<code>    } for</code>
<code></code>
<code>    % Put the checksum character</code>
<code>    /enc encs checksum get def</code>
<code>    /heights enc length array def</code>
<code>    0 1 enc length 1 sub {</code>
<code>        /j exch def</code>
<code>        heights j enc j 1 getinterval cvi height mul 5 div put</code>
<code>    } for</code>
<code>    bhs barlen 5 mul 1 add heights putinterval</code>
<code></code>
<code>    includecheckintext {</code>
<code>        txt barlen [barchars checksum 1 getinterval barlen 5 mul 1 add 3.312 mul textyoffset textfont textsize] put</code>
<code>    } {</code>
<code>        txt barlen [( ) barlen 5 mul 1 add 72 mul 25 div textyoffset textfont textsize] put</code>
<code>    } ifelse</code>
<code></code>
<code>    % Put end character</code>
<code>    /enc encs 11 get def</code>
<code>    /heights enc length array def</code>
<code>    0 1 enc length 1 sub {</code>
<code>        /j exch def</code>
<code>        heights j enc j 1 getinterval cvi height mul 5 div put</code>
<code>    } for</code>
<code>    bhs barlen 5 mul 6 add heights putinterval</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /bhs bhs</code>
<code>    /bbs [bhs length {0} repeat]</code>
<code>    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]</code>
<code>    includetext {</code>
<code>        /txt txt</code>
<code>    } if</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /planet dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER planet--</code>
<code></code>
<code>% --BEGIN ENCODER royalmail--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear--</code>
<code>% --DESC: Royal Mail 4 State Customer Code</code>
<code>% --EXAM: LE28HS9Z</code>
<code>% --EXOP: includetext barcolor=FF0000</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp royalmail 0.0 2024010300 71959 71677</code>
<code>%%BeginData:        145 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/royalmail {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def          % Enable/disable text</code>
<code>    /validatecheck false def</code>
<code>    /includecheckintext false def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 0.175 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.royalmailEmptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /royalmail //loadctx exec</code>
<code></code>
<code>{</code>
<code>    % Create a string of the available characters</code>
<code>    /barchars (ZUVWXY501234B6789AHCDEFGNIJKLMTOPQRS) def</code>
<code>    /charvals 36 dict def</code>
<code>    0 1 35 {charvals exch dup barchars exch 1 getinterval exch put} for</code>
<code></code>
<code>    % Create an array containing the character mappings</code>
<code>    /encs</code>
<code>    [ (3300) (2211) (2301) (2310) (3201) (3210)</code>
<code>      (1122) (0033) (0123) (0132) (1023) (1032)</code>
<code>      (1302) (0213) (0303) (0312) (1203) (1212)</code>
<code>      (1320) (0231) (0321) (0330) (1221) (1230)</code>
<code>      (3102) (2013) (2103) (2112) (3003) (3012)</code>
<code>      (3120) (2031) (2121) (2130) (3021) (3030)</code>
<code>      (2) (3)</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Validate the input</code>
<code>    0 1 barcode length 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch known not {</code>
<code>            /bwipp.royalmailBadCharacter (RM4SCC must contain only capital letters and digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    /barlen barcode length validatecheck {1 sub} if def</code>
<code></code>
<code>    /checksumrow 0 def</code>
<code>    /checksumcol 0 def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        /indx charvals barcode i 1 getinterval get def</code>
<code>        /checksumrow checksumrow indx 6 idiv add def</code>
<code>        /checksumcol checksumcol indx 6 mod add def</code>
<code>    } for</code>
<code>    /checksum checksumrow 6 mod 6 mul checksumcol 6 mod add def</code>
<code>    validatecheck {</code>
<code>        barcode barlen get barchars checksum get ne {</code>
<code>            /bwipp.royalmailBadCheckDigit (Incorrect RM4SCC check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>        /barcode barcode 0 barlen getinterval def</code>
<code>    } if</code>
<code></code>
<code>    /encstr barlen 4 mul 6 add string def</code>
<code>    /txt barlen 1 add array def</code>
<code></code>
<code>    % Put start character</code>
<code>    encstr 0 encs 36 get putinterval</code>
<code></code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        /indx charvals barcode i 1 getinterval get def</code>
<code>        encstr i 4 mul 1 add encs indx get putinterval</code>
<code>        txt i [barcode i 1 getinterval i 4 mul 1 add 3.312 mul textyoffset textfont textsize] put</code>
<code>    } for</code>
<code></code>
<code>    % Put the checksum character</code>
<code>    encstr barlen 4 mul 1 add encs checksum get putinterval</code>
<code>    includecheckintext {</code>
<code>        txt barlen [barchars checksum 1 getinterval barlen 4 mul 1 add 3.312 mul textyoffset textfont textsize] put</code>
<code>    } {</code>
<code>        txt barlen [( ) barlen 4 mul 1 add 3.312 mul textyoffset textfont textsize] put</code>
<code>    } ifelse</code>
<code></code>
<code>    % Put end character</code>
<code>    encstr barlen 4 mul 5 add encs 37 get putinterval</code>
<code></code>
<code>    /bbs encstr length array def</code>
<code>    /bhs encstr length array def</code>
<code>    0 1 encstr length 1 sub {</code>
<code>        /i exch def</code>
<code>        /enc encstr i 1 getinterval def</code>
<code>        enc (0) eq {</code>
<code>            bbs i 3 height mul 8 div put</code>
<code>            bhs i 2 height mul 8 div put</code>
<code>        } if</code>
<code>        enc (1) eq {</code>
<code>            bbs i 0 height mul 8 div put</code>
<code>            bhs i 5 height mul 8 div put</code>
<code>        } if</code>
<code>        enc (2) eq {</code>
<code>            bbs i 3 height mul 8 div put</code>
<code>            bhs i 5 height mul 8 div put</code>
<code>        } if</code>
<code>        enc (3) eq {</code>
<code>            bbs i 0 height mul 8 div put</code>
<code>            bhs i 8 height mul 8 div put</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /bbs bbs</code>
<code>    /bhs bhs</code>
<code>    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]</code>
<code>    includetext {</code>
<code>        /txt txt</code>
<code>    } if</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /royalmail dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER royalmail--</code>
<code></code>
<code>% --BEGIN ENCODER auspost--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear--</code>
<code>% --DESC: AusPost 4 State Customer Code</code>
<code>% --EXAM: 5956439111ABA 9</code>
<code>% --EXOP: includetext custinfoenc=character</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp auspost 0.0 2024010300 87272 86741</code>
<code>%%BeginData:        235 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/auspost {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def         % Enable/disable text</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 0.175 def</code>
<code>    /custinfoenc (character) def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    custinfoenc (character) ne custinfoenc (numeric) ne and {</code>
<code>        /bwipp.auspostBadCustinfoEncoding (Customer information encoding must be either character or numeric) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /auspost //loadctx exec</code>
<code></code>
<code>    % Create an array containing the character mappings</code>
<code>{</code>
<code>    /encs</code>
<code>    [ (000) (001) (002) (010) (011) (012) (020) (021)</code>
<code>      (022) (100) (101) (102) (110) (111) (112) (120)</code>
<code>      (121) (122) (200) (201) (202) (210) (211) (212)</code>
<code>      (220) (221) (222) (300) (301) (302) (310) (311)</code>
<code>      (312) (320) (321) (322) (023) (030) (031) (032)</code>
<code>      (033) (103) (113) (123) (130) (131) (132) (133)</code>
<code>      (203) (213) (223) (230) (231) (232) (233) (303)</code>
<code>      (313) (323) (330) (331) (332) (333) (003) (013)</code>
<code>      (00) (01) (02) (10) (11) (12) (20) (21) (22) (30)</code>
<code>      (13) (3)</code>
<code>    ] def</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>    /barchars (ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz #) def</code>
<code></code>
<code>    % FCC lengths</code>
<code>    /fcclen &lt;&lt; (11) 37  (45) 37  (59) 52  (62) 67 &gt;&gt; def</code>
<code></code>
<code>} ctxdef</code>
<code></code>
<code>    /barlen barcode length def</code>
<code>    barlen 10 lt {</code>
<code>        /bwipp.auspostTooShort (The data length must be at least 10) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /txt barlen 2 sub array def</code>
<code></code>
<code>    fcclen barlen 2 ge { barcode 0 2 getinterval } { () } ifelse</code>
<code>    2 copy known not {</code>
<code>        pop pop /bwipp.auspostBadFCC (Must begin with an FCC, either 11, 45, 59 or 62) //raiseerror exec</code>
<code>    } if</code>
<code>    get /encstr exch string def</code>
<code></code>
<code>    % Validate that the message has a complete, numeric DPID</code>
<code>    true</code>
<code>    1 {</code>
<code>        barlen 10 lt { pop false exit } if</code>
<code>        barcode 2 8 getinterval { dup 48 lt exch 57 gt or { pop false exit } if } forall</code>
<code>    } repeat</code>
<code>    not {</code>
<code>        /bwipp.auspostIncompleteDPID (The DPID must be 8 digits) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Validate that the message will fit</code>
<code>    barlen 10 sub custinfoenc (numeric) eq {2} {3} ifelse mul</code>
<code>    encstr length 22 sub 14 sub gt {</code>
<code>        /bwipp.auspostTooLong (The message is too long) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Put start character</code>
<code>    encstr 0 encs 74 get putinterval</code>
<code></code>
<code>    % Encode the FCC</code>
<code>    0 1 1 {</code>
<code>        /i exch def</code>
<code>        encs barcode i 1 getinterval cvi 64 add get</code>
<code>        encstr i 2 mul 2 add 3 2 roll putinterval</code>
<code>    } for</code>
<code></code>
<code>    % Encode the DPID</code>
<code>    2 1 9 {</code>
<code>        /i exch def</code>
<code>        encs barcode i 1 getinterval cvi 64 add get</code>
<code>        encstr i 2 mul 2 add 3 2 roll putinterval</code>
<code>        txt i 2 sub [barcode i 1 getinterval i 2 sub 2 mul 6 add 3.312 mul textyoffset textfont textsize] put</code>
<code>    } for</code>
<code></code>
<code>    % Encode the customer information</code>
<code>    custinfoenc (numeric) eq {</code>
<code>        0 1 barlen 11 sub {</code>
<code>            /i exch def</code>
<code>            encs barcode i 10 add get</code>
<code>            dup dup 48 lt exch 57 gt or {</code>
<code>                /bwipp.auspostInvalidCustinfoDigit (The customer information data contains a non-digit character) //raiseerror exec</code>
<code>            } if</code>
<code>            48 sub 64 add get</code>
<code>            encstr i 2 mul 22 add 3 2 roll putinterval</code>
<code>            txt i 8 add [barcode i 10 add 1 getinterval i 2 mul 22 add 3.312 mul textyoffset textfont textsize] put</code>
<code>        } for</code>
<code>        /ciflen barlen 10 sub 2 mul def</code>
<code>    } {</code>
<code>        0 1 barlen 11 sub {</code>
<code>            /i exch def</code>
<code>            barcode i 10 add 1 getinterval barchars exch search</code>
<code>            not {</code>
<code>                pop /bwipp.auspostInvalidCustinfoCharacter (The customer information contains an invalid character) //raiseerror exec</code>
<code>            } if</code>
<code>            length /indx exch def</code>
<code>            pop pop</code>
<code>            /enc encs indx get def</code>
<code>            encstr i 3 mul 22 add enc putinterval</code>
<code>            txt i 8 add [barcode i 10 add 1 getinterval i 3 mul 22 add 3.312 mul textyoffset textfont textsize] put</code>
<code>        } for</code>
<code>        /ciflen barlen 10 sub 3 mul def</code>
<code>    } ifelse</code>
<code></code>
<code>    % Add any filler characters</code>
<code>    22 ciflen add 1 encstr length 14 sub {</code>
<code>        encstr exch encs 75 get putinterval</code>
<code>    } for</code>
<code></code>
<code>    % Create the 64x64 Reed-Solomon table</code>
<code>{</code>
<code>    /rstable 64 64 mul array def</code>
<code>    rstable 0 [ 64 {0} repeat ] putinterval</code>
<code>    rstable 64 [ 0 1 63 {} for ] putinterval</code>
<code>    /prev 1 def</code>
<code>    64 {</code>
<code>        /next prev 1 bitshift def</code>
<code>        next 64 and 0 ne {</code>
<code>            /next next 67 xor def</code>
<code>        } if</code>
<code>        0 1 63 {</code>
<code>            /j exch def</code>
<code>            /nextcell {rstable 64 next mul j add} def</code>
<code>            nextcell rstable 64 prev mul j add get 1 bitshift put</code>
<code>            nextcell get 64 and 0 ne {</code>
<code>                nextcell nextcell get 67 xor put</code>
<code>            } if</code>
<code>        } for</code>
<code>        /prev next def</code>
<code>    } repeat</code>
<code>} ctxdef</code>
<code></code>
<code>    % Calculate the Reed-Solomon codes for triples</code>
<code>    /rscodes encstr length 16 sub 3 idiv 4 add array def</code>
<code>    rscodes 0 [ 4 {0} repeat ] putinterval</code>
<code>    2 3 encstr length 16 sub {</code>
<code>        /i exch def</code>
<code>        rscodes rscodes length i 2 sub 3 idiv sub 1 sub</code>
<code>        encstr i 1 getinterval cvi 16 mul</code>
<code>        encstr i 1 add 1 getinterval cvi 4 mul add</code>
<code>        encstr i 2 add 1 getinterval cvi add</code>
<code>        put</code>
<code>    } for</code>
<code>    rscodes length 5 sub -1 0 {</code>
<code>       /i exch def</code>
<code>       0 1 4 {</code>
<code>           /j exch def</code>
<code>           rscodes i j add rscodes i j add get</code>
<code>           rstable 64 [48 17 29 30 1] j get mul rscodes i 4 add get add get</code>
<code>           xor put</code>
<code>       } for</code>
<code>    } for</code>
<code>    /checkcode (000000000000) 12 string copy def</code>
<code>    0 1 3 {</code>
<code>        /i exch def</code>
<code>        /enc rscodes 3 i sub get 4 3 string cvrs def</code>
<code>        checkcode i 3 mul 3 enc length sub add enc putinterval</code>
<code>    } for</code>
<code></code>
<code>    % Put checkcode and end characters</code>
<code>    encstr encstr length 14 sub checkcode putinterval</code>
<code>    encstr encstr length 2 sub encs 74 get putinterval</code>
<code></code>
<code>    /bbs encstr length array def</code>
<code>    /bhs encstr length array def</code>
<code>    0 1 encstr length 1 sub {</code>
<code>        /i exch def</code>
<code>        /enc encstr i 1 getinterval def</code>
<code>        enc (0) eq {</code>
<code>            bbs i 0 height mul 8 div put</code>
<code>            bhs i 8 height mul 8 div put</code>
<code>        } if</code>
<code>        enc (1) eq {</code>
<code>            bbs i 3 height mul 8 div put</code>
<code>            bhs i 5 height mul 8 div put</code>
<code>        } if</code>
<code>        enc (2) eq {</code>
<code>            bbs i 0 height mul 8 div put</code>
<code>            bhs i 5 height mul 8 div put</code>
<code>        } if</code>
<code>        enc (3) eq {</code>
<code>            bbs i 3 height mul 8 div put</code>
<code>            bhs i 2 height mul 8 div put</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /bbs bbs</code>
<code>    /bhs bhs</code>
<code>    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]</code>
<code>    includetext {</code>
<code>        /txt txt</code>
<code>    } if</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /auspost dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER auspost--</code>
<code></code>
<code>% --BEGIN ENCODER kix--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear--</code>
<code>% --DESC: Royal Dutch TPG Post KIX</code>
<code>% --EXAM: 1231FZ13XHS</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp kix 0.0 2024010300 67079 66848</code>
<code>%%BeginData:        111 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/kix {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def          % Enable/disable text</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 0.175 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.kixEmptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /kix //loadctx exec</code>
<code></code>
<code>{</code>
<code>    % Create an array containing the character mappings</code>
<code>    /encs</code>
<code>    [ (0033) (0123) (0132) (1023) (1032) (1122)</code>
<code>      (0213) (0303) (0312) (1203) (1212) (1302)</code>
<code>      (0231) (0321) (0330) (1221) (1230) (1320)</code>
<code>      (2013) (2103) (2112) (3003) (3012) (3102)</code>
<code>      (2031) (2121) (2130) (3021) (3030) (3120)</code>
<code>      (2211) (2301) (2310) (3201) (3210) (3300)</code>
<code>    ] def</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ) def</code>
<code>    /charvals 36 dict def</code>
<code>    0 1 35 {charvals exch dup barchars exch 1 getinterval exch put} for</code>
<code>} ctxdef</code>
<code></code>
<code>    % Validate the input</code>
<code>    0 1 barcode length 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch known not {</code>
<code>            /bwipp.kixBadCharacter (KIX must contain only capital letters and digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    /barlen barcode length def</code>
<code>    /encstr barlen 4 mul string def</code>
<code>    /txt barlen array def</code>
<code></code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        /indx charvals barcode i 1 getinterval get def</code>
<code>        encstr i 4 mul encs indx get putinterval</code>
<code>        txt i [barcode i 1 getinterval i 4 mul 3.312 mul textyoffset textfont textsize] put</code>
<code>    } for</code>
<code></code>
<code>    /bbs encstr length array def</code>
<code>    /bhs encstr length array def</code>
<code>    0 1 encstr length 1 sub {</code>
<code>        /i exch def</code>
<code>        /enc encstr i 1 getinterval def</code>
<code>        enc (0) eq {</code>
<code>            bbs i 3 height mul 8 div put</code>
<code>            bhs i 2 height mul 8 div put</code>
<code>        } if</code>
<code>        enc (1) eq {</code>
<code>            bbs i 0 height mul 8 div put</code>
<code>            bhs i 5 height mul 8 div put</code>
<code>        } if</code>
<code>        enc (2) eq {</code>
<code>            bbs i 3 height mul 8 div put</code>
<code>            bhs i 5 height mul 8 div put</code>
<code>        } if</code>
<code>        enc (3) eq {</code>
<code>            bbs i 0 height mul 8 div put</code>
<code>            bhs i 8 height mul 8 div put</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /bbs bbs</code>
<code>    /bhs bhs</code>
<code>    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]</code>
<code>    includetext {</code>
<code>        /txt txt</code>
<code>    } if</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /kix dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER kix--</code>
<code></code>
<code>% --BEGIN ENCODER japanpost--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear--</code>
<code>% --DESC: Japan Post 4 State Customer Code</code>
<code>% --EXAM: 6540123789-A-K-Z</code>
<code>% --EXOP: includetext includecheckintext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp japanpost 0.0 2024010300 74254 73854</code>
<code>%%BeginData:        176 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/japanpost {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def          % Enable/disable text</code>
<code>    /includecheckintext false def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 0.175 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.japanpostEmptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /japanpost //loadctx exec</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode {</code>
<code>        dup dup 48 ge exch 57 le and exch  % 0-9</code>
<code>        dup dup 65 ge exch 90 le and exch  % A-Z</code>
<code>        45 eq or or not {                  % "-"</code>
<code>            /bwipp.japanpostBadCharacter (Japan Post must contain only digits, capital letters and the dash symbol) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>{</code>
<code>    % Create an array containing the character mappings</code>
<code>    /encs</code>
<code>    [ (300) (330) (312) (132) (321) (303) (123) (231) (213) (033) (030)  % 0-9 and "-"</code>
<code>      (120) (102) (210) (012) (201) (021) (003) (333)                    % C1-C8</code>
<code>      (31) (13)                                                          % ST EN</code>
<code>    ] def</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>    /barchars (0123456789-ABCDEFGHIJKLMNOPQRSTUVWXYZ) def</code>
<code>} ctxdef</code>
<code></code>
<code>    /barlen barcode length def</code>
<code></code>
<code>    /encstr 20 1 add 3 mul 4 add string def</code>
<code>    /digits 20 array def</code>
<code>    /txt barlen 1 add array def</code>
<code></code>
<code>    % Put start character</code>
<code>    encstr 0 encs 19 get putinterval</code>
<code></code>
<code>    /checksum 0 def</code>
<code>    /j 0 def /i 0 def</code>
<code>    true</code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        barcode i 1 getinterval barchars exch search</code>
<code>        pop                                  % Discard true leaving pre</code>
<code>        length /indx exch def                % indx is the length of pre</code>
<code>        pop pop                              % Discard match and post</code>
<code>        indx 11 ge indx 37 lt and {          % Insert escape</code>
<code>            j 18 gt {pop false exit} if      % Should fit in 20 chars</code>
<code>                                             % 11-20: C1 (11)</code>
<code>                                             % 21-30: C2 (12)</code>
<code>                                             % 31-36: C3 (13)</code>
<code>            /digit indx 1 sub 10 idiv 10 add def</code>
<code>            encstr j 3 mul 2 add encs digit get putinterval</code>
<code>            /checksum checksum digit add def</code>
<code>            digits j digit put</code>
<code>            /j j 1 add def</code>
<code>        } if</code>
<code>        j 19 gt {pop false exit} if          % Should fit in 20 chars</code>
<code>        /digit 0 def</code>
<code>        indx 37 eq {</code>
<code>            /digit 14 def                    % space (C14)</code>
<code>        } if</code>
<code>        indx 11 ge indx 37 lt and {</code>
<code>            /digit indx 1 sub 10 mod def</code>
<code>        } if</code>
<code>        indx 11 lt {</code>
<code>            /digit indx def</code>
<code>        } if</code>
<code>        encstr j 3 mul 2 add encs digit get putinterval % space</code>
<code>        /checksum checksum digit add def</code>
<code>        digits j digit put</code>
<code>        txt i [barcode i 1 getinterval j 3 mul 2 add 3.312 mul textyoffset textfont textsize] put</code>
<code>        /j j 1 add def</code>
<code>    } for</code>
<code></code>
<code>    not {</code>
<code>        /bwipp.japanpostTooLong (The input is too long) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Fill spaces (c14) at right end</code>
<code>    j 1 20 1 sub {</code>
<code>        /k exch def</code>
<code>        encstr k 3 mul 2 add encs 14 get putinterval</code>
<code>        /checksum checksum 14 add def</code>
<code>        digits k 14 put</code>
<code>    } for</code>
<code></code>
<code>    % Put the checksum character</code>
<code>    /checksum checksum 19 mod 19 exch sub def</code>
<code>    encstr 2 20 3 mul add encs checksum get putinterval</code>
<code></code>
<code>    % Put end character</code>
<code>    encstr 2 21 3 mul add encs 20 get putinterval</code>
<code>    /checkdigit ( ) def</code>
<code>    includecheckintext {</code>
<code>        /checkdigit barchars checksum 1 getinterval def</code>
<code>    } if</code>
<code>    txt i 1 add [ checkdigit 20 3 mul 2 add 3.312 mul textyoffset textfont textsize] put</code>
<code></code>
<code>    % Put end character</code>
<code>    encstr 20 1 add 3 mul 2 add encs 20 get putinterval</code>
<code></code>
<code>    /bbs 21 3 mul 4 add array def</code>
<code>    /bhs bbs length array def</code>
<code>    0 1 bbs length 1 sub {</code>
<code>        /i exch def</code>
<code>        /enc encstr i 1 getinterval def</code>
<code>        /bunit 0 def</code>
<code>        /hunit 0 def</code>
<code>        enc (0) eq {</code>
<code>            /bunit 3 def</code>
<code>            /hunit 2 def</code>
<code>        } if</code>
<code>        enc (1) eq {</code>
<code>            /bunit 0 def</code>
<code>            /hunit 5 def</code>
<code>        } if</code>
<code>        enc (2) eq {</code>
<code>            /bunit 3 def</code>
<code>            /hunit 5 def</code>
<code>        } if</code>
<code>        enc (3) eq {</code>
<code>            /bunit 0 def</code>
<code>            /hunit 8 def</code>
<code>        } if</code>
<code>        bbs i bunit height mul 8 div put</code>
<code>        bhs i hunit height mul 8 div put</code>
<code>    } for</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /bbs bbs</code>
<code>    /bhs bhs</code>
<code>    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]</code>
<code>    includetext {</code>
<code>        /txt txt</code>
<code>    } if</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /japanpost dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER japanpost--</code>
<code></code>
<code>% --BEGIN ENCODER msi--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear--</code>
<code>% --DESC: MSI Modified Plessey</code>
<code>% --EXAM: 0123456789</code>
<code>% --EXOP: includetext includecheck includecheckintext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp msi 0.0 2024010300 79911 79532</code>
<code>%%BeginData:        168 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/msi {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includecheck false def  % Enable/disable checkdigit</code>
<code>    /includetext false def   % Enable/disable text</code>
<code>    /includecheckintext false def</code>
<code>    /checktype (unset) def</code>
<code>    /badmod11 false def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 1.0 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    checktype (unset) ne includecheck not and {</code>
<code>        /bwipp.msiCheckTypeWithoutCheck (checktype requires includecheck) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    badmod11 checktype (mod11) ne checktype (ncrmod11) ne and checktype (mod1110) ne and checktype (ncrmod1110) ne and and {</code>
<code>        /bwipp.msiBadMod11Mismatch (badmod11 requires checktype with mod11) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    checktype (unset) eq { /checktype (mod10) def } if</code>
<code></code>
<code>    /msi //loadctx exec</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.msiBadCharacter (MSI must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>{</code>
<code>    % Create an array containing the character mappings</code>
<code>    /encs</code>
<code>    [ (12121212) (12121221) (12122112) (12122121) (12211212)</code>
<code>      (12211221) (12212112) (12212121) (21121212) (21121221)</code>
<code>      (21) (121)</code>
<code>    ] def</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>    /barchars (0123456789) def</code>
<code>} ctxdef</code>
<code></code>
<code>    /barlen barcode length def     % Length of the code</code>
<code>    /txtlen barlen def</code>
<code></code>
<code>    /mod10 {</code>
<code>        /code exch def</code>
<code>        0 0 code {48 sub exch 10 mul add exch} forall pop 2 mul</code>
<code>        0 {1 index 10 mod add exch 10 idiv dup 0 eq {pop exit} if exch} loop</code>
<code>        0 0 code {48 sub add exch} forall exch pop add</code>
<code>        10 mod 10 exch sub 10 mod</code>
<code>        code length 1 add string dup 0 code putinterval dup code length 4 -1 roll 48 add put</code>
<code>    } def</code>
<code></code>
<code>    /mod11 {</code>
<code>        /code exch def</code>
<code>        code length 1 sub code {48 sub exch dup 1 sub exch 6 mod 2 add exch} forall pop</code>
<code>        0 code length {3 1 roll mul add} repeat</code>
<code>        11 mod 11 exch sub 11 mod</code>
<code>        dup 10 eq {</code>
<code>            badmod11 {</code>
<code>                pop code length 2 add string dup 0 code putinterval dup code length (10) putinterval</code>
<code>            } {</code>
<code>                pop /bwipp.msiBadMod11NotSpecified (mod11 check digit is 10 but badmod11 not specified) //raiseerror exec</code>
<code>            } ifelse</code>
<code>        } {</code>
<code>            code length 1 add string dup 0 code putinterval dup code length 4 -1 roll 48 add put</code>
<code>        } ifelse</code>
<code>    } def</code>
<code></code>
<code>    /ncrmod11 {</code>
<code>        /code exch def</code>
<code>        code length 1 sub code {48 sub exch dup 1 sub exch 8 mod 2 add exch} forall pop</code>
<code>        0 code length {3 1 roll mul add} repeat</code>
<code>        11 mod 11 exch sub 11 mod</code>
<code>        dup 10 eq {</code>
<code>            badmod11 {</code>
<code>                pop code length 2 add string dup 0 code putinterval dup code length (10) putinterval</code>
<code>            } {</code>
<code>                pop /bwipp.msiBadMod11NotSpecified (mod11 check digit is 10 but badmod11 not specified) //raiseerror exec</code>
<code>            } ifelse</code>
<code>        } {</code>
<code>            code length 1 add string dup 0 code putinterval dup code length 4 -1 roll 48 add put</code>
<code>        } ifelse</code>
<code>    } def</code>
<code></code>
<code>{</code>
<code>    /checkfunc &lt;&lt;</code>
<code>        /mod10      { mod10 }</code>
<code>        /mod1010    { mod10 mod10 }</code>
<code>        /mod11      { mod11 }</code>
<code>        /ncrmod11   { ncrmod11 }</code>
<code>        /mod1110    { mod11 mod10 }</code>
<code>        /ncrmod1110 { ncrmod11 mod10 }</code>
<code>    &gt;&gt; def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Calculate checksum</code>
<code>    includecheck {</code>
<code>        checkfunc checktype 2 copy known not {</code>
<code>            pop pop /bwipp.msiBadCharacter (MSI checktype must be mod10, mod1010, mod11, ncrmod11, mod1110 or ncrmod1110) //raiseerror exec</code>
<code>        } if</code>
<code>        get barcode exch exec /barcode exch def</code>
<code>        /barlen barcode length def</code>
<code>        includecheckintext {/txtlen barlen def} if</code>
<code>    } if</code>
<code></code>
<code>    /sbs barlen 8 mul 5 add string def</code>
<code>    /txt barlen array def</code>
<code></code>
<code>    % Put start character</code>
<code>    sbs 0 encs 10 get putinterval</code>
<code></code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        % Lookup the encoding for the each barcode character</code>
<code>        barcode i 1 getinterval barchars exch search</code>
<code>        pop                                % Discard true leaving pre</code>
<code>        length /indx exch def              % indx is the length of pre</code>
<code>        pop pop                            % Discard seek and post</code>
<code>        /enc encs indx get def             % Get the indxth encoding</code>
<code>        sbs i 8 mul 2 add enc putinterval  % Put encoded digit into sbs</code>
<code>        txt i [barcode i 1 getinterval i 12 mul 3 add textyoffset textfont textsize] put</code>
<code>    } for</code>
<code></code>
<code>    % Put the end character</code>
<code>    sbs barlen 8 mul 2 add encs 11 get putinterval</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs [sbs {48 sub} forall]</code>
<code>    /bhs [sbs length 1 add 2 idiv {height} repeat]</code>
<code>    /bbs [sbs length 1 add 2 idiv {0} repeat]</code>
<code>    includetext {</code>
<code>        /txt txt 0 txtlen getinterval</code>
<code>    } if</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /msi dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER msi--</code>
<code></code>
<code>% --BEGIN ENCODER plessey--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear--</code>
<code>% --DESC: Plessey UK</code>
<code>% --EXAM: 01234ABCD</code>
<code>% --EXOP: includetext includecheckintext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp plessey 0.0 2024010300 73583 73305</code>
<code>%%BeginData:        146 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/plessey {</code>
<code></code>
<code>    20 dict begin                  % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def    % Enable/disable text</code>
<code>    /validatecheck false def</code>
<code>    /includecheckintext false def</code>
<code>    /unidirectional false def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 1.0 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.plesseyEmptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /plessey //loadctx exec</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>{</code>
<code>    /barchars (0123456789ABCDEF) def</code>
<code>    /charvals 16 dict def</code>
<code>    0 1 15 {charvals exch dup barchars exch 1 getinterval exch put} for</code>
<code></code>
<code>    % Create an array containing the character mappings</code>
<code>    /encs</code>
<code>    [ (14141414) (32141414) (14321414) (32321414)</code>
<code>      (14143214) (32143214) (14323214) (32323214)</code>
<code>      (14141432) (32141432) (14321432) (32321432)</code>
<code>      (14143232) (32143232) (14323232) (32323232)</code>
<code>      (32321432) (541412323) (323)</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Validate the input</code>
<code>    0 1 barcode length 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch known not {</code>
<code>            /bwipp.plesseyBadCharacter (Plessey must contain only digits and letters A B C D E F) //raiseerror exec</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    /barlen barcode length validatecheck {2 sub} if def</code>
<code></code>
<code>    % Calculate the checksums</code>
<code>    /checkbits barlen 4 mul 8 add array def</code>
<code>    checkbits barlen 4 mul [ 0 0 0 0 0 0 0 0 ] putinterval</code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        /indx charvals barcode i 1 getinterval get def</code>
<code>        checkbits i 4 mul [</code>
<code>                indx 1 and</code>
<code>                indx -1 bitshift 1 and</code>
<code>                indx -2 bitshift 1 and</code>
<code>                indx -3 bitshift</code>
<code>        ] putinterval</code>
<code>    } for</code>
<code>    /checksalt [ 1 1 1 1 0 1 0 0 1 ] def</code>
<code>    0 1 barlen 4 mul 1 sub {</code>
<code>        /i exch def</code>
<code>        checkbits i get 1 eq {</code>
<code>            0 1 8 {</code>
<code>                /j exch def</code>
<code>                checkbits i j add checkbits i j add get checksalt j get xor put</code>
<code>            } for</code>
<code>        } if</code>
<code>    } for</code>
<code>    /checkval 0 def</code>
<code>    0 1 7 {</code>
<code>        /i exch def</code>
<code>        /checkval checkval 2 i exp cvi checkbits barlen 4 mul i add get mul add def</code>
<code>    } for</code>
<code>    /checksum1 checkval 15 and def</code>
<code>    /checksum2 checkval -4 bitshift def</code>
<code>    validatecheck {</code>
<code>        barcode barlen get barchars checksum1 get ne</code>
<code>        barcode barlen 1 add get barchars checksum2 get ne or {</code>
<code>            /bwipp.plesseyBadCheckDigits (Incorrect Plessey check digits provided) //raiseerror exec</code>
<code>        } if</code>
<code>        /barcode barcode 0 barlen getinterval def</code>
<code>    } if</code>
<code></code>
<code>    /sbs barlen 8 mul unidirectional {27} {33} ifelse add string def</code>
<code>    /txt barlen 2 add array def</code>
<code></code>
<code>    % Put start character</code>
<code>    sbs 0 encs 16 get putinterval</code>
<code></code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        /indx charvals barcode i 1 getinterval get def</code>
<code>        sbs i 8 mul 8 add encs indx get putinterval</code>
<code>        txt i [barcode i 1 getinterval i 20 mul 20 add textyoffset textfont textsize] put</code>
<code>    } for</code>
<code></code>
<code>    % Put the checksum characters</code>
<code>    sbs barlen 8 mul 8 add encs checksum1 get putinterval</code>
<code>    sbs barlen 8 mul 16 add encs checksum2 get putinterval</code>
<code>    includecheckintext {</code>
<code>        txt barlen [barchars checksum1 1 getinterval barlen 20 mul 20 add textyoffset textfont textsize] put</code>
<code>        txt barlen 1 add [barchars checksum2 1 getinterval barlen 1 add 20 mul 20 add textyoffset textfont textsize] put</code>
<code>    } {</code>
<code>        txt barlen [( ) barlen 20 mul 20 add textyoffset textfont textsize] put</code>
<code>        txt barlen 1 add [( ) barlen 1 add 20 mul 20 add textyoffset textfont textsize] put</code>
<code>    } ifelse</code>
<code></code>
<code>    % Put end character</code>
<code>    sbs barlen 8 mul 24 add encs unidirectional {18} {17} ifelse get putinterval</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs [sbs {48 sub} forall]</code>
<code>    /bhs [sbs length 1 add 2 idiv {height} repeat]</code>
<code>    /bbs [sbs length 1 add 2 idiv {0} repeat]</code>
<code>    includetext {</code>
<code>        /txt txt</code>
<code>    } if</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /plessey dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER plessey--</code>
<code></code>
<code>% --BEGIN ENCODER telepen--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renlinear--</code>
<code>% --DESC: Telepen</code>
<code>% --EXAM: ABCDEF</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp telepen 0.0 2024010300 74651 77695</code>
<code>%%BeginData:        173 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/telepen {</code>
<code></code>
<code>    20 dict begin                  % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /numeric false def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def    % Enable/disable text</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 1.0 def</code>
<code>    /parse false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /telepen //loadctx exec</code>
<code></code>
<code>    % Parse ordinals of the form ^NNN to ASCII</code>
<code>    /fncvals &lt;&lt;</code>
<code>        /parse parse</code>
<code>        /parseonly true</code>
<code>        /parsefnc false</code>
<code>    &gt;&gt; def</code>
<code>    /barcode barcode fncvals //parseinput exec def</code>
<code>    /barlen barcode length def</code>
<code>    options (parse) undef</code>
<code></code>
<code>    numeric barlen 2 mod 0 ne and {</code>
<code>        /bwipp.telepenNumericOddLength (Telepen Numeric must have an even length) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Create an array containing the character mappings</code>
<code>{</code>
<code>    /encs</code>
<code>    [ (31313131)        (1131313111)     (33313111)       (1111313131)</code>
<code>      (3111313111)      (11333131)       (13133131)       (111111313111)</code>
<code>      (31333111)        (1131113131)     (33113131)       (1111333111)</code>
<code>      (3111113131)      (1113133111)     (1311133111)     (111111113131)</code>
<code>      (3131113111)      (11313331)       (333331)         (111131113111)</code>
<code>      (31113331)        (1133113111)     (1313113111)     (1111113331)</code>
<code>      (31131331)        (113111113111)   (3311113111)     (1111131331)</code>
<code>      (311111113111)    (1113111331)     (1311111331)     (11111111113111)</code>
<code>      (31313311)        (1131311131)     (33311131)       (1111313311)</code>
<code>      (3111311131)      (11333311)       (13133311)       (111111311131)</code>
<code>      (31331131)        (1131113311)     (33113311)       (1111331131)</code>
<code>      (3111113311)      (1113131131)     (1311131131)     (111111113311)</code>
<code>      (3131111131)      (1131131311)     (33131311)       (111131111131)</code>
<code>      (3111131311)      (1133111131)     (1313111131)     (111111131311)</code>
<code>      (3113111311)      (113111111131)   (3311111131)     (111113111311)</code>
<code>      (311111111131)    (111311111311)   (131111111311)   (11111111111131)</code>
<code>      (3131311111)      (11313133)       (333133)         (111131311111)</code>
<code>      (31113133)        (1133311111)     (1313311111)     (1111113133)</code>
<code>      (313333)          (113111311111)   (3311311111)     (11113333)</code>
<code>      (311111311111)    (11131333)       (13111333)       (11111111311111)</code>
<code>      (31311133)        (1131331111)     (33331111)       (1111311133)</code>
<code>      (3111331111)      (11331133)       (13131133)       (111111331111)</code>
<code>      (3113131111)      (1131111133)     (33111133)       (111113131111)</code>
<code>      (3111111133)      (111311131111)   (131111131111)   (111111111133)</code>
<code>      (31311313)        (113131111111)   (3331111111)     (1111311313)</code>
<code>      (311131111111)    (11331313)       (13131313)       (11111131111111)</code>
<code>      (3133111111)      (1131111313)     (33111313)       (111133111111)</code>
<code>      (3111111313)      (111313111111)   (131113111111)   (111111111313)</code>
<code>      (313111111111)    (1131131113)     (33131113)       (11113111111111)</code>
<code>      (3111131113)      (113311111111)   (131311111111)   (111111131113)</code>
<code>      (3113111113)      (11311111111111) (331111111111)   (111113111113)</code>
<code>      (31111111111111)  (111311111113)   (131111111113)   (1111111111111111)</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /sbs barlen 16 mul 48 add string def</code>
<code>    /txt barlen array def</code>
<code></code>
<code>    % Put the start character ASCII 95</code>
<code>    /enc encs 95 get def</code>
<code>    sbs 0 enc putinterval</code>
<code>    /l enc length def</code>
<code></code>
<code>    /checksum 0 def</code>
<code>    /i 0 def /j 0 def</code>
<code>    { % loop</code>
<code>        i barlen eq {exit} if</code>
<code>        numeric {</code>
<code>            barcode i get 16 gt {  % 00-99 or 0X-9X</code>
<code>                /np barcode i 2 getinterval def</code>
<code>                np 0 get dup 48 lt exch 57 gt or</code>
<code>                np 1 get dup 48 lt 1 index 57 gt or exch 88 eq not and</code>
<code>                or {</code>
<code>                    -1</code>
<code>                } {</code>
<code>                    np 0 get 48 sub</code>
<code>                    np 1 get 48 sub dup 40 ne { exch 10 mul add 10 add } { pop } ifelse</code>
<code>                    17 add</code>
<code>                } ifelse</code>
<code>                dup -1 eq {</code>
<code>                    /bwipp.telepenInvalidNumericCharacter (Telepen Numeric may contain only digits, or X in even positions) //raiseerror exec</code>
<code>                } if</code>
<code>                /indx exch def</code>
<code>                txt j [np j 16 mul 16 add textyoffset textfont textsize] put</code>
<code>                /i i 2 add def</code>
<code>            } {  % Ordinal values 0-16</code>
<code>                /indx barcode i get def</code>
<code>                txt j [( ) j 16 mul 16 add textyoffset textfont textsize] put</code>
<code>                /i i 1 add def</code>
<code>            } ifelse</code>
<code>        } {  % ASCII mode</code>
<code>            /indx barcode i get def</code>
<code>            indx 127 gt {</code>
<code>                /bwipp.telepenInvalidAlphaCharacter (Telepen Alpha characters must have ordinal values 0 to 127) //raiseerror exec</code>
<code>            } if</code>
<code>            indx 32 ge indx 126 le and {</code>
<code>                txt j [barcode i 1 getinterval j 16 mul 16 add textyoffset textfont textsize] put</code>
<code>            } {</code>
<code>                txt j [( ) j 16 mul 16 add textyoffset textfont textsize] put</code>
<code>            } ifelse</code>
<code>            /i i 1 add def</code>
<code>        } ifelse</code>
<code>        /checksum checksum indx add def</code>
<code>        /enc encs indx get def</code>
<code>        sbs l enc putinterval          % Put encoded digit into sbs</code>
<code>        /l l enc length add def</code>
<code>        /j j 1 add def</code>
<code>    } loop</code>
<code></code>
<code>    % Put the checksum character</code>
<code>    /checksum 127 checksum 127 mod sub 127 mod def</code>
<code>    /enc encs checksum get def</code>
<code>    sbs l enc putinterval</code>
<code>    /l l enc length add def</code>
<code></code>
<code>    % Put the end character ASCII 122</code>
<code>    /enc encs 122 get def</code>
<code>    sbs l enc putinterval</code>
<code>    /l l enc length add def</code>
<code></code>
<code>    % Shrink sbs and txt to fit exactly</code>
<code>    /sbs sbs 0 l getinterval def</code>
<code>    /txt txt 0 j getinterval def</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs [sbs {48 sub} forall]</code>
<code>    /bhs [sbs length 1 add 2 idiv {height} repeat]</code>
<code>    /bbs [sbs length 1 add 2 idiv {0} repeat]</code>
<code>    includetext {</code>
<code>        /txt txt</code>
<code>    } if</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /telepen dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER telepen--</code>
<code></code>
<code>% --BEGIN ENCODER telepennumeric--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renlinear telepen--</code>
<code>% --DESC: Telepen Numeric</code>
<code>% --EXAM: 01234567</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp telepennumeric 0.0 2024010300 63095 63061</code>
<code>%%BeginData:         36 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /telepen dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/telepennumeric {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Get the result of encoding with telepen with numeric=true</code>
<code>    options (dontdraw) true put</code>
<code>    options (numeric) true put</code>
<code></code>
<code>    /args barcode options //telepen exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /telepennumeric dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER telepennumeric--</code>
<code></code>
<code>% --BEGIN ENCODER posicode--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renlinear--</code>
<code>% --DESC: PosiCode</code>
<code>% --EXAM: ABC123</code>
<code>% --EXOP: version=b inkspread=-0.5 parsefnc includetext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp posicode 0.0 2024010300 116031 118710</code>
<code>%%BeginData:        395 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/posicode {</code>
<code></code>
<code>    20 dict begin                  % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def    % Enable/disable text</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textxoffset 0.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 1.0 def</code>
<code>    /encoding (auto) def</code>
<code>    /version (a) def</code>
<code>    /checkoffset 0 def</code>
<code>    /raw false def</code>
<code>    /parse false def</code>
<code>    /parsefnc false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /posicode //loadctx exec</code>
<code></code>
<code>{</code>
<code>    % Special function characters</code>
<code>    /la0  -1 def  /la1  -2 def  /la2  -3 def</code>
<code>    /sf0  -4 def  /sf1  -5 def  /sf2  -6 def</code>
<code>    /fn1  -7 def  /fn2  -8 def  /fn3  -9 def  /fn4 -10 def</code>
<code></code>
<code>    % Character maps for each state</code>
<code>    /charmapsnormal [</code>
<code>          %  0    1    2        0    1    2        0    1    2</code>
<code>          [ (0)  (^)  (') ]  [ (1)  (;)   27 ]  [ (2)  (&lt;)   28 ]  % 0-2</code>
<code>          [ (3)  (=)   29 ]  [ (4)  (&gt;)   30 ]  [ (5)  (?)   31 ]  % 3-5</code>
<code>          [ (6)  (@)  (!) ]  [ (7)  ([)  (") ]  [ (8)   92  (#) ]  % 6-8</code>
<code>          [ (9)  (])  (&amp;) ]  [ (A)  (a)    1 ]  [ (B)  (b)    2 ]  % 9-11</code>
<code>          [ (C)  (c)    3 ]  [ (D)  (d)    4 ]  [ (E)  (e)    5 ]  % 12-14</code>
<code>          [ (F)  (f)    6 ]  [ (G)  (g)    7 ]  [ (H)  (h)    8 ]  % 15-17</code>
<code>          [ (I)  (i)    9 ]  [ (J)  (j)   10 ]  [ (K)  (k)   11 ]  % 18-20</code>
<code>          [ (L)  (l)   12 ]  [ (M)  (m)   13 ]  [ (N)  (n)   14 ]  % 21-23</code>
<code>          [ (O)  (o)   15 ]  [ (P)  (p)   16 ]  [ (Q)  (q)   17 ]  % 24-26</code>
<code>          [ (R)  (r)   18 ]  [ (S)  (s)   19 ]  [ (T)  (t)   20 ]  % 27-29</code>
<code>          [ (U)  (u)   21 ]  [ (V)  (v)   22 ]  [ (W)  (w)   23 ]  % 30-32</code>
<code>          [ (X)  (x)   24 ]  [ (Y)  (y)   25 ]  [ (Z)  (z)   26 ]  % 33-35</code>
<code>          [ (-)  (_)   40 ]  [ (.)  (`)   41 ]  [ ( )  127    0 ]  % 36-38</code>
<code>          [ ($)  ({)  (*) ]  [ (/)  (|)  (,) ]  [ (+)  (})  (:) ]  % 39-41</code>
<code>          [ (%)  (~)  fn1 ]  [ la1  la0  fn2 ]  [ sf1  sf0  fn3 ]  % 42-44</code>
<code>          [ sf2  sf2  fn4 ]                                        % 45</code>
<code>    ] def</code>
<code>    /chapmapslimited [</code>
<code>          [ (0)  -98  -98 ]  [ (1)  -98   -98 ]  [ (2)  -98  -98 ]  % 0-2</code>
<code>          [ (3)  -98  -98 ]  [ (4)  -98   -98 ]  [ (5)  -98  -98 ]  % 3-5</code>
<code>          [ (6)  -98  -98 ]  [ (7)  -98   -98 ]  [ (8)  -98  -98 ]  % 6-8</code>
<code>          [ (9)  -98  -98 ]  [ (A)  -98   -98 ]  [ (B)  -98  -98 ]  % 9-11</code>
<code>          [ (C)  -98  -98 ]  [ (D)  -98   -98 ]  [ (E)  -98  -98 ]  % 12-14</code>
<code>          [ (F)  -98  -98 ]  [ (G)  -98   -98 ]  [ (H)  -98  -98 ]  % 15-17</code>
<code>          [ (I)  -98  -98 ]  [ (J)  -98   -98 ]  [ (K)  -98  -98 ]  % 18-20</code>
<code>          [ (L)  -98  -98 ]  [ (M)  -98   -98 ]  [ (N)  -98  -98 ]  % 21-23</code>
<code>          [ (O)  -98  -98 ]  [ (P)  -98   -98 ]  [ (Q)  -98  -98 ]  % 24-26</code>
<code>          [ (R)  -98  -98 ]  [ (S)  -98   -98 ]  [ (T)  -98  -98 ]  % 27-29</code>
<code>          [ (U)  -98  -98 ]  [ (V)  -98   -98 ]  [ (W)  -98  -98 ]  % 30-32</code>
<code>          [ (X)  -98  -98 ]  [ (Y)  -98   -98 ]  [ (Z)  -98  -98 ]  % 33-35</code>
<code>          [ (-)  -98  -98 ]  [ (.)  -98   -98 ]                     % 36-37</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    version (a) ne version (b) ne and version (limiteda) ne and version (limitedb) ne and {</code>
<code>        /bwipp.posicodeInvalidVersion (The version must be either a, b, limiteda or limitedb) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /charmaps version (a) eq version (b) eq or {charmapsnormal} {chapmapslimited} ifelse def</code>
<code></code>
<code>    % Invert charmaps to give character to value maps for each state</code>
<code>    /charvals [</code>
<code>        charmaps length dict charmaps length dict charmaps length dict</code>
<code>    ] def</code>
<code>    0 1 charmaps length 1 sub {</code>
<code>        /i exch def</code>
<code>        /encs charmaps i get def</code>
<code>        0 1 2 {</code>
<code>            /j exch def</code>
<code>            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required</code>
<code>            charvals j get exch i put</code>
<code>        } for</code>
<code>    } for</code>
<code>    /set0 charvals 0 get def</code>
<code>    /set1 charvals 1 get def</code>
<code>    /set2 charvals 2 get def</code>
<code></code>
<code>    % Validate the input if limited</code>
<code>    version (limiteda) eq version (limitedb) eq or {</code>
<code>        0 1 barcode length 1 sub {</code>
<code>            barcode exch 1 getinterval 0 get set0 exch known not {</code>
<code>                /bwipp.posicodeBadCharacter (Posicode limited must contain only digits, capital letters, and the symbols - and .) //raiseerror exec</code>
<code>            } if</code>
<code>        } for</code>
<code>    } if</code>
<code></code>
<code>    raw {/encoding (raw) def} if</code>
<code></code>
<code>    encoding (raw) eq {</code>
<code>        /cws barcode length array def</code>
<code>        /i 0 def /j 0 def</code>
<code>        { % loop</code>
<code>            i barcode length eq {exit} if</code>
<code>            /cw barcode i 1 add 3 getinterval cvi def</code>
<code>            cws j cw put</code>
<code>            /i i 4 add def</code>
<code>            /j j 1 add def</code>
<code>        } loop</code>
<code>        /cws cws 0 j getinterval def</code>
<code>        /text () def</code>
<code>    } if</code>
<code></code>
<code>    encoding (auto) eq {</code>
<code></code>
<code>        % Parse the input</code>
<code>        /fncvals &lt;&lt;</code>
<code>            /parse parse</code>
<code>            /parsefnc parsefnc</code>
<code>            (FNC1) fn1</code>
<code>            (FNC2) fn2</code>
<code>            (FNC3) fn3</code>
<code>%            (FNC4) fn4        Not user accessible as encoded automatically</code>
<code>        &gt;&gt; def</code>
<code>        /msg barcode fncvals //parseinput exec def</code>
<code>        /msglen msg length def</code>
<code></code>
<code>        /text msglen string def</code>
<code>        0 1 msglen 1 sub {</code>
<code>            /i exch def</code>
<code>            text i msg i get dup 0 lt { pop 32 } if put</code>
<code>        } for</code>
<code></code>
<code>        % Standard and extended ASCII runlength at position</code>
<code>        /numSA [ msglen {0} repeat 0 ] def</code>
<code>        /numEA [ msglen {0} repeat 0 ] def</code>
<code>        msglen 1 sub -1 0 {</code>
<code>            /i exch def</code>
<code>            msg i get 0 ge {</code>
<code>                msg i get 128 ge {</code>
<code>                    numEA i numEA i 1 add get 1 add put</code>
<code>                } {</code>
<code>                    numSA i numSA i 1 add get 1 add put</code>
<code>                } ifelse</code>
<code>            } if</code>
<code>        } for</code>
<code></code>
<code>        % FNC4 codeword insertion for extended ASCII</code>
<code>        /ea false def /msgtmp [] def</code>
<code>        0 1 msglen 1 sub {</code>
<code>            /i exch def</code>
<code>            /c msg i get def</code>
<code>            ea c 128 lt xor not c 0 ge and {  % Other mode required</code>
<code>                ea {numSA} {numEA} ifelse i get dup  % Runlength of other mode</code>
<code>                i add msglen eq {3} {5} ifelse       % Does run terminate symbol</code>
<code>                lt {  % Shift</code>
<code>                    /msgtmp [ msgtmp aload pop fn4 ] def</code>
<code>                } {   % Latch</code>
<code>                    /msgtmp [ msgtmp aload pop fn4 fn4 ] def</code>
<code>                    /ea ea not def</code>
<code>                } ifelse</code>
<code>            } if</code>
<code>            /msgtmp [ msgtmp aload pop c 0 ge {c 127 and} {c} ifelse ] def</code>
<code>        } for</code>
<code>        /msg msgtmp def</code>
<code>        /msglen msg length def</code>
<code></code>
<code>        % Convert the input message to codewords</code>
<code>        /enc {</code>
<code>            exch get cws exch j exch put</code>
<code>            /j j 1 add def</code>
<code>        } def</code>
<code></code>
<code>        /cws msglen 2 mul array def</code>
<code>        /i 0 def /j 0 def /cset (set0) def</code>
<code>        {</code>
<code>            i msglen eq {exit} if</code>
<code></code>
<code>            {  % common exit</code>
<code></code>
<code>                % Read next two characters</code>
<code>                /char1 msg i get def</code>
<code>                /char2 i 1 add msglen lt {msg i 1 add get} {-99} ifelse def</code>
<code></code>
<code>                % If current mode is sufficient then directly encode</code>
<code>                cset load char1 known {</code>
<code>                    char1 cset load enc</code>
<code>                    /i i 1 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code></code>
<code>                % If char1 is in set2 then shift encode</code>
<code>                set2 char1 known {</code>
<code>                    sf2 cset load enc</code>
<code>                    char1 set2 enc</code>
<code>                    /i i 1 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code></code>
<code>                % If char2 is also not in this set then latch else shift encode</code>
<code>                cset load char2 known not {</code>
<code>                    cset (set0) eq {</code>
<code>                       la1 cset load enc</code>
<code>                       /cset (set1) def</code>
<code>                    } {</code>
<code>                       la0 cset load enc</code>
<code>                       /cset (set0) def</code>
<code>                    } ifelse</code>
<code>                    exit</code>
<code>                } {</code>
<code>                    cset (set0) eq {</code>
<code>                        sf1 cset load enc</code>
<code>                        char1 set1 enc</code>
<code>                    } {</code>
<code>                        sf0 cset load enc</code>
<code>                        char1 set0 enc</code>
<code>                    } ifelse</code>
<code>                    /i i 1 add def</code>
<code>                    exit</code>
<code>                } ifelse</code>
<code></code>
<code>                exit</code>
<code>            } loop</code>
<code></code>
<code>        } loop</code>
<code>        /cws cws 0 j getinterval def</code>
<code>    } if  % auto encoding</code>
<code></code>
<code>    % Create an array containing the character mappings</code>
<code>{</code>
<code>    /encmaps &lt;&lt;   % ";"=11, "&lt;"=12</code>
<code>    /a</code>
<code>        [ (141112) (131212) (121312) (111412) (131113)</code>
<code>          (121213) (111313) (121114) (111214) (111115)</code>
<code>          (181111) (171211) (161311) (151411) (141511)</code>
<code>          (131611) (121711) (111811) (171112) (161212)</code>
<code>          (151312) (141412) (131512) (121612) (111712)</code>
<code>          (161113) (151213) (141313) (131413) (121513)</code>
<code>          (111613) (151114) (141214) (131314) (121414)</code>
<code>          (111514) (141115) (131215) (121315) (111415)</code>
<code>          (131116) (121216) (111316) (121117) (111217)</code>
<code>          (111118) (1&lt;111112) (111111111;1)</code>
<code>        ]</code>
<code>    /b</code>
<code>        [ (151213) (141313) (131413) (121513) (141214)</code>
<code>          (131314) (121414) (131215) (121315) (121216)</code>
<code>          (191212) (181312) (171412) (161512) (151612)</code>
<code>          (141712) (131812) (121912) (181213) (171313)</code>
<code>          (161413) (151513) (141613) (131713) (121813)</code>
<code>          (171214) (161314) (151414) (141514) (131614)</code>
<code>          (121714) (161215) (151315) (141415) (131515)</code>
<code>          (121615) (151216) (141316) (131416) (121516)</code>
<code>          (141217) (131317) (121417) (131218) (121318)</code>
<code>          (121219) (1&lt;121312) (121212121&lt;1)</code>
<code>        ]</code>
<code>    /limiteda</code>
<code>        [ (111411) (111312) (111213) (111114) (121311)</code>
<code>          (121212) (121113) (141111) (131211) (131112)</code>
<code>          (171111) (161211) (151311) (141411) (131511)</code>
<code>          (121611) (111711) (161112) (151212) (141312)</code>
<code>          (131412) (121512) (111612) (151113) (141213)</code>
<code>          (131313) (121413) (111513) (141114) (131214)</code>
<code>          (121314) (111414) (131115) (121215) (111315)</code>
<code>          (121116) (111216) (111117) (151111) (1)</code>
<code>        ]</code>
<code>    /limitedb</code>
<code>        [ (121512) (121413) (121314) (121215) (131412)</code>
<code>          (131313) (131214) (151212) (141312) (141213)</code>
<code>          (181212) (171312) (161412) (151512) (141612)</code>
<code>          (131712) (121812) (171213) (161313) (151413)</code>
<code>          (141513) (131613) (121713) (161214) (151314)</code>
<code>          (141414) (131514) (121614) (151215) (141315)</code>
<code>          (131415) (121515) (141216) (131316) (121416)</code>
<code>          (131217) (121317) (121218) (141212) (1)</code>
<code>        ]</code>
<code>    &gt;&gt; def</code>
<code>} ctxdef</code>
<code>    encmaps version get /encs exch def</code>
<code></code>
<code>{</code>
<code>    /c2w [</code>
<code>        [ 495 330 210 126  70  35  15   5 ]</code>
<code>        [ 165 120  84  56  35  20  10   4 ]</code>
<code>        [  45  36  28  21  15  10   6   3 ]</code>
<code>        [   9   8   7   6   5   4   3   2 ]</code>
<code>        [   1   1   1   1   1   1   1   1 ]</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code>    /v 0 def</code>
<code>    cws {</code>
<code>        /cw exch def</code>
<code>        6 {</code>
<code>            cw v xor 1 and 0 ne {</code>
<code>                /v v 7682 xor def</code>
<code>            } if</code>
<code>            /v v -1 bitshift def</code>
<code>            /cw cw -1 bitshift def</code>
<code>        } repeat</code>
<code>    } forall</code>
<code>    /v v checkoffset add def</code>
<code></code>
<code>    version (limiteda) eq version (limitedb) eq or {</code>
<code>        /v v 1023 and def</code>
<code>        v 824 gt v 853 lt and {</code>
<code>            /v v 292 add def</code>
<code>        } if</code>
<code>    } {</code>
<code>        /v v 1023 and 45 add def</code>
<code>    } ifelse</code>
<code></code>
<code>    /d [ 2 2 2 2 2 2 ] def</code>
<code>    /r 0 def /c 0 def /w 0 def /sum 0 def</code>
<code>    {</code>
<code>        sum v eq {exit} if</code>
<code>        /t sum c2w r get c get add def</code>
<code>        t v eq {</code>
<code>            /w w 1 add def</code>
<code>            d r w 2 add put</code>
<code>            /sum t def</code>
<code>        } if</code>
<code>        t v gt {</code>
<code>            d r w 2 add put</code>
<code>            /r r 1 add def</code>
<code>            /w 0 def</code>
<code>        } if</code>
<code>        t v lt {</code>
<code>            /c c 1 add def</code>
<code>            /w w 1 add def</code>
<code>            /sum t def</code>
<code>        } if</code>
<code>    } loop</code>
<code>    20 0 1 4 {d exch get sub} for</code>
<code>    d exch 5 exch put</code>
<code>    version (b) eq version (limitedb) eq or {</code>
<code>        /d [ d {1 add} forall ] def</code>
<code>    } if</code>
<code>    /cbs (111111111111) 12 string copy def</code>
<code>    5 -1 0 {</code>
<code>        /i exch def</code>
<code>        cbs 5 i sub 2 mul 1 add d i get 47 add put</code>
<code>    } for</code>
<code></code>
<code>    % Concatenate the space bar successions</code>
<code>    /sbs cws length 6 mul 31 add string def</code>
<code>    encs encs length 2 sub get dup</code>
<code>    sbs exch 0 exch putinterval</code>
<code>    length /j exch def</code>
<code>    0 1 cws length 1 sub {</code>
<code>        /i exch def</code>
<code>        sbs j encs cws i get get putinterval</code>
<code>        /j j 6 add def</code>
<code>    } for</code>
<code>    sbs j cbs putinterval</code>
<code>    /j j 12 add def</code>
<code>    encs encs length 1 sub get dup</code>
<code>    sbs exch j exch putinterval</code>
<code>    length j add /j exch def</code>
<code>    /sbs sbs 0 j getinterval def</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs [sbs {48 sub} forall]</code>
<code>    /bhs [sbs length 1 add 2 idiv {height} repeat]</code>
<code>    /bbs [sbs length 1 add 2 idiv {0} repeat]</code>
<code>    /txt [ [text textxoffset textyoffset textfont textsize] ]</code>
<code>    /textxalign (center)</code>
<code>    /borderleft  &lt;&lt; /a 0.0  /b 0.0  /limiteda 12.0  /limitedb 13.0 &gt;&gt; version get</code>
<code>    /borderright &lt;&lt; /a 0.0  /b 0.0  /limiteda 12.0  /limitedb 13.0 &gt;&gt; version get</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /posicode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER posicode--</code>
<code></code>
<code>% --BEGIN ENCODER codablockf--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix--</code>
<code>% --DESC: Codablock F</code>
<code>% --EXAM: CODABLOCK F 34567890123456789010040digit</code>
<code>% --EXOP: columns=8</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp codablockf 0.0 2024010300 140106 142562</code>
<code>%%BeginData:        535 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/codablockf {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /rows -1 def</code>
<code>    /columns 8 def</code>
<code>    /rowheight 10 def</code>
<code>    /sepheight 1 def</code>
<code>    /parse false def</code>
<code>    /parsefnc false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    columns 4 lt columns 62 gt or {</code>
<code>        /bwipp.codablockfBadColumns (Codablock F must have 4 to 62 columns) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    rows -1 ne rows 2 lt rows 44 gt or and {</code>
<code>        /bwipp.codablockfBadRows (Codablock F must have 2 to 44 rows) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    rowheight 8 lt {</code>
<code>        /bwipp.codablockfBadRowHeight (Codablock F must have rowheight of at least 8) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    sepheight 1 lt {</code>
<code>        /bwipp.codablockfBadSepHeight (Codablock F must have sepheight of at least 1) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /codablockf //loadctx exec</code>
<code></code>
<code>    /c columns 4 ge columns 62 le and {columns} {8} ifelse def</code>
<code>    /rows rows 2 ge rows 44 le and {rows} {-1} ifelse def</code>
<code></code>
<code>    % Convert input into bytes accounting for FNC characters</code>
<code>    /swa -1 def  /swb -2 def  /swc -3 def  /sft -4 def</code>
<code>    /fn1 -5 def  /fn2 -6 def  /fn3 -7 def  /fn4 -8 def</code>
<code>    /sta -9 def  /stp -10 def</code>
<code></code>
<code>    % Parse the input</code>
<code>    /fncvals &lt;&lt;</code>
<code>        /parse parse</code>
<code>        /parsefnc parsefnc</code>
<code>        (FNC1) fn1</code>
<code>%        (FNC2) fn2      Not permitted for Codablock F</code>
<code>        (FNC3) fn3</code>
<code>%        (FNC4) fn4      Not user accessible as encoded automatically</code>
<code>    &gt;&gt; def</code>
<code>    /msg barcode fncvals //parseinput exec def</code>
<code>    /msglen msg length def</code>
<code></code>
<code>    % FNC4 codeword insertion for extended ASCII</code>
<code>    /msgtmp [] def</code>
<code>    msg {</code>
<code>        /char exch def</code>
<code>        /msgtmp [ msgtmp aload pop char 128 lt {char} {fn4 char 127 and} ifelse ] def</code>
<code>    } forall</code>
<code>    /kmsg msg def  % Keep for k1/k2 check characters calculation</code>
<code>    /msg msgtmp def</code>
<code>    /msglen msg length def</code>
<code></code>
<code>    % Character maps for each state</code>
<code>{</code>
<code>    /charmaps [</code>
<code>      %  A    B    C         A    B    C         A    B    C</code>
<code>      [  32   32  (00) ]  [ (!)  (!)  (01) ]  [ (")  (")  (02) ]  % 0-2</code>
<code>      [ (#)  (#)  (03) ]  [ ($)  ($)  (04) ]  [ (%)  (%)  (05) ]  % 3-5</code>
<code>      [ (&amp;)  (&amp;)  (06) ]  [ (')  (')  (07) ]  [  40   40  (08) ]  % 6-8</code>
<code>      [  41   41  (09) ]  [ (*)  (*)  (10) ]  [ (+)  (+)  (11) ]  % 9-11</code>
<code>      [ (,)  (,)  (12) ]  [ (-)  (-)  (13) ]  [ (.)  (.)  (14) ]  % 12-14</code>
<code>      [ (/)  (/)  (15) ]  [ (0)  (0)  (16) ]  [ (1)  (1)  (17) ]  % 15-17</code>
<code>      [ (2)  (2)  (18) ]  [ (3)  (3)  (19) ]  [ (4)  (4)  (20) ]  % 18-20</code>
<code>      [ (5)  (5)  (21) ]  [ (6)  (6)  (22) ]  [ (7)  (7)  (23) ]  % 21-23</code>
<code>      [ (8)  (8)  (24) ]  [ (9)  (9)  (25) ]  [ (:)  (:)  (26) ]  % 24-26</code>
<code>      [ (;)  (;)  (27) ]  [ (&lt;)  (&lt;)  (28) ]  [ (=)  (=)  (29) ]  % 27-29</code>
<code>      [ (&gt;)  (&gt;)  (30) ]  [ (?)  (?)  (31) ]  [ (@)  (@)  (32) ]  % 30-32</code>
<code>      [ (A)  (A)  (33) ]  [ (B)  (B)  (34) ]  [ (C)  (C)  (35) ]  % 33-35</code>
<code>      [ (D)  (D)  (36) ]  [ (E)  (E)  (37) ]  [ (F)  (F)  (38) ]  % 36-38</code>
<code>      [ (G)  (G)  (39) ]  [ (H)  (H)  (40) ]  [ (I)  (I)  (41) ]  % 39-41</code>
<code>      [ (J)  (J)  (42) ]  [ (K)  (K)  (43) ]  [ (L)  (L)  (44) ]  % 42-44</code>
<code>      [ (M)  (M)  (45) ]  [ (N)  (N)  (46) ]  [ (O)  (O)  (47) ]  % 45-47</code>
<code>      [ (P)  (P)  (48) ]  [ (Q)  (Q)  (49) ]  [ (R)  (R)  (50) ]  % 48-50</code>
<code>      [ (S)  (S)  (51) ]  [ (T)  (T)  (52) ]  [ (U)  (U)  (53) ]  % 51-53</code>
<code>      [ (V)  (V)  (54) ]  [ (W)  (W)  (55) ]  [ (X)  (X)  (56) ]  % 54-56</code>
<code>      [ (Y)  (Y)  (57) ]  [ (Z)  (Z)  (58) ]  [ ([)  ([)  (59) ]  % 57-59</code>
<code>      [  92   92  (60) ]  [ (])  (])  (61) ]  [ (^)  (^)  (62) ]  % 60-62</code>
<code>      [ (_)  (_)  (63) ]  [   0  (`)  (64) ]  [   1  (a)  (65) ]  % 63-65</code>
<code>      [   2  (b)  (66) ]  [   3  (c)  (67) ]  [   4  (d)  (68) ]  % 66-68</code>
<code>      [   5  (e)  (69) ]  [   6  (f)  (70) ]  [   7  (g)  (71) ]  % 69-71</code>
<code>      [   8  (h)  (72) ]  [   9  (i)  (73) ]  [  10  (j)  (74) ]  % 72-74</code>
<code>      [  11  (k)  (75) ]  [  12  (l)  (76) ]  [  13  (m)  (77) ]  % 75-77</code>
<code>      [  14  (n)  (78) ]  [  15  (o)  (79) ]  [  16  (p)  (80) ]  % 78-80</code>
<code>      [  17  (q)  (81) ]  [  18  (r)  (82) ]  [  19  (s)  (83) ]  % 81-83</code>
<code>      [  20  (t)  (84) ]  [  21  (u)  (85) ]  [  22  (v)  (86) ]  % 84-86</code>
<code>      [  23  (w)  (87) ]  [  24  (x)  (88) ]  [  25  (y)  (89) ]  % 87-89</code>
<code>      [  26  (z)  (90) ]  [  27  ({)  (91) ]  [  28  (|)  (92) ]  % 90-92</code>
<code>      [  29  (})  (93) ]  [  30  (~)  (94) ]  [  31  127  (95) ]  % 93-95</code>
<code>      [ fn3  fn3  (96) ]  [ fn2  fn2  (97) ]  [ sft  sft  (98) ]  % 96-98</code>
<code>      [ swc  swc  (99) ]  [ swb  fn4  swb  ]  [ fn4  swa  swa  ]  % 99-101</code>
<code>      [ fn1  fn1  fn1  ]  [ sta  sta  sta  ]  [ stp  stp  stp  ]  % 102-104</code>
<code>    ] def</code>
<code></code>
<code>    % Invert charmaps to give character to value maps for each state</code>
<code>    /charvals [ 105 dict 105 dict 105 dict ] def</code>
<code>    0 1 charmaps length 1 sub {</code>
<code>        /i exch def</code>
<code>        /encs charmaps i get def</code>
<code>        0 1 2 {</code>
<code>            /j exch def</code>
<code>            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required</code>
<code>            charvals j get exch i put</code>
<code>        } for</code>
<code>    } for</code>
<code>    /seta charvals 0 get def</code>
<code>    /setb charvals 1 get def</code>
<code>    /setc charvals 2 get def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Determine digit runlength and characters from given position</code>
<code>    /numsscr {</code>
<code>        /n 0 def /s 0 def</code>
<code>        /p exch def {</code>
<code>            p msglen ge {exit} if</code>
<code>            msg p get</code>
<code>            dup setc exch known not {pop exit} if</code>
<code>            fn1 eq {</code>
<code>                % FNC1 in odd position of run like two digits</code>
<code>                s 2 mod 0 eq {/s s 1 add def} {exit} ifelse</code>
<code>            } if</code>
<code>            /n n 1 add def</code>
<code>            /s s 1 add def</code>
<code>            /p p 1 add def</code>
<code>        } loop</code>
<code>        n s</code>
<code>    } def</code>
<code></code>
<code>    % Encoding for each alphabet</code>
<code>    /enca {</code>
<code>        seta exch get cws exch j exch put</code>
<code>        /j j 1 add def</code>
<code>    } def</code>
<code>    /encb {</code>
<code>        setb exch get cws exch j exch put</code>
<code>        /j j 1 add def</code>
<code>    } def</code>
<code>    /encc {</code>
<code>        dup type /arraytype ne {</code>
<code>            setc exch get</code>
<code>        } {</code>
<code>            aload pop 48 sub exch 48 sub 10 mul add</code>
<code>        } ifelse</code>
<code>        cws exch j exch put</code>
<code>        /j j 1 add def</code>
<code>    } def</code>
<code></code>
<code>    % Character exclusively in either alphabet A or B</code>
<code>    /anotb {dup seta exch known exch setb exch known not and} def</code>
<code>    /bnota {dup setb exch known exch seta exch known not and} def</code>
<code></code>
<code>    % Pre-compute relative position of next anotb and next bnota characters</code>
<code>    /nextanotb [ msg length {0} repeat 9999 ] def</code>
<code>    /nextbnota [ msg length {0} repeat 9999 ] def</code>
<code>    msg length 1 sub -1 0 {</code>
<code>        /i exch def</code>
<code>        msg i get anotb {</code>
<code>            nextanotb i 0 put</code>
<code>        } {</code>
<code>            nextanotb i nextanotb i 1 add get 1 add put</code>
<code>        } ifelse</code>
<code>        msg i get bnota {</code>
<code>            nextbnota i 0 put</code>
<code>        } {</code>
<code>            nextbnota i nextbnota i 1 add get 1 add put</code>
<code>        } ifelse</code>
<code>    } for</code>
<code></code>
<code>    % Does a-only come before b-only after given position and vice versa</code>
<code>    /abeforeb {dup nextanotb exch get exch nextbnota exch get lt} def</code>
<code>    /bbeforea {dup nextbnota exch get exch nextanotb exch get lt} def</code>
<code></code>
<code>    % Add padding to row</code>
<code>    /padrow {</code>
<code>        {</code>
<code>           {  % common exit</code>
<code>               cset (seta) eq {swc enca /cset (setc) def exit} if</code>
<code>               cset (setb) eq {swc encb /cset (setc) def exit} if</code>
<code>               cset (setc) eq {swb encc /cset (setb) def exit} if</code>
<code>           } loop</code>
<code>        } repeat</code>
<code>    } def</code>
<code></code>
<code>    % Encode a if fits in row, allowing for fn4 + possible shift, assuming rem ge 1</code>
<code>    /encafitsrow {</code>
<code>        rem 2 le msg i get fn4 eq and {</code>
<code>            % If have 2 left and don't need to shift</code>
<code>            rem 2 eq msg i 1 add get 95 le and dup {  % Return false if not</code>
<code>                fn4 enca</code>
<code>                msg i 1 add get enca</code>
<code>                /i i 2 add def</code>
<code>            } if</code>
<code>        } {</code>
<code>            msg i get enca</code>
<code>            /i i 1 add def</code>
<code>            true</code>
<code>        } ifelse</code>
<code>    } def</code>
<code></code>
<code>    % Encode b if fits in row, allowing for fn4 + possible shift, assuming rem ge 1</code>
<code>    /encbfitsrow {</code>
<code>        rem 2 le msg i get fn4 eq and {</code>
<code>            % If have 2 left and don't need to shift</code>
<code>            rem 2 eq msg i 1 add get 32 ge and dup {  % Return false if not</code>
<code>                fn4 encb</code>
<code>                msg i 1 add get encb</code>
<code>                /i i 2 add def</code>
<code>            } if</code>
<code>        } {</code>
<code>            msg i get encb</code>
<code>            /i i 1 add def</code>
<code>            true</code>
<code>        } ifelse</code>
<code>    } def</code>
<code></code>
<code>    % Convert message to codewords</code>
<code>    /cws c 5 add 44 mul array def</code>
<code></code>
<code>    /i 0 def /j 0 def /r 1 def</code>
<code>    /lastrow false def {</code>
<code></code>
<code>        lastrow {exit} if</code>
<code></code>
<code>        r 44 gt {</code>
<code>            /bwipp.codablockfTooBig (Maximum length exceeded) //raiseerror exec</code>
<code>        } if</code>
<code></code>
<code>        % Add start character and code subset selector</code>
<code>        sta enca</code>
<code>        i msglen lt {i numsscr} {-1 -1} ifelse /nums exch def /nchars exch def</code>
<code>        {  % common exit</code>
<code>            msglen 0 eq {</code>
<code>                swb enca</code>
<code>                /cset (setb) def</code>
<code>                exit</code>
<code>            } if</code>
<code>            nums 2 ge {</code>
<code>                swc enca</code>
<code>                /cset (setc) def</code>
<code>                exit</code>
<code>            } if</code>
<code>            i abeforeb {</code>
<code>                sft enca</code>
<code>                /cset (seta) def</code>
<code>                exit</code>
<code>            } if</code>
<code>            swb enca</code>
<code>            /cset (setb) def</code>
<code>            exit</code>
<code>        } loop</code>
<code>        /j j 1 add def  % Skip row indicator position</code>
<code></code>
<code>        % Main encoding loop</code>
<code>        /endofrow false def {</code>
<code>            /rem c 3 add j c 5 add mod sub def  % Codewords to end of row</code>
<code></code>
<code>            i msglen eq endofrow or {exit} if</code>
<code></code>
<code>            i numsscr /nums exch def /nchars exch def</code>
<code>            /remnums nums rem 2 mul gt {rem 2 mul} {nums} ifelse def</code>
<code></code>
<code>            % Determine switches and shifts</code>
<code>            {  % common exit</code>
<code>                cset (seta) eq cset (setb) eq or remnums 4 ge and</code>
<code>                msg i get fn1 ne and {</code>
<code>                    remnums 2 mod 0 eq</code>
<code>                    rem 3 ge and {</code>
<code>                        swc cset (seta) eq {enca} {encb} ifelse</code>
<code>                        /cset (setc) def</code>
<code>                        2 {</code>
<code>                            msg i get fn1 eq {</code>
<code>                                fn1 encc</code>
<code>                                /i i 1 add def</code>
<code>                            } {</code>
<code>                                msg i 2 getinterval encc</code>
<code>                                /i i 2 add def</code>
<code>                            } ifelse</code>
<code>                        } repeat</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    remnums 2 mod 0 ne</code>
<code>                    rem 4 ge and {</code>
<code>                        msg i get cset (seta) eq {enca} {encb} ifelse</code>
<code>                        /i i 1 add def</code>
<code>                        swc cset (seta) eq {enca} {encb} ifelse</code>
<code>                        /cset (setc) def</code>
<code>                        2 {</code>
<code>                            msg i get fn1 eq {</code>
<code>                                fn1 encc</code>
<code>                                /i i 1 add def</code>
<code>                            } {</code>
<code>                                msg i 2 getinterval encc</code>
<code>                                /i i 2 add def</code>
<code>                            } ifelse</code>
<code>                        } repeat</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                } if</code>
<code>                cset (setb) eq msg i get anotb and</code>
<code>                rem 2 ge and {</code>
<code>                    i msglen 1 sub lt {</code>
<code>                        i 1 add bbeforea {</code>
<code>                            sft encb</code>
<code>                            msg i get enca</code>
<code>                            /i i 1 add def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    swa encb</code>
<code>                    /cset (seta) def</code>
<code>                    msg i get enca</code>
<code>                    /i i 1 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                cset (seta) eq msg i get bnota and</code>
<code>                rem 2 ge and {</code>
<code>                    i msglen 1 sub lt {</code>
<code>                        i 1 add abeforeb {</code>
<code>                            sft enca</code>
<code>                            msg i get encb</code>
<code>                            /i i 1 add def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    swb enca</code>
<code>                    /cset (setb) def</code>
<code>                    msg i get encb</code>
<code>                    /i i 1 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                cset (setc) eq remnums 2 lt and</code>
<code>                rem 2 ge and {</code>
<code>                    /rem rem 1 sub def</code>
<code>                    i abeforeb {</code>
<code>                        swa encc</code>
<code>                        /cset (seta) def</code>
<code>                        encafitsrow { exit } if</code>
<code>                    } {</code>
<code>                        swb encc</code>
<code>                        /cset (setb) def</code>
<code>                        encbfitsrow { exit } if</code>
<code>                    } ifelse</code>
<code>                } if</code>
<code></code>
<code>                % No switches or latches so try to encode</code>
<code>                cset (seta) eq seta msg i get known and</code>
<code>                rem 1 ge and {</code>
<code>                    encafitsrow { exit } if</code>
<code>                } if</code>
<code>                cset (setb) eq setb msg i get known and</code>
<code>                rem 1 ge and {</code>
<code>                    encbfitsrow { exit } if</code>
<code>                } if</code>
<code>                cset (setc) eq remnums 2 ge and</code>
<code>                rem 1 ge and {</code>
<code>                    msg i get fn1 eq {</code>
<code>                        fn1 encc</code>
<code>                        /i i 1 add def</code>
<code>                    } {</code>
<code>                        msg i 2 getinterval encc</code>
<code>                        /i i 2 add def</code>
<code>                    } ifelse</code>
<code>                    exit</code>
<code>                } if</code>
<code></code>
<code>                % Encoding does not fit in the row</code>
<code>                /endofrow true def</code>
<code>                exit</code>
<code></code>
<code>            } loop  % common exit</code>
<code></code>
<code>        } loop</code>
<code></code>
<code>        % Determine whether this is the final row</code>
<code>        r rows ge rows -1 eq or r 1 gt and i msglen eq and rem 2 ge and {</code>
<code>            rem 2 sub padrow</code>
<code>            /j j 3 add def  % Skip symbol and row checksum character positions</code>
<code>            stp enca</code>
<code>            /lastrow true def</code>
<code>        } {</code>
<code>            rem padrow</code>
<code>            /j j 1 add def  % Skip row checksum character positions</code>
<code>            stp enca</code>
<code>            /r r 1 add def</code>
<code>        } ifelse</code>
<code></code>
<code>    } loop</code>
<code>    /cws cws 0 j getinterval def</code>
<code></code>
<code>    % Maps for row indicators and symbol checksums</code>
<code>{</code>
<code>    /abmap [</code>
<code>        64 1 95 {} for</code>
<code>         0 1 15 {} for</code>
<code>        26 1 63 {} for</code>
<code>    ] def</code>
<code>    /cmap [ 0 1 85 {} for ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Add symbol check characters to last row</code>
<code>    /chkmsg kmsg length array def  % Using kmsg (pre-fn4 insertion)</code>
<code>    /j 0 def</code>
<code>    0 1 kmsg length 1 sub {</code>
<code>        /i exch def</code>
<code>        /char kmsg i get def</code>
<code>        char 0 ge {chkmsg j char put /j j 1 add def} if</code>
<code>        char fn1 eq i 0 ne and {chkmsg j 29 put /j j 1 add def} if</code>
<code>    } for</code>
<code>    /t1 0 def /t2 0 def /k1 0 def /k2 0 def</code>
<code>    0 1 j 1 sub {</code>
<code>        /i exch def</code>
<code>        /t1 chkmsg i get i mul 86 mod def</code>
<code>        /t2 t1 chkmsg i get add 86 mod def</code>
<code>        /k1 k1 t2 add 86 mod def</code>
<code>        /k2 k2 t1 add 86 mod def</code>
<code>    } for</code>
<code>    cws cws length 4 sub cset (setc) ne {abmap} {cmap} ifelse k1 get put</code>
<code>    cws cws length 3 sub cset (setc) ne {abmap} {cmap} ifelse k2 get put</code>
<code></code>
<code>    % Populate row indicators</code>
<code>    cws 2 2 copy 1 sub get 99 ne {abmap} {cmap} ifelse r 2 sub get put</code>
<code>    1 1 r 1 sub {</code>
<code>        /i exch def</code>
<code>        cws i c 5 add mul 2 add 2 copy 1 sub get 99 ne {abmap} {cmap} ifelse i 42 add get put</code>
<code>    } for</code>
<code></code>
<code>    % Calculate row check characters</code>
<code>    0 1 r 1 sub {</code>
<code>        cws exch c 5 add mul c 4 add getinterval /rcws exch def</code>
<code>        /csum rcws 0 get def</code>
<code>        1 1 rcws length 2 sub {</code>
<code>            /i exch def</code>
<code>            /csum csum rcws i get i mul add def</code>
<code>        } for</code>
<code>        rcws rcws length 1 sub csum 103 mod put</code>
<code>    } for</code>
<code></code>
<code>    options /debugcws known { /bwipp.debugcws cws //raiseerror exec } if</code>
<code></code>
<code>    % Create an array containing the character mappings</code>
<code>{</code>
<code>    /encs</code>
<code>    [ (212222) (222122) (222221) (121223) (121322) (131222) (122213)</code>
<code>      (122312) (132212) (221213) (221312) (231212) (112232) (122132)</code>
<code>      (122231) (113222) (123122) (123221) (223211) (221132) (221231)</code>
<code>      (213212) (223112) (312131) (311222) (321122) (321221) (312212)</code>
<code>      (322112) (322211) (212123) (212321) (232121) (111323) (131123)</code>
<code>      (131321) (112313) (132113) (132311) (211313) (231113) (231311)</code>
<code>      (112133) (112331) (132131) (113123) (113321) (133121) (313121)</code>
<code>      (211331) (231131) (213113) (213311) (213131) (311123) (311321)</code>
<code>      (331121) (312113) (312311) (332111) (314111) (221411) (431111)</code>
<code>      (111224) (111422) (121124) (121421) (141122) (141221) (112214)</code>
<code>      (112412) (122114) (122411) (142112) (142211) (241211) (221114)</code>
<code>      (413111) (241112) (134111) (111242) (121142) (121241) (114212)</code>
<code>      (124112) (124211) (411212) (421112) (421211) (212141) (214121)</code>
<code>      (412121) (111143) (111341) (131141) (114113) (114311) (411113)</code>
<code>      (411311) (113141) (114131) (311141) (411131) (211412) (2331112)</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Derive the bits for each row</code>
<code>    /rowbits r array def</code>
<code>    0 1 r 1 sub {</code>
<code>        /i exch def</code>
<code>        /sbs [</code>
<code>            cws i c 5 add mul c 5 add getinterval {</code>
<code>                encs exch get {48 sub} forall</code>
<code>            } forall</code>
<code>        ] def</code>
<code>        mark</code>
<code>        0 sbs {1 index 1 eq {{0}} {{1}} ifelse repeat} forall</code>
<code>        counttomark 1 sub array astore exch pop exch pop</code>
<code>        rowbits i 3 -1 roll put</code>
<code>    } for</code>
<code></code>
<code>    % Populate the bitmap</code>
<code>    /symwid c 11 mul 57 add def</code>
<code>    /pixs [</code>
<code>        symwid sepheight mul {1} repeat</code>
<code>        0 1 r 2 sub {</code>
<code>            /i exch def</code>
<code>            rowheight {rowbits i get aload pop} repeat</code>
<code>            sepheight {</code>
<code>                1 1 0 1 0 0 0 0 1 0 0</code>
<code>                symwid 24 sub {1} repeat</code>
<code>                1 1 0 0 0 1 1 1 0 1 0 1 1</code>
<code>            } repeat</code>
<code>        } for</code>
<code>        rowheight {rowbits r 1 sub get aload pop} repeat</code>
<code>        symwid sepheight mul {1} repeat</code>
<code>    ] def</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renmatrix</code>
<code>    /pixs pixs</code>
<code>    /pixx symwid</code>
<code>    /pixy pixs length symwid idiv</code>
<code>    /height pixs length symwid idiv 72 div</code>
<code>    /width symwid 72 div</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /codablockf dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER codablockf--</code>
<code></code>
<code>% --BEGIN ENCODER code16k--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix--</code>
<code>% --DESC: Code 16K</code>
<code>% --EXAM: Abcd-1234567890-wxyZ</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp code16k 0.0 2024010300 163595 165899</code>
<code>%%BeginData:        740 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/code16k {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /sam -1 def</code>
<code>    /rows 0 def</code>
<code>    /rowheight 8 def</code>
<code>    /sepheight 1 def</code>
<code>    /raw false def</code>
<code>    /parse false def</code>
<code>    /parsefnc false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    rows 0 ne rows 2 lt rows 16 gt or and {</code>
<code>        /bwipp.code16kBadRows (Code 16K must have 2 to 16 rows) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    rowheight 8 lt {</code>
<code>        /bwipp.code16kBadRowHeight (Code 16K must have rowheight of at least 8) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    sepheight 1 lt {</code>
<code>        /bwipp.code16kBadSepHeight (Code 16K must have sepheight of at least 1) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    sam -1 ne {</code>
<code>        true</code>
<code>        1 {</code>
<code>            sam dup 12 lt exch 99 gt or { pop false exit } if</code>
<code>            sam 10 mod 2 lt { pop false exit } if</code>
<code>            sam 10 idiv sam 10 mod gt { pop false exit } if</code>
<code>        } repeat</code>
<code>        not {</code>
<code>            /bwipp.code16kBadSAM (SAM must be formatted as "NM" for Nth of M symbols, from 2 to 9 symbols) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    /code16k //loadctx exec</code>
<code></code>
<code>    sam -1 ne {/rows 16 def} if</code>
<code></code>
<code>    % Convert input into bytes accounting for FNC characters</code>
<code>{</code>
<code>    /swa  -1 def  /swb  -2 def  /swc  -3 def</code>
<code>    /sa1  -4 def  /sb1  -5 def  /sc1  -6 def</code>
<code>    /sa2  -7 def  /sb2  -8 def  /sc2  -9 def</code>
<code>    /pad -10 def  /sb3 -11 def  /sc3 -12 def</code>
<code>    /fn1 -13 def  /fn2 -14 def  /fn3 -15 def  /fn4 -16 def</code>
<code></code>
<code>    % Character maps for each state</code>
<code>    /charmaps [</code>
<code>      %  A    B    C         A    B    C         A    B    C</code>
<code>      [  32   32  (00) ]  [ (!)  (!)  (01) ]  [ (")  (")  (02) ]  % 0-2</code>
<code>      [ (#)  (#)  (03) ]  [ ($)  ($)  (04) ]  [ (%)  (%)  (05) ]  % 3-5</code>
<code>      [ (&amp;)  (&amp;)  (06) ]  [ (')  (')  (07) ]  [  40   40  (08) ]  % 6-8</code>
<code>      [  41   41  (09) ]  [ (*)  (*)  (10) ]  [ (+)  (+)  (11) ]  % 9-11</code>
<code>      [ (,)  (,)  (12) ]  [ (-)  (-)  (13) ]  [ (.)  (.)  (14) ]  % 12-14</code>
<code>      [ (/)  (/)  (15) ]  [ (0)  (0)  (16) ]  [ (1)  (1)  (17) ]  % 15-17</code>
<code>      [ (2)  (2)  (18) ]  [ (3)  (3)  (19) ]  [ (4)  (4)  (20) ]  % 18-20</code>
<code>      [ (5)  (5)  (21) ]  [ (6)  (6)  (22) ]  [ (7)  (7)  (23) ]  % 21-23</code>
<code>      [ (8)  (8)  (24) ]  [ (9)  (9)  (25) ]  [ (:)  (:)  (26) ]  % 24-26</code>
<code>      [ (;)  (;)  (27) ]  [ (&lt;)  (&lt;)  (28) ]  [ (=)  (=)  (29) ]  % 27-29</code>
<code>      [ (&gt;)  (&gt;)  (30) ]  [ (?)  (?)  (31) ]  [ (@)  (@)  (32) ]  % 30-32</code>
<code>      [ (A)  (A)  (33) ]  [ (B)  (B)  (34) ]  [ (C)  (C)  (35) ]  % 33-35</code>
<code>      [ (D)  (D)  (36) ]  [ (E)  (E)  (37) ]  [ (F)  (F)  (38) ]  % 36-38</code>
<code>      [ (G)  (G)  (39) ]  [ (H)  (H)  (40) ]  [ (I)  (I)  (41) ]  % 39-41</code>
<code>      [ (J)  (J)  (42) ]  [ (K)  (K)  (43) ]  [ (L)  (L)  (44) ]  % 42-44</code>
<code>      [ (M)  (M)  (45) ]  [ (N)  (N)  (46) ]  [ (O)  (O)  (47) ]  % 45-47</code>
<code>      [ (P)  (P)  (48) ]  [ (Q)  (Q)  (49) ]  [ (R)  (R)  (50) ]  % 48-50</code>
<code>      [ (S)  (S)  (51) ]  [ (T)  (T)  (52) ]  [ (U)  (U)  (53) ]  % 51-53</code>
<code>      [ (V)  (V)  (54) ]  [ (W)  (W)  (55) ]  [ (X)  (X)  (56) ]  % 54-56</code>
<code>      [ (Y)  (Y)  (57) ]  [ (Z)  (Z)  (58) ]  [ ([)  ([)  (59) ]  % 57-59</code>
<code>      [  92   92  (60) ]  [ (])  (])  (61) ]  [ (^)  (^)  (62) ]  % 60-62</code>
<code>      [ (_)  (_)  (63) ]  [   0  (`)  (64) ]  [   1  (a)  (65) ]  % 63-65</code>
<code>      [   2  (b)  (66) ]  [   3  (c)  (67) ]  [   4  (d)  (68) ]  % 66-68</code>
<code>      [   5  (e)  (69) ]  [   6  (f)  (70) ]  [   7  (g)  (71) ]  % 69-71</code>
<code>      [   8  (h)  (72) ]  [   9  (i)  (73) ]  [  10  (j)  (74) ]  % 72-74</code>
<code>      [  11  (k)  (75) ]  [  12  (l)  (76) ]  [  13  (m)  (77) ]  % 75-77</code>
<code>      [  14  (n)  (78) ]  [  15  (o)  (79) ]  [  16  (p)  (80) ]  % 78-80</code>
<code>      [  17  (q)  (81) ]  [  18  (r)  (82) ]  [  19  (s)  (83) ]  % 81-83</code>
<code>      [  20  (t)  (84) ]  [  21  (u)  (85) ]  [  22  (v)  (86) ]  % 84-86</code>
<code>      [  23  (w)  (87) ]  [  24  (x)  (88) ]  [  25  (y)  (89) ]  % 87-89</code>
<code>      [  26  (z)  (90) ]  [  27  ({)  (91) ]  [  28  (|)  (92) ]  % 90-92</code>
<code>      [  29  (})  (93) ]  [  30  (~)  (94) ]  [  31  127  (95) ]  % 93-95</code>
<code>      [ fn3  fn3  (96) ]  [ fn2  fn2  (97) ]  [ sb1  sa1  (98) ]  % 96-98</code>
<code>      [ swc  swc  (99) ]  [ swb  fn4  swb  ]  [ fn4  swa  swa  ]  % 99-101</code>
<code>      [ fn1  fn1  fn1  ]  [ pad  pad  pad  ]  [ sb2  sa2  sb1  ]  % 102-104</code>
<code>      [ sc2  sc2  sb2  ]  [ sc3  sc3  sb3  ]                      % 105-106</code>
<code>    ] def</code>
<code></code>
<code>    % Invert charmaps to give character to value maps for each state</code>
<code>    /charvals [ 109 dict 109 dict 109 dict ] def</code>
<code>    0 1 charmaps length 1 sub {</code>
<code>        /i exch def</code>
<code>        /encs charmaps i get def</code>
<code>        0 1 2 {</code>
<code>            /j exch def</code>
<code>            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required</code>
<code>            charvals j get exch i put</code>
<code>        } for</code>
<code>    } for</code>
<code>    /seta charvals 0 get def</code>
<code>    /setb charvals 1 get def</code>
<code>    /setc charvals 2 get def</code>
<code>} ctxdef</code>
<code></code>
<code>    raw {</code>
<code></code>
<code>        /cws barcode length array def</code>
<code>        /i 0 def /j 0 def</code>
<code>        { % loop</code>
<code>            i barcode length 3 sub ge {exit} if</code>
<code>            barcode i get 94 ne {exit} if</code>
<code>            barcode i 1 add 3 getinterval false 1 index {</code>
<code>                dup 48 lt exch 57 gt or { pop true } if</code>
<code>            } forall { pop exit } if</code>
<code>            cvi /cw exch def</code>
<code>            cws j cw put</code>
<code>            /i i 4 add def</code>
<code>            /j j 1 add def</code>
<code>        } loop</code>
<code>        i barcode length ne {</code>
<code>            /bwipp.code16kBadRawFormat (raw data must be formatted as ^NNN) //raiseerror exec</code>
<code>        } if</code>
<code>        /cws cws 0 j getinterval def</code>
<code></code>
<code>    } {</code>
<code></code>
<code>        % Parse the input</code>
<code>        /fncvals &lt;&lt;</code>
<code>            /parse parse</code>
<code>            /parsefnc parsefnc</code>
<code>            /eci true</code>
<code>            (FNC1) fn1</code>
<code>            (FNC2) fn2</code>
<code>            (FNC3) fn3</code>
<code>%            (FNC4) fn4        Not user accessible as encoded automatically</code>
<code>        &gt;&gt; def</code>
<code>        /msg barcode fncvals //parseinput exec def</code>
<code>        /msglen msg length def</code>
<code></code>
<code>        % Standard and extended ASCII runlength at position</code>
<code>        /numSA [ msglen {0} repeat 0 ] def</code>
<code>        /numEA [ msglen {0} repeat 0 ] def</code>
<code>        msglen 1 sub -1 0 {</code>
<code>            /i exch def</code>
<code>            msg i get 0 ge {</code>
<code>                msg i get 128 ge {</code>
<code>                    numEA i numEA i 1 add get 1 add put</code>
<code>                } {</code>
<code>                    numSA i numSA i 1 add get 1 add put</code>
<code>                } ifelse</code>
<code>            } if</code>
<code>        } for</code>
<code></code>
<code>        % FNC4 codeword insertion for extended ASCII</code>
<code>        /ea false def /msgtmp [] def</code>
<code>        0 1 msglen 1 sub {</code>
<code>            /i exch def</code>
<code>            /c msg i get def</code>
<code>            ea c 128 lt xor not c 0 ge and {  % Other mode required</code>
<code>                ea {numSA} {numEA} ifelse i get dup  % Runlength of other mode</code>
<code>                i add msglen eq {3} {5} ifelse       % Does run terminate symbol</code>
<code>                lt {  % Shift</code>
<code>                    /msgtmp [ msgtmp aload pop fn4 ] def</code>
<code>                } {   % Latch</code>
<code>                    /msgtmp [ msgtmp aload pop fn4 fn4 ] def</code>
<code>                    /ea ea not def</code>
<code>                } ifelse</code>
<code>            } if</code>
<code>            /msgtmp [ msgtmp aload pop c 0 ge {c 127 and} {c} ifelse ] def</code>
<code>        } for</code>
<code>        /msg msgtmp def</code>
<code>        /msglen msg length def</code>
<code></code>
<code>        % Determine digit runlength and characters from given position</code>
<code>        /numsscr {</code>
<code>            /n 0 def /s 0 def</code>
<code>            /p exch def {</code>
<code>                p msglen ge {exit} if</code>
<code>                msg p get</code>
<code>                dup setc exch known not {pop exit} if</code>
<code>                fn1 eq {</code>
<code>                    % FNC1 in odd position of run like two digits</code>
<code>                    s 2 mod 0 eq {/s s 1 add def} {exit} ifelse</code>
<code>                } if</code>
<code>                /n n 1 add def</code>
<code>                /s s 1 add def</code>
<code>                /p p 1 add def</code>
<code>            } loop</code>
<code>            n s</code>
<code>        } def</code>
<code></code>
<code>        % Encoding for each alphabet</code>
<code>        /enca {</code>
<code>            seta exch get cws exch j exch put</code>
<code>            /j j 1 add def</code>
<code>        } def</code>
<code>        /encb {</code>
<code>            setb exch get cws exch j exch put</code>
<code>            /j j 1 add def</code>
<code>        } def</code>
<code>        /encc {</code>
<code>            dup type /arraytype ne {</code>
<code>                setc exch get</code>
<code>            } {</code>
<code>                aload pop 48 sub exch 48 sub 10 mul add</code>
<code>            } ifelse</code>
<code>            cws exch j exch put</code>
<code>            /j j 1 add def</code>
<code>        } def</code>
<code></code>
<code>        % Character exclusively in either alphabet A or B</code>
<code>        /anotb {dup seta exch known exch setb exch known not and} def</code>
<code>        /bnota {dup setb exch known exch seta exch known not and} def</code>
<code></code>
<code>        % Pre-compute relative position of next anotb and next bnota characters</code>
<code>        /nextanotb [ msg length {0} repeat 9999 ] def</code>
<code>        /nextbnota [ msg length {0} repeat 9999 ] def</code>
<code>        msg length 1 sub -1 0 {</code>
<code>            /i exch def</code>
<code>            msg i get anotb {</code>
<code>                nextanotb i 0 put</code>
<code>            } {</code>
<code>                nextanotb i nextanotb i 1 add get 1 add put</code>
<code>            } ifelse</code>
<code>            msg i get bnota {</code>
<code>                nextbnota i 0 put</code>
<code>            } {</code>
<code>                nextbnota i nextbnota i 1 add get 1 add put</code>
<code>            } ifelse</code>
<code>        } for</code>
<code></code>
<code>        % Does a-only come before b-only after given position and vice versa</code>
<code>        /abeforeb {dup nextanotb exch get exch nextbnota exch get lt} def</code>
<code>        /bbeforea {dup nextbnota exch get exch nextanotb exch get lt} def</code>
<code></code>
<code>        /cws barcode length 2 mul 3 add array def</code>
<code></code>
<code>        % Select mode and encode first characters</code>
<code>        /i 0 def /j 0 def</code>
<code>        {  % common exit</code>
<code>            % extended data length</code>
<code>            sam -1 ne {</code>
<code>                % encode one and two</code>
<code>                cws 0 sam 10 idiv 1 sub put</code>
<code>                cws 1 sam 10 mod 1 sub put</code>
<code>                /j 2 def</code>
<code>                /cset (setb) def</code>
<code>                /mode 7 def</code>
<code>                exit</code>
<code>            } if</code>
<code>            % empty =&gt; b</code>
<code>            msglen 0 eq {</code>
<code>                /cset (setb) def</code>
<code>                /mode 1 def</code>
<code>                exit</code>
<code>            } if</code>
<code>            % FNC1 . 2+ nums =&gt; c fnc1</code>
<code>            msglen 2 ge {</code>
<code>                msg 0 get fn1 eq 1 numsscr exch pop 2 ge and {</code>
<code>                    /cset (setc) def</code>
<code>                    /mode 4 def</code>
<code>                    /i 1 def</code>
<code>                    exit</code>
<code>                } if</code>
<code>            } if</code>
<code>            % FNC1 =&gt; b fnc1</code>
<code>            msg 0 get fn1 eq {</code>
<code>                /cset (setb) def</code>
<code>                /mode 3 def</code>
<code>                /i 1 def</code>
<code>                exit</code>
<code>            } if</code>
<code>            msglen 2 ge {</code>
<code>                % 2+ even nums =&gt; c</code>
<code>                0 numsscr exch pop dup 2 ge exch 2 mod 0 eq and {</code>
<code>                    /cset (setc) def</code>
<code>                    /mode 2 def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                % 3+ odd nums =&gt; c sb1 encode</code>
<code>                0 numsscr exch pop dup 3 ge exch 2 mod 1 eq and {</code>
<code>                    msg 0 get encb</code>
<code>                    /cset (setc) def</code>
<code>                    /mode 5 def</code>
<code>                    /i 1 def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                % b . 2+ even nums =&gt; c sb1 encode</code>
<code>                setb msg 0 get known</code>
<code>                1 numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {</code>
<code>                    msg 0 get encb</code>
<code>                    /cset (setc) def</code>
<code>                    /mode 5 def</code>
<code>                    /i 1 def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                % b . 3+ odd nums =&gt; c sb2 encode</code>
<code>                setb msg 0 get known</code>
<code>                1 numsscr exch pop dup 3 ge exch 2 mod 1 eq and and {</code>
<code>                    msg 0 get encb</code>
<code>                    msg 1 get encb</code>
<code>                    /cset (setc) def</code>
<code>                    /mode 6 def</code>
<code>                    /i 2 def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                % b . b . 2+ even nums =&gt; c sb2 encode</code>
<code>                setb msg 0 get known</code>
<code>                setb msg 1 get known and</code>
<code>                2 numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {</code>
<code>                    msg 0 get encb</code>
<code>                    msg 1 get encb</code>
<code>                    /cset (setc) def</code>
<code>                    /mode 6 def</code>
<code>                    /i 2 def</code>
<code>                    exit</code>
<code>                } if</code>
<code>            } if</code>
<code>            % anotb before bnota =&gt; a</code>
<code>            0 abeforeb {</code>
<code>                /cset (seta) def</code>
<code>                /mode 0 def</code>
<code>                exit</code>
<code>            } if</code>
<code>            % otherwise =&gt; b</code>
<code>            /cset (setb) def</code>
<code>            /mode 1 def</code>
<code>            exit</code>
<code>        } loop</code>
<code></code>
<code>        {  % Encode remainder</code>
<code>            i msglen eq {exit} if</code>
<code></code>
<code>            i numsscr /nums exch def /nchars exch def</code>
<code></code>
<code>            % Determine switches and shifts</code>
<code>            {  % common exit</code>
<code>                cset (seta) eq {</code>
<code>                    % bnota . anotb before bnota =&gt; sb1 encode</code>
<code>                    i msglen 1 sub lt {</code>
<code>                        msg i get bnota</code>
<code>                        i 1 add abeforeb and {</code>
<code>                            sb1 enca</code>
<code>                            msg i get encb</code>
<code>                            /i i 1 add def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    % bnota . bnota . anotb before bnota =&gt; sb2 encode</code>
<code>                    i msglen 2 sub lt {</code>
<code>                        msg i get bnota</code>
<code>                        msg i 1 add get bnota and</code>
<code>                        i 2 add abeforeb and {</code>
<code>                            sb2 enca</code>
<code>                            msg i get encb</code>
<code>                            msg i 1 add get encb</code>
<code>                            /i i 2 add def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    % bnota =&gt; swb</code>
<code>                    msg i get bnota {</code>
<code>                        swb enca</code>
<code>                        /cset (setb) def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    % 4 nums . a =&gt; sc2 encode</code>
<code>                    i msglen 4 sub lt {</code>
<code>                        nums 4 eq</code>
<code>                        seta msg i 4 add get known and {</code>
<code>                            sc2 enca</code>
<code>                            2 {</code>
<code>                                msg i get fn1 eq {</code>
<code>                                    fn1 encc</code>
<code>                                    /i i 1 add def</code>
<code>                                } {</code>
<code>                                    msg i 2 getinterval encc</code>
<code>                                    /i i 2 add def</code>
<code>                                } ifelse</code>
<code>                            } repeat</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    % 6 nums . a =&gt; sc3 encode</code>
<code>                    i msglen 6 sub lt {</code>
<code>                        nums 6 eq</code>
<code>                        seta msg i 6 add get known and {</code>
<code>                            sc3 enca</code>
<code>                            3 {</code>
<code>                                msg i get fn1 eq {</code>
<code>                                    fn1 encc</code>
<code>                                    /i i 1 add def</code>
<code>                                } {</code>
<code>                                    msg i 2 getinterval encc</code>
<code>                                    /i i 2 add def</code>
<code>                                } ifelse</code>
<code>                            } repeat</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    % 4+ even nums =&gt; swc</code>
<code>                    nums 4 ge nums 2 mod 0 eq and {</code>
<code>                        swc enca</code>
<code>                        /cset (setc) def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    % otherwise =&gt; encode</code>
<code>                    msg i get enca</code>
<code>                    /i i 1 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                cset (setb) eq {</code>
<code>                    % anotb . bnota before anotb =&gt; sa1 encode</code>
<code>                    i msglen 1 sub lt {</code>
<code>                        msg i get anotb</code>
<code>                        i 1 add bbeforea and {</code>
<code>                            sa1 encb</code>
<code>                            msg i get enca</code>
<code>                            /i i 1 add def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    % anotb . anotb . bnota before anotb =&gt; sa2 encode</code>
<code>                    i msglen 2 sub lt {</code>
<code>                        msg i get anotb</code>
<code>                        msg i 1 add get anotb and</code>
<code>                        i 2 add bbeforea and {</code>
<code>                            sa2 encb</code>
<code>                            msg i get enca</code>
<code>                            msg i 1 add get enca</code>
<code>                            /i i 2 add def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    % anotb =&gt; swa</code>
<code>                    msg i get anotb {</code>
<code>                        swa encb</code>
<code>                        /cset (seta) def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    % 4 nums . b =&gt; sc2 encode</code>
<code>                    i msglen 4 sub lt {</code>
<code>                        nums 4 eq</code>
<code>                        setb msg i 4 add get known and {</code>
<code>                            sc2 encb</code>
<code>                            2 {</code>
<code>                                msg i get fn1 eq {</code>
<code>                                    fn1 encc</code>
<code>                                    /i i 1 add def</code>
<code>                                } {</code>
<code>                                    msg i 2 getinterval encc</code>
<code>                                    /i i 2 add def</code>
<code>                                } ifelse</code>
<code>                            } repeat</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    % 6 nums . b =&gt; sc3 encode</code>
<code>                    i msglen 6 sub lt {</code>
<code>                        nums 6 eq</code>
<code>                        setb msg i 6 add get known and {</code>
<code>                            sc3 encb</code>
<code>                            3 {</code>
<code>                                msg i get fn1 eq {</code>
<code>                                    fn1 encc</code>
<code>                                    /i i 1 add def</code>
<code>                                } {</code>
<code>                                    msg i 2 getinterval encc</code>
<code>                                    /i i 2 add def</code>
<code>                                } ifelse</code>
<code>                            } repeat</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    % 4+ even nums =&gt; swc</code>
<code>                    nums 4 ge nums 2 mod 0 eq and {</code>
<code>                        swc encb</code>
<code>                        /cset (setc) def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    % otherwise =&gt; encode</code>
<code>                    msg i get encb</code>
<code>                    /i i 1 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                cset (setc) eq {</code>
<code>                    % 2+ nums =&gt; encode</code>
<code>                    nums 2 ge {</code>
<code>                        msg i get fn1 eq {</code>
<code>                            fn1 encc</code>
<code>                            /i i 1 add def</code>
<code>                        } {</code>
<code>                            msg i 2 getinterval encc</code>
<code>                            /i i 2 add def</code>
<code>                        } ifelse</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    % b . 2+ even nums =&gt; sb1 encode</code>
<code>                    i msglen 1 sub lt {</code>
<code>                        setb msg i get known</code>
<code>                        i 1 add numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {</code>
<code>                            sb1 encc</code>
<code>                            msg i get encb</code>
<code>                            /i i 1 add def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    % b . 3+ odd nums =&gt; sb2 encode</code>
<code>                    i msglen 1 sub lt {</code>
<code>                        setb msg i get known</code>
<code>                        i 1 add numsscr exch pop dup 3 ge exch 2 mod 1 eq and and {</code>
<code>                            sb2 encc</code>
<code>                            msg i get encb</code>
<code>                            msg i 1 add get encb</code>
<code>                            /i i 2 add def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    % b . b . 2+ even nums =&gt; sb2 encode</code>
<code>                    i msglen 2 sub lt {</code>
<code>                        setb msg i get known</code>
<code>                        setb msg i 1 add get known and</code>
<code>                        i 2 add numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {</code>
<code>                            sb2 encc</code>
<code>                            msg i get encb</code>
<code>                            msg i 1 add get encb</code>
<code>                            /i i 2 add def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    % b . b . 3+ odd nums =&gt; sb3 encode</code>
<code>                    i msglen 3 sub lt {</code>
<code>                        setb msg i get known</code>
<code>                        setb msg i 1 add get known and</code>
<code>                        i 2 add numsscr exch pop dup 3 ge exch 2 mod 1 eq and and {</code>
<code>                            sb3 encc</code>
<code>                            msg i get encb</code>
<code>                            msg i 1 add get encb</code>
<code>                            msg i 2 add get encb</code>
<code>                            /i i 3 add def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    % b . b . b . 2+ even nums =&gt; sb3 encode</code>
<code>                    i msglen 3 sub lt {</code>
<code>                        setb msg i get known</code>
<code>                        setb msg i 1 add get known and</code>
<code>                        setb msg i 2 add get known and</code>
<code>                        i 3 add numsscr exch pop dup 2 ge exch 2 mod 0 eq and and {</code>
<code>                            sb3 encc</code>
<code>                            msg i get encb</code>
<code>                            msg i 1 add get encb</code>
<code>                            msg i 2 add get encb</code>
<code>                            /i i 3 add def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    % anotb before bnota =&gt; swa</code>
<code>                    i abeforeb {</code>
<code>                        swa encc</code>
<code>                        /cset (seta) def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    % otherwise =&gt; swb</code>
<code>                    swb encc</code>
<code>                    /cset (setb) def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                exit</code>
<code>            } loop</code>
<code></code>
<code>        } loop</code>
<code>        /cws cws 0 j getinterval def</code>
<code>    } ifelse</code>
<code></code>
<code>    % Basic metrics for the each symbol</code>
<code>    %     r  dcws</code>
<code>{</code>
<code>    /metrics [</code>
<code>        [  2    7 ]</code>
<code>        [  3   12 ]</code>
<code>        [  4   17 ]</code>
<code>        [  5   22 ]</code>
<code>        [  6   27 ]</code>
<code>        [  7   32 ]</code>
<code>        [  8   37 ]</code>
<code>        [  9   42 ]</code>
<code>        [ 10   47 ]</code>
<code>        [ 11   52 ]</code>
<code>        [ 12   57 ]</code>
<code>        [ 13   62 ]</code>
<code>        [ 14   67 ]</code>
<code>        [ 15   72 ]</code>
<code>        [ 16   77 ]</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Select metrics of an appropriate symbol</code>
<code>    /urows rows def</code>
<code>    metrics {</code>
<code>        /m exch def</code>
<code>        /r    m 0 get def        % Columns in symbol</code>
<code>        /dcws m 1 get def        % Data codewords in symbol</code>
<code>        /okay true def</code>
<code>        urows 0 ne urows r ne and {/okay false def} if</code>
<code>        cws length dcws gt {/okay false def} if</code>
<code>        okay {exit} if</code>
<code>    } forall</code>
<code></code>
<code>    okay not {</code>
<code>        /bwipp.code16kNoValidSymbol (Maximum length exceeded or data too large for given options) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Extend cws to ncws codewords by addition of pad characters</code>
<code>    /cws [ cws aload pop dcws cws length sub {103} repeat ] def</code>
<code></code>
<code>    % Add the start character</code>
<code>    /cws [ r 2 sub 7 mul mode add cws aload pop ] def</code>
<code></code>
<code>    % Calculate the check characters</code>
<code>    0 0 1 dcws {dup 2 add exch cws exch get mul add} for</code>
<code>    107 mod /c1 exch def</code>
<code>    0 0 1 dcws {dup 1 add exch cws exch get mul add} for</code>
<code>    c1 dcws 2 add mul add 107 mod /c2 exch def</code>
<code>    /cws [ cws aload pop c1 c2 ] def</code>
<code></code>
<code>    options /debugcws known { /bwipp.debugcws cws //raiseerror exec } if</code>
<code></code>
<code>    % Create an array containing the character mappings</code>
<code>{</code>
<code>    /encs</code>
<code>    [ (212222) (222122) (222221) (121223) (121322) (131222) (122213)</code>
<code>      (122312) (132212) (221213) (221312) (231212) (112232) (122132)</code>
<code>      (122231) (113222) (123122) (123221) (223211) (221132) (221231)</code>
<code>      (213212) (223112) (312131) (311222) (321122) (321221) (312212)</code>
<code>      (322112) (322211) (212123) (212321) (232121) (111323) (131123)</code>
<code>      (131321) (112313) (132113) (132311) (211313) (231113) (231311)</code>
<code>      (112133) (112331) (132131) (113123) (113321) (133121) (313121)</code>
<code>      (211331) (231131) (213113) (213311) (213131) (311123) (311321)</code>
<code>      (331121) (312113) (312311) (332111) (314111) (221411) (431111)</code>
<code>      (111224) (111422) (121124) (121421) (141122) (141221) (112214)</code>
<code>      (112412) (122114) (122411) (142112) (142211) (241211) (221114)</code>
<code>      (413111) (241112) (134111) (111242) (121142) (121241) (114212)</code>
<code>      (124112) (124211) (411212) (421112) (421211) (212141) (214121)</code>
<code>      (412121) (111143) (111341) (131141) (114113) (114311) (411113)</code>
<code>      (411311) (113141) (114131) (311141) (411131) (211412) (211214)</code>
<code>      (211232) (211133)</code>
<code>    ] def</code>
<code></code>
<code>    % Start/stop character encodings</code>
<code>    /startencs [</code>
<code>        (3211) (2221) (2122) (1411) (1132) (1231) (1114) (3112)</code>
<code>        (3211) (2221) (2122) (1411) (1132) (1231) (1114) (3112)</code>
<code>    ] def</code>
<code>    /stopencsodd [</code>
<code>        (3211) (2221) (2122) (1411) (1132) (1231) (1114) (3112)</code>
<code>        (1132) (1231) (1114) (3112) (3211) (2221) (2122) (1411)</code>
<code>    ] def</code>
<code>    /stopencseven [</code>
<code>        (2122) (1411) (1132) (1231) (1114) (3112) (1132) (1231)</code>
<code>        (1114) (3112) (3211) (2221) (2122) (1411) (3211) (2221)</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    sam -1 eq sam 10 idiv 2 mod 1 eq or {</code>
<code>        /stopencs stopencsodd def</code>
<code>    } {</code>
<code>        /stopencs stopencseven def</code>
<code>    } ifelse</code>
<code></code>
<code>    % Derive the bits for each row</code>
<code>    /rowbits r array def</code>
<code>    0 1 r 1 sub {</code>
<code>        /i exch def</code>
<code>        /sbs [</code>
<code>            10</code>
<code>            startencs i get {48 sub} forall</code>
<code>            1</code>
<code>            cws i 5 mul 5 getinterval {</code>
<code>                encs exch get {48 sub} forall</code>
<code>            } forall</code>
<code>            stopencs i get {48 sub} forall</code>
<code>            1</code>
<code>        ] def</code>
<code>        mark</code>
<code>        1 sbs {1 index 0 eq {{1}} {{0}} ifelse repeat} forall</code>
<code>        counttomark 1 sub array astore exch pop exch pop</code>
<code>        rowbits i 3 -1 roll put</code>
<code>    } for</code>
<code></code>
<code>    % Populate the bitmap</code>
<code>    /pixs [</code>
<code>        81 sepheight mul {1} repeat</code>
<code>        0 1 r 2 sub {</code>
<code>            /i exch def</code>
<code>            rowheight {rowbits i get aload pop} repeat</code>
<code>            sepheight {10 {0} repeat 70 {1} repeat 0} repeat</code>
<code>        } for</code>
<code>        rowheight {rowbits r 1 sub get aload pop} repeat</code>
<code>        81 sepheight mul {1} repeat</code>
<code>    ] def</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renmatrix</code>
<code>    /pixs pixs</code>
<code>    /pixx 81</code>
<code>    /pixy pixs length 81 idiv</code>
<code>    /height pixs length 81 idiv 72 div</code>
<code>    /width 81 72 div</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /code16k dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER code16k--</code>
<code></code>
<code>% --BEGIN ENCODER code49--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix--</code>
<code>% --DESC: Code 49</code>
<code>% --EXAM: MULTIPLE ROWS IN CODE 49</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp code49 0.0 2024010300 265413 278096</code>
<code>%%BeginData:       1096 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/code49 {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /sam -1 def</code>
<code>    /append false def</code>
<code>    /rows 0 def</code>
<code>    /rowheight 8 def</code>
<code>    /sepheight 1 def</code>
<code>    /parse false def</code>
<code>    /parsefnc false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    rows 0 ne rows 2 lt rows 8 gt or and {</code>
<code>        /bwipp.code49badRows (Code 49 must have 2 to 8 rows) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    rowheight 8 lt {</code>
<code>        /bwipp.code49badRowHeight (Code 49 must have rowheight of at least 8) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    sepheight 1 lt {</code>
<code>        /bwipp.code49badSepHeight (Code 49 must have sepheight of at least 1) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    append sam -1 ne and {</code>
<code>        /bwipp.code49samAndAppend (sam and append cannot be specified together) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    sam -1 ne {</code>
<code>        true</code>
<code>        1 {</code>
<code>            sam dup 12 lt exch 99 gt or { pop false exit } if</code>
<code>            sam 10 mod 2 lt { pop false exit } if</code>
<code>            sam 10 idiv sam 10 mod gt { pop false exit } if</code>
<code>        } repeat</code>
<code>        not {</code>
<code>            /bwipp.code49badSAM (SAM must be formatted as "NM" for Nth of M symbols, from 2 to 9 symbols) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    /code49 //loadctx exec</code>
<code></code>
<code>{</code>
<code>    /s1 -1 def /s2 -2 def /fn1 -3 def /fn2 -4 def /fn3 -5 def /ns -6 def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Parse the input</code>
<code>    /fncvals &lt;&lt;</code>
<code>        /parse parse</code>
<code>        /parsefnc parsefnc</code>
<code>        (FNC1) fn1</code>
<code>        (FNC2) fn2</code>
<code>        (FNC3) fn3</code>
<code>    &gt;&gt; def</code>
<code>    /msg barcode fncvals //parseinput exec def</code>
<code>    /msglen msg length def</code>
<code></code>
<code>    msg {</code>
<code>        127 gt {</code>
<code>            /bwipp.code49badCharacter (Code 49 can only support ASCII characters with values 0 to 127) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>{</code>
<code>    % Character encodings</code>
<code>    /charmap [</code>
<code>        (0) (1) (2) (3) (4) (5) (6) (7) (8) (9)</code>
<code>        (A) (B) (C) (D) (E) (F) (G) (H) (I) (J) (K) (L) (M)</code>
<code>        (N) (O) (P) (Q) (R) (S) (T) (U) (V) (W) (X) (Y) (Z)</code>
<code>        (-) (.) ( ) ($) (/) (+) (%)</code>
<code>        s1  s2  fn1 fn2 fn3 ns</code>
<code>    ] def</code>
<code></code>
<code>    % Invert charmap to give character to value map</code>
<code>    /charvals 49 dict def</code>
<code>    0 1 48 {</code>
<code>        /i exch def</code>
<code>        charmap i get</code>
<code>        dup type /stringtype eq {0 get} if  % convert string to ASCII if required</code>
<code>        charvals exch i put</code>
<code>    } for</code>
<code></code>
<code>    % Shifted character encodings</code>
<code>    /combos</code>
<code>    [ (1 ) (1A) (1B) (1C) (1D) (1E) (1F) (1G) (1H) (1I) (1J) (1K) (1L) (1M) (1N) (1O)</code>
<code>      (1P) (1Q) (1R) (1S) (1T) (1U) (1V) (1W) (1X) (1Y) (1Z) (11) (12) (13) (14) (15)</code>
<code>      (  ) (16) (17) (18) ( $) ( %) (19) (10) (1-) (1.) (1$) ( +) (1/) ( -) ( .) ( /)</code>
<code>      ( 0) ( 1) ( 2) ( 3) ( 4) ( 5) ( 6) ( 7) ( 8) ( 9) (1+) (21) (22) (23) (24) (25)</code>
<code>      (26) ( A) ( B) ( C) ( D) ( E) ( F) ( G) ( H) ( I) ( J) ( K) ( L) ( M) ( N) ( O)</code>
<code>      ( P) ( Q) ( R) ( S) ( T) ( U) ( V) ( W) ( X) ( Y) ( Z) (27) (28) (29) (20) (2-)</code>
<code>      (2.) (2A) (2B) (2C) (2D) (2E) (2F) (2G) (2H) (2I) (2J) (2K) (2L) (2M) (2N) (2O)</code>
<code>      (2P) (2Q) (2R) (2S) (2T) (2U) (2V) (2W) (2X) (2Y) (2Z) (2$) (2/) (2+) (2%) (2 )</code>
<code>    ] def</code>
<code>    0 1 127 {</code>
<code>        /i exch def</code>
<code>        combos i get dup 0 get /c1 exch def 1 get /c2 exch def</code>
<code>        c1 49 eq {  % s1 char</code>
<code>            charvals i [ charvals s1 get charvals c2 get ] put</code>
<code>        } if</code>
<code>        c1 50 eq {  % s2 char</code>
<code>            charvals i [ charvals s2 get charvals c2 get ] put</code>
<code>        } if</code>
<code>    } for</code>
<code>} ctxdef</code>
<code></code>
<code>    /encodealpha {</code>
<code>        charvals exch get</code>
<code>        dup type /arraytype ne {1 array astore} if</code>
<code>        dup cws exch j exch putinterval</code>
<code>        length j add /j exch def</code>
<code>    } def</code>
<code></code>
<code>    /base48 {</code>
<code>        0 exch {48 sub exch 10 mul add} forall</code>
<code>        [ 3 1 roll exch 1 sub {dup 48 mod exch 48 idiv} repeat ]</code>
<code>        [ exch dup length 1 sub -1 0 {1 index exch get exch} for pop ]</code>
<code>        dup cws exch j exch putinterval</code>
<code>        length j add /j exch def</code>
<code>    } def</code>
<code></code>
<code>    /encodenumeric {</code>
<code>        /nums exch def</code>
<code>        /pre nums length dup 5 mod dup 2 ne {sub} {sub 5 sub} ifelse def</code>
<code>        0 5 pre 1 sub {nums exch 5 getinterval 3 exch base48} for</code>
<code>        /nums nums pre nums length pre sub getinterval def</code>
<code>        nums length</code>
<code>        dup 1 eq {nums i get encodealpha} if</code>
<code>        dup 3 eq {2 nums base48} if</code>
<code>        dup 4 eq {3 [49 48 nums aload pop] base48} if</code>
<code>        7 eq {</code>
<code>            3 [49 48 nums 0 4 getinterval aload pop] base48</code>
<code>            2 nums 4 3 getinterval base48</code>
<code>        } if</code>
<code>    } def</code>
<code></code>
<code>    % Pre-compute alphanumeric and numeric runlengths</code>
<code>    /numericruns [ msglen {0} repeat 0 ] def</code>
<code>    msglen 1 sub -1 0 {</code>
<code>        /i exch def</code>
<code>        msg i get</code>
<code>        dup 48 ge exch 57 le and {</code>
<code>            numericruns i numericruns i 1 add get 1 add put</code>
<code>        } {</code>
<code>            numericruns i 0 put</code>
<code>        } ifelse</code>
<code>    } for</code>
<code></code>
<code>    /cws msglen 2 mul 1 add array def</code>
<code></code>
<code>{</code>
<code>    /samval [</code>
<code>        12 22</code>
<code>        13 23 33</code>
<code>        14 24 34 44</code>
<code>        15 25 35 45 55</code>
<code>        16 26 36 46 56 66</code>
<code>        17 27 37 47 57 67 77</code>
<code>        18 28 38 48 58 68 78 88</code>
<code>        19 29 39 49 59 69 79 89 99</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Autoselect and encode the starting mode</code>
<code>    {  % common exit</code>
<code>        append {  % Concatenate alphanumeric mode</code>
<code>            /mode 1 def</code>
<code>            /method (alpha) def</code>
<code>            /i 0 def /j 0 def</code>
<code>            exit</code>
<code>        } if</code>
<code>        sam -1 ne {  % Group alphanumeric mode</code>
<code>            /mode 3 def</code>
<code>            cws 0 0 1 43 { dup samval exch get sam ne {pop} if } for 1 add put</code>
<code>            /method (alpha) def</code>
<code>            /i 0 def /j 1 def</code>
<code>            exit</code>
<code>        } if</code>
<code>        numericruns 0 get 5 ge {  % Numeric mode</code>
<code>            /mode 2 def</code>
<code>            /method (numeric) def /i 0 def /j 0 def</code>
<code>            exit</code>
<code>        } if</code>
<code>        charvals msg 0 get get</code>
<code>        dup type /arraytype ne {  % Regular alphanumeric mode</code>
<code>            pop</code>
<code>            /mode 0 def</code>
<code>            /method (alpha) def</code>
<code>            /i 0 def /j 0 def</code>
<code>            exit</code>
<code>        } if</code>
<code>        % Alphanumeric mode starting shift 1 (mode=4) or shift 2 (mode=5)</code>
<code>        0 get 43 eq {4} {5} ifelse /mode exch def</code>
<code>        cws 0 charvals msg 0 get get 1 get put</code>
<code>        /method (alpha) def</code>
<code>        /i 1 def /j 1 def</code>
<code>        exit</code>
<code>    } loop</code>
<code></code>
<code>    % Encode remainder</code>
<code>    {</code>
<code>        i msglen eq {exit} if</code>
<code>        {  % not a loop but common exit point</code>
<code>            method (alpha) eq {</code>
<code>                numericruns i get 5 ge {</code>
<code>                    ns encodealpha</code>
<code>                    /method (numeric) def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                msg i get encodealpha</code>
<code>                /i i 1 add def</code>
<code>                exit</code>
<code>            } if</code>
<code>            method (numeric) eq {</code>
<code>                numericruns i get 5 lt {</code>
<code>                    ns encodealpha</code>
<code>                    /method (alpha) def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                msg i numericruns i get getinterval encodenumeric</code>
<code>                /i i numericruns i get add def</code>
<code>                exit</code>
<code>            } if</code>
<code>        } loop</code>
<code>    } loop</code>
<code>    /cws cws 0 j getinterval def</code>
<code></code>
<code>    % Basic metrics for the each symbol</code>
<code>    %     r dcws</code>
<code>{</code>
<code>    /metrics [</code>
<code>        [ 2    9 ]</code>
<code>        [ 3   16 ]</code>
<code>        [ 4   23 ]</code>
<code>        [ 5   30 ]</code>
<code>        [ 6   37 ]</code>
<code>        [ 7   42 ]</code>
<code>        [ 8   49 ]</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Select metrics of an appropriate symbol</code>
<code>    /urows rows def</code>
<code>    metrics {</code>
<code>        /m exch def</code>
<code>        /r    m 0 get def        % Columns in symbol</code>
<code>        /dcws m 1 get def        % Data codewords in symbol</code>
<code>        /okay true def</code>
<code>        urows 0 ne urows r ne and {/okay false def} if</code>
<code>        cws length dcws gt {/okay false def} if</code>
<code>        okay {exit} if</code>
<code>    } forall</code>
<code></code>
<code>    okay not {</code>
<code>        /bwipp.code49noValidSymbol (Maximum length exceeded) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Extend cws to ncws codewords by addition of pad characters</code>
<code>    /cws [ cws aload pop dcws cws length sub {48} repeat ] def</code>
<code></code>
<code>    % Populate code character array and add row check characters</code>
<code>    /ccs r 8 mul array def</code>
<code>    /j 0 def</code>
<code>    0 1 r 2 sub {</code>
<code>        /i exch def</code>
<code>        /cc cws j 7 getinterval def</code>
<code>        ccs i 8 mul cc putinterval</code>
<code>        ccs i 8 mul 7 add 0 cc {add} forall 49 mod put</code>
<code>        /j j 7 add def</code>
<code>    } for</code>
<code>    j dcws lt {</code>
<code>        ccs ccs length 8 sub cws j dcws j sub getinterval putinterval</code>
<code>    } if</code>
<code></code>
<code>    % Place row count character</code>
<code>    /cr7 r 2 sub 7 mul mode add def</code>
<code>    ccs ccs length 2 sub cr7 put</code>
<code></code>
<code>    % Calculate the symbol check characters</code>
<code>{</code>
<code>    [  1  9 31 26  2 12 17 23 37 18 22  6 27 44 15 43 39</code>
<code>      11 13  5 41 33 36  8  4 32  3 19 40 25 29 10 24 30 ]</code>
<code>    dup [ exch 20 exch 0 32 getinterval aload pop ] /weightx exch def</code>
<code>    dup [ exch 16 exch 1 32 getinterval aload pop ] /weighty exch def</code>
<code>        [ exch 38 exch 2 32 getinterval aload pop ] /weightz exch def</code>
<code>} ctxdef</code>
<code>    /calccheck {</code>
<code>        /weights exch def</code>
<code>        /score 0 def</code>
<code>        0 1 r 1 sub 8 mul 2 idiv 1 sub {</code>
<code>            /i exch def</code>
<code>            ccs i 2 mul get 49 mul ccs i 2 mul 1 add get add</code>
<code>            weights i 1 add get mul /score exch score add def</code>
<code>        } for</code>
<code>        score</code>
<code>    } def</code>
<code>    /lastrow ccs ccs length 8 sub 8 getinterval def</code>
<code></code>
<code>    % wr1 check character</code>
<code>    r 7 ge {</code>
<code>        cr7 weightz 0 get mul weightz calccheck add 2401 mod</code>
<code>        dup 49 idiv exch 49 mod 2 array astore</code>
<code>        lastrow 0 3 -1 roll putinterval</code>
<code>    } if</code>
<code>    /wr1 lastrow 0 get 49 mul lastrow 1 get add def</code>
<code></code>
<code>    % wr2 check character</code>
<code>    cr7 weighty 0 get mul weighty calccheck add</code>
<code>    wr1 weighty r 4 mul 3 sub get mul add</code>
<code>    2401 mod dup /wr2 exch def</code>
<code>    dup 49 idiv exch 49 mod 2 array astore</code>
<code>    lastrow 2 3 -1 roll putinterval</code>
<code></code>
<code>    % wr3 check character</code>
<code>    cr7 weightx 0 get mul weightx calccheck add</code>
<code>    wr1 weightx r 4 mul 3 sub get mul add</code>
<code>    wr2 weightx r 4 mul 2 sub get mul add</code>
<code>    2401 mod</code>
<code>    dup 49 idiv exch 49 mod 2 array astore</code>
<code>    lastrow 4 3 -1 roll putinterval</code>
<code></code>
<code>    % Place last row check character</code>
<code>    ccs ccs length 8 sub 7 getinterval 0 exch {add} forall 49 mod</code>
<code>    ccs ccs length 1 sub 3 -1 roll put</code>
<code></code>
<code>    options /debugcws known { /bwipp.debugcws ccs //raiseerror exec } if</code>
<code></code>
<code>{</code>
<code>    /patterns [</code>
<code>        [  % Even parity</code>
<code>            (11521132) (25112131) (14212132) (25121221) (14221222) (12412132) (23321221)</code>
<code>            (12421222) (21521221) (15112222) (15121312) (13312222) (24221311) (13321312)</code>
<code>            (11512222) (22421311) (11521312) (25112311) (14212312) (23312311) (12412312)</code>
<code>            (21512311) (16121131) (14321131) (12521131) (15212131) (15221221) (13412131)</code>
<code>            (13421221) (11612131) (16112221) (16121311) (14312221) (14321311) (12512221)</code>
<code>            (12521311) (15212311) (13412311) (11612311) (11131135) (31131133) (51131131)</code>
<code>            (21122134) (41122132) (21131224) (41131222) (11113135) (31113133) (51113131)</code>
<code>            (11122225) (31122223) (51122221) (11131315) (31131313) (51131311) (21113224)</code>
<code>            (41113222) (21122314) (41122312) (11113315) (31113313) (51113311) (12131134)</code>
<code>            (32131132) (21231133) (41231131) (22122133) (42122131) (11222134) (22131223)</code>
<code>            (42131221) (11231224) (31231222) (12113134) (32113132) (12122224) (32122222)</code>
<code>            (12131314) (32131312) (21231313) (41231311) (22113223) (42113221) (11213224)</code>
<code>            (22122313) (42122311) (11222314) (31222312) (12113314) (32113312) (21213313)</code>
<code>            (41213311) (13131133) (33131131) (22231132) (11331133) (31331131) (23122132)</code>
<code>            (12222133) (23131222) (12231223) (32231221) (21331222) (13113133) (33113131)</code>
<code>            (13122223) (33122221) (11313133) (13131313) (33131311) (11322223) (22231312)</code>
<code>            (11331313) (31331311) (23113222) (12213223) (23122312) (12222313) (32222311)</code>
<code>            (21322312) (13113313) (33113311) (22213312) (11313313) (31313311) (14131132)</code>
<code>            (23231131) (12331132) (21431131) (24122131) (13222132) (24131221) (13231222)</code>
<code>            (11422132) (22331221) (11431222) (14113132) (14122222) (12313132) (14131312)</code>
<code>            (12322222) (23231311) (12331312) (21431311) (24113221) (13213222) (24122311)</code>
<code>            (13222312) (11413222) (22322311) (11422312) (14113312) (23213311) (12313312)</code>
<code>            (21413311) (15131131) (13331131) (14222131) (14231221) (12422131) (12431221)</code>
<code>            (15113131) (15122221) (13313131) (15131311) (13322221) (11513131) (13331311)</code>
<code>            (11522221) (14213221) (14222311) (12413221) (12422311) (15113311) (13313311)</code>
<code>            (11513311) (11141134) (31141132) (21132133) (41132131) (21141223) (41141221)</code>
<code>            (11123134) (31123132) (11132224) (31132222) (11141314) (31141312) (21114133)</code>
<code>            (41114131) (21123223) (41123221) (21132313) (41132311) (11114224) (31114222)</code>
<code>            (11123314) (31123312) (21114313) (41114311) (12141133) (32141131) (21241132)</code>
<code>            (22132132) (11232133) (22141222) (11241223) (31241221) (12123133) (32123131)</code>
<code>            (12132223) (32132221) (12141313) (32141311) (21241312) (22114132) (11214133)</code>
<code>            (22123222) (11223223) (22132312) (11232313) (31232311) (12114223) (32114221)</code>
<code>            (12123313) (32123311) (21223312) (22114312) (11214313) (31214311) (13141132)</code>
<code>            (22241131) (11341132) (23132131) (12232132) (23141221) (12241222) (21341221)</code>
<code>            (13123132) (13132222) (11323132) (13141312) (11332222) (22241311) (11341312)</code>
<code>            (23114131) (12214132) (23123221) (12223222) (23132311) (12232312) (21332311)</code>
<code>            (13114222) (13123312) (11314222) (22223311) (11323312) (23114311) (12214312)</code>
<code>            (21314311) (14141131) (12341131) (13232131) (13241221) (11432131) (14123131)</code>
<code>            (14132221) (12323131) (14141311) (12332221) (12341311) (13214131) (13223221)</code>
<code>            (11414131) (13232311) (11423221) (11432311) (14114221) (14123311) (12314221)</code>
<code>            (12323311) (13214311) (11414311) (11151133) (31151131) (21142132) (21151222)</code>
<code>            (11133133) (31133131) (11142223) (31142221) (11151313) (31151311) (21124132)</code>
<code>            (21133222) (21142312) (11115133) (31115131) (11124223) (31124221) (11133313)</code>
<code>            (31133311) (21115222) (21124312) (12151132) (21251131) (22142131) (11242132)</code>
<code>            (22151221) (11251222) (12133132) (12142222) (12151312) (21251311) (22124131)</code>
<code>            (11224132) (22133221) (11233222) (22142311) (11242312) (12115132) (12124222)</code>
<code>            (12133312) (21233311) (22115221) (11215222) (22124311) (11224312) (13151131)</code>
<code>            (12242131) (12251221) (13133131) (13142221) (11333131) (13151311) (11342221)</code>
<code>            (12224131) (12233221) (12242311) (13115131) (13124221) (11315131) (13133311)</code>
<code>            (11324221) (11333311) (12215221) (12224311) (11161132) (21152131) (21161221)</code>
<code>            (11143132) (11152222) (11161312) (21134131) (21143221) (21152311) (11125132)</code>
<code>            (11134222) (11143312) (21116131) (21125221) (21134311) (12161131) (11252131)</code>
<code>            (12143131) (12152221) (12161311) (11234131) (11243221) (11252311) (12125131)</code>
<code>            (12134221) (12143311) (11216131) (11225221) (11234311) (11111236) (31111234)</code>
<code>            (51111232) (21111325) (41111323) (61111321) (11111416) (31111414) (51111412)</code>
<code>            (31211143) (51211141) (12111235) (32111233) (52111231) (21211234) (41211232)</code>
<code>            (22111324) (42111322) (11211325) (31211323) (51211321) (12111415) (32111413)</code>
<code>            (52111411) (21211414) (41211412) (12211144) (32211142) (21311143) (41311141)</code>
<code>            (13111234) (33111232) (22211233) (42211231) (11311234) (31311232) (23111323)</code>
<code>            (43111321) (12211324) (32211322) (21311323) (41311321) (13111414) (33111412)</code>
<code>            (22211413) (42211411) (11311414) (31311412) (13211143) (33211141) (22311142)</code>
<code>            (11411143) (31411141) (14111233) (34111231) (23211232) (12311233) (32311231)</code>
<code>            (21411232) (24111322) (13211323) (33211321) (22311322) (11411323) (31411321)</code>
<code>            (14111413) (34111411) (23211412) (12311413) (32311411) (21411412) (14211142)</code>
<code>            (23311141) (12411142) (21511141) (15111232) (24211231) (13311232) (22411231)</code>
<code>            (11511232) (25111321) (14211322) (23311321) (12411322) (21511321) (15111412)</code>
<code>            (24211411) (13311412) (22411411) (11511412) (15211141) (13411141) (11611141)</code>
<code>            (16111231) (14311231) (12511231) (15211321) (13411321) (11611321) (16111411)</code>
<code>            (14311411) (12511411) (21121144) (41121142) (11112145) (31112143) (51112141)</code>
<code>            (11121235) (31121233) (51121231) (21112234) (41112232) (21121324) (41121322)</code>
<code>            (11112325) (31112323) (51112321) (11121415) (31121413) (51121411) (21112414)</code>
<code>            (41112412) (22121143) (42121141) (11221144) (31221142) (12112144) (32112142)</code>
<code>            (12121234) (32121232) (21221233) (41221231) (22112233) (42112231) (11212234)</code>
<code>            (22121323) (42121321) (11221324) (31221322) (12112324) (32112322) (12121414)</code>
<code>            (32121412) (21221413) (41221411) (22112413) (42112411) (11212414) (31212412)</code>
<code>            (23121142) (12221143) (32221141) (21321142) (13112143) (33112141) (13121233)</code>
<code>            (33121231) (11312143) (22221232) (11321233) (31321231) (23112232) (12212233)</code>
<code>            (23121322) (12221323) (32221321) (21321322) (13112323) (33112321) (13121413)</code>
<code>            (33121411) (11312323) (22221412) (11321413) (31321411) (23112412) (12212413)</code>
<code>            (32212411) (21312412) (24121141) (13221142) (22321141) (11421142) (14112142)</code>
<code>            (14121232) (12312142) (23221231) (12321232) (21421231) (24112231) (13212232)</code>
<code>            (24121321) (13221322) (11412232) (22321321) (11421322) (14112322) (14121412)</code>
<code>            (12312322) (23221411) (12321412) (21421411) (24112411) (13212412) (22312411)</code>
<code>            (11412412) (14221141) (12421141) (15112141) (15121231) (13312141) (13321231)</code>
<code>            (11512141) (11521231) (14212231) (14221321) (12412231) (12421321) (15112321)</code>
<code>            (15121411) (13312321) (13321411) (11512321) (11521411) (14212411) (12412411)</code>
<code>            (21131143) (41131141) (11122144) (31122142) (11131234) (31131232) (21113143)</code>
<code>            (41113141) (21122233) (41122231) (21131323) (41131321) (11113234) (31113232)</code>
<code>            (11122324) (31122322) (11131414) (31131412) (21113323) (41113321) (21122413)</code>
<code>            (41122411) (11113414) (31113412) (22131142) (11231143) (31231141) (12122143)</code>
<code>            (32122141) (12131233) (32131231) (21231232) (22113142) (11213143) (22122232)</code>
<code>            (11222233) (22131322) (11231323) (31231321) (12113233) (32113231) (12122323)</code>
<code>            (32122321) (12131413) (32131411) (21231412) (22113322) (11213323) (22122412)</code>
<code>            (11222413) (31222411) (12113413) (32113411) (21213412) (23131141) (12231142)</code>
<code>            (21331141) (13122142) (13131232) (11322142) (22231231) (11331232) (23113141)</code>
<code>            (12213142) (23122231) (12222232) (23131321) (12231322) (21331321) (13113232)</code>
<code>            (13122322) (11313232) (13131412) (11322322) (22231411) (11331412) (23113321)</code>
<code>            (12213322) (23122411) (12222412) (21322411) (13113412) (22213411) (11313412)</code>
<code>            (13231141) (11431141) (14122141) (14131231) (12322141) (12331231) (13213141)</code>
<code>            (13222231) (11413141) (13231321) (11422231) (11431321) (14113231) (14122321)</code>
<code>            (12313231) (14131411) (12322321) (12331411) (13213321) (13222411) (11413321)</code>
<code>            (11422411) (14113411) (12313411) (21141142) (11132143) (31132141) (11141233)</code>
<code>            (31141231) (21123142) (21132232) (21141322) (11114143) (31114141) (11123233)</code>
<code>            (31123231) (11132323) (31132321) (11141413) (31141411) (21114232) (21123322)</code>
<code>            (21132412) (11114323) (31114321) (11123413) (31123411) (22141141) (11241142)</code>
<code>            (12132142) (12141232) (21241231) (22123141) (11223142) (22132231) (11232232)</code>
<code>            (22141321) (11241322) (12114142) (12123232) (12132322) (12141412) (21241411)</code>
<code>            (22114231) (11214232) (22123321) (11223322) (22132411) (11232412) (12114322)</code>
<code>            (12123412) (21223411) (12241141) (13132141) (13141231) (11332141) (11341231)</code>
<code>            (12223141) (12232231) (12241321) (13114141) (13123231) (11314141) (13132321)</code>
<code>            (11323231) (13141411) (11332321) (11341411) (12214231) (12223321) (12232411)</code>
<code>            (13114321) (13123411) (11314321) (11323411) (21151141) (11142142) (11151232)</code>
<code>            (21133141) (21142231) (21151321) (11124142) (11133232) (11142322) (11151412)</code>
<code>            (21115141) (21124231) (21133321) (21142411) (11115232) (11124322) (11133412)</code>
<code>            (11251141) (12142141) (12151231) (11233141) (11242231) (11251321) (12124141)</code>
<code>            (12133231) (12142321) (12151411) (11215141) (11224231) (11233321) (11242411)</code>
<code>            (12115231) (12124321) (12133411) (11152141) (11161231) (11134141) (11143231)</code>
<code>            (11152321) (11161411) (11116141) (11125231) (11134321) (11143411) (21111244)</code>
<code>            (41111242) (11111335) (31111333) (51111331) (21111424) (41111422) (11111515)</code>
<code>            (31111513) (51111511) (21211153) (41211151) (22111243) (42111241) (11211244)</code>
<code>            (31211242) (12111334) (32111332) (21211333) (41211331) (22111423) (42111421)</code>
<code>            (11211424) (31211422) (12111514) (32111512) (21211513) (41211511) (22211152)</code>
<code>            (11311153) (31311151) (23111242) (12211243) (32211241) (21311242) (13111333)</code>
<code>            (33111331) (22211332) (11311333) (31311331) (23111422) (12211423) (32211421)</code>
<code>            (21311422) (13111513) (33111511) (22211512) (11311513) (31311511) (23211151)</code>
<code>            (12311152) (21411151) (24111241) (13211242) (22311241) (11411242) (14111332)</code>
<code>            (23211331) (12311332) (21411331) (24111421) (13211422) (22311421) (11411422)</code>
<code>            (14111512) (23211511) (12311512) (21411511) (13311151) (11511151) (14211241)</code>
<code>            (12411241) (15111331) (13311331) (11511331) (14211421) (12411421) (15111511)</code>
<code>            (13311511) (11511511) (31121152) (21112153) (41112151) (21121243) (41121241)</code>
<code>            (11112244) (31112242) (11121334) (31121332) (21112333) (41112331) (21121423)</code>
<code>            (41121421) (11112424) (31112422) (11121514) (31121512) (21112513) (41112511)</code>
<code>            (12121153) (32121151) (21221152) (22112152) (11212153) (22121242) (11221243)</code>
<code>            (31221241) (12112243) (32112241) (12121333) (32121331) (21221332) (22112332)</code>
<code>            (11212333) (22121422) (11221423) (31221421) (12112423) (32112421) (12121513)</code>
<code>            (32121511) (21221512) (22112512) (11212513) (31212511) (13121152) (22221151)</code>
<code>            (11321152) (23112151) (12212152) (23121241) (12221242) (21321241) (13112242)</code>
<code>            (13121332) (11312242) (22221331) (11321332) (23112331) (12212332) (23121421)</code>
<code>            (12221422) (21321421) (13112422) (13121512) (11312422) (22221511) (11321512)</code>
<code>            (23112511) (12212512) (21312511) (14121151) (12321151) (13212151) (13221241)</code>
<code>            (11412151) (11421241) (14112241) (14121331) (12312241) (12321331) (13212331)</code>
<code>            (13221421) (11412331) (11421421) (14112421) (14121511) (12312421) (12321511)</code>
<code>            (13212511) (11412511) (11131153) (31131151) (21122152) (21131242) (11113153)</code>
<code>            (31113151) (11122243) (31122241) (11131333) (31131331) (21113242) (21122332)</code>
<code>            (21131422) (11113333) (31113331) (11122423) (31122421) (11131513) (31131511)</code>
<code>            (21113422) (21122512) (12131152) (21231151) (22122151) (11222152) (22131241)</code>
<code>            (11231242) (12113152) (12122242) (12131332) (21231331) (22113241) (11213242)</code>
<code>            (22122331) (11222332) (22131421) (11231422) (12113332) (12122422) (12131512)</code>
<code>            (21231511) (22113421) (11213422) (22122511) (11222512) (13131151) (11331151)</code>
<code>            (12222151) (12231241) (13113151) (13122241) (11313151) (13131331) (11322241)</code>
<code>            (11331331) (12213241) (12222331) (12231421) (13113331) (13122421) (11313331)</code>
<code>            (13131511) (11322421) (11331511) (12213421) (12222511) (11141152) (21132151)</code>
<code>            (21141241) (11123152) (11132242) (11141332) (21114151) (21123241) (21132331)</code>
<code>            (21141421) (11114242) (11123332) (11132422) (11141512) (21114331) (21123421)</code>
<code>            (21132511) (12141151) (11232151) (11241241) (12123151) (12132241) (12141331)</code>
<code>            (11214151) (11223241) (11232331) (11241421) (12114241) (12123331) (12132421)</code>
<code>            (12141511) (11214331) (11223421) (11232511) (11151151) (11133151) (11142241)</code>
<code>            (11151331) (11115151) (11124241) (11133331) (11142421) (11151511) (11111254)</code>
<code>            (31111252) (21111343) (41111341) (11111434) (31111432) (21111523) (41111521)</code>
<code>            (11111614) (31111612) (31211161) (12111253) (32111251) (21211252) (22111342)</code>
<code>            (11211343) (31211341) (12111433) (32111431) (21211432) (22111522) (11211523)</code>
<code>            (31211521) (12111613) (32111611) (21211612) (12211162) (21311161) (13111252)</code>
<code>            (22211251) (11311252) (23111341) (12211342) (21311341) (13111432) (22211431)</code>
<code>            (11311432) (23111521) (12211522) (21311521) (13111612) (22211611) (11311612)</code>
<code>            (13211161) (11411161) (14111251) (12311251) (13211341) (11411341) (14111431)</code>
<code>            (12311431) (13211521) (11411521) (14111611) (12311611) (21121162) (11112163)</code>
<code>            (31112161) (11121253) (31121251) (21112252) (21121342) (11112343) (31112341)</code>
<code>            (11121433) (31121431) (21112432) (21121522) (11112523) (31112521) (11121613)</code>
<code>            (31121611) (22121161) (11221162) (12112162) (12121252) (21221251) (22112251)</code>
<code>            (11212252) (22121341) (11221342) (12112342) (12121432) (21221431) (22112431)</code>
<code>            (11212432) (22121521) (11221522) (12112522) (12121612) (21221611) (12221161)</code>
<code>            (13112161) (13121251) (11312161) (11321251) (32121115) (52121113) (21221116)</code>
<code>            (41221114) (61221112) (22112116) (42112114) (31212115) (51212113) (13121116)</code>
<code>            (33121114) (22221115) (42221113) (11321116) (31321114) (51321112) (23112115)</code>
<code>            (43112113) (12212116) (32212114) (52212112) (21312115) (41312113) (61312111)</code>
<code>            (14121115) (34121113) (23221114) (43221112) (12321115) (32321113) (52321111)</code>
<code>            (21421114) (41421112) (24112114) (13212115) (33212113) (22312114) (42312112)</code>
<code>            (11412115) (31412113) (51412111) (15121114) (24221113) (13321114) (33321112)</code>
<code>            (22421113) (42421111) (11521114) (31521112) (25112113) (14212114) (34212112)</code>
<code>            (23312113) (43312111) (12412114) (32412112) (21512113) (41512111) (16121113)</code>
<code>            (25221112) (14321113) (34321111) (23421112) (12521113) (32521111) (15212113)</code>
<code>            (24312112) (13412113) (33412111) (22512112) (11612113) (31612111) (31131115)</code>
<code>            (51131113) (21122116) (41122114) (61122112) (31113115) (51113113) (12131116)</code>
<code>            (32131114) (52131112) (21231115) (41231113) (61231111) (22122115) (42122113)</code>
<code>            (11222116) (31222114) (51222112) (12113116) (32113114) (52113112) (21213115)</code>
<code>            (41213113) (61213111) (13131115) (33131113) (22231114) (42231112) (11331115)</code>
<code>            (31331113) (51331111) (23122114) (43122112) (12222115) (32222113) (52222111)</code>
<code>            (21322114) (41322112) (13113115) (33113113) (22213114) (42213112) (11313115)</code>
<code>            (31313113) (51313111) (14131114) (34131112) (23231113) (43231111) (12331114)</code>
<code>            (32331112) (21431113) (41431111) (24122113) (13222114) (33222112) (22322113)</code>
<code>            (42322111) (11422114) (31422112) (14113114) (34113112) (23213113) (43213111)</code>
<code>            (12313114) (32313112) (21413113) (41413111) (15131113) (24231112) (13331113)</code>
<code>            (33331111) (22431112) (25122112) (14222113) (34222111) (23322112) (12422113)</code>
<code>            (32422111) (21522112) (15113113) (24213112) (13313113) (33313111) (22413112)</code>
<code>            (11513113) (31513111) (16131112) (25231111) (14331112) (23431111) (15222112)</code>
<code>            (24322111) (13422112) (22522111) (16113112) (25213111) (14313112) (23413111)</code>
<code>            (12513112) (21613111) (11141116) (31141114) (51141112) (21132115) (41132113)</code>
<code>            (61132111) (11123116) (31123114) (51123112) (21114115) (41114113) (61114111)</code>
<code>            (12141115) (32141113) (52141111) (21241114) (41241112) (22132114) (42132112)</code>
<code>            (11232115) (31232113) (51232111) (12123115) (32123113) (52123111) (21223114)</code>
<code>            (41223112) (22114114) (42114112) (11214115) (31214113) (51214111) (13141114)</code>
<code>            (33141112) (22241113) (42241111) (11341114) (31341112) (23132113) (43132111)</code>
<code>            (12232114) (32232112) (21332113) (41332111) (13123114) (33123112) (22223113)</code>
<code>            (42223111) (11323114) (31323112) (23114113) (43114111) (12214114) (32214112)</code>
<code>            (21314113) (41314111) (14141113) (34141111) (23241112) (12341113) (32341111)</code>
<code>            (24132112) (13232113) (33232111) (22332112) (11432113) (31432111) (14123113)</code>
<code>            (34123111) (23223112) (12323113) (32323111) (21423112) (24114112) (13214113)</code>
<code>            (33214111) (22314112) (11414113) (31414111) (15141112) (24241111) (13341112)</code>
<code>            (25132111) (14232112) (23332111) (12432112) (15123112) (24223111) (13323112)</code>
<code>            (22423111) (11523112) (25114111) (14214112) (23314111) (12414112) (21514111)</code>
<code>            (16141111) (14341111) (15232111) (13432111) (16123111) (14323111) (12523111)</code>
<code>            (15214111) (13414111) (11614111) (11151115) (31151113) (51151111) (21142114)</code>
<code>            (41142112) (11133115) (31133113) (51133111) (21124114) (41124112) (11115115)</code>
<code>            (31115113) (51115111) (12151114) (32151112) (21251113) (41251111) (22142113)</code>
<code>            (42142111) (11242114) (31242112) (12133114) (32133112) (21233113) (41233111)</code>
<code>            (22124113) (42124111) (11224114) (31224112) (12115114) (32115112) (21215113)</code>
<code>            (41215111) (13151113) (33151111) (22251112) (23142112) (12242113) (32242111)</code>
<code>            (21342112) (13133113) (33133111) (22233112) (11333113) (31333111) (23124112)</code>
<code>            (12224113) (32224111) (21324112) (13115113) (33115111) (22215112) (11315113)</code>
<code>            (31315111) (14151112) (23251111) (24142111) (13242112) (22342111) (14133112)</code>
<code>            (23233111) (12333112) (21433111) (24124111) (13224112) (22324111) (11424112)</code>
<code>            (14115112) (23215111) (12315112) (21415111) (15151111) (14242111) (15133111)</code>
<code>            (13333111) (14224111) (12424111) (15115111) (13315111) (11515111) (11161114)</code>
<code>            (31161112) (21152113) (41152111) (11143114) (31143112) (21134113) (41134111)</code>
<code>            (11125114) (31125112) (21116113) (41116111) (12161113) (32161111) (22152112)</code>
<code>            (11252113) (31252111) (12143113) (32143111) (21243112) (22134112) (11234113)</code>
<code>            (31234111) (12125113) (32125111) (21225112) (22116112) (11216113) (31216111)</code>
<code>            (13161112) (23152111) (12252112) (13143112) (22243111) (11343112) (23134111)</code>
<code>            (12234112) (21334111) (13125112) (22225111) (11325112) (23116111) (12216112)</code>
<code>            (21316111) (14161111) (13252111) (14143111) (12343111) (13234111) (11434111)</code>
<code>            (14125111) (12325111) (13216111) (11416111) (31111216) (51111214) (31211125)</code>
<code>            (51211123) (32111215) (52111213) (21211216) (41211214) (61211212) (12211126)</code>
<code>            (32211124) (52211122) (21311125) (41311123) (61311121) (13111216) (33111214)</code>
<code>            (22211215) (42211213) (11311216) (31311214) (51311212) (13211125) (33211123)</code>
<code>            (22311124) (42311122) (11411125) (31411123) (51411121) (14111215) (34111213)</code>
<code>            (23211214) (43211212) (12311215) (32311213) (52311211) (21411214) (41411212)</code>
<code>            (14211124) (34211122) (23311123) (43311121) (12411124) (32411122) (21511123)</code>
<code>            (41511121) (15111214) (24211213) (13311214) (33311212) (22411213) (42411211)</code>
<code>            (11511214) (31511212) (15211123) (24311122) (13411123) (33411121) (22511122)</code>
<code>            (11611123) (31611121) (16111213) (25211212) (14311213) (34311211) (23411212)</code>
<code>            (12511213) (32511211) (21611212) (21121126) (41121124) (61121122) (31112125)</code>
<code>            (51112123) (31121215) (51121213) (21112216) (41112214) (61112212) (22121125)</code>
<code>            (42121123) (11221126) (31221124) (51221122) (12112126) (32112124) (52112122)</code>
<code>            (12121216) (32121214) (52121212) (21221215) (41221213) (61221211) (22112215)</code>
<code>            (42112213) (11212216) (31212214) (51212212) (23121124) (43121122) (12221125)</code>
<code>            (32221123) (52221121) (21321124) (41321122) (13112125) (33112123) (13121215)</code>
<code>            (33121213) (11312125) (22221214) (42221212) (11321215) (31321213) (51321211)</code>
<code>            (23112214) (43112212) (12212215) (32212213) (52212211) (21312214) (41312212)</code>
<code>            (24121123) (13221124) (33221122) (22321123) (42321121) (11421124) (31421122)</code>
<code>            (14112124) (34112122) (14121214) (34121212) (12312124) (23221213) (43221211)</code>
<code>            (12321214) (32321212) (21421213) (41421211) (24112213) (13212214) (33212212)</code>
<code>            (22312213) (42312211) (11412214) (31412212) (25121122) (14221123) (34221121)</code>
<code>            (23321122) (12421123) (32421121) (21521122) (15112123) (15121213) (13312123)</code>
<code>            (24221212) (13321213) (33321211) (11512123) (22421212) (11521213) (31521211)</code>
<code>            (25112212) (14212213) (34212211) (23312212) (12412213) (32412211) (21512212)</code>
<code>            (15221122) (24321121) (13421122) (22521121) (16112122) (16121212) (14312122)</code>
<code>            (25221211) (14321212) (12512122) (23421211) (12521212) (15212212) (24312211)</code>
<code>            (13412212) (22512211) (11612212) (21131125) (41131123) (61131121) (11122126)</code>
<code>            (31122124) (51122122) (11131216) (31131214) (51131212) (21113125) (41113123)</code>
<code>            (61113121) (21122215) (41122213) (61122211) (11113216) (31113214) (51113212)</code>
<code>            (22131124) (42131122) (11231125) (31231123) (51231121) (12122125) (32122123)</code>
<code>            (52122121) (12131215) (32131213) (52131211) (21231214) (41231212) (22113124)</code>
<code>            (42113122) (11213125) (22122214) (42122212) (11222215) (31222213) (51222211)</code>
<code>            (12113215) (32113213) (52113211) (21213214) (41213212) (23131123) (43131121)</code>
<code>            (12231124) (32231122) (21331123) (41331121) (13122124) (33122122) (13131214)</code>
<code>            (33131212) (11322124) (22231213) (42231211) (11331214) (31331212) (23113123)</code>
<code>            (43113121) (12213124) (23122213) (43122211) (12222214) (32222212) (21322213)</code>
<code>            (41322211) (13113214) (33113212) (22213213) (42213211) (11313214) (31313212)</code>
<code>            (24131122) (13231123) (33231121) (22331122) (11431123) (31431121) (14122123)</code>
<code>            (34122121) (14131213) (34131211) (12322123) (23231212) (12331213) (32331211)</code>
<code>            (21431212) (24113122) (13213123) (24122212) (13222213) (33222211) (11413123)</code>
<code>            (22322212) (11422213) (31422211) (14113213) (34113211) (23213212) (12313213)</code>
<code>            (32313211) (21413212) (25131121) (14231122) (23331121) (12431122) (15122122)</code>
<code>            (15131212) (13322122) (24231211) (13331212) (11522122) (22431211) (25113121)</code>
<code>            (14213122) (25122211) (14222212) (12413122) (23322211) (12422212) (21522211)</code>
<code>            (15113212) (24213211) (13313212) (22413211) (11513212) (15231121) (13431121)</code>
<code>            (16122121) (16131211) (14322121) (14331211) (12522121) (15213121) (15222211)</code>
<code>            (13413121) (13422211) (11613121) (16113211) (14313211) (12513211) (21141124)</code>
<code>            (41141122) (11132125) (31132123) (51132121) (11141215) (31141213) (51141211)</code>
<code>            (21123124) (41123122) (21132214) (41132212) (11114125) (31114123) (51114121)</code>
<code>            (11123215) (31123213) (51123211) (21114214) (41114212) (22141123) (42141121)</code>
<code>            (11241124) (31241122) (12132124) (32132122) (12141214) (32141212) (21241213)</code>
<code>            (41241211) (22123123) (42123121) (11223124) (22132213) (42132211) (11232214)</code>
<code>            (31232212) (12114124) (32114122) (12123214) (32123212) (21223213) (41223211)</code>
<code>            (22114213) (42114211) (11214214) (31214212) (23141122) (12241123) (32241121)</code>
<code>            (21341122) (13132123) (33132121) (13141213) (33141211) (11332123) (22241212)</code>
<code>            (11341213) (31341211) (23123122) (12223123) (23132212) (12232213) (32232211)</code>
<code>            (21332212) (13114123) (33114121) (13123213) (33123211) (11314123) (22223212)</code>
<code>            (11323213) (31323211) (23114212) (12214213) (32214211) (21314212) (24141121)</code>
<code>            (13241122) (22341121) (14132122) (14141212) (12332122) (23241211) (12341212)</code>
<code>            (24123121) (13223122) (24132211) (13232212) (11423122) (22332211) (11432212)</code>
<code>            (14114122) (14123212) (12314122) (23223211) (12323212) (21423211) (24114211)</code>
<code>            (13214212) (22314211) (11414212) (14241121) (15132121) (15141211) (13332121)</code>
<code>            (13341211) (14223121) (14232211) (12423121) (12432211) (15114121) (15123211)</code>
<code>            (13314121) (13323211) (11514121) (11523211) (14214211) (12414211) (21151123)</code>
<code>            (41151121) (11142124) (31142122) (11151214) (31151212) (21133123) (41133121)</code>
<code>            (21142213) (41142211) (11124124) (31124122) (11133214) (31133212) (21115123)</code>
<code>            (41115121) (21124213) (41124211) (11115214) (31115212) (22151122) (11251123)</code>
<code>            (31251121) (12142123) (32142121) (12151213) (32151211) (21251212) (22133122)</code>
<code>            (11233123) (22142212) (11242213) (31242211) (12124123) (32124121) (12133213)</code>
<code>            (32133211) (21233212) (22115122) (11215123) (22124212) (11224213) (31224211)</code>
<code>            (12115213) (32115211) (21215212) (23151121) (12251122) (13142122) (13151212)</code>
<code>            (11342122) (22251211) (23133121) (12233122) (23142211) (12242212) (21342211)</code>
<code>            (13124122) (13133212) (11324122) (22233211) (11333212) (23115121) (12215122)</code>
<code>            (23124211) (12224212) (21324211) (13115212) (22215211) (11315212) (13251121)</code>
<code>            (14142121) (14151211) (12342121) (13233121) (13242211) (11433121) (14124121)</code>
<code>            (14133211) (12324121) (12333211) (13215121) (13224211) (11415121) (11424211)</code>
<code>            (14115211) (12315211) (21161122) (11152123) (31152121) (11161213) (31161211)</code>
<code>            (21143122) (21152212) (11134123) (31134121) (11143213) (31143211) (21125122)</code>
<code>            (21134212) (11116123) (31116121) (11125213) (31125211) (22161121) (12152122)</code>
<code>            (12161212) (22143121) (11243122) (22152211) (11252212) (12134122) (12143212)</code>
<code>            (21243211) (22125121) (11225122) (22134211) (11234212) (12116122) (12125212)</code>
<code>            (21225211) (13152121) (13161211) (12243121) (12252211) (13134121) (13143211)</code>
<code>            (11334121) (11343211) (12225121) (12234211) (13116121) (13125211) (11316121)</code>
<code>            (11325211) (21111226) (41111224) (61111222) (31111315) (51111313) (21211135)</code>
<code>            (41211133) (61211131) (22111225) (42111223) (11211226) (31211224) (51211222)</code>
<code>            (12111316) (32111314) (52111312) (21211315) (41211313) (61211311) (22211134)</code>
<code>            (42211132) (11311135) (31311133) (51311131) (23111224) (43111222) (12211225)</code>
<code>            (32211223) (52211221) (21311224) (41311222) (13111315) (33111313) (22211314)</code>
<code>            (42211312) (11311315) (31311313) (51311311) (23211133) (43211131) (12311134)</code>
<code>            (32311132) (21411133) (41411131) (24111223) (13211224) (33211222) (22311223)</code>
<code>            (42311221) (11411224) (31411222) (14111314) (34111312) (23211313) (43211311)</code>
<code>            (12311314) (32311312) (21411313) (41411311) (24211132) (13311133) (33311131)</code>
<code>            (22411132) (11511133) (31511131) (25111222) (14211223) (34211221) (23311222)</code>
<code>            (12411223) (32411221) (21511222) (15111313) (24211312) (13311313) (33311311)</code>
<code>            (22411312) (11511313) (31511311) (25211131) (14311132) (23411131) (12511132)</code>
<code>            (21611131) (15211222) (24311221) (13411222) (22511221) (11611222) (16111312)</code>
<code>            (25211311) (14311312) (23411311) (12511312) (21611311) (31121134) (51121132)</code>
<code>            (21112135) (41112133) (61112131) (21121225) (41121223) (61121221) (11112226)</code>
<code>            (31112224) (51112222) (11121316) (31121314) (51121312) (21112315) (41112313)</code>
<code>            (61112311) (12121135) (32121133) (52121131) (21221134) (41221132) (22112134)</code>
<code>            (42112132) (11212135) (22121224) (42121222) (11221225) (31221223) (51221221)</code>
<code>            (12112225) (32112223) (52112221) (12121315) (32121313) (52121311) (21221314)</code>
<code>            (41221312) (22112314) (42112312) (11212315) (31212313) (51212311) (13121134)</code>
<code>            (33121132) (22221133) (42221131) (11321134) (31321132) (23112133) (43112131)</code>
<code>            (12212134) (23121223) (43121221) (12221224) (32221222) (21321223) (41321221)</code>
<code>            (13112224) (33112222) (13121314) (33121312) (11312224) (22221313) (42221311)</code>
<code>            (11321314) (31321312) (23112313) (43112311) (12212314) (32212312) (21312313)</code>
<code>            (41312311) (14121133) (34121131) (23221132) (12321133) (32321131) (21421132)</code>
<code>            (24112132) (13212133) (24121222) (13221223) (33221221) (11412133) (22321222)</code>
<code>            (11421223) (31421221) (14112223) (34112221) (14121313) (34121311) (12312223)</code>
<code>            (23221312) (12321313) (32321311) (21421312) (24112312) (13212313) (33212311)</code>
<code>            (22312312) (11412313) (31412311) (15121132) (24221131) (13321132) (22421131)</code>
<code>        ] [  % Odd parity</code>
<code>            (22121116) (42121114) (31221115) (51221113) (32112115) (52112113) (21212116)</code>
<code>            (41212114) (61212112) (23121115) (43121113) (12221116) (32221114) (52221112)</code>
<code>            (21321115) (41321113) (61321111) (13112116) (33112114) (22212115) (42212113)</code>
<code>            (11312116) (31312114) (51312112) (24121114) (13221115) (33221113) (22321114)</code>
<code>            (42321112) (11421115) (31421113) (51421111) (14112115) (34112113) (23212114)</code>
<code>            (43212112) (12312115) (32312113) (52312111) (21412114) (41412112) (25121113)</code>
<code>            (14221114) (34221112) (23321113) (43321111) (12421114) (32421112) (21521113)</code>
<code>            (41521111) (15112114) (24212113) (13312114) (33312112) (22412113) (42412111)</code>
<code>            (11512114) (31512112) (15221113) (24321112) (13421113) (33421111) (22521112)</code>
<code>            (16112113) (25212112) (14312113) (34312111) (23412112) (12512113) (32512111)</code>
<code>            (21612112) (21131116) (41131114) (61131112) (31122115) (51122113) (21113116)</code>
<code>            (41113114) (61113112) (22131115) (42131113) (11231116) (31231114) (51231112)</code>
<code>            (12122116) (32122114) (52122112) (21222115) (41222113) (61222111) (22113115)</code>
<code>            (42113113) (11213116) (31213114) (51213112) (23131114) (43131112) (12231115)</code>
<code>            (32231113) (52231111) (21331114) (41331112) (13122115) (33122113) (22222114)</code>
<code>            (42222112) (11322115) (31322113) (51322111) (23113114) (43113112) (12213115)</code>
<code>            (32213113) (52213111) (21313114) (41313112) (24131113) (13231114) (33231112)</code>
<code>            (22331113) (42331111) (11431114) (31431112) (14122114) (34122112) (23222113)</code>
<code>            (43222111) (12322114) (32322112) (21422113) (41422111) (24113113) (13213114)</code>
<code>            (33213112) (22313113) (42313111) (11413114) (31413112) (25131112) (14231113)</code>
<code>            (34231111) (23331112) (12431113) (32431111) (15122113) (24222112) (13322113)</code>
<code>            (33322111) (22422112) (11522113) (31522111) (25113112) (14213113) (34213111)</code>
<code>            (23313112) (12413113) (32413111) (21513112) (15231112) (24331111) (13431112)</code>
<code>            (16122112) (25222111) (14322112) (23422111) (12522112) (15213112) (24313111)</code>
<code>            (13413112) (22513111) (11613112) (21141115) (41141113) (61141111) (11132116)</code>
<code>            (31132114) (51132112) (21123115) (41123113) (61123111) (11114116) (31114114)</code>
<code>            (51114112) (22141114) (42141112) (11241115) (31241113) (51241111) (12132115)</code>
<code>            (32132113) (52132111) (21232114) (41232112) (22123114) (42123112) (11223115)</code>
<code>            (31223113) (51223111) (12114115) (32114113) (52114111) (21214114) (41214112)</code>
<code>            (23141113) (43141111) (12241114) (32241112) (21341113) (41341111) (13132114)</code>
<code>            (33132112) (22232113) (42232111) (11332114) (31332112) (23123113) (43123111)</code>
<code>            (12223114) (32223112) (21323113) (41323111) (13114114) (33114112) (22214113)</code>
<code>            (42214111) (11314114) (31314112) (24141112) (13241113) (33241111) (22341112)</code>
<code>            (14132113) (34132111) (23232112) (12332113) (32332111) (21432112) (24123112)</code>
<code>            (13223113) (33223111) (22323112) (11423113) (31423111) (14114113) (34114111)</code>
<code>            (23214112) (12314113) (32314111) (21414112) (25141111) (14241112) (23341111)</code>
<code>            (15132112) (24232111) (13332112) (22432111) (25123111) (14223112) (23323111)</code>
<code>            (12423112) (21523111) (15114112) (24214111) (13314112) (22414111) (11514112)</code>
<code>            (15241111) (16132111) (14332111) (15223111) (13423111) (16114111) (14314111)</code>
<code>            (12514111) (21151114) (41151112) (11142115) (31142113) (51142111) (21133114)</code>
<code>            (41133112) (11124115) (31124113) (51124111) (21115114) (41115112) (22151113)</code>
<code>            (42151111) (11251114) (31251112) (12142114) (32142112) (21242113) (41242111)</code>
<code>            (22133113) (42133111) (11233114) (31233112) (12124114) (32124112) (21224113)</code>
<code>            (41224111) (22115113) (42115111) (11215114) (31215112) (23151112) (12251113)</code>
<code>            (32251111) (13142113) (33142111) (22242112) (11342113) (31342111) (23133112)</code>
<code>            (12233113) (32233111) (21333112) (13124113) (33124111) (22224112) (11324113)</code>
<code>            (31324111) (23115112) (12215113) (32215111) (21315112) (24151111) (13251112)</code>
<code>            (14142112) (23242111) (12342112) (24133111) (13233112) (22333111) (11433112)</code>
<code>            (14124112) (23224111) (12324112) (21424111) (24115111) (13215112) (22315111)</code>
<code>            (11415112) (14251111) (15142111) (13342111) (14233111) (12433111) (15124111)</code>
<code>            (13324111) (11524111) (14215111) (12415111) (21161113) (41161111) (11152114)</code>
<code>            (31152112) (21143113) (41143111) (11134114) (31134112) (21125113) (41125111)</code>
<code>            (11116114) (31116112) (22161112) (12152113) (32152111) (21252112) (22143112)</code>
<code>            (11243113) (31243111) (12134113) (32134111) (21234112) (22125112) (11225113)</code>
<code>            (31225111) (12116113) (32116111) (21216112) (23161111) (13152112) (22252111)</code>
<code>            (23143111) (12243112) (21343111) (13134112) (22234111) (11334112) (23125111)</code>
<code>            (12225112) (21325111) (13116112) (22216111) (11316112) (14152111) (13243111)</code>
<code>            (14134111) (12334111) (13225111) (11425111) (14116111) (12316111) (41111215)</code>
<code>            (61111213) (21211126) (41211124) (61211122) (22111216) (42111214) (31211215)</code>
<code>            (51211213) (22211125) (42211123) (11311126) (31311124) (51311122) (23111215)</code>
<code>            (43111213) (12211216) (32211214) (52211212) (21311215) (41311213) (61311211)</code>
<code>            (23211124) (43211122) (12311125) (32311123) (52311121) (21411124) (41411122)</code>
<code>            (24111214) (13211215) (33211213) (22311214) (42311212) (11411215) (31411213)</code>
<code>            (51411211) (24211123) (13311124) (33311122) (22411123) (42411121) (11511124)</code>
<code>            (31511122) (25111213) (14211214) (34211212) (23311213) (43311211) (12411214)</code>
<code>            (32411212) (21511213) (41511211) (25211122) (14311123) (34311121) (23411122)</code>
<code>            (12511123) (32511121) (21611122) (15211213) (24311212) (13411213) (33411211)</code>
<code>            (22511212) (11611213) (31611211) (31121125) (51121123) (21112126) (41112124)</code>
<code>            (61112122) (21121216) (41121214) (61121212) (31112215) (51112213) (12121126)</code>
<code>            (32121124) (52121122) (21221125) (41221123) (61221121) (22112125) (42112123)</code>
<code>            (11212126) (22121215) (42121213) (11221216) (31221214) (51221212) (12112216)</code>
<code>            (32112214) (52112212) (21212215) (41212213) (61212211) (13121125) (33121123)</code>
<code>            (22221124) (42221122) (11321125) (31321123) (51321121) (23112124) (43112122)</code>
<code>            (12212125) (23121214) (43121212) (12221215) (32221213) (52221211) (21321214)</code>
<code>            (41321212) (13112215) (33112213) (22212214) (42212212) (11312215) (31312213)</code>
<code>            (51312211) (14121124) (34121122) (23221123) (43221121) (12321124) (32321122)</code>
<code>            (21421123) (41421121) (24112123) (13212124) (24121213) (13221214) (33221212)</code>
<code>            (11412124) (22321213) (42321211) (11421214) (31421212) (14112214) (34112212)</code>
<code>            (23212213) (43212211) (12312214) (32312212) (21412213) (41412211) (15121123)</code>
<code>            (24221122) (13321123) (33321121) (22421122) (11521123) (31521121) (25112122)</code>
<code>            (14212123) (25121212) (14221213) (34221211) (12412123) (23321212) (12421213)</code>
<code>            (32421211) (21521212) (15112213) (24212212) (13312213) (33312211) (22412212)</code>
<code>            (11512213) (31512211) (16121122) (25221121) (14321122) (23421121) (12521122)</code>
<code>            (15212122) (15221212) (13412122) (24321211) (13421212) (11612122) (22521211)</code>
<code>            (16112212) (25212211) (14312212) (23412211) (12512212) (21612211) (11131126)</code>
<code>            (31131124) (51131122) (21122125) (41122123) (61122121) (21131215) (41131213)</code>
<code>            (61131211) (11113126) (31113124) (51113122) (11122216) (31122214) (51122212)</code>
<code>            (21113215) (41113213) (61113211) (12131125) (32131123) (52131121) (21231124)</code>
<code>            (41231122) (22122124) (42122122) (11222125) (22131214) (42131212) (11231215)</code>
<code>            (31231213) (51231211) (12113125) (32113123) (52113121) (12122215) (32122213)</code>
<code>            (52122211) (21222214) (41222212) (22113214) (42113212) (11213215) (31213213)</code>
<code>            (51213211) (13131124) (33131122) (22231123) (42231121) (11331124) (31331122)</code>
<code>            (23122123) (43122121) (12222124) (23131213) (43131211) (12231214) (32231212)</code>
<code>            (21331213) (41331211) (13113124) (33113122) (13122214) (33122212) (11313124)</code>
<code>            (22222213) (42222211) (11322214) (31322212) (23113213) (43113211) (12213214)</code>
<code>            (32213212) (21313213) (41313211) (14131123) (34131121) (23231122) (12331123)</code>
<code>            (32331121) (21431122) (24122122) (13222123) (24131212) (13231213) (33231211)</code>
<code>            (11422123) (22331212) (11431213) (31431211) (14113123) (34113121) (14122213)</code>
<code>            (34122211) (12313123) (23222212) (12322213) (32322211) (21422212) (24113212)</code>
<code>            (13213213) (33213211) (22313212) (11413213) (31413211) (15131122) (24231121)</code>
<code>            (13331122) (22431121) (25122121) (14222122) (25131211) (14231212) (12422122)</code>
<code>            (23331211) (12431212) (15113122) (15122212) (13313122) (24222211) (13322212)</code>
<code>            (11513122) (22422211) (11522212) (25113211) (14213212) (23313211) (12413212)</code>
<code>            (21513211) (16131121) (14331121) (15222121) (15231211) (13422121) (13431211)</code>
<code>            (16113121) (16122211) (14313121) (14322211) (12513121) (12522211) (15213211)</code>
<code>            (13413211) (11613211) (11141125) (31141123) (51141121) (21132124) (41132122)</code>
<code>            (21141214) (41141212) (11123125) (31123123) (51123121) (11132215) (31132213)</code>
<code>            (51132211) (21114124) (41114122) (21123214) (41123212) (11114215) (31114213)</code>
<code>            (51114211) (12141124) (32141122) (21241123) (41241121) (22132123) (42132121)</code>
<code>            (11232124) (22141213) (42141211) (11241214) (31241212) (12123124) (32123122)</code>
<code>            (12132214) (32132212) (21232213) (41232211) (22114123) (42114121) (11214124)</code>
<code>            (22123213) (42123211) (11223214) (31223212) (12114214) (32114212) (21214213)</code>
<code>            (41214211) (13141123) (33141121) (22241122) (11341123) (31341121) (23132122)</code>
<code>            (12232123) (23141212) (12241213) (32241211) (21341212) (13123123) (33123121)</code>
<code>            (13132213) (33132211) (11323123) (22232212) (11332213) (31332211) (23114122)</code>
<code>            (12214123) (23123212) (12223213) (32223211) (21323212) (13114213) (33114211)</code>
<code>            (22214212) (11314213) (31314211) (14141122) (23241121) (12341122) (24132121)</code>
<code>            (13232122) (24141211) (13241212) (11432122) (22341211) (14123122) (14132212)</code>
<code>            (12323122) (23232211) (12332212) (21432211) (24114121) (13214122) (24123211)</code>
<code>            (13223212) (11414122) (22323211) (11423212) (14114212) (23214211) (12314212)</code>
<code>            (21414211) (15141121) (13341121) (14232121) (14241211) (12432121) (15123121)</code>
<code>            (15132211) (13323121) (13332211) (11523121) (14214121) (14223211) (12414121)</code>
<code>            (12423211) (15114211) (13314211) (11514211) (11151124) (31151122) (21142123)</code>
<code>            (41142121) (21151213) (41151211) (11133124) (31133122) (11142214) (31142212)</code>
<code>            (21124123) (41124121) (21133213) (41133211) (11115124) (31115122) (11124214)</code>
<code>            (31124212) (21115213) (41115211) (12151123) (32151121) (21251122) (22142122)</code>
<code>            (11242123) (22151212) (11251213) (31251211) (12133123) (32133121) (12142213)</code>
<code>            (32142211) (21242212) (22124122) (11224123) (22133212) (11233213) (31233211)</code>
<code>            (12115123) (32115121) (12124213) (32124211) (21224212) (22115212) (11215213)</code>
<code>            (31215211) (13151122) (22251121) (23142121) (12242122) (23151211) (12251212)</code>
<code>            (13133122) (13142212) (11333122) (22242211) (11342212) (23124121) (12224122)</code>
<code>            (23133211) (12233212) (21333211) (13115122) (13124212) (11315122) (22224211)</code>
<code>            (11324212) (23115211) (12215212) (21315211) (14151121) (13242121) (13251211)</code>
<code>            (14133121) (14142211) (12333121) (12342211) (13224121) (13233211) (11424121)</code>
<code>            (11433211) (14115121) (14124211) (12315121) (12324211) (13215211) (11415211)</code>
<code>            (11161123) (31161121) (21152122) (21161212) (11143123) (31143121) (11152213)</code>
<code>            (31152211) (21134122) (21143212) (11125123) (31125121) (11134213) (31134211)</code>
<code>            (21116122) (21125212) (12161122) (22152121) (11252122) (22161211) (12143122)</code>
<code>            (12152212) (21252211) (22134121) (11234122) (22143211) (11243212) (12125122)</code>
<code>            (12134212) (21234211) (22116121) (11216122) (22125211) (11225212) (13161121)</code>
<code>            (12252121) (13143121) (13152211) (11343121) (12234121) (12243211) (13125121)</code>
<code>            (13134211) (11325121) (11334211) (12216121) (12225211) (31111225) (51111223)</code>
<code>            (21111316) (41111314) (61111312) (31211134) (51211132) (12111226) (32111224)</code>
<code>            (52111222) (21211225) (41211223) (61211221) (22111315) (42111313) (11211316)</code>
<code>            (31211314) (51211312) (12211135) (32211133) (52211131) (21311134) (41311132)</code>
<code>            (13111225) (33111223) (22211224) (42211222) (11311225) (31311223) (51311221)</code>
<code>            (23111314) (43111312) (12211315) (32211313) (52211311) (21311314) (41311312)</code>
<code>            (13211134) (33211132) (22311133) (42311131) (11411134) (31411132) (14111224)</code>
<code>            (34111222) (23211223) (43211221) (12311224) (32311222) (21411223) (41411221)</code>
<code>            (24111313) (13211314) (33211312) (22311313) (42311311) (11411314) (31411312)</code>
<code>            (14211133) (34211131) (23311132) (12411133) (32411131) (21511132) (15111223)</code>
<code>            (24211222) (13311223) (33311221) (22411222) (11511223) (31511221) (25111312)</code>
<code>            (14211313) (34211311) (23311312) (12411313) (32411311) (21511312) (15211132)</code>
<code>            (24311131) (13411132) (22511131) (11611132) (16111222) (25211221) (14311222)</code>
<code>            (23411221) (12511222) (21611221) (15211312) (24311311) (13411312) (22511311)</code>
<code>            (11611312) (21121135) (41121133) (61121131) (11112136) (31112134) (51112132)</code>
<code>            (11121226) (31121224) (51121222) (21112225) (41112223) (61112221) (21121315)</code>
<code>            (41121313) (61121311) (11112316) (31112314) (51112312) (22121134) (42121132)</code>
<code>            (11221135) (31221133) (51221131) (12112135) (32112133) (52112131) (12121225)</code>
<code>            (32121223) (52121221) (21221224) (41221222) (22112224) (42112222) (11212225)</code>
<code>            (22121314) (42121312) (11221315) (31221313) (51221311) (12112315) (32112313)</code>
<code>            (52112311) (21212314) (41212312) (23121133) (43121131) (12221134) (32221132)</code>
<code>            (21321133) (41321131) (13112134) (33112132) (13121224) (33121222) (11312134)</code>
<code>            (22221223) (42221221) (11321224) (31321222) (23112223) (43112221) (12212224)</code>
<code>            (23121313) (43121311) (12221314) (32221312) (21321313) (41321311) (13112314)</code>
<code>            (33112312) (22212313) (42212311) (11312314) (31312312) (24121132) (13221133)</code>
<code>            (33221131) (22321132) (11421133) (31421131) (14112133) (34112131) (14121223)</code>
<code>            (34121221) (12312133) (23221222) (12321223) (32321221) (21421222) (24112222)</code>
<code>            (13212223) (24121312) (13221313) (33221311) (11412223) (22321312) (11421313)</code>
<code>            (31421311) (14112313) (34112311) (23212312) (12312313) (32312311) (21412312)</code>
<code>            (25121131) (14221132) (23321131) (12421132) (21521131) (15112132) (15121222)</code>
<code>            (13312132) (24221221) (13321222) (11512132) (22421221) (11521222) (25112221)</code>
<code>            (14212222) (25121311) (14221312) (12412222) (23321311) (12421312) (21521311)</code>
<code>            (15112312) (24212311) (13312312) (22412311) (11512312) (15221131) (13421131)</code>
<code>            (16112131) (16121221) (14312131) (14321221) (12512131) (12521221) (15212221)</code>
<code>            (15221311) (13412221) (13421311) (11612221) (16112311) (14312311) (12512311)</code>
<code>            (21131134) (41131132) (11122135) (31122133) (51122131) (11131225) (31131223)</code>
<code>            (51131221) (21113134) (41113132) (21122224) (41122222) (21131314) (41131312)</code>
<code>            (11113225) (31113223) (51113221) (11122315) (31122313) (51122311) (21113314)</code>
<code>            (41113312) (22131133) (42131131) (11231134) (31231132) (12122134) (32122132)</code>
<code>            (12131224) (32131222) (21231223) (41231221) (22113133) (42113131) (11213134)</code>
<code>            (22122223) (42122221) (11222224) (22131313) (42131311) (11231314) (31231312)</code>
<code>            (12113224) (32113222) (12122314) (32122312) (21222313) (41222311) (22113313)</code>
<code>            (42113311) (11213314) (31213312) (23131132) (12231133) (32231131) (21331132)</code>
<code>            (13122133) (33122131) (13131223) (33131221) (11322133) (22231222) (11331223)</code>
<code>            (31331221) (23113132) (12213133) (23122222) (12222223) (23131312) (12231313)</code>
<code>            (32231311) (21331312) (13113223) (33113221) (13122313) (33122311) (11313223)</code>
<code>            (22222312) (11322313) (31322311) (23113312) (12213313) (32213311) (21313312)</code>
<code>            (24131131) (13231132) (22331131) (11431132) (14122132) (14131222) (12322132)</code>
<code>            (23231221) (12331222) (21431221) (24113131) (13213132) (24122221) (13222222)</code>
<code>            (24131311) (11413132) (13231312) (11422222) (22331311) (11431312) (14113222)</code>
<code>            (14122312) (12313222) (23222311) (12322312) (21422311) (24113311) (13213312)</code>
<code>            (22313311) (11413312) (14231131) (12431131) (15122131) (15131221) (13322131)</code>
<code>            (13331221) (11522131) (14213131) (14222221) (12413131) (14231311) (12422221)</code>
<code>            (12431311) (15113221) (15122311) (13313221) (13322311) (11513221) (11522311)</code>
<code>            (14213311) (12413311) (21141133) (41141131) (11132134) (31132132) (11141224)</code>
<code>            (31141222) (21123133) (41123131) (21132223) (41132221) (21141313) (41141311)</code>
<code>            (11114134) (31114132) (11123224) (31123222) (11132314) (31132312) (21114223)</code>
<code>            (41114221) (21123313) (41123311) (11114314) (31114312) (22141132) (11241133)</code>
<code>            (31241131) (12132133) (32132131) (12141223) (32141221) (21241222) (22123132)</code>
<code>            (11223133) (22132222) (11232223) (22141312) (11241313) (31241311) (12114133)</code>
<code>            (32114131) (12123223) (32123221) (12132313) (32132311) (21232312) (22114222)</code>
<code>            (11214223) (22123312) (11223313) (31223311) (12114313) (32114311) (21214312)</code>
<code>            (23141131) (12241132) (21341131) (13132132) (13141222) (11332132) (22241221)</code>
<code>            (11341222) (23123131) (12223132) (23132221) (12232222) (23141311) (12241312)</code>
<code>            (21341311) (13114132) (13123222) (11314132) (13132312) (11323222) (22232311)</code>
<code>            (11332312) (23114221) (12214222) (23123311) (12223312) (21323311) (13114312)</code>
<code>            (22214311) (11314312) (13241131) (14132131) (14141221) (12332131) (12341221)</code>
<code>            (13223131) (13232221) (11423131) (13241311) (11432221) (14114131) (14123221)</code>
<code>            (12314131) (14132311) (12323221) (12332311) (13214221) (13223311) (11414221)</code>
<code>            (11423311) (14114311) (12314311) (21151132) (11142133) (31142131) (11151223)</code>
<code>            (31151221) (21133132) (21142222) (21151312) (11124133) (31124131) (11133223)</code>
<code>            (31133221) (11142313) (31142311) (21115132) (21124222) (21133312) (11115223)</code>
<code>            (31115221) (11124313) (31124311) (22151131) (11251132) (12142132) (12151222)</code>
<code>            (21251221) (22133131) (11233132) (22142221) (11242222) (22151311) (11251312)</code>
<code>            (12124132) (12133222) (12142312) (21242311) (22115131) (11215132) (22124221)</code>
<code>            (11224222) (22133311) (11233312) (12115222) (12124312) (21224311) (12251131)</code>
<code>            (13142131) (13151221) (11342131) (12233131) (12242221) (12251311) (13124131)</code>
<code>            (13133221) (11324131) (13142311) (11333221) (11342311) (12215131) (12224221)</code>
<code>            (12233311) (13115221) (13124311) (11315221) (11324311) (21161131) (11152132)</code>
<code>            (11161222) (21143131) (21152221) (21161311) (11134132) (11143222) (11152312)</code>
<code>            (21125131) (21134221) (21143311) (11116132) (11125222) (11134312) (12152131)</code>
<code>            (12161221) (11243131) (11252221) (12134131) (12143221) (12152311) (11225131)</code>
<code>            (11234221) (11243311) (12116131) (12125221) (12134311) (21111235) (41111233)</code>
<code>            (61111231) (11111326) (31111324) (51111322) (21111415) (41111413) (61111411)</code>
<code>            (21211144) (41211142) (22111234) (42111232) (11211235) (31211233) (51211231)</code>
<code>            (12111325) (32111323) (52111321) (21211324) (41211322) (22111414) (42111412)</code>
<code>            (11211415) (31211413) (51211411) (22211143) (42211141) (11311144) (31311142)</code>
<code>            (23111233) (43111231) (12211234) (32211232) (21311233) (41311231) (13111324)</code>
<code>            (33111322) (22211323) (42211321) (11311324) (31311322) (23111413) (43111411)</code>
<code>            (12211414) (32211412) (21311413) (41311411) (23211142) (12311143) (32311141)</code>
<code>            (21411142) (24111232) (13211233) (33211231) (22311232) (11411233) (31411231)</code>
<code>            (14111323) (34111321) (23211322) (12311323) (32311321) (21411322) (24111412)</code>
<code>            (13211413) (33211411) (22311412) (11411413) (31411411) (24211141) (13311142)</code>
<code>            (22411141) (11511142) (25111231) (14211232) (23311231) (12411232) (21511231)</code>
<code>            (15111322) (24211321) (13311322) (22411321) (11511322) (25111411) (14211412)</code>
<code>            (23311411) (12411412) (21511411) (14311141) (12511141) (15211231) (13411231)</code>
<code>            (11611231) (16111321) (14311321) (12511321) (15211411) (13411411) (11611411)</code>
<code>            (31121143) (51121141) (21112144) (41112142) (21121234) (41121232) (11112235)</code>
<code>            (31112233) (51112231) (11121325) (31121323) (51121321) (21112324) (41112322)</code>
<code>            (21121414) (41121412) (11112415) (31112413) (51112411) (12121144) (32121142)</code>
<code>            (21221143) (41221141) (22112143) (42112141) (11212144) (22121233) (42121231)</code>
<code>            (11221234) (31221232) (12112234) (32112232) (12121324) (32121322) (21221323)</code>
<code>            (41221321) (22112323) (42112321) (11212324) (22121413) (42121411) (11221414)</code>
<code>            (31221412) (12112414) (32112412) (21212413) (41212411) (13121143) (33121141)</code>
<code>            (22221142) (11321143) (31321141) (23112142) (12212143) (23121232) (12221233)</code>
<code>            (32221231) (21321232) (13112233) (33112231) (13121323) (33121321) (11312233)</code>
<code>            (22221322) (11321323) (31321321) (23112322) (12212323) (23121412) (12221413)</code>
<code>            (32221411) (21321412) (13112413) (33112411) (22212412) (11312413) (31312411)</code>
<code>            (14121142) (23221141) (12321142) (21421141) (24112141) (13212142) (24121231)</code>
<code>            (13221232) (11412142) (22321231) (11421232) (14112232) (14121322) (12312232)</code>
<code>            (23221321) (12321322) (21421321) (24112321) (13212322) (24121411) (13221412)</code>
<code>            (11412322) (22321411) (11421412) (14112412) (23212411) (12312412) (21412411)</code>
<code>            (15121141) (13321141) (11521141) (14212141) (14221231) (12412141) (12421231)</code>
<code>            (15112231) (15121321) (13312231) (13321321) (11512231) (11521321) (14212321)</code>
<code>            (14221411) (12412321) (12421411) (15112411) (13312411) (11512411) (11131144)</code>
<code>            (31131142) (21122143) (41122141) (21131233) (41131231) (11113144) (31113142)</code>
<code>            (11122234) (31122232) (11131324) (31131322) (21113233) (41113231) (21122323)</code>
<code>            (41122321) (21131413) (41131411) (11113324) (31113322) (11122414) (31122412)</code>
<code>            (21113413) (41113411) (12131143) (32131141) (21231142) (22122142) (11222143)</code>
<code>            (22131232) (11231233) (31231231) (12113143) (32113141) (12122233) (32122231)</code>
<code>            (12131323) (32131321) (21231322) (22113232) (11213233) (22122322) (11222323)</code>
<code>            (22131412) (11231413) (31231411) (12113323) (32113321) (12122413) (32122411)</code>
<code>            (21222412) (22113412) (11213413) (31213411) (13131142) (22231141) (11331142)</code>
<code>            (23122141) (12222142) (23131231) (12231232) (21331231) (13113142) (13122232)</code>
<code>            (11313142) (13131322) (11322232) (22231321) (11331322) (23113231) (12213232)</code>
<code>            (23122321) (12222322) (23131411) (12231412) (21331411) (13113322) (13122412)</code>
<code>            (11313322) (22222411) (11322412) (23113411) (12213412) (21313411) (14131141)</code>
<code>            (12331141) (13222141) (13231231) (11422141) (11431231) (14113141) (14122231)</code>
<code>            (12313141) (14131321) (12322231) (12331321) (13213231) (13222321) (11413231)</code>
<code>            (13231411) (11422321) (11431411) (14113321) (14122411) (12313321) (12322411)</code>
<code>            (13213411) (11413411) (11141143) (31141141) (21132142) (21141232) (11123143)</code>
<code>            (31123141) (11132233) (31132231) (11141323) (31141321) (21114142) (21123232)</code>
<code>            (21132322) (21141412) (11114233) (31114231) (11123323) (31123321) (11132413)</code>
<code>            (31132411) (21114322) (21123412) (12141142) (21241141) (22132141) (11232142)</code>
<code>            (22141231) (11241232) (12123142) (12132232) (12141322) (21241321) (22114141)</code>
<code>            (11214142) (22123231) (11223232) (22132321) (11232322) (22141411) (11241412)</code>
<code>            (12114232) (12123322) (12132412) (21232411) (22114321) (11214322) (22123411)</code>
<code>            (11223412) (13141141) (11341141) (12232141) (12241231) (13123141) (13132231)</code>
<code>            (11323141) (13141321) (11332231) (11341321) (12214141) (12223231) (12232321)</code>
<code>            (12241411) (13114231) (13123321) (11314231) (13132411) (11323321) (11332411)</code>
<code>            (12214321) (12223411) (11151142) (21142141) (21151231) (11133142) (11142232)</code>
<code>            (11151322) (21124141) (21133231) (21142321) (21151411) (11115142) (11124232)</code>
<code>            (11133322) (11142412) (21115231) (21124321) (21133411) (12151141) (11242141)</code>
<code>            (11251231) (12133141) (12142231) (12151321) (11224141) (11233231) (11242321)</code>
<code>            (11251411) (12115141) (12124231) (12133321) (12142411) (11215231) (11224321)</code>
<code>            (11233411) (11161141) (11143141) (11152231) (11161321) (11125141) (11134231)</code>
<code>            (11143321) (11152411) (11111245) (31111243) (51111241) (21111334) (41111332)</code>
<code>            (11111425) (31111423) (51111421) (21111514) (41111512) (31211152) (12111244)</code>
<code>            (32111242) (21211243) (41211241) (22111333) (42111331) (11211334) (31211332)</code>
<code>            (12111424) (32111422) (21211423) (41211421) (22111513) (42111511) (11211514)</code>
<code>            (31211512) (12211153) (32211151) (21311152) (13111243) (33111241) (22211242)</code>
<code>            (11311243) (31311241) (23111332) (12211333) (32211331) (21311332) (13111423)</code>
<code>            (33111421) (22211422) (11311423) (31311421) (23111512) (12211513) (32211511)</code>
<code>            (21311512) (13211152) (22311151) (11411152) (14111242) (23211241) (12311242)</code>
<code>            (21411241) (24111331) (13211332) (22311331) (11411332) (14111422) (23211421)</code>
<code>            (12311422) (21411421) (24111511) (13211512) (22311511) (11411512) (14211151)</code>
<code>            (12411151) (15111241) (13311241) (11511241) (14211331) (12411331) (15111421)</code>
<code>            (13311421) (11511421) (14211511) (12411511) (21121153) (41121151) (11112154)</code>
<code>            (31112152) (11121244) (31121242) (21112243) (41112241) (21121333) (41121331)</code>
<code>            (11112334) (31112332) (11121424) (31121422) (21112423) (41112421) (21121513)</code>
<code>            (41121511) (11112514) (31112512) (22121152) (11221153) (31221151) (12112153)</code>
<code>            (32112151) (12121243) (32121241) (21221242) (22112242) (11212243) (22121332)</code>
<code>            (11221333) (31221331) (12112333) (32112331) (12121423) (32121421) (21221422)</code>
<code>            (22112422) (11212423) (22121512) (11221513) (31221511) (12112513) (32112511)</code>
<code>            (21212512) (23121151) (12221152) (21321151) (13112152) (13121242) (11312152)</code>
<code>            (22221241) (11321242) (23112241) (12212242) (23121331) (12221332) (21321331)</code>
<code>            (13112332) (13121422) (11312332) (22221421) (11321422) (23112421) (12212422)</code>
<code>            (23121511) (12221512) (21321511) (13112512) (22212511) (11312512) (13221151)</code>
<code>            (11421151) (14112151) (14121241) (12312151) (12321241) (13212241) (13221331)</code>
<code>            (11412241) (11421331) (14112331) (14121421) (12312331) (12321421) (13212421)</code>
<code>            (13221511) (11412421) (11421511) (14112511) (12312511) (21131152) (11122153)</code>
<code>            (31122151) (11131243) (31131241) (21113152) (21122242) (21131332) (11113243)</code>
<code>            (31113241) (11122333) (31122331) (11131423) (31131421) (21113332) (21122422)</code>
<code>            (21131512) (11113423) (31113421) (11122513) (31122511) (22131151) (11231152)</code>
<code>            (12122152) (12131242) (21231241) (22113151) (11213152) (22122241) (11222242)</code>
<code>            (22131331) (11231332) (12113242) (12122332) (12131422) (21231421) (22113331)</code>
<code>            (11213332) (22122421) (11222422) (22131511) (11231512) (12113422) (12122512)</code>
<code>            (21222511) (12231151) (13122151) (13131241) (11322151) (11331241) (12213151)</code>
<code>            (12222241) (12231331) (13113241) (13122331) (11313241) (13131421) (11322331)</code>
<code>            (11331421) (12213331) (12222421) (12231511) (13113421) (13122511) (11313421)</code>
<code>            (11322511) (21141151) (11132152) (11141242) (21123151) (21132241) (21141331)</code>
<code>            (11114152) (11123242) (11132332) (11141422) (21114241) (21123331) (21132421)</code>
<code>            (21141511) (11114332) (11123422) (11132512) (11241151) (12132151) (12141241)</code>
<code>            (11223151) (11232241) (11241331) (12114151) (12123241) (12132331) (12141421)</code>
<code>            (11214241) (11223331) (11232421) (11241511) (12114331) (12123421) (12132511)</code>
<code>            (11142151) (11151241) (11124151) (11133241) (11142331) (11151421) (11115241)</code>
<code>            (11124331) (11133421) (11142511) (21111253) (41111251) (11111344) (31111342)</code>
<code>            (21111433) (41111431) (11111524) (31111522) (21111613) (41111611) (21211162)</code>
<code>            (22111252) (11211253) (31211251) (12111343) (32111341) (21211342) (22111432)</code>
<code>            (11211433) (31211431) (12111523) (32111521) (21211522) (22111612) (11211613)</code>
<code>            (31211611) (22211161) (11311162) (23111251) (12211252) (21311251) (13111342)</code>
<code>            (22211341) (11311342) (23111431) (12211432) (21311431) (13111522) (22211521)</code>
<code>            (11311522) (23111611) (12211612) (21311611) (12311161) (13211251) (11411251)</code>
<code>            (14111341) (12311341) (13211431) (11411431) (14111521) (12311521) (13211611)</code>
<code>            (11411611) (31121161) (21112162) (21121252) (11112253) (31112251) (11121343)</code>
<code>            (31121341) (21112342) (21121432) (11112433) (31112431) (11121523) (31121521)</code>
<code>            (21112522) (21121612) (12121162) (21221161) (22112161) (11212162) (22121251)</code>
<code>            (11221252) (12112252) (12121342) (21221341) (22112341) (11212342) (22121431)</code>
<code>            (11221432) (12112432) (12121522) (21221521) (22112521) (11212522) (22121611)</code>
<code>            (11221612) (13121161) (11321161) (12212161) (12221251) (13112251) (13121341)</code>
<code>            (11312251) (11321341) (12212341) (12221431) (13112431) (13121521) (11312431)</code>
<code>            (11321521) (12212521) (12221611) (11131162) (21122161) (21131251) (11113162)</code>
<code>        ]</code>
<code>    ] def</code>
<code></code>
<code>    /parity [</code>
<code>        (1001) (0101) (1100) (0011) (1010) (0110) (1111) (0000)</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Derive the bits for each row</code>
<code>    /rowbits r array def</code>
<code>    0 1 r 1 sub {</code>
<code>        /i exch def</code>
<code>        /p i r 1 sub ne {parity i get} {(0000)} ifelse def</code>
<code>        /ccrow ccs i 8 mul 8 getinterval def</code>
<code>        /scrow [</code>
<code>            0 2 7 {ccrow exch 2 getinterval aload pop exch 49 mul add} for</code>
<code>        ] def</code>
<code>        /sbs [</code>
<code>            10 1 1</code>
<code>            0 1 3 {</code>
<code>                /j exch def</code>
<code>                patterns p j get 48 sub get scrow j get get {48 sub} forall</code>
<code>            } for</code>
<code>            4 1</code>
<code>        ] def</code>
<code>        mark</code>
<code>        1 sbs {1 index 0 eq {{1}} {{0}} ifelse repeat} forall</code>
<code>        counttomark 1 sub array astore exch pop exch pop</code>
<code>        rowbits i 3 -1 roll put</code>
<code>    } for</code>
<code></code>
<code>    % Populate the bitmap</code>
<code>    /pixs [</code>
<code>        81 sepheight mul {1} repeat</code>
<code>        0 1 r 2 sub {</code>
<code>            /i exch def</code>
<code>            rowheight {rowbits i get aload pop} repeat</code>
<code>            sepheight {10 {0} repeat 70 {1} repeat 0} repeat</code>
<code>        } for</code>
<code>        rowheight {rowbits r 1 sub get aload pop} repeat</code>
<code>        81 sepheight mul {1} repeat</code>
<code>    ] def</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renmatrix</code>
<code>    /pixs pixs</code>
<code>    /pixx 81</code>
<code>    /pixy pixs length 81 idiv</code>
<code>    /height pixs length 81 idiv 72 div</code>
<code>    /width 81 72 div</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /code49 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER code49--</code>
<code></code>
<code>% --BEGIN ENCODER channelcode--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear--</code>
<code>% --DESC: Channel Code</code>
<code>% --EXAM: 3493</code>
<code>% --EXOP: height=0.5 includetext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp channelcode 0.0 2024010300 133320 132535</code>
<code>%%BeginData:        252 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>%psc /channelcode {</code>
<code>%psc </code>
<code>%psc     20 dict begin                 % Confine variables to local scope</code>
<code>%psc </code>
<code>%psc     %psc /ctx null def</code>
<code>%psc     /dontdraw false def</code>
<code>%psc     /shortfinder false def</code>
<code>%psc     /includetext false def</code>
<code>%psc     /includecheck false def</code>
<code>%psc     /height 1.0 def</code>
<code>%psc </code>
<code>%psc     currentdict //processoptions exec /options exch def</code>
<code>%psc     /barcode exch def</code>
<code>%psc </code>
<code>%psc     /channelcode //loadctx exec</code>
<code>%psc </code>
<code>%psc     % Validate the input</code>
<code>%psc     barcode length 2 lt barcode length 7 gt or {</code>
<code>%psc         /bwipp.channelcodeBadLength (Channel Code must be 2 to 7 digits) //raiseerror exec</code>
<code>%psc     } if</code>
<code>%psc     barcode {</code>
<code>%psc         dup 48 lt exch 57 gt or {</code>
<code>%psc             /bwipp.channelcodeBadCharacter (Channel Code must contain only digits) //raiseerror exec</code>
<code>%psc         } if</code>
<code>%psc     } forall</code>
<code>%psc     barcode cvi [ 26 292 3493 44072 576688 7742862 ] barcode length 2 sub get gt {</code>
<code>%psc         /bwipp.channelcodeTooBig (The Channel Code value is too big for the number of channels) //raiseerror exec</code>
<code>%psc     } if</code>
<code>%psc </code>
<code>%psc     % Tail-call optimisation FTW!</code>
<code>%psc     /loops1 { /s2max s1max 1 add s1 sub def  /b1 1 def</code>
<code>%psc               s1 1 eq {nextb1} {loopb1} ifelse                             } def</code>
<code>%psc     /loopb1 { /b2max b1max 1 add b1 sub def  /s2 1 def  loops2             } def</code>
<code>%psc     /loops2 { /s3max s2max 1 add s2 sub def  /b2 1 def</code>
<code>%psc               s1 b1 add s2 add 3 eq {nextb2} {loopb2} ifelse               } def</code>
<code>%psc     /loopb2 { /b3max b2max 1 add b2 sub def  /s3 1 def  loops3             } def</code>
<code>%psc     /loops3 { /s4max s3max 1 add s3 sub def  /b3 1 def</code>
<code>%psc               b1 s2 add b2 add s3 add 4 eq {nextb3} {loopb3} ifelse        } def</code>
<code>%psc     /loopb3 { /b4max b3max 1 add b3 sub def  /s4 1 def  loops4             } def</code>
<code>%psc     /loops4 { /s5max s4max 1 add s4 sub def  /b4 1 def</code>
<code>%psc               b2 s3 add b3 add s4 add 4 eq {nextb4} {loopb4} ifelse        } def</code>
<code>%psc     /loopb4 { /b5max b4max 1 add b4 sub def  /s5 1 def  loops5             } def</code>
<code>%psc     /loops5 { /s6max s5max 1 add s5 sub def  /b5 1 def</code>
<code>%psc               b3 s4 add b4 add s5 add 4 eq {nextb5} {loopb5} ifelse        } def</code>
<code>%psc     /loopb5 { /b6max b5max 1 add b5 sub def  /s6 1 def  loops6             } def</code>
<code>%psc     /loops6 { /s7max s6max 1 add s6 sub def  /b6 1 def</code>
<code>%psc               b4 s5 add b5 add s6 add 4 eq {nextb6} {loopb6} ifelse        } def</code>
<code>%psc     /loopb6 { /b7max b6max 1 add b6 sub def  /s7 1 def  loops7             } def</code>
<code>%psc     /loops7 { /s8 s7max 1 add s7 sub def     /b7 1 def</code>
<code>%psc               b5 s6 add b6 add s7 add 4 eq {nextb7} {loopb7} ifelse        } def</code>
<code>%psc     /loopb7 { /b8 b7max 1 add b7 sub def</code>
<code>%psc               b6 s7 add b7 add s8 add b8 add 5 eq {nextb7} {chkchr} ifelse } def</code>
<code>%psc     /chkchr {</code>
<code>%psc         value target eq {</code>
<code>%psc             [s1 b1 s2 b2 s3 b3 s4 b4 s5 b5 s6 b6 s7 b7 s8 b8] exit</code>
<code>%psc         } if</code>
<code>%psc         /value value 1 add def</code>
<code>%psc         nextb7</code>
<code>%psc     } def</code>
<code>%psc     /nextb7 { /b7 b7 1 add def  b7 b7max le {loopb7} {nexts7} ifelse } def</code>
<code>%psc     /nexts7 { /s7 s7 1 add def  s7 s7max le {loops7} {nextb6} ifelse } def</code>
<code>%psc     /nextb6 { /b6 b6 1 add def  b6 b6max le {loopb6} {nexts6} ifelse } def</code>
<code>%psc     /nexts6 { /s6 s6 1 add def  s6 s6max le {loops6} {nextb5} ifelse } def</code>
<code>%psc     /nextb5 { /b5 b5 1 add def  b5 b5max le {loopb5} {nexts5} ifelse } def</code>
<code>%psc     /nexts5 { /s5 s5 1 add def  s5 s5max le {loops5} {nextb4} ifelse } def</code>
<code>%psc     /nextb4 { /b4 b4 1 add def  b4 b4max le {loopb4} {nexts4} ifelse } def</code>
<code>%psc     /nexts4 { /s4 s4 1 add def  s4 s4max le {loops4} {nextb3} ifelse } def</code>
<code>%psc     /nextb3 { /b3 b3 1 add def  b3 b3max le {loopb3} {nexts3} ifelse } def</code>
<code>%psc     /nexts3 { /s3 s3 1 add def  s3 s3max le {loops3} {nextb2} ifelse } def</code>
<code>%psc     /nextb2 { /b2 b2 1 add def  b2 b2max le {loopb2} {nexts2} ifelse } def</code>
<code>%psc     /nexts2 { /s2 s2 1 add def  s2 s2max le {loops2} {nextb1} ifelse } def</code>
<code>%psc     /nextb1 { /b1 b1 1 add def  b1 b1max le {loopb1} {nexts1} ifelse } def</code>
<code>%psc     /nexts1 { /s1 s1 1 add def  s1 s1max le {loops1} if              } def</code>
<code>%psc </code>
<code>%psc {</code>
<code>%psc     /memo [  % Accelerate generation of bar patterns</code>
<code>%psc         [  % CH3</code>
<code>%psc             [       0  [1 1 1 1 1 2 1 2]  [1 1 1 1 1 1 1 3]  [1 1 1 1 1 3 2]  [1 1 1 1 1 3 3] ]</code>
<code>%psc         ]</code>
<code>%psc         [  % CH4</code>
<code>%psc             [       0  [1 1 1 1 2 1 1 3]  [1 1 1 1 1 1 1 4]  [1 1 1 1 4 3 3]  [1 1 1 1 4 4 4] ]</code>
<code>%psc         ]</code>
<code>%psc         [  % CH5</code>
<code>%psc             [       0  [1 1 1 2 1 1 2 3]  [1 1 1 1 1 1 1 5]  [1 1 1 5 4 4 4]  [1 1 1 5 5 5 5] ]</code>
<code>%psc         ]</code>
<code>%psc         [  % CH6</code>
<code>%psc             [       0  [1 1 2 1 1 2 1 4]  [1 1 1 1 1 1 1 6]  [1 1 6 5 5 5 4]  [1 1 6 6 6 6 6] ]</code>
<code>%psc         ]</code>
<code>%psc         [  % CH7</code>
<code>%psc             [       0  [1 2 1 1 2 1 1 5]  [1 1 1 1 1 1 1 7]  [1 7 6 6 6 5 5]  [1 7 7 7 7 7 7] ]</code>
<code>%psc             [  150000  [1 3 1 1 2 4 1 1]  [1 1 3 1 2 3 2 1]  [1 7 5 5 5 4 1]  [1 7 7 5 5 4 2] ]</code>
<code>%psc             [  300000  [1 1 4 2 1 1 1 3]  [1 2 4 1 1 1 2 2]  [1 7 7 4 3 3 3]  [1 7 6 3 3 3 3] ]</code>
<code>%psc             [  450000  [1 1 4 1 1 4 1 1]  [1 3 2 1 2 1 2 2]  [1 7 7 4 4 4 1]  [1 7 5 4 4 3 3] ]</code>
<code>%psc         ]</code>
<code>%psc         [  % CH8</code>
<code>%psc             [       0  [2 1 1 2 1 1 2 5]  [1 1 1 1 1 1 1 8]  [8 7 7 7 6 6 6]  [8 8 8 8 8 8 8] ]</code>
<code>%psc             [  150000  [2 1 1 2 1 1 5 2]  [1 1 2 1 5 2 1 2]  [8 7 7 7 6 6 6]  [8 8 8 7 7 3 2] ]</code>
<code>%psc             [  300000  [2 1 1 4 2 2 2 1]  [1 1 4 2 1 2 1 3]  [8 7 7 7 4 3 2]  [8 8 8 5 4 4 3] ]</code>
<code>%psc             [  450000  [2 2 2 1 1 3 1 3]  [1 1 2 1 1 2 4 3]  [8 7 6 5 5 5 3]  [8 8 8 7 7 7 6] ]</code>
<code>%psc             [  600000  [2 3 1 1 4 2 1 1]  [1 1 3 1 3 1 2 3]  [8 7 5 5 5 2 1]  [8 8 8 6 6 4 4] ]</code>
<code>%psc             [  750000  [2 1 3 1 2 3 2 1]  [1 2 1 1 3 4 1 2]  [8 7 7 5 5 4 2]  [8 8 7 7 7 5 2] ]</code>
<code>%psc             [  900000  [2 2 1 4 1 2 2 1]  [1 2 1 2 1 5 1 2]  [8 7 6 6 3 3 2]  [8 8 7 7 6 6 2] ]</code>
<code>%psc             [ 1050000  [2 4 1 1 1 2 2 2]  [1 2 1 2 1 3 1 4]  [8 7 4 4 4 4 3]  [8 8 7 7 6 6 4] ]</code>
<code>%psc             [ 1200000  [2 2 1 5 2 1 1 1]  [1 3 1 3 2 1 1 3]  [8 7 6 6 2 1 1]  [8 8 6 6 4 3 3] ]</code>
<code>%psc             [ 1350000  [2 2 1 3 3 1 1 2]  [1 4 1 2 1 1 4 1]  [8 7 6 6 4 2 2]  [8 8 5 5 4 4 4] ]</code>
<code>%psc             [ 1500000  [3 1 2 2 2 1 1 3]  [1 1 1 1 2 2 4 3]  [8 6 6 5 4 3 3]  [8 8 8 8 8 7 6] ]</code>
<code>%psc             [ 1650000  [3 2 1 2 3 1 2 1]  [1 1 1 1 3 2 4 2]  [8 6 5 5 4 2 2]  [8 8 8 8 8 6 5] ]</code>
<code>%psc             [ 1800000  [3 1 1 3 2 3 1 1]  [1 2 1 1 3 4 2 1]  [8 6 6 6 4 3 1]  [8 8 7 7 7 5 2] ]</code>
<code>%psc             [ 1950000  [3 2 1 2 1 2 2 2]  [1 2 4 1 2 2 1 2]  [8 6 5 5 4 4 3]  [8 8 7 4 4 3 2] ]</code>
<code>%psc             [ 2100000  [3 1 2 1 4 2 1 1]  [1 4 1 2 1 1 2 3]  [8 6 6 5 5 2 1]  [8 8 5 5 4 4 4] ]</code>
<code>%psc             [ 2250000  [4 1 1 4 1 1 2 1]  [1 1 4 2 1 1 1 4]  [8 5 5 5 2 2 2]  [8 8 8 5 4 4 4] ]</code>
<code>%psc             [ 2400000  [4 3 1 2 1 2 1 1]  [1 2 4 2 2 2 1 1]  [8 5 3 3 2 2 1]  [8 8 7 4 3 2 1] ]</code>
<code>%psc             [ 2550000  [5 1 1 1 1 1 3 2]  [1 2 2 4 3 1 1 1]  [8 4 4 4 4 4 4]  [8 8 7 6 3 1 1] ]</code>
<code>%psc             [ 2700000  [1 1 3 6 1 1 1 1]  [2 1 1 2 1 1 6 1]  [8 8 8 6 1 1 1]  [8 7 7 7 6 6 6] ]</code>
<code>%psc             [ 2850000  [1 1 1 2 2 3 2 3]  [2 1 3 3 2 1 1 2]  [8 8 8 8 7 6 4]  [8 7 7 5 3 2 2] ]</code>
<code>%psc             [ 3000000  [1 2 3 3 3 1 1 1]  [2 1 1 1 5 1 2 2]  [8 8 7 5 3 1 1]  [8 7 7 7 7 3 3] ]</code>
<code>%psc             [ 3150000  [1 3 1 2 2 2 3 1]  [2 1 1 3 2 1 3 2]  [8 8 6 6 5 4 3]  [8 7 7 7 5 4 4] ]</code>
<code>%psc             [ 3300000  [1 5 1 1 3 1 1 2]  [2 1 1 4 3 2 1 1]  [8 8 4 4 4 2 2]  [8 7 7 7 4 2 1] ]</code>
<code>%psc             [ 3450000  [1 1 2 2 2 5 1 1]  [2 2 2 2 3 1 1 2]  [8 8 8 7 6 5 1]  [8 7 6 5 4 2 2] ]</code>
<code>%psc             [ 3600000  [1 2 1 1 3 4 2 1]  [2 2 3 1 1 1 2 3]  [8 8 7 7 7 5 2]  [8 7 6 4 4 4 4] ]</code>
<code>%psc             [ 3750000  [1 1 2 1 1 5 3 1]  [2 3 1 1 4 1 2 1]  [8 8 8 7 7 7 3]  [8 7 5 5 5 2 2] ]</code>
<code>%psc             [ 3900000  [1 3 1 2 4 2 1 1]  [2 3 3 1 1 1 2 2]  [8 8 6 6 5 2 1]  [8 7 5 3 3 3 3] ]</code>
<code>%psc             [ 4050000  [1 3 1 2 3 1 2 2]  [2 6 2 1 1 1 1 1]  [8 8 6 6 5 3 3]  [8 7 2 1 1 1 1] ]</code>
<code>%psc             [ 4200000  [2 1 1 2 1 2 2 4]  [2 1 3 1 3 3 1 1]  [8 7 7 7 6 6 5]  [8 7 7 5 5 3 1] ]</code>
<code>%psc             [ 4350000  [2 2 1 4 1 2 2 1]  [2 1 4 1 3 1 2 1]  [8 7 6 6 3 3 2]  [8 7 7 4 4 2 2] ]</code>
<code>%psc             [ 4500000  [2 1 1 1 2 1 3 4]  [2 2 2 1 2 1 3 2]  [8 7 7 7 7 6 6]  [8 7 6 5 5 4 4] ]</code>
<code>%psc             [ 4650000  [2 4 2 1 2 2 1 1]  [2 2 2 1 2 1 2 3]  [8 7 4 3 3 2 1]  [8 7 6 5 5 4 4] ]</code>
<code>%psc             [ 4800000  [2 3 2 1 1 2 2 2]  [2 4 1 2 1 1 3 1]  [8 7 5 4 4 4 3]  [8 7 4 4 3 3 3] ]</code>
<code>%psc             [ 4950000  [3 2 2 1 2 1 1 3]  [2 1 1 2 1 1 1 6]  [8 6 5 4 4 3 3]  [8 7 7 7 6 6 6] ]</code>
<code>%psc             [ 5100000  [3 2 1 1 1 3 3 1]  [2 2 3 2 1 1 3 1]  [8 6 5 5 5 5 3]  [8 7 6 4 3 3 3] ]</code>
<code>%psc             [ 5250000  [4 1 2 1 2 2 1 2]  [2 1 4 1 2 1 1 3]  [8 5 5 4 4 3 2]  [8 7 7 4 4 3 3] ]</code>
<code>%psc             [ 5400000  [5 1 2 1 2 1 1 2]  [2 2 1 1 4 1 3 1]  [8 4 4 3 3 2 2]  [8 7 6 6 6 3 3] ]</code>
<code>%psc             [ 5550000  [1 1 4 4 1 2 1 1]  [3 1 2 1 1 3 2 2]  [8 8 8 5 2 2 1]  [8 6 6 5 5 5 3] ]</code>
<code>%psc             [ 5700000  [1 2 1 1 2 1 3 4]  [3 1 4 1 2 2 1 1]  [8 8 7 7 7 6 6]  [8 6 6 3 3 2 1] ]</code>
<code>%psc             [ 5850000  [1 1 3 3 2 2 2 1]  [3 2 1 1 2 1 4 1]  [8 8 8 6 4 3 2]  [8 6 5 5 5 4 4] ]</code>
<code>%psc             [ 6000000  [1 4 3 1 1 2 1 2]  [3 2 2 1 2 2 1 2]  [8 8 5 3 3 3 2]  [8 6 5 4 4 3 2] ]</code>
<code>%psc             [ 6150000  [2 1 1 4 1 2 1 3]  [3 1 1 2 1 2 1 4]  [8 7 7 7 4 4 3]  [8 6 6 6 5 5 4] ]</code>
<code>%psc             [ 6300000  [2 2 2 1 3 2 2 1]  [3 1 4 1 3 1 1 1]  [8 7 6 5 5 3 2]  [8 6 6 3 3 1 1] ]</code>
<code>%psc             [ 6450000  [2 5 1 3 1 1 1 1]  [3 2 1 1 2 3 1 2]  [8 7 3 3 1 1 1]  [8 6 5 5 5 4 2] ]</code>
<code>%psc             [ 6600000  [3 2 3 1 2 1 2 1]  [3 1 3 2 2 1 1 2]  [8 6 5 3 3 2 2]  [8 6 6 4 3 2 2] ]</code>
<code>%psc             [ 6750000  [4 1 2 2 1 1 3 1]  [3 2 1 3 1 1 3 1]  [8 5 5 4 3 3 3]  [8 6 5 5 3 3 3] ]</code>
<code>%psc             [ 6900000  [1 2 1 4 2 2 2 1]  [4 1 1 2 2 2 2 1]  [8 8 7 7 4 3 2]  [8 5 5 5 4 3 2] ]</code>
<code>%psc             [ 7050000  [1 2 5 2 1 2 1 1]  [4 2 1 3 2 1 1 1]  [8 8 7 3 2 2 1]  [8 5 4 4 2 1 1] ]</code>
<code>%psc             [ 7200000  [2 2 2 1 3 1 3 1]  [4 1 3 1 3 1 1 1]  [8 7 6 5 5 3 3]  [8 5 5 3 3 1 1] ]</code>
<code>%psc             [ 7350000  [3 1 4 2 1 1 1 2]  [4 2 2 1 1 1 2 2]  [8 6 6 3 2 2 2]  [8 5 4 3 3 3 3] ]</code>
<code>%psc             [ 7500000  [1 1 1 4 1 1 3 3]  [5 2 1 2 2 1 1 1]  [8 8 8 8 5 5 5]  [8 4 3 3 2 1 1] ]</code>
<code>%psc             [ 7650000  [5 2 1 2 1 2 1 1]  [5 2 2 1 1 2 1 1]  [8 4 3 3 2 2 1]  [8 4 3 2 2 2 1] ]</code>
<code>%psc         ]</code>
<code>%psc     ] def</code>
<code>%psc } ctxdef</code>
<code>%psc </code>
<code>%psc     /encode {</code>
<code>%psc         /chan exch def</code>
<code>%psc         /target exch def</code>
<code>%psc </code>
<code>%psc         % Lookup memoized starting value close to the target</code>
<code>%psc         memo chan 3 sub get {</code>
<code>%psc             /m exch def</code>
<code>%psc             m 0 get target gt {exit} if</code>
<code>%psc             /mv    m 0 get def</code>
<code>%psc             /mb    m 1 get def</code>
<code>%psc             /ms    m 2 get def</code>
<code>%psc             /mbmax m 3 get def</code>
<code>%psc             /msmax m 4 get def</code>
<code>%psc         } forall</code>
<code>%psc         /value mv def</code>
<code>%psc         mb    aload pop [/b8 /b7 /b6 /b5 /b4 /b3 /b2 /b1] {exch def} forall</code>
<code>%psc         ms    aload pop [/s8 /s7 /s6 /s5 /s4 /s3 /s2 /s1] {exch def} forall</code>
<code>%psc         mbmax aload pop [/b7max /b6max /b5max /b4max /b3max /b2max /b1max] {exch def} forall</code>
<code>%psc         msmax aload pop [/s7max /s6max /s5max /s4max /s3max /s2max /s1max] {exch def} forall</code>
<code>%psc </code>
<code>%psc         1 {chkchr} repeat 8 chan sub 2 mul dup 16 exch sub getinterval</code>
<code>%psc </code>
<code>%psc     } def</code>
<code>%psc </code>
<code>%psc     /barlen barcode length def</code>
<code>%psc </code>
<code>%psc     % Determine finder</code>
<code>%psc     /finder shortfinder { [ 1 1 1 1 1 ] } { [ 1 1 1 1 1 1 1 1 1 ] } ifelse def</code>
<code>%psc </code>
<code>%psc     % Encode the main data</code>
<code>%psc     /data barcode cvi barlen 1 add encode def</code>
<code>%psc </code>
<code>%psc     % Determine check data</code>
<code>%psc {</code>
<code>%psc     /mod23map [</code>
<code>%psc             [] []</code>
<code>%psc             [ 13 12  4  9  3  1 ]</code>
<code>%psc             [  8  2 12  3 18 16  4  1 ]</code>
<code>%psc             [ 11 16 17  8 20  4 10  2  5  1 ]</code>
<code>%psc             [  1  4 16 18  3 12  2  8  9 13  6  1 ]</code>
<code>%psc             [ 20 16 22 13 15 12  5  4 17  9 21  3  7  1 ]</code>
<code>%psc             [  2  6 18  8  1  3  9  4 12 13 16  2  6 18  8  1 ]</code>
<code>%psc     ] def</code>
<code>%psc } ctxdef</code>
<code>%psc     /check [] def</code>
<code>%psc     includecheck {</code>
<code>%psc         /mod23 mod23map barlen get def</code>
<code>%psc         0</code>
<code>%psc         0 1 data length 1 sub {</code>
<code>%psc             dup data exch get 1 sub exch mod23 exch get mul add</code>
<code>%psc         } for</code>
<code>%psc         23 mod 3 encode /check exch def</code>
<code>%psc     } if</code>
<code>%psc </code>
<code>%psc     % Construct the symbol</code>
<code>%psc     /sbs [</code>
<code>%psc         finder aload pop</code>
<code>%psc         data aload pop</code>
<code>%psc         check aload pop</code>
<code>%psc     ] def</code>
<code>%psc </code>
<code>%psc     % Create the human readable text</code>
<code>%psc     /txt barlen array def</code>
<code>%psc     0 1 barlen 1 sub {</code>
<code>%psc         /i exch def</code>
<code>%psc         txt i [barcode i 1 getinterval 0 0 () 0] put</code>
<code>%psc     } for</code>
<code>%psc </code>
<code>%psc     % Return the arguments</code>
<code>%psc     &lt;&lt;</code>
<code>%psc     /ren //renlinear</code>
<code>%psc     /sbs sbs</code>
<code>%psc     /bhs [sbs length 1 add 2 idiv {height} repeat]</code>
<code>%psc     /bbs [sbs length 1 add 2 idiv {0} repeat]</code>
<code>%psc     /txt txt</code>
<code>%psc     /textxalign (center)</code>
<code>%psc     /borderleft 1.0</code>
<code>%psc     /borderright 2.0</code>
<code>%psc     /opt options</code>
<code>%psc     &gt;&gt;</code>
<code>%psc </code>
<code>%psc     dontdraw not //renlinear if</code>
<code>%psc </code>
<code>%psc     //unloadctx exec</code>
<code>%psc </code>
<code>%psc     end</code>
<code>%psc </code>
<code>%psc }</code>
<code>%psc [/barcode] {null def} forall</code>
<code>%psc bind def</code>
<code>%psc /channelcode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER channelcode--</code>
<code></code>
<code>% --BEGIN ENCODER flattermarken--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear--</code>
<code>% --DESC: Flattermarken</code>
<code>% --EXAM: 11099</code>
<code>% --EXOP: inkspread=-0.25 showborder borderleft=0 borderright=0</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp flattermarken 0.0 2024010300 62583 62412</code>
<code>%%BeginData:         82 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/flattermarken {</code>
<code></code>
<code>    20 dict begin                 % Confine variable to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /includetext false def   % Enable/disable text</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /height 0.3 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /flattermarken //loadctx exec</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.flattermarkenBadCharacter (Flattermarken must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>{</code>
<code>    % Create an array containing the character mappings</code>
<code>    /encs</code>
<code>    [ (0018) (0117) (0216) (0315) (0414) (0513) (0612) (0711) (0810)</code>
<code>      (0900)</code>
<code>    ] def</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>    /barchars (1234567890) def</code>
<code>} ctxdef</code>
<code></code>
<code>    /barlen barcode length def            % Length of the code</code>
<code></code>
<code>    /sbs barlen 4 mul string def</code>
<code>    /txt barlen array def</code>
<code></code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        % Lookup the encoding for the each barcode character</code>
<code>        barcode i 1 getinterval barchars exch search</code>
<code>        pop                                 % Discard true leaving pre</code>
<code>        length /indx exch def               % indx is the length of pre</code>
<code>        pop pop                             % Discard seek and post</code>
<code>        /enc encs indx get def              % Get the indxth encoding</code>
<code>        sbs i 4 mul enc putinterval         % Put encoded digit into sbs</code>
<code>        txt i [barcode i 1 getinterval i 9 mul textyoffset textfont textsize] put</code>
<code>    } for</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs [sbs {48 sub} forall]</code>
<code>    /bhs [sbs length 1 add 2 idiv {height} repeat]</code>
<code>    /bbs [sbs length 1 add 2 idiv {0} repeat]</code>
<code>    /txt txt</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /flattermarken dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER flattermarken--</code>
<code></code>
<code>% --BEGIN ENCODER raw--</code>
<code>% --REQUIRES preamble raiseerror processoptions renlinear--</code>
<code>% --DESC: Custom 1D symbology</code>
<code>% --EXAM: 331132131313411122131311333213114131131221323</code>
<code>% --EXOP: height=0.5</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp raw 0.0 2024010300 50104 50015</code>
<code>%%BeginData:         43 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/raw {</code>
<code></code>
<code>    20 dict begin                  % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /height 1.0 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Validate input</code>
<code>    barcode {</code>
<code>        dup 49 lt exch 57 gt or {</code>
<code>            /bwipp.rawBadCharacter (Raw must contain only digits 1 to 9) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs [barcode {48 sub} forall]</code>
<code>    /bhs [barcode length 1 add 2 idiv {height} repeat]</code>
<code>    /bbs [barcode length 1 add 2 idiv {0} repeat]</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /raw dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER raw--</code>
<code></code>
<code>% --BEGIN ENCODER daft--</code>
<code>% --REQUIRES preamble raiseerror processoptions renlinear--</code>
<code>% --DESC: Custom 4 state symbology</code>
<code>% --EXAM: FATDAFTDAD</code>
<code>% --EXOP:</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp daft 0.0 2024010300 53715 53468</code>
<code>%%BeginData:         71 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/daft {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /height 0.175 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.daftEmptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    barcode {</code>
<code>        dup 68 ne exch dup 65 ne exch dup 70 ne exch 84 ne and and and {</code>
<code>            /bwipp.daftBadCharacter (DAFT must contain only characters D, A, F and T) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code></code>
<code>    /barlen barcode length def</code>
<code></code>
<code>    /bbs barlen array def</code>
<code>    /bhs barlen array def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        /enc barcode i 1 getinterval def</code>
<code>        enc (D) eq {</code>
<code>            bbs i 0 height mul 8 div put</code>
<code>            bhs i 5 height mul 8 div put</code>
<code>        } if</code>
<code>        enc (A) eq {</code>
<code>            bbs i 3 height mul 8 div put</code>
<code>            bhs i 5 height mul 8 div put</code>
<code>        } if</code>
<code>        enc (F) eq {</code>
<code>            bbs i 0 height mul 8 div put</code>
<code>            bhs i 8 height mul 8 div put</code>
<code>        } if</code>
<code>        enc (T) eq {</code>
<code>            bbs i 3 height mul 8 div put</code>
<code>            bhs i 2 height mul 8 div put</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /bbs bbs</code>
<code>    /bhs bhs</code>
<code>    /sbs [bhs length 1 sub {1.44 1.872} repeat 1.44]</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /daft dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER daft--</code>
<code></code>
<code>% --BEGIN ENCODER symbol--</code>
<code>% --REQUIRES preamble raiseerror processoptions renlinear--</code>
<code>% --DESC: Miscellaneous symbols</code>
<code>% --EXAM: fima</code>
<code>% --EXOP: backgroundcolor=DD000011</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp symbol 0.0 2024010300 54198 53937</code>
<code>%%BeginData:         70 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/symbol {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /symbols &lt;&lt;</code>
<code>        /fima {</code>
<code>            /sbs [2.25 2.25 2.25 11.25 2.25 11.25 2.25 2.25 2.25] def</code>
<code>            /bhs [.625 .625 .625 .625 .625] def</code>
<code>            /bbs [0 0 0 0 0] def</code>
<code>        } bind</code>
<code>        /fimb {</code>
<code>            /sbs [2.25 6.75 2.25 2.25 2.25 6.25 2.25 2.25 2.25 6.75 2.25] def</code>
<code>            /bhs [.625 .625 .625 .625 .625 .625] def</code>
<code>            /bbs [0 0 0 0 0 0] def</code>
<code>        } bind</code>
<code>        /fimc {</code>
<code>            /sbs [2.25 2.25 2.25 6.75 2.25 6.75 2.25 6.75 2.25 2.25 2.25] def</code>
<code>            /bhs [.625 .625 .625 .625 .625 .625] def</code>
<code>            /bbs [0 0 0 0 0 0] def</code>
<code>        } bind</code>
<code>        /fimd {</code>
<code>            /sbs [2.25 2.25 2.25 2.25 2.25 6.75 2.25 6.75 2.25 2.25 2.25 2.25 2.25] def</code>
<code>            /bhs [.625 .625 .625 .625 .625 .625 .625] def</code>
<code>            /bbs [0 0 0 0 0 0 0] def</code>
<code>        } bind</code>
<code>        /fime {</code>
<code>            /sbs [2.25 6.75 2.25 15.75 2.25 6.75 2.25] def</code>
<code>            /bhs [.625 .625 .625 .625 .625 .625 .625] def</code>
<code>            /bbs [0 0 0 0 0 0 0] def</code>
<code>        } bind</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    % Valiate input</code>
<code>    symbols barcode known not {</code>
<code>        /bwipp.symbolUnknownSymbol (Unknown symbol name provided) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    symbols barcode get exec</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs sbs</code>
<code>    /bhs bhs</code>
<code>    /bbs bbs</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /symbol dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER symbol--</code>
<code></code>
<code>% --BEGIN ENCODER pdf417--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix--</code>
<code>% --DESC: PDF417</code>
<code>% --EXAM: This is PDF417</code>
<code>% --EXOP: columns=2</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp pdf417 0.0 2024010300 211198 212970</code>
<code>%%BeginData:        972 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/pdf417 {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /compact false def</code>
<code>    /eclevel -1 def</code>
<code>    /columns 0 def</code>
<code>    /rows 0 def</code>
<code>    /rowmult 3 def</code>
<code>    /ccc false def</code>
<code>    /raw false def</code>
<code>    /parse false def</code>
<code>    /parsefnc false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.pdf417emptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    eclevel -1 ne eclevel 0 lt eclevel 8 gt or and {</code>
<code>        /bwipp.pdf417InvalidErrorCorrectionLevel (Valid error correction levels are 0 to 8) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    ccc raw and {</code>
<code>        /bwipp.pdf417cccAndRaw (Cannot combine ccc and raw) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    ccc compact and {</code>
<code>        /bwipp.pdf417cccAndCompact (Cannot combine ccc and compact) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    rows 0 ne rows 3 lt rows 90 gt or and {</code>
<code>        /bwipp.pdf417invalidRows (There must be between 3 and 90 rows) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    columns 0 ne columns 1 lt columns 30 gt or and {</code>
<code>        /bwipp.pdf417invalidColumns (There must be between 1 and 30 columns) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    rowmult 0 le {</code>
<code>        /bwipp.pdf417badRowMult (The row multiplier must be greater than zero) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /pdf417 //loadctx exec</code>
<code></code>
<code>{</code>
<code>    % Modes and text submodes</code>
<code>    /T 0 def  /N 1 def  /B 2 def</code>
<code>    /A 0 def  /L 1 def  /M 2 def  /P 3 def</code>
<code></code>
<code>    % Special function characters for mode switching</code>
<code>    /tl -1 def  /nl -2 def  /bl -3 def  /bl6 -4 def  /bs -5 def</code>
<code></code>
<code>    % Special function characters for text mode</code>
<code>    /al -6 def  /ll -7 def  /ml -8 def  /pl -9 def  /as -10 def  /ps -11 def</code>
<code></code>
<code>    % Character maps for each state</code>
<code>    /charmaps [</code>
<code>      %  A    L    M    P</code>
<code>      [ (A)  (a)  (0)  (;) ]  % 0</code>
<code>      [ (B)  (b)  (1)  (&lt;) ]  % 1</code>
<code>      [ (C)  (c)  (2)  (&gt;) ]  % 2</code>
<code>      [ (D)  (d)  (3)  (@) ]  % 3</code>
<code>      [ (E)  (e)  (4)  ([) ]  % 4</code>
<code>      [ (F)  (f)  (5)   92 ]  % 5</code>
<code>      [ (G)  (g)  (6)  (]) ]  % 6</code>
<code>      [ (H)  (h)  (7)  (_) ]  % 7</code>
<code>      [ (I)  (i)  (8)  (`) ]  % 8</code>
<code>      [ (J)  (j)  (9)  (~) ]  % 9</code>
<code>      [ (K)  (k)  (&amp;)  (!) ]  % 10</code>
<code>      [ (L)  (l)   13   13 ]  % 11</code>
<code>      [ (M)  (m)    9    9 ]  % 12</code>
<code>      [ (N)  (n)  (,)  (,) ]  % 13</code>
<code>      [ (O)  (o)  (:)  (:) ]  % 14</code>
<code>      [ (P)  (p)  (#)   10 ]  % 15</code>
<code>      [ (Q)  (q)  (-)  (-) ]  % 16</code>
<code>      [ (R)  (r)  (.)  (.) ]  % 17</code>
<code>      [ (S)  (s)  ($)  ($) ]  % 18</code>
<code>      [ (T)  (t)  (/)  (/) ]  % 19</code>
<code>      [ (U)  (u)  (+)  (") ]  % 20</code>
<code>      [ (V)  (v)  (%)  (|) ]  % 21</code>
<code>      [ (W)  (w)  (*)  (*) ]  % 22</code>
<code>      [ (X)  (x)  (=)   40 ]  % 23</code>
<code>      [ (Y)  (y)  (^)   41 ]  % 24</code>
<code>      [ (Z)  (z)   pl  (?) ]  % 25</code>
<code>      [ ( )  ( )  ( )  ({) ]  % 26</code>
<code>      [  ll   as   ll  (}) ]  % 27</code>
<code>      [  ml   ml   al  (') ]  % 28</code>
<code>      [  ps   ps   ps   al ]  % 29</code>
<code>    ] def</code>
<code></code>
<code>    % Invert charmaps to give character to value maps for each state</code>
<code>    /charvals [ 30 dict 30 dict 30 dict 30 dict ] def</code>
<code>    /alltext 104 dict def</code>
<code>    0 1 charmaps length 1 sub {</code>
<code>        /i exch def</code>
<code>        /encs charmaps i get def</code>
<code>        0 1 3 {</code>
<code>            /j exch def</code>
<code>            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required</code>
<code>            dup charvals j get exch i put</code>
<code>            alltext exch -1 put</code>
<code>        } for</code>
<code>    } for</code>
<code></code>
<code>    /e 10000 def  % "Empty"</code>
<code></code>
<code>    /latlen [  % Bit length of latch between submodes</code>
<code>    % To:  A  L  M  P      From</code>
<code>        [  0  1  1  2 ]  % A</code>
<code>        [  2  0  1  2 ]  % L</code>
<code>        [  1  1  0  1 ]  % M</code>
<code>        [  1  2  2  0 ]  % P</code>
<code>    ] def</code>
<code></code>
<code>    /latseq [  % Latch sequences between submodes</code>
<code>    % To: A       L       M       P               From</code>
<code>        [ []      [ll]    [ml]    [ml pl]    ]  % A</code>
<code>        [ [ml al] []      [ml]    [ml pl]    ]  % L</code>
<code>        [ [al]    [ll]    []      [pl]       ]  % M</code>
<code>        [ [al]    [al ll] [al ml] []         ]  % P</code>
<code>    ] def</code>
<code></code>
<code>    /shftlen [  % Bit length of shift to submode</code>
<code>    % To:  A  L  M  P      From</code>
<code>        [  e  e  e  1 ]  % A</code>
<code>        [  1  e  e  1 ]  % L</code>
<code>        [  e  e  e  1 ]  % M</code>
<code>        [  e  e  e  e ]  % P</code>
<code>    ] def</code>
<code></code>
<code>    /latchcws &lt;&lt;</code>
<code>        tl 900  bl 901  bl6 924  nl 902  bs 913</code>
<code>    &gt;&gt; def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Convert input into array of codewords</code>
<code>    raw {</code>
<code>        /datcws barcode length array def</code>
<code>        /i 0 def /j 0 def</code>
<code>        { % loop</code>
<code>            i barcode length 3 sub ge {exit} if</code>
<code>            barcode i get 94 ne {exit} if</code>
<code>            barcode i 1 add 3 getinterval false 1 index {</code>
<code>                dup 48 lt exch 57 gt or { pop true } if</code>
<code>            } forall { pop exit } if</code>
<code>            cvi /cw exch def</code>
<code>            datcws j cw put</code>
<code>            /i i 4 add def</code>
<code>            /j j 1 add def</code>
<code>        } loop</code>
<code>        i barcode length ne {</code>
<code>            /bwipp.pdf417badRawFormat (raw data must be formatted as ^NNN) //raiseerror exec</code>
<code>        } if</code>
<code>        /datcws datcws 0 j getinterval def</code>
<code>    } if</code>
<code></code>
<code>    /encb {</code>
<code>        /in exch def</code>
<code>        /inlen in length def</code>
<code>        /out inlen 6 idiv 5 mul inlen 6 mod add array def</code>
<code>        0 1 inlen 6 idiv 1 sub {</code>
<code>            /k exch def</code>
<code>            /msbs [ in k 6 mul 3 getinterval aload pop ] def</code>
<code>            /mscs [</code>
<code>                msbs aload pop exch 256 mul add exch 65536 mul add</code>
<code>                3 {dup 900 mod exch 900 idiv} repeat</code>
<code>            ] def</code>
<code>            /lsbs [ in k 6 mul 3 add 3 getinterval aload pop ] def</code>
<code>            /lscs [</code>
<code>                lsbs aload pop exch 256 mul add exch 65536 mul add</code>
<code>                3 {dup 900 mod exch 900 idiv} repeat</code>
<code>            ] def</code>
<code>            lscs 0 get mscs 0 get 316 mul add</code>
<code>            out k 5 mul 4 add 2 index 900 mod put</code>
<code>            900 idiv lscs 1 get add mscs 0 get 641 mul add mscs 1 get 316 mul add</code>
<code>            out k 5 mul 3 add 2 index 900 mod put</code>
<code>            900 idiv lscs 2 get add mscs 0 get 20 mul add mscs 1 get 641 mul add mscs 2 get 316 mul add</code>
<code>            out k 5 mul 2 add 2 index 900 mod put</code>
<code>            900 idiv lscs 3 get add mscs 1 get 20 mul add mscs 2 get 641 mul add</code>
<code>            out k 5 mul 1 add 2 index 900 mod put</code>
<code>            900 idiv mscs 2 get 20 mul add</code>
<code>            out k 5 mul 3 -1 roll 900 mod put</code>
<code>        } for</code>
<code>        /rem inlen 6 mod def</code>
<code>        rem 0 ne {</code>
<code>            out out length rem sub</code>
<code>            [ in inlen rem sub rem getinterval aload pop ]</code>
<code>            putinterval</code>
<code>        } if</code>
<code>        out</code>
<code>    } def</code>
<code></code>
<code>    ccc {</code>
<code>        /barlen barcode length def</code>
<code>        /datcws barlen 6 idiv 5 mul barlen 6 mod add 2 add array def</code>
<code>        datcws 0 920 put</code>
<code>        datcws 1 barlen 6 mod 0 eq {924} {901} ifelse put</code>
<code>        datcws 2 [ barcode {} forall ] encb putinterval</code>
<code>    } if</code>
<code></code>
<code>    raw not ccc not and {</code>
<code></code>
<code>        % Parse the input</code>
<code>        /fncvals &lt;&lt;</code>
<code>            /parse parse</code>
<code>            /parsefnc parsefnc</code>
<code>            /eci true</code>
<code>            % Predates FNC non-data codewords, but supports ECI</code>
<code>        &gt;&gt; def</code>
<code>        /msg barcode fncvals //parseinput exec def</code>
<code>        /msglen msg length def</code>
<code></code>
<code>        % Determine runlengths of digits</code>
<code>        /numdigits [ msglen {0} repeat 0 ] def</code>
<code>        /numtext   [ msglen {0} repeat 0 ] def</code>
<code>        /numbytes  [ msglen {0} repeat 0 ] def</code>
<code>        /iseci     [ msglen {0} repeat 0 ] def</code>
<code>        msglen 1 sub -1 0 {</code>
<code>            /i exch def</code>
<code>            msg i get dup 48 ge exch 57 le and {</code>
<code>                numdigits i numdigits i 1 add get 1 add put</code>
<code>            } if</code>
<code>            alltext msg i get known numdigits i get 13 lt and {</code>
<code>                numtext i numtext i 1 add get 1 add put</code>
<code>            } if</code>
<code>            msg i get 0 ge numtext i get 5 lt and numdigits i get 13 lt and {</code>
<code>                numbytes i numbytes i 1 add get 1 add put</code>
<code>            } if</code>
<code>            iseci i msg i get -1000000 le put</code>
<code>        } for</code>
<code>        /numdigits numdigits 0 msglen getinterval def</code>
<code>        /numtext   numtext   0 msglen getinterval def</code>
<code>        /numbytes  numbytes  0 msglen getinterval def</code>
<code></code>
<code>        /seq [] def /seqlen 0 def /state T def /p 0 def {  % loop</code>
<code>            p msglen eq {exit} if</code>
<code>            iseci p get {</code>
<code>                /eci msg p get def</code>
<code>                /seq [</code>
<code>                    seq aload pop</code>
<code>                    [ eci ]</code>
<code>                ] def</code>
<code>                /p p 1 add def</code>
<code>                /seqlen seqlen eci -1810900 le {2} {eci -1000900 le {3} {2} ifelse} ifelse add def</code>
<code>            } {</code>
<code>            /n numdigits p get def</code>
<code>            n 13 ge n msglen eq n 8 ge and or {  % 13+ digits or all-numeric and 8+ digits</code>
<code>                /seq [</code>
<code>                    seq aload pop</code>
<code>                    nl</code>
<code>                    [ msg p n getinterval aload pop ]</code>
<code>                ] def</code>
<code>                /state N def</code>
<code>                /p p n add def</code>
<code>                /seqlen seqlen 1 add n add def</code>
<code>            } {  % next</code>
<code>            /t numtext p get def</code>
<code>            t 5 ge {</code>
<code>                /seq [</code>
<code>                    seq aload pop</code>
<code>                    state T ne {</code>
<code>                        tl</code>
<code>                    } if</code>
<code>                    [ msg p t getinterval aload pop ]</code>
<code>                ] def</code>
<code>                /state T def</code>
<code>                /p p t add def</code>
<code>                /seqlen seqlen 1 add t add def  % ish</code>
<code>            } {  % next</code>
<code>            /b numbytes p get def</code>
<code>            b 1 eq state T eq and {</code>
<code>                /seq [</code>
<code>                    seq aload pop</code>
<code>                    bs</code>
<code>                    [ msg p get ]</code>
<code>                ] def</code>
<code>                /p p b add def</code>
<code>                /seqlen seqlen 2 add def</code>
<code>            } {  % next</code>
<code>                /seq [</code>
<code>                    seq aload pop</code>
<code>                    b 6 mod 0 ne {bl} {bl6} ifelse</code>
<code>                    [ msg p b getinterval aload pop ]</code>
<code>                ] def</code>
<code>                /state B def</code>
<code>                /p p b add def</code>
<code>                /seqlen seqlen 1 add b add def</code>
<code>            } ifelse } ifelse } ifelse } ifelse</code>
<code>        } loop</code>
<code></code>
<code>        % Submode encoding functions</code>
<code>        /enca {charvals A get exch get} def</code>
<code>        /encl {charvals L get exch get} def</code>
<code>        /encm {charvals M get exch get} def</code>
<code>        /encp {charvals P get exch get} def</code>
<code>        /textencfuncs [ /enca /encl /encm /encp ] def</code>
<code></code>
<code>        /addtotext {</code>
<code>            text exch l exch put</code>
<code>            /l l 1 add def</code>
<code>        } def</code>
<code></code>
<code>        /enct {</code>
<code>            /in exch def</code>
<code></code>
<code>            /curlen [  e  e  e  e ] def</code>
<code>            curlen submode 0 put</code>
<code>            /curseq [ [] [] [] [] ] def</code>
<code></code>
<code>            % Derive the optimal sequences ending in each submode</code>
<code>            in {</code>
<code></code>
<code>                /char exch def</code>
<code></code>
<code>                % Check for optimisations in the current sequences by latching from x to y</code>
<code>                {  % loop</code>
<code>                    /imp false def</code>
<code>                    [ A L M P ] {</code>
<code>                        /x exch def</code>
<code>                        [ A L M P ] {</code>
<code>                            /y exch def</code>
<code>                            /cost curlen x get latlen x get y get add def</code>
<code>                            cost curlen y get lt {</code>
<code>                                curlen y cost put</code>
<code>                                curseq y [</code>
<code>                                    curseq x get aload pop</code>
<code>                                    latseq x get y get aload pop</code>
<code>                                ] put</code>
<code>                                /imp true def</code>
<code>                            } if</code>
<code>                        } forall</code>
<code>                    } forall</code>
<code>                    imp not {exit} if  % Repeat unless no improvement</code>
<code>                } loop</code>
<code></code>
<code>                % Determine optimal next sequences for each valid encoding</code>
<code>                /nxtlen [ e e e e ] def</code>
<code>                /nxtseq 4 array def</code>
<code></code>
<code>                [ A L M P ] {</code>
<code>                    /x exch def</code>
<code></code>
<code>                    { % loop for common exit</code>
<code></code>
<code>                        charvals x get char known not {exit} if</code>
<code></code>
<code>                        % Extend directly</code>
<code>                        /cost curlen x get 1 add def</code>
<code>                        cost nxtlen x get lt {</code>
<code>                            nxtlen x cost put</code>
<code>                            nxtseq x [ curseq x get aload pop char ] put</code>
<code>                        } if</code>
<code></code>
<code>                        % Optimise for direct shifts from y to x</code>
<code>                        [ A L M P ] {</code>
<code>                            /y exch def</code>
<code>                            x y ne {</code>
<code>                                /cost curlen y get shftlen y get x get add 1 add def</code>
<code>                                cost nxtlen y get lt {</code>
<code>                                    nxtlen y cost put</code>
<code>                                    nxtseq y [</code>
<code>                                        curseq y get aload pop</code>
<code>                                        x A eq {as} {ps} ifelse</code>
<code>                                        char</code>
<code>                                    ] put</code>
<code>                                } if</code>
<code>                            } if</code>
<code>                        } forall</code>
<code></code>
<code>                        exit</code>
<code>                    } loop</code>
<code></code>
<code>                } forall</code>
<code></code>
<code>                /curlen nxtlen def</code>
<code>                /curseq nxtseq def</code>
<code></code>
<code>            } forall</code>
<code></code>
<code>            % Select the optimal sequence</code>
<code>            /minseq e def</code>
<code>            [ A L M P ] {</code>
<code>                /k exch def</code>
<code>                curlen k get minseq lt {</code>
<code>                    /minseq curlen k get def</code>
<code>                    /txtseq curseq k get def</code>
<code>                } if</code>
<code>            } forall</code>
<code></code>
<code>            % Encode the sequence</code>
<code>            /text minseq array def</code>
<code>            /k 0 def /l 0 def {</code>
<code>                k txtseq length ge {exit} if</code>
<code></code>
<code>                /char txtseq k get def</code>
<code></code>
<code>                % Encode character</code>
<code>                char textencfuncs submode get load exec addtotext</code>
<code>                /k k 1 add def</code>
<code></code>
<code>                % Encode shifted next character</code>
<code>                char as eq char ps eq or {</code>
<code>                    txtseq k get char as eq {enca} {encp} ifelse addtotext</code>
<code>                    /k k 1 add def</code>
<code>                } if</code>
<code></code>
<code>                % Latches to new submode</code>
<code>                char al eq {/submode A def} if</code>
<code>                char ll eq {/submode L def} if</code>
<code>                char ml eq {/submode M def} if</code>
<code>                char pl eq {/submode P def} if</code>
<code>            } loop</code>
<code></code>
<code>            text length 2 mod 1 eq {</code>
<code>                submode P eq {</code>
<code>                    /pad al encp def</code>
<code>                    /submode A def</code>
<code>                } {</code>
<code>                    % Need to check whether a ps shift can be used to pad</code>
<code>                    /nextecitext false def</code>
<code>                    % If have one or more ECIs next followed by text sequence (array)</code>
<code>                    i 1 add 1 seq length 1 sub {</code>
<code>                        /ti exch def</code>
<code>                        seq ti get type /arraytype ne { /nextecitext false def exit } if</code>
<code>                        seq ti get 0 get -1000000 gt { exit } if</code>
<code>                        /nextecitext true def</code>
<code>                    } for</code>
<code>                    nextecitext { % Then don't use ps as it would affect first char of text sequence</code>
<code>                        submode A eq {</code>
<code>                            charvals L get seq ti get 0 get known {  % Check whether to use ll or ml latch</code>
<code>                                /pad ll enca def</code>
<code>                                /submode L def</code>
<code>                            } {</code>
<code>                                /pad ml enca def</code>
<code>                                /submode M def</code>
<code>                            } ifelse</code>
<code>                        } {</code>
<code>                        submode M eq {</code>
<code>                            charvals L get seq ti get 0 get known {  % Check whether to use ll, pl or al latch</code>
<code>                                /pad ll encm def</code>
<code>                                /submode L def</code>
<code>                            } {</code>
<code>                            charvals P get seq ti get 0 get known {</code>
<code>                                /pad pl encm def</code>
<code>                                /submode P def</code>
<code>                            } {</code>
<code>                                /pad al encm def</code>
<code>                                /submode A def</code>
<code>                            } ifelse } ifelse</code>
<code>                        } {  % L</code>
<code>                            /pad ml encl def  % Only latch available</code>
<code>                            /submode M def</code>
<code>                        } ifelse } ifelse</code>
<code>                    } {  % Otherwise use standard ps shift pad</code>
<code>                        /pad ps textencfuncs submode get load exec def</code>
<code>                    } ifelse</code>
<code>                } ifelse</code>
<code>                /text [ text aload pop pad ] def</code>
<code>            } if</code>
<code></code>
<code>            /out text length 2 idiv array def</code>
<code>            0 1 out length 1 sub {</code>
<code>                /k exch def</code>
<code>                out k text k 2 mul get 30 mul text k 2 mul 1 add get add put</code>
<code>            } for</code>
<code></code>
<code>            out</code>
<code></code>
<code>        } def</code>
<code></code>
<code>        /encn {</code>
<code>            /in exch def</code>
<code>            /out [] def</code>
<code>            0 44 in length 1 sub {</code>
<code>                /k exch def</code>
<code>                /gmod [</code>
<code>                    1 in k in length k sub dup 44 gt {pop 44} if getinterval</code>
<code>                    {48 sub} forall</code>
<code>                ] def</code>
<code>                /cwn [] def {</code>
<code>                    /dv 900 def</code>
<code>                    /gmul [] def /val 0 def {</code>
<code>                        gmod length 0 eq {exit} if</code>
<code>                        /val val 10 mul gmod 0 get add def</code>
<code>                        /gmod gmod 1 gmod length 1 sub getinterval def</code>
<code>                        val dv lt {</code>
<code>                            gmul length 0 ne {</code>
<code>                                /gmul [ gmul aload pop 0 ] def</code>
<code>                            } if</code>
<code>                        } {</code>
<code>                            /gmul [ gmul aload pop val dv idiv ] def</code>
<code>                        } ifelse</code>
<code>                        /val val dv mod def</code>
<code>                    } loop</code>
<code>                    /dv val def</code>
<code>                    /cwn [ dv cwn aload pop ] def</code>
<code>                    /gmod gmul def</code>
<code>                    gmul length 0 eq {exit} if</code>
<code>                } loop</code>
<code>                /out [ out aload pop cwn aload pop ] def</code>
<code>            } for</code>
<code>            out</code>
<code>        } def</code>
<code></code>
<code>        /ence {</code>
<code>            0 get neg 1000000 sub</code>
<code>                dup 000899 le {  % ECI 000000 - 000899</code>
<code>                927 exch 2 array astore</code>
<code>            } { dup 810899 le {  % ECI 000900 - 810899</code>
<code>                926 exch dup 900 idiv 1 sub exch 900 mod 3 array astore</code>
<code>            } { dup 811799 le {  % ECI 810900 - 811799</code>
<code>                925 exch 810900 sub 2 array astore</code>
<code>            } {</code>
<code>                /bwipp.pdf417badECI (PDF417 supports ECIs 000000 to 811799) //raiseerror exec</code>
<code>            } ifelse } ifelse } ifelse</code>
<code>        } def</code>
<code></code>
<code>        /encfuncs [ /enct /encn /encb ] def</code>
<code></code>
<code>        /addtocws {</code>
<code>            dup datcws j 3 -1 roll putinterval</code>
<code>            length j add /j exch def</code>
<code>        } def</code>
<code></code>
<code>        % Encode the sequence</code>
<code>        /state T def /submode A def</code>
<code>        /datcws seqlen array def</code>
<code>        /i 0 def /j 0 def {</code>
<code>            i seq length ge {exit} if</code>
<code>            /chars seq i get def</code>
<code>            chars type /arraytype eq {</code>
<code>                chars 0 get -1000000 le {  % ECI</code>
<code>                    chars ence addtocws</code>
<code>                } {  % Encode data according to mode</code>
<code>                    chars encfuncs state get load exec addtocws</code>
<code>                } ifelse</code>
<code>            } {  % Encode the latch to new state or byte shift</code>
<code>                [ latchcws chars get ] addtocws</code>
<code>                chars tl eq {/state T def /submode A def} if</code>
<code>                chars nl eq {/state N def} if</code>
<code>                chars bl eq chars bl6 eq or {/state B def} if</code>
<code>                chars bs eq {</code>
<code>                    /i i 1 add def</code>
<code>                    seq i get encb addtocws</code>
<code>                } if</code>
<code>            } ifelse</code>
<code>            /i i 1 add def</code>
<code>        } loop</code>
<code>        /datcws datcws 0 j getinterval def</code>
<code>    } if</code>
<code></code>
<code>    % Determine the error correction level if unspecified</code>
<code>    /m datcws length def</code>
<code>    eclevel -1 eq {</code>
<code>        m  40 le              {/eclevel 2 def} if</code>
<code>        m  41 ge m 160 le and {/eclevel 3 def} if</code>
<code>        m 161 ge m 320 le and {/eclevel 4 def} if</code>
<code>        m 321 ge              {/eclevel 5 def} if</code>
<code>    } if</code>
<code></code>
<code>    % Reduce the error level so that it does not cause an excessive number of codewords</code>
<code>    /maxeclevel 928 1 sub m sub ln 2 ln div cvi 1 sub def</code>
<code>    eclevel maxeclevel gt {/eclevel maxeclevel def} if</code>
<code>    /k 2 eclevel 1 add exp cvi def</code>
<code></code>
<code>    % To determine size of matrix, number of columns if given by user...</code>
<code>    columns 0 eq {/columns m k add 3 div sqrt round cvi def} if</code>
<code>    /c columns 1 ge {columns} {1} ifelse def</code>
<code></code>
<code>    % ... and rows is greater of those required and that given by user within limits</code>
<code>    /r m k add 1 add columns div ceiling cvi def  % Required</code>
<code>    r rows lt rows 90 le and {/r rows def} if</code>
<code>    r 3 lt {/r 3 def} if</code>
<code></code>
<code>    % Symbol cannot exceed 90 rows</code>
<code>    r 90 gt {</code>
<code>      /bwipp.pdf417insufficientCapacity (Insufficient capacity in the symbol) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Opportunistically raise the error level if a better fit to the matrix is possible</code>
<code>    /maxeclevel c r mul 1 sub m sub ln 2 ln div cvi 1 sub 8 2 copy gt {exch} if pop def</code>
<code>    maxeclevel eclevel gt {</code>
<code>      /eclevel maxeclevel def</code>
<code>      /k 2 eclevel 1 add exp cvi def</code>
<code>    } if</code>
<code></code>
<code>    % Create codewords array with one extra working space element and add padding</code>
<code>    /n c r mul k sub def</code>
<code>    /cws c r mul 1 add array def</code>
<code>    cws 0 n put</code>
<code>    cws 1 datcws putinterval</code>
<code>    cws m 1 add [ n m sub 1 sub {900} repeat ] putinterval</code>
<code>    cws n [ k {0} repeat 0 ] putinterval</code>
<code></code>
<code>    % Calculate the log and anti-log tables</code>
<code>{</code>
<code>    /rsalog [ 1 928 {dup 3 mul 929 mod} repeat ] def</code>
<code>    /rslog 929 array def</code>
<code>    1 1 928 {dup rsalog exch get exch rslog 3 1 roll put} for</code>
<code>} ctxdef</code>
<code></code>
<code>    % Function to calculate the product in the field</code>
<code>    /rsprod {</code>
<code>        2 copy 0 ne exch 0 ne and {</code>
<code>            rslog exch get exch rslog exch get add 928 mod rsalog exch get</code>
<code>        } {</code>
<code>            pop pop 0</code>
<code>        } ifelse</code>
<code>    } def</code>
<code></code>
<code>    % Generate the coefficients</code>
<code>    /coeffs [ 1 k {0} repeat ] def</code>
<code>    1 1 k {</code>
<code>        /i exch def</code>
<code>        coeffs i coeffs i 1 sub get put</code>
<code>        i 1 sub -1 1 {</code>
<code>            /j exch def</code>
<code>            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod add 929 mod put</code>
<code>        } for</code>
<code>        coeffs 0 coeffs 0 get rsalog i get rsprod put</code>
<code>    } for</code>
<code>    /coeffs coeffs 0 coeffs length 1 sub getinterval def</code>
<code>    coeffs length 1 sub -2 0 {coeffs exch 2 copy get 929 exch sub put} for</code>
<code></code>
<code>    % Derive the error codewords</code>
<code>    0 1 n 1 sub {</code>
<code>        /t exch cws exch get cws n get add 929 mod def</code>
<code>        0 1 k 1 sub {</code>
<code>            /j exch def</code>
<code>            cws n j add cws n j add 1 add get 929 t coeffs k j sub 1 sub get mul 929 mod sub add 929 mod put</code>
<code>        } for</code>
<code>    } for</code>
<code>    n 1 n k add { dup cws exch 929 cws 5 -1 roll get sub 929 mod put } for</code>
<code></code>
<code>    % Trim the working space from the end of the codewords</code>
<code>    /cws cws 0 cws length 1 sub getinterval def</code>
<code></code>
<code>    options /debugcws known { /bwipp.debugcws cws //raiseerror exec } if</code>
<code></code>
<code>    % Base 10 encoding of the bar space successions for the codewords in each cluster</code>
<code>{</code>
<code>    /clusters [</code>
<code>        [</code>
<code>            120256 125680 128380 120032 125560 128318 108736 119920 108640  86080 108592  86048</code>
<code>            110016 120560 125820 109792 120440 125758  88256 109680  88160  89536 110320 120700</code>
<code>             89312 110200 120638  89200 110140  89840 110460  89720 110398  89980 128506 119520</code>
<code>            125304 128190 107712 119408 125244 107616 119352  84032 107568 119324  84000 107544</code>
<code>             83984 108256 119672 125374  85184 108144 119612  85088 108088 119582  85040 108060</code>
<code>             85728 108408 119742  85616 108348  85560 108318  85880 108478  85820  85790 107200</code>
<code>            119152 125116 107104 119096 125086  83008 107056 119068  82976 107032  82960  82952</code>
<code>             83648 107376 119228  83552 107320 119198  83504 107292  83480  83468  83824 107452</code>
<code>             83768 107422  83740  83900 106848 118968 125022  82496 106800 118940  82464 106776</code>
<code>            118926  82448 106764  82440 106758  82784 106936 119006  82736 106908  82712 106894</code>
<code>             82700  82694 106974  82830  82240 106672 118876  82208 106648 118862  82192 106636</code>
<code>             82184 106630  82180  82352  82328  82316  82080 118830 106572 106566  82050 117472</code>
<code>            124280 127678 103616 117360 124220 103520 117304 124190  75840 103472  75808 104160</code>
<code>            117624 124350  76992 104048 117564  76896 103992  76848  76824  77536 104312 117694</code>
<code>             77424 104252  77368  77340  77688 104382  77628  77758 121536 126320 128700 121440</code>
<code>            126264 128670 111680 121392 126236 111648 121368 126222 111632 121356 103104 117104</code>
<code>            124092 112320 103008 117048 124062 112224 121656 126366  93248  74784 102936 117006</code>
<code>             93216 112152  93200  75456 103280 117180  93888  75360 103224 117150  93792 112440</code>
<code>            121758  93744  75288  93720  75632 103356  94064  75576 103326  94008 112542  93980</code>
<code>             75708  94140  75678  94110 121184 126136 128606 111168 121136 126108 111136 121112</code>
<code>            126094 111120 121100 111112 111108 102752 116920 123998 111456 102704 116892  91712</code>
<code>             74272 121244 116878  91680  74256 102668  91664 111372 102662  74244  74592 102840</code>
<code>            116958  92000  74544 102812  91952 111516 102798  91928  74508  74502  74680 102878</code>
<code>             92088  74652  92060  74638  92046  92126 110912 121008 126044 110880 120984 126030</code>
<code>            110864 120972 110856 120966 110852 110850  74048 102576 116828  90944  74016 102552</code>
<code>            116814  90912 111000 121038  90896  73992 102534  90888 110982  90884  74160 102620</code>
<code>             91056  74136 102606  91032 111054  91020  74118  91014  91100  91086 110752 120920</code>
<code>            125998 110736 120908 110728 120902 110724 110722  73888 102488 116782  90528  73872</code>
<code>            102476  90512 110796 102470  90504  73860  90500  73858  73944  90584  90572  90566</code>
<code>            120876 120870 110658 102444  73800  90312  90308  90306 101056 116080 123580 100960</code>
<code>            116024  70720 100912 115996  70688 100888  70672  70664  71360 101232 116156  71264</code>
<code>            101176 116126  71216 101148  71192  71180  71536 101308  71480 101278  71452  71612</code>
<code>             71582 118112 124600 127838 105024 118064 124572 104992 118040 124558 104976 118028</code>
<code>            104968 118022 100704 115896 123486 105312 100656 115868  79424  70176 118172 115854</code>
<code>             79392 105240 100620  79376  70152  79368  70496 100792 115934  79712  70448 118238</code>
<code>             79664 105372 100750  79640  70412  79628  70584 100830  79800  70556  79772  70542</code>
<code>             70622  79838 122176 126640 128860 122144 126616 128846 122128 126604 122120 126598</code>
<code>            122116 104768 117936 124508 113472 104736 126684 124494 113440 122264 126670 113424</code>
<code>            104712 117894 113416 122246 104706  69952 100528 115804  78656  69920 100504 115790</code>
<code>             96064  78624 104856 117966  96032 113560 122318 100486  96016  78600 104838  96008</code>
<code>             69890  70064 100572  78768  70040 100558  96176  78744 104910  96152 113614  70022</code>
<code>             78726  70108  78812  70094  96220  78798 122016 126552 128814 122000 126540 121992</code>
<code>            126534 121988 121986 104608 117848 124462 113056 104592 126574 113040 122060 117830</code>
<code>            113032 104580 113028 104578 113026  69792 100440 115758  78240  69776 100428  95136</code>
<code>             78224 104652 100422  95120 113100  69764  95112  78212  69762  78210  69848 100462</code>
<code>             78296  69836  95192  78284  69830  95180  78278  69870  95214 121936 126508 121928</code>
<code>            126502 121924 121922 104528 117804 112848 104520 117798 112840 121958 112836 104514</code>
<code>            112834  69712 100396  78032  69704 100390  94672  78024 104550  94664 112870  69698</code>
<code>             94660  78018  94658  78060  94700  94694 126486 121890 117782 104484 104482  69672</code>
<code>             77928  94440  69666  77922  99680  68160  99632  68128  99608 115342  68112  99596</code>
<code>             68104  99590  68448  99768 115422  68400  99740  68376  99726  68364  68358  68536</code>
<code>             99806  68508  68494  68574 101696 116400 123740 101664 116376 101648 116364 101640</code>
<code>            116358 101636  67904  99504 115292  72512  67872 116444 115278  72480 101784 116430</code>
<code>             72464  67848  99462  72456 101766  67842  68016  99548  72624  67992  99534  72600</code>
<code>            101838  72588  67974  68060  72668  68046  72654 118432 124760 127918 118416 124748</code>
<code>            118408 124742 118404 118402 101536 116312 105888 101520 116300 105872 118476 116294</code>
<code>            105864 101508 105860 101506 105858  67744  99416  72096  67728 116334  80800  72080</code>
<code>            101580  99398  80784 105932  67716  80776  72068  67714  72066  67800  99438  72152</code>
<code>             67788  80856  72140  67782  80844  72134  67822  72174  80878 126800 128940 126792</code>
<code>            128934 126788 126786 118352 124716 122576 126828 124710 122568 126822 122564 118338</code>
<code>            122562 101456 116268 105680 101448 116262 114128 105672 118374 114120 122598 101442</code>
<code>            114116 105666 114114  67664  99372  71888  67656  99366  80336  71880 101478  97232</code>
<code>             80328 105702  67650  97224 114150  71874  97220  67692  71916  67686  80364  71910</code>
<code>             97260  80358  97254 126760 128918 126756 126754 118312 124694 122472 126774 122468</code>
<code>            118306 122466 101416 116246 105576 101412 113896 105572 101410 113892 105570 113890</code>
<code>             67624  99350  71784 101430  80104  71780  67618  96744  80100  71778  96740  80098</code>
<code>             96738  71798  96758 126738 122420 122418 105524 113780 113778  71732  79988  96500</code>
<code>             96498  66880  66848  98968  66832  66824  66820  66992  66968  66956  66950  67036</code>
<code>             67022 100000  99984 115532  99976 115526  99972  99970  66720  98904  69024 100056</code>
<code>             98892  69008 100044  69000 100038  68996  66690  68994  66776  98926  69080 100078</code>
<code>             69068  66758  69062  66798  69102 116560 116552 116548 116546  99920 102096 116588</code>
<code>            115494 102088 116582 102084  99906 102082  66640  68816  66632  98854  73168  68808</code>
<code>             66628  73160  68804  66626  73156  68802  66668  68844  66662  73196  68838  73190</code>
<code>            124840 124836 124834 116520 118632 124854 118628 116514 118626  99880 115478 101992</code>
<code>            116534 106216 101988  99874 106212 101986 106210  66600  98838  68712  99894  72936</code>
<code>             68708  66594  81384  72932  68706  81380  72930  66614  68726  72950  81398 128980</code>
<code>            128978 124820 126900 124818 126898 116500 118580 116498 122740 118578 122738  99860</code>
<code>            101940  99858 106100 101938 114420</code>
<code>        ] [</code>
<code>            128352 129720 125504 128304 129692 125472 128280 129678 125456 128268 125448 128262</code>
<code>            125444 125792 128440 129758 120384 125744 128412 120352 125720 128398 120336 125708</code>
<code>            120328 125702 120324 120672 125880 128478 110144 120624 125852 110112 120600 125838</code>
<code>            110096 120588 110088 120582 110084 110432 120760 125918  89664 110384 120732  89632</code>
<code>            110360 120718  89616 110348  89608 110342  89952 110520 120798  89904 110492  89880</code>
<code>            110478  89868  90040 110558  90012  89998 125248 128176 129628 125216 128152 129614</code>
<code>            125200 128140 125192 128134 125188 125186 119616 125360 128220 119584 125336 128206</code>
<code>            119568 125324 119560 125318 119556 119554 108352 119728 125404 108320 119704 125390</code>
<code>            108304 119692 108296 119686 108292 108290  85824 108464 119772  85792 108440 119758</code>
<code>             85776 108428  85768 108422  85764  85936 108508  85912 108494  85900  85894  85980</code>
<code>             85966 125088 128088 129582 125072 128076 125064 128070 125060 125058 119200 125144</code>
<code>            128110 119184 125132 119176 125126 119172 119170 107424 119256 125166 107408 119244</code>
<code>            107400 119238 107396 107394  83872 107480 119278  83856 107468  83848 107462  83844</code>
<code>             83842  83928 107502  83916  83910  83950 125008 128044 125000 128038 124996 124994</code>
<code>            118992 125036 118984 125030 118980 118978 106960 119020 106952 119014 106948 106946</code>
<code>             82896 106988  82888 106982  82884  82882  82924  82918 124968 128022 124964 124962</code>
<code>            118888 124982 118884 118882 106728 118902 106724 106722  82408 106742  82404  82402</code>
<code>            124948 124946 118836 118834 106612 106610 124224 127664 129372 124192 127640 129358</code>
<code>            124176 127628 124168 127622 124164 124162 117568 124336 127708 117536 124312 127694</code>
<code>            117520 124300 117512 124294 117508 117506 104256 117680 124380 104224 117656 124366</code>
<code>            104208 117644 104200 117638 104196 104194  77632 104368 117724  77600 104344 117710</code>
<code>             77584 104332  77576 104326  77572  77744 104412  77720 104398  77708  77702  77788</code>
<code>             77774 128672 129880  93168 128656 129868  92664 128648 129862  92412 128644 128642</code>
<code>            124064 127576 129326 126368 124048 129902 126352 128716 127558 126344 124036 126340</code>
<code>            124034 126338 117152 124120 127598 121760 117136 124108 121744 126412 124102 121736</code>
<code>            117124 121732 117122 121730 103328 117208 124142 112544 103312 117196 112528 121804</code>
<code>            117190 112520 103300 112516 103298 112514  75680 103384 117230  94112  75664 103372</code>
<code>             94096 112588 103366  94088  75652  94084  75650  75736 103406  94168  75724  94156</code>
<code>             75718  94150  75758 128592 129836  91640 128584 129830  91388 128580  91262 128578</code>
<code>            123984 127532 126160 123976 127526 126152 128614 126148 123970 126146 116944 124012</code>
<code>            121296 116936 124006 121288 126182 121284 116930 121282 102864 116972 111568 102856</code>
<code>            116966 111560 121318 111556 102850 111554  74704 102892  92112  74696 102886  92104</code>
<code>            111590  92100  74690  92098  74732  92140  74726  92134 128552 129814  90876 128548</code>
<code>             90750 128546 123944 127510 126056 128566 126052 123938 126050 116840 123958 121064</code>
<code>            116836 121060 116834 121058 102632 116854 111080 121078 111076 102626 111074  74216</code>
<code>            102646  91112  74212  91108  74210  91106  74230  91126 128532  90494 128530 123924</code>
<code>            126004 123922 126002 116788 120948 116786 120946 102516 110836 102514 110834  73972</code>
<code>             90612  73970  90610 128522 123914 125978 116762 120890 102458 110714 123552 127320</code>
<code>            129198 123536 127308 123528 127302 123524 123522 116128 123608 127342 116112 123596</code>
<code>            116104 123590 116100 116098 101280 116184 123630 101264 116172 101256 116166 101252</code>
<code>            101250  71584 101336 116206  71568 101324  71560 101318  71556  71554  71640 101358</code>
<code>             71628  71622  71662 127824 129452  79352 127816 129446  79100 127812  78974 127810</code>
<code>            123472 127276 124624 123464 127270 124616 127846 124612 123458 124610 115920 123500</code>
<code>            118224 115912 123494 118216 124646 118212 115906 118210 100816 115948 105424 100808</code>
<code>            115942 105416 118246 105412 100802 105410  70608 100844  79824  70600 100838  79816</code>
<code>            105446  79812  70594  79810  70636  79852  70630  79846 129960  95728 113404 129956</code>
<code>             95480 113278 129954  95356  95294 127784 129430  78588 128872 129974  95996  78462</code>
<code>            128868 127778  95870 128866 123432 127254 124520 123428 126696 128886 123426 126692</code>
<code>            124514 126690 115816 123446 117992 115812 122344 117988 115810 122340 117986 122338</code>
<code>            100584 115830 104936 100580 113640 104932 100578 113636 104930 113634  70120 100598</code>
<code>             78824  70116  96232  78820  70114  96228  78818  96226  70134  78838 129940  94968</code>
<code>            113022 129938  94844  94782 127764  78206 128820 127762  95102 128818 123412 124468</code>
<code>            123410 126580 124466 126578 115764 117876 115762 122100 117874 122098 100468 104692</code>
<code>            100466 113140 104690 113138  69876  78324  69874  95220  78322  95218 129930  94588</code>
<code>             94526 127754 128794 123402 124442 126522 115738 117818 121978 100410 104570 112890</code>
<code>             69754  78074  94714  94398 123216 127148 123208 127142 123204 123202 115408 123244</code>
<code>            115400 123238 115396 115394  99792 115436  99784 115430  99780  99778  68560  99820</code>
<code>             68552  99814  68548  68546  68588  68582 127400 129238  72444 127396  72318 127394</code>
<code>            123176 127126 123752 123172 123748 123170 123746 115304 123190 116456 115300 116452</code>
<code>            115298 116450  99560 115318 101864  99556 101860  99554 101858  68072  99574  72680</code>
<code>             68068  72676  68066  72674  68086  72694 129492  80632 105854 129490  80508  80446</code>
<code>            127380  72062 127924 127378  80766 127922 123156 123700 123154 124788 123698 124786</code>
<code>            115252 116340 115250 118516 116338 118514  99444 101620  99442 105972 101618 105970</code>
<code>             67828  72180  67826  80884  72178  80882  97008 114044  96888 113982  96828  96798</code>
<code>            129482  80252 130010  97148  80190  97086 127370 127898 128954 123146 123674 124730</code>
<code>            126842 115226 116282 118394 122618  99386 101498 105722 114170  67706  71930  80378</code>
<code>             96632 113854  96572  96542  80062  96702  96444  96414  96350 123048 123044 123042</code>
<code>            115048 123062 115044 115042  99048 115062  99044  99042  67048  99062  67044  67042</code>
<code>             67062 127188  68990 127186 123028 123316 123026 123314 114996 115572 114994 115570</code>
<code>             98932 100084  98930 100082  66804  69108  66802  69106 129258  73084  73022 127178</code>
<code>            127450 123018 123290 123834 114970 115514 116602  98874  99962 102138  66682  68858</code>
<code>             73210  81272 106174  81212  81182  72894  81342  97648 114364  97592 114334  97564</code>
<code>             97550  81084  97724  81054  97694  97464 114270  97436  97422  80990  97502  97372</code>
<code>             97358  97326 114868 114866  98676  98674  66292  66290 123098 114842 115130  98618</code>
<code>             99194  66170  67322  69310  73404  73374  81592 106334  81564  81550  73310  81630</code>
<code>             97968 114524  97944 114510  97932  97926  81500  98012  81486  97998  97880 114478</code>
<code>             97868  97862  81454  97902  97836  97830  69470  73564  73550  81752 106414  81740</code>
<code>             81734  73518  81774  81708  81702</code>
<code>        ] [</code>
<code>            109536 120312  86976 109040 120060  86496 108792 119934  86256 108668  86136 129744</code>
<code>             89056 110072 129736  88560 109820 129732  88312 109694 129730  88188 128464 129772</code>
<code>             89592 128456 129766  89340 128452  89214 128450 125904 128492 125896 128486 125892</code>
<code>            125890 120784 125932 120776 125926 120772 120770 110544 120812 110536 120806 110532</code>
<code>             84928 108016 119548  84448 107768 119422  84208 107644  84088 107582  84028 129640</code>
<code>             85488 108284 129636  85240 108158 129634  85116  85054 128232 129654  85756 128228</code>
<code>             85630 128226 125416 128246 125412 125410 119784 125430 119780 119778 108520 119798</code>
<code>            108516 108514  83424 107256 119166  83184 107132  83064 107070  83004  82974 129588</code>
<code>             83704 107390 129586  83580  83518 128116  83838 128114 125172 125170 119284 119282</code>
<code>            107508 107506  82672 106876  82552 106814  82492  82462 129562  82812  82750 128058</code>
<code>            125050 119034  82296 106686  82236  82206  82366  82108  82078  76736 103920 117500</code>
<code>             76256 103672 117374  76016 103548  75896 103486  75836 129384  77296 104188 129380</code>
<code>             77048 104062 129378  76924  76862 127720 129398  77564 127716  77438 127714 124392</code>
<code>            127734 124388 124386 117736 124406 117732 117730 104424 117750 104420 104418 112096</code>
<code>            121592 126334  92608 111856 121468  92384 111736 121406  92272 111676  92216 111646</code>
<code>             92188  75232 103160 117118  93664  74992 103036  93424 112252 102974  93304  74812</code>
<code>             93244  74782  93214 129332  75512 103294 129908 129330  93944  75388 129906  93820</code>
<code>             75326  93758 127604  75646 128756 127602  94078 128754 124148 126452 124146 126450</code>
<code>            117236 121844 117234 121842 103412 103410  91584 111344 121212  91360 111224 121150</code>
<code>             91248 111164  91192 111134  91164  91150  74480 102780  91888  74360 102718  91768</code>
<code>            111422  91708  74270  91678 129306  74620 129850  92028  74558  91966 127546 128634</code>
<code>            124026 126202 116986 121338 102906  90848 110968 121022  90736 110908  90680 110878</code>
<code>             90652  90638  74104 102590  91000  74044  90940  74014  90910  74174  91070  90480</code>
<code>            110780  90424 110750  90396  90382  73916  90556  73886  90526  90296 110686  90268</code>
<code>             90254  73822  90334  90204  90190  71136 101112 116094  70896 100988  70776 100926</code>
<code>             70716  70686 129204  71416 101246 129202  71292  71230 127348  71550 127346 123636</code>
<code>            123634 116212 116210 101364 101362  79296 105200 118140  79072 105080 118078  78960</code>
<code>            105020  78904 104990  78876  78862  70384 100732  79600  70264 100670  79480 105278</code>
<code>             79420  70174  79390 129178  70524 129466  79740  70462  79678 127290 127866 123514</code>
<code>            124666 115962 118266 100858 113376 122232 126654  95424 113264 122172  95328 113208</code>
<code>            122142  95280 113180  95256 113166  95244  78560 104824 117950  95968  78448 104764</code>
<code>             95856 113468 104734  95800  78364  95772  78350  95758  70008 100542  78712  69948</code>
<code>             96120  78652  69918  96060  78622  96030  70078  78782  96190  94912 113008 122044</code>
<code>             94816 112952 122014  94768 112924  94744 112910  94732  94726  78192 104636  95088</code>
<code>             78136 104606  95032 113054  95004  78094  94990  69820  78268  69790  95164  78238</code>
<code>             95134  94560 112824 121950  94512 112796  94488 112782  94476  94470  78008 104542</code>
<code>             94648  77980  94620  77966  94606  69726  78046  94686  94384 112732  94360 112718</code>
<code>             94348  94342  77916  94428  77902  94414  94296 112686  94284  94278  77870  94318</code>
<code>             94252  94246  68336  99708  68216  99646  68156  68126  68476  68414 127162 123258</code>
<code>            115450  99834  72416 101752 116414  72304 101692  72248 101662  72220  72206  67960</code>
<code>             99518  72568  67900  72508  67870  72478  68030  72638  80576 105840 118460  80480</code>
<code>            105784 118430  80432 105756  80408 105742  80396  80390  72048 101564  80752  71992</code>
<code>            101534  80696  71964  80668  71950  80654  67772  72124  67742  80828  72094  80798</code>
<code>            114016 122552 126814  96832 113968 122524  96800 113944 122510  96784 113932  96776</code>
<code>            113926  96772  80224 105656 118366  97120  80176 105628  97072 114076 105614  97048</code>
<code>             80140  97036  80134  97030  71864 101470  80312  71836  97208  80284  71822  97180</code>
<code>             80270  97166  67678  71902  80350  97246  96576 113840 122460  96544 113816 122446</code>
<code>             96528 113804  96520 113798  96516  96514  80048 105564  96688  80024 105550  96664</code>
<code>            113870  96652  80006  96646  71772  80092  71758  96732  80078  96718  96416 113752</code>
<code>            122414  96400 113740  96392 113734  96388  96386  79960 105518  96472  79948  96460</code>
<code>             79942  96454  71726  79982  96494  96336 113708  96328 113702  96324  96322  79916</code>
<code>             96364  79910  96358  96296 113686  96292  96290  79894  96310  66936  99006  66876</code>
<code>             66846  67006  68976 100028  68920  99998  68892  68878  66748  69052  66718  69022</code>
<code>             73056 102072 116574  73008 102044  72984 102030  72972  72966  68792  99934  73144</code>
<code>             68764  73116  68750  73102  66654  68830  73182  81216 106160 118620  81184 106136</code>
<code>            118606  81168 106124  81160 106118  81156  81154  72880 101980  81328  72856 101966</code>
<code>             81304 106190  81292  72838  81286  68700  72924  68686  81372  72910  81358 114336</code>
<code>            122712 126894 114320 122700 114312 122694 114308 114306  81056 106072 118574  97696</code>
<code>             81040 106060  97680 114380 106054  97672  81028  97668  81026  97666  72792 101934</code>
<code>             81112  72780  97752  81100  72774  97740  81094  97734  68654  72814  81134  97774</code>
<code>            114256 122668 114248 122662 114244 114242  80976 106028  97488  80968 106022  97480</code>
<code>            114278  97476  80962  97474  72748  81004  72742  97516  80998  97510 114216 122646</code>
<code>            114212 114210  80936 106006  97384  80932  97380  80930  97378  72726  80950  97398</code>
<code>            114196 114194  80916  97332  80914  97330  66236  66206  67256  99166  67228  67214</code>
<code>             66142  67294  69296 100188  69272 100174  69260  69254  67164  69340  67150  69326</code>
<code>             73376 102232 116654  73360 102220  73352 102214  73348  73346  69208 100142  73432</code>
<code>            102254  73420  69190  73414  67118  69230  73454 106320 118700 106312 118694 106308</code>
<code>            106306  73296 102188  81616 106348 102182  81608  73284  81604  73282  81602  69164</code>
<code>             73324  69158  81644  73318  81638 122792 126934 122788 122786 106280 118678 114536</code>
<code>            106276 114532 106274 114530  73256 102166  81512  73252  98024  81508  73250  98020</code>
<code>             81506  98018  69142  73270  81526  98038 122772 122770 106260 114484 106258 114482</code>
<code>             73236  81460  73234  97908  81458  97906 122762 106250 114458  73226  81434  97850</code>
<code>             66396  66382  67416  99246  67404  67398  66350  67438  69456 100268  69448 100262</code>
<code>             69444  69442  67372  69484  67366  69478 102312 116694 102308 102306  69416 100246</code>
<code>             73576 102326  73572  69410  73570  67350  69430  73590 118740 118738 102292 106420</code>
<code>            102290 106418  69396  73524  69394  81780  73522  81778 118730 102282 106394  69386</code>
<code>             73498  81722  66476  66470  67496  99286  67492  67490  66454  67510 100308 100306</code>
<code>             67476  69556  67474  69554 116714</code>
<code>        ]</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Return the 17 bits for a codeword in a given cluster</code>
<code>    /cwtobits {</code>
<code>        clusters exch get exch get /v exch def</code>
<code>        [ 17 {0} repeat v 2 17 string cvrs {48 sub} forall ]</code>
<code>        dup length 17 sub 17 getinterval</code>
<code>    } def</code>
<code></code>
<code>    % Populate bitmap for the image</code>
<code>    compact {</code>
<code>        /rwid 17 c mul 17 add 17 add 1 add def</code>
<code>    } {</code>
<code>        /rwid 17 c mul 17 add 17 add 17 add 18 add def</code>
<code>    } ifelse</code>
<code>    /pixs rwid r mul rowmult mul array def</code>
<code></code>
<code>    0 1 r 1 sub {</code>
<code>        /i exch def</code>
<code></code>
<code>        i 3 mod 0 eq {</code>
<code>            /lcw i 3 idiv 30 mul r 1 sub 3 idiv add def</code>
<code>            /rcw i 3 idiv 30 mul c add 1 sub def</code>
<code>        } if</code>
<code>        i 3 mod 1 eq {</code>
<code>            /lcw i 3 idiv 30 mul eclevel 3 mul add r 1 sub 3 mod add def</code>
<code>            /rcw i 3 idiv 30 mul r 1 sub 3 idiv add def</code>
<code>        } if</code>
<code>        i 3 mod 2 eq {</code>
<code>            /lcw i 3 idiv 30 mul c add 1 sub def</code>
<code>            /rcw i 3 idiv 30 mul eclevel 3 mul add r 1 sub 3 mod add def</code>
<code>        } if</code>
<code></code>
<code>        [</code>
<code>            1 1 1 1 1 1 1 1 0 1 0 1 0 1 0 0 0</code>
<code>            lcw i 3 mod cwtobits aload pop</code>
<code>            cws c i mul c getinterval { i 3 mod cwtobits aload pop } forall</code>
<code>            compact {</code>
<code>                1</code>
<code>            } {</code>
<code>                rcw i 3 mod cwtobits aload pop</code>
<code>                1 1 1 1 1 1 1 0 1 0 0 0 1 0 1 0 0 1</code>
<code>            } ifelse</code>
<code>        ]</code>
<code>        0 1 rowmult 1 sub {</code>
<code>            i rowmult mul add rwid mul pixs exch 2 index putinterval</code>
<code>        } for</code>
<code>        pop</code>
<code>    } for</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renmatrix</code>
<code>    /pixs pixs</code>
<code>    /pixx rwid</code>
<code>    /pixy r rowmult mul</code>
<code>    /height r rowmult mul 72 div</code>
<code>    /width rwid 72 div</code>
<code>    /borderleft 2.0</code>
<code>    /borderright 2.0</code>
<code>    /bordertop 2.0</code>
<code>    /borderbottom 2.0</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /pdf417 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER pdf417--</code>
<code></code>
<code>% --BEGIN ENCODER pdf417compact--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix pdf417--</code>
<code>% --DESC: Compact PDF417</code>
<code>% --EXAM: This is compact PDF417</code>
<code>% --EXOP: columns=2</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp pdf417compact 0.0 2024010300 63089 63056</code>
<code>%%BeginData:         36 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /pdf417 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/pdf417compact {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Get the result of encoding with pdf417 with compact option</code>
<code>    options (dontdraw) true put</code>
<code>    options (compact) true put</code>
<code></code>
<code>    /args barcode options //pdf417 exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /pdf417compact dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER pdf417compact--</code>
<code></code>
<code>% --BEGIN ENCODER micropdf417--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix--</code>
<code>% --DESC: MicroPDF417</code>
<code>% --EXAM: MicroPDF417</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp micropdf417 0.0 2024010300 230277 238718</code>
<code>%%BeginData:       1107 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/micropdf417 {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /version (unset) def</code>
<code>    /columns 0 def</code>
<code>    /rows 0 def</code>
<code>    /rowmult 2 def</code>
<code>    /cca false def</code>
<code>    /ccb false def</code>
<code>    /raw false def</code>
<code>    /parse false def</code>
<code>    /parsefnc false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.micropdf417emptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    rowmult 0 le {</code>
<code>        /bwipp.micropdf417badRowMult (The row multiplier must be greater than zero) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    cca ccb and cca raw and ccb raw and or or {</code>
<code>        /bwipp.micropdf417ccaAndCcb (Cannot combine cca, ccb and raw) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Parse version=RxC into rows and columns</code>
<code>    version (unset) ne {</code>
<code>        version (x) search {</code>
<code>            exch pop</code>
<code>            2 copy 2 array astore {</code>
<code>                true</code>
<code>                1 index length 0 eq { pop false } if</code>
<code>                exch {</code>
<code>                    dup 48 lt exch 57 gt or { pop false } if</code>
<code>                } forall</code>
<code>                not {</code>
<code>                    /bwipp.micropdf417BadVersionBadRowOrColumn (version must be formatted as RxC) //raiseerror exec</code>
<code>                } if</code>
<code>            } forall</code>
<code>            /rows exch cvi def</code>
<code>            /columns exch cvi def</code>
<code>        } {</code>
<code>            pop /bwipp.micropdf417badVersionFormat (version must be formatted as RxC) //raiseerror exec</code>
<code>        } ifelse</code>
<code>    } if</code>
<code></code>
<code>    /micropdf417 //loadctx exec</code>
<code></code>
<code>{</code>
<code>    % Modes and text submodes</code>
<code>    /T 0 def  /N 1 def  /B 2 def</code>
<code>    /A 0 def  /L 1 def  /M 2 def  /P 3 def</code>
<code></code>
<code>    % Special function characters for mode switching</code>
<code>    /tl -1 def  /nl -2 def  /bl -3 def  /bl6 -4 def  /bs -5 def</code>
<code></code>
<code>    % Special function characters for text mode</code>
<code>    /al -6 def  /ll -7 def  /ml -8 def  /pl -9 def  /as -10 def  /ps -11 def</code>
<code></code>
<code>    % Special function characters for 05/06 macros</code>
<code>    /m05 -12 def  /m06 -13 def</code>
<code></code>
<code>    % Character maps for each state</code>
<code>    /charmaps [</code>
<code>      %  A    L    M    P</code>
<code>      [ (A)  (a)  (0)  (;) ]  % 0</code>
<code>      [ (B)  (b)  (1)  (&lt;) ]  % 1</code>
<code>      [ (C)  (c)  (2)  (&gt;) ]  % 2</code>
<code>      [ (D)  (d)  (3)  (@) ]  % 3</code>
<code>      [ (E)  (e)  (4)  ([) ]  % 4</code>
<code>      [ (F)  (f)  (5)   92 ]  % 5</code>
<code>      [ (G)  (g)  (6)  (]) ]  % 6</code>
<code>      [ (H)  (h)  (7)  (_) ]  % 7</code>
<code>      [ (I)  (i)  (8)  (`) ]  % 8</code>
<code>      [ (J)  (j)  (9)  (~) ]  % 9</code>
<code>      [ (K)  (k)  (&amp;)  (!) ]  % 10</code>
<code>      [ (L)  (l)   13   13 ]  % 11</code>
<code>      [ (M)  (m)    9    9 ]  % 12</code>
<code>      [ (N)  (n)  (,)  (,) ]  % 13</code>
<code>      [ (O)  (o)  (:)  (:) ]  % 14</code>
<code>      [ (P)  (p)  (#)   10 ]  % 15</code>
<code>      [ (Q)  (q)  (-)  (-) ]  % 16</code>
<code>      [ (R)  (r)  (.)  (.) ]  % 17</code>
<code>      [ (S)  (s)  ($)  ($) ]  % 18</code>
<code>      [ (T)  (t)  (/)  (/) ]  % 19</code>
<code>      [ (U)  (u)  (+)  (") ]  % 20</code>
<code>      [ (V)  (v)  (%)  (|) ]  % 21</code>
<code>      [ (W)  (w)  (*)  (*) ]  % 22</code>
<code>      [ (X)  (x)  (=)   40 ]  % 23</code>
<code>      [ (Y)  (y)  (^)   41 ]  % 24</code>
<code>      [ (Z)  (z)   pl  (?) ]  % 25</code>
<code>      [ ( )  ( )  ( )  ({) ]  % 26</code>
<code>      [  ll   as   ll  (}) ]  % 27</code>
<code>      [  ml   ml   al  (') ]  % 28</code>
<code>      [  ps   ps   ps   al ]  % 29</code>
<code>    ] def</code>
<code></code>
<code>    % Invert charmaps to give character to value maps for each state</code>
<code>    /charvals [ 30 dict 30 dict 30 dict 30 dict ] def</code>
<code>    /alltext 104 dict def</code>
<code>    0 1 charmaps length 1 sub {</code>
<code>        /i exch def</code>
<code>        /encs charmaps i get def</code>
<code>        0 1 3 {</code>
<code>            /j exch def</code>
<code>            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required</code>
<code>            dup charvals j get exch i put</code>
<code>            alltext exch -1 put</code>
<code>        } for</code>
<code>    } for</code>
<code></code>
<code>    /e 10000 def  % "Empty"</code>
<code></code>
<code>    /latlen [  % Bit length of latch between submodes</code>
<code>    % To:  A  L  M  P      From</code>
<code>        [  0  1  1  2 ]  % A</code>
<code>        [  2  0  1  2 ]  % L</code>
<code>        [  1  1  0  1 ]  % M</code>
<code>        [  1  2  2  0 ]  % P</code>
<code>    ] def</code>
<code></code>
<code>    /latseq [  % Latch sequences between submodes</code>
<code>    % To: A       L       M       P               From</code>
<code>        [ []      [ll]    [ml]    [ml pl]    ]  % A</code>
<code>        [ [ml al] []      [ml]    [ml pl]    ]  % L</code>
<code>        [ [al]    [ll]    []      [pl]       ]  % M</code>
<code>        [ [al]    [al ll] [al ml] []         ]  % P</code>
<code>    ] def</code>
<code></code>
<code>    /shftlen [  % Bit length of shift to submode</code>
<code>    % To:  A  L  M  P      From</code>
<code>        [  e  e  e  1 ]  % A</code>
<code>        [  1  e  e  1 ]  % L</code>
<code>        [  e  e  e  1 ]  % M</code>
<code>        [  e  e  e  e ]  % P</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Convert input into array of codewords</code>
<code>    raw cca or {</code>
<code>        /datcws barcode length array def</code>
<code>        /i 0 def /j 0 def</code>
<code>        { % loop</code>
<code>            i barcode length 3 sub ge {exit} if</code>
<code>            barcode i get 94 ne {exit} if</code>
<code>            barcode i 1 add 3 getinterval false 1 index {</code>
<code>                dup 48 lt exch 57 gt or { pop true } if</code>
<code>            } forall { pop exit } if</code>
<code>            cvi /cw exch def</code>
<code>            datcws j cw put</code>
<code>            /i i 4 add def</code>
<code>            /j j 1 add def</code>
<code>        } loop</code>
<code>        i barcode length ne {</code>
<code>            /bwipp.micropdf417badCcaRawFormat (cca and raw data must be formatted as ^NNN) //raiseerror exec</code>
<code>        } if</code>
<code>        /datcws datcws 0 j getinterval def</code>
<code>    } if</code>
<code></code>
<code>    /encb {</code>
<code>        /in exch def</code>
<code>        /inlen in length def</code>
<code>        /out inlen 6 idiv 5 mul inlen 6 mod add array def</code>
<code>        0 1 inlen 6 idiv 1 sub {</code>
<code>            /k exch def</code>
<code>            /msbs [ in k 6 mul 3 getinterval aload pop ] def</code>
<code>            /mscs [</code>
<code>                msbs aload pop exch 256 mul add exch 65536 mul add</code>
<code>                3 {dup 900 mod exch 900 idiv} repeat</code>
<code>            ] def</code>
<code>            /lsbs [ in k 6 mul 3 add 3 getinterval aload pop ] def</code>
<code>            /lscs [</code>
<code>                lsbs aload pop exch 256 mul add exch 65536 mul add</code>
<code>                3 {dup 900 mod exch 900 idiv} repeat</code>
<code>            ] def</code>
<code>            lscs 0 get mscs 0 get 316 mul add</code>
<code>            out k 5 mul 4 add 2 index 900 mod put</code>
<code>            900 idiv lscs 1 get add mscs 0 get 641 mul add mscs 1 get 316 mul add</code>
<code>            out k 5 mul 3 add 2 index 900 mod put</code>
<code>            900 idiv lscs 2 get add mscs 0 get 20 mul add mscs 1 get 641 mul add mscs 2 get 316 mul add</code>
<code>            out k 5 mul 2 add 2 index 900 mod put</code>
<code>            900 idiv lscs 3 get add mscs 1 get 20 mul add mscs 2 get 641 mul add</code>
<code>            out k 5 mul 1 add 2 index 900 mod put</code>
<code>            900 idiv mscs 2 get 20 mul add</code>
<code>            out k 5 mul 3 -1 roll 900 mod put</code>
<code>        } for</code>
<code>        /rem inlen 6 mod def</code>
<code>        rem 0 ne {</code>
<code>            out out length rem sub</code>
<code>            [ in inlen rem sub rem getinterval aload pop ]</code>
<code>            putinterval</code>
<code>        } if</code>
<code>        out</code>
<code>    } def</code>
<code></code>
<code>    ccb {</code>
<code>        /barlen barcode length def</code>
<code>        /datcws barlen 6 idiv 5 mul barlen 6 mod add 2 add array def</code>
<code>        datcws 0 920 put</code>
<code>        datcws 1 barlen 6 mod 0 eq {924} {901} ifelse put</code>
<code>        datcws 2 [ barcode {} forall ] encb putinterval</code>
<code>    } if</code>
<code></code>
<code>    raw not cca not and ccb not and {</code>
<code></code>
<code>        % Parse the input</code>
<code>        /fncvals &lt;&lt;</code>
<code>            /parse parse</code>
<code>            /parsefnc parsefnc</code>
<code>%            (MAC5) m05    Encoded automatically</code>
<code>%            (MAC6) m06    Encoded automatically</code>
<code>            % Predates FNC non-data codewords, but supports ECI</code>
<code>            /eci true</code>
<code>        &gt;&gt; def</code>
<code>        /msg barcode fncvals //parseinput exec def</code>
<code>        /msglen msg length def</code>
<code></code>
<code>        % Macro 05/06 compression of [)&gt;{RS}05/06{GS}...{RS}{EOT} structured data</code>
<code>        msglen 9 ge {</code>
<code>            msg 0 7 getinterval aload pop</code>
<code>            29 eq exch pop exch 48 eq and exch  % [)&gt;{RS}0*{GS}...</code>
<code>            30 eq and exch 62 eq and exch 41 eq and exch 91 eq and {</code>
<code>                msg msglen 2 sub 2 getinterval aload pop</code>
<code>                4 eq exch 30 eq and {           %              ...{RS}{EOT}</code>
<code>                    msg 5 get 53 eq {           %      ...5...</code>
<code>                        /msg [ m05 msg 7 msg length 9 sub getinterval aload pop ] def</code>
<code>                    } {</code>
<code>                        msg 5 get 54 eq {       %      ...6...</code>
<code>                            /msg [ m06 msg 7 msg length 9 sub getinterval aload pop ] def</code>
<code>                        } if</code>
<code>                    } ifelse</code>
<code>                } if</code>
<code>            } if</code>
<code>        } if</code>
<code>        /msglen msg length def</code>
<code></code>
<code>        % Determine runlengths of digits</code>
<code>        /numdigits [ msglen {0} repeat 0 ] def</code>
<code>        /numtext   [ msglen {0} repeat 0 ] def</code>
<code>        /numbytes  [ msglen {0} repeat 0 ] def</code>
<code>        /iseci     [ msglen {0} repeat ] def</code>
<code>        msglen 1 sub -1 0 {</code>
<code>            /i exch def</code>
<code>            msg i get dup 48 ge exch 57 le and {</code>
<code>                numdigits i numdigits i 1 add get 1 add put</code>
<code>            } if</code>
<code>            alltext msg i get known numdigits i get 13 lt and {</code>
<code>                numtext i numtext i 1 add get 1 add put</code>
<code>            } if</code>
<code>            msg i get 0 ge numtext i get 5 lt and numdigits i get 13 lt and {</code>
<code>                numbytes i numbytes i 1 add get 1 add put</code>
<code>            } if</code>
<code>            iseci i msg i get -1000000 le put</code>
<code>        } for</code>
<code>        /numdigits numdigits 0 msglen getinterval def</code>
<code>        /numtext   numtext   0 msglen getinterval def</code>
<code>        /numbytes  numbytes  0 msglen getinterval def</code>
<code></code>
<code>        /seq [] def /seqlen 0 def /state B def /p 0 def {  % loop</code>
<code>            p msglen eq {exit} if</code>
<code>            p 0 eq msg p get dup m05 eq exch m06 eq or and {</code>
<code>                /seq [</code>
<code>                    seq aload pop</code>
<code>                    msg p get m05 eq { m05 } { m06 } ifelse</code>
<code>                ] def</code>
<code>                /p p 1 add def</code>
<code>                /seqlen seqlen 1 add def</code>
<code>            } {</code>
<code>            iseci p get {</code>
<code>                /eci msg p get def</code>
<code>                /seq [</code>
<code>                    seq aload pop</code>
<code>                    [ eci ]</code>
<code>                ] def</code>
<code>                /p p 1 add def</code>
<code>                /seqlen seqlen eci -1810900 le {2} {eci -1000900 le {3} {2} ifelse} ifelse add def</code>
<code>            } {</code>
<code>            /n numdigits p get def</code>
<code>            n 13 ge n msglen eq n 8 ge and or {  % 13+ digits or all-numeric and 8+ digits</code>
<code>                /seq [</code>
<code>                    seq aload pop</code>
<code>                    nl</code>
<code>                    [ msg p n getinterval aload pop ]</code>
<code>                ] def</code>
<code>                /state N def</code>
<code>                /p p n add def</code>
<code>                /seqlen seqlen 1 add n add def</code>
<code>            } {  % next</code>
<code>            /t numtext p get def</code>
<code>            t 5 ge {</code>
<code>                /seq [</code>
<code>                    seq aload pop</code>
<code>                    state T ne {</code>
<code>                        tl</code>
<code>                    } if</code>
<code>                    [ msg p t getinterval aload pop ]</code>
<code>                ] def</code>
<code>                /state T def</code>
<code>                /p p t add def</code>
<code>                /seqlen seqlen 1 add t add def  % ish</code>
<code>            } {  % next</code>
<code>            /b numbytes p get def</code>
<code>            b 1 eq state T eq and {</code>
<code>                /seq [</code>
<code>                    seq aload pop</code>
<code>                    bs</code>
<code>                    [ msg p get ]</code>
<code>                ] def</code>
<code>                /p p b add def</code>
<code>                /seqlen seqlen 2 add def</code>
<code>            } {  % next</code>
<code>                /seq [</code>
<code>                    seq aload pop</code>
<code>                    b 6 mod 0 ne {bl} {bl6} ifelse</code>
<code>                    [ msg p b getinterval aload pop ]</code>
<code>                ] def</code>
<code>                /state B def</code>
<code>                /p p b add def</code>
<code>                /seqlen seqlen 1 add b add def</code>
<code>            } ifelse } ifelse } ifelse } ifelse } ifelse</code>
<code>        } loop</code>
<code></code>
<code>        /latchcws &lt;&lt;</code>
<code>            tl 900  bl 901  bl6 924  nl 902  bs 913  m05 916  m06 917</code>
<code>        &gt;&gt; def</code>
<code></code>
<code>        % Submode encoding functions</code>
<code>        /enca {charvals A get exch get} def</code>
<code>        /encl {charvals L get exch get} def</code>
<code>        /encm {charvals M get exch get} def</code>
<code>        /encp {charvals P get exch get} def</code>
<code>        /textencfuncs [ /enca /encl /encm /encp ] def</code>
<code></code>
<code>        /addtotext {</code>
<code>            text exch l exch put</code>
<code>            /l l 1 add def</code>
<code>        } def</code>
<code></code>
<code>        /enct {</code>
<code></code>
<code>            /in exch def</code>
<code></code>
<code>            /curlen [  e  e  e  e ] def</code>
<code>            curlen submode 0 put</code>
<code>            /curseq [ [] [] [] [] ] def</code>
<code></code>
<code>            % Derive the optimal sequences ending in each submode</code>
<code>            in {</code>
<code></code>
<code>                /char exch def</code>
<code></code>
<code>                % Check for optimisations in the current sequences by latching from x to y</code>
<code>                {  % loop</code>
<code>                    /imp false def</code>
<code>                    [ A L M P ] {</code>
<code>                        /x exch def</code>
<code>                        [ A L M P ] {</code>
<code>                            /y exch def</code>
<code>                            /cost curlen x get latlen x get y get add def</code>
<code>                            cost curlen y get lt {</code>
<code>                                curlen y cost put</code>
<code>                                curseq y [</code>
<code>                                    curseq x get aload pop</code>
<code>                                    latseq x get y get aload pop</code>
<code>                                ] put</code>
<code>                                /imp true def</code>
<code>                            } if</code>
<code>                        } forall</code>
<code>                    } forall</code>
<code>                    imp not {exit} if  % Repeat unless no improvement</code>
<code>                } loop</code>
<code></code>
<code>                % Determine optimal next sequences for each valid encoding</code>
<code>                /nxtlen [ e e e e ] def</code>
<code>                /nxtseq 4 array def</code>
<code></code>
<code>                [ A L M P ] {</code>
<code>                    /x exch def</code>
<code></code>
<code>                    { % loop for common exit</code>
<code></code>
<code>                        charvals x get char known not {exit} if</code>
<code></code>
<code>                        % Extend directly</code>
<code>                        /cost curlen x get 1 add def</code>
<code>                        cost nxtlen x get lt {</code>
<code>                            nxtlen x cost put</code>
<code>                            nxtseq x [ curseq x get aload pop char ] put</code>
<code>                        } if</code>
<code></code>
<code>                        % Optimise for direct shifts from y to x</code>
<code>                        [ A L M P ] {</code>
<code>                            /y exch def</code>
<code>                            x y ne {</code>
<code>                                /cost curlen y get shftlen y get x get add 1 add def</code>
<code>                                cost nxtlen y get lt {</code>
<code>                                    nxtlen y cost put</code>
<code>                                    nxtseq y [</code>
<code>                                        curseq y get aload pop</code>
<code>                                        x A eq {as} {ps} ifelse</code>
<code>                                        char</code>
<code>                                    ] put</code>
<code>                                } if</code>
<code>                            } if</code>
<code>                        } forall</code>
<code></code>
<code>                        exit</code>
<code>                    } loop</code>
<code></code>
<code>                } forall</code>
<code></code>
<code>                /curlen nxtlen def</code>
<code>                /curseq nxtseq def</code>
<code></code>
<code>            } forall</code>
<code></code>
<code>            % Select the optimal sequence</code>
<code>            /minseq e def</code>
<code>            [ A L M P ] {</code>
<code>                /k exch def</code>
<code>                curlen k get minseq lt {</code>
<code>                    /minseq curlen k get def</code>
<code>                    /txtseq curseq k get def</code>
<code>                } if</code>
<code>            } forall</code>
<code></code>
<code>            % Encode the sequence</code>
<code>            /text minseq array def</code>
<code>            /k 0 def /l 0 def {</code>
<code>                k txtseq length ge {exit} if</code>
<code></code>
<code>                /char txtseq k get def</code>
<code></code>
<code>                % Encode character</code>
<code>                char textencfuncs submode get load exec addtotext</code>
<code>                /k k 1 add def</code>
<code></code>
<code>                % Encode shifted next character</code>
<code>                char as eq char ps eq or {</code>
<code>                    txtseq k get char as eq {enca} {encp} ifelse addtotext</code>
<code>                    /k k 1 add def</code>
<code>                } if</code>
<code></code>
<code>                % Latches to new submode</code>
<code>                char al eq {/submode A def} if</code>
<code>                char ll eq {/submode L def} if</code>
<code>                char ml eq {/submode M def} if</code>
<code>                char pl eq {/submode P def} if</code>
<code>            } loop</code>
<code></code>
<code>            text length 2 mod 1 eq {</code>
<code>                submode P eq {</code>
<code>                    /pad al encp def</code>
<code>                    /submode A def</code>
<code>                } {</code>
<code>                    % Need to check whether a ps shift can be used to pad</code>
<code>                    /nextecitext false def</code>
<code>                    % If have one or more ECIs next followed by text sequence (array)</code>
<code>                    i 1 add 1 seq length 1 sub {</code>
<code>                        /ti exch def</code>
<code>                        seq ti get type /arraytype ne { /nextecitext false def exit } if</code>
<code>                        seq ti get 0 get -1000000 gt { exit } if</code>
<code>                        /nextecitext true def</code>
<code>                    } for</code>
<code>                    nextecitext { % Then don't use ps as it would affect first char of text sequence</code>
<code>                        submode A eq {</code>
<code>                            charvals L get seq ti get 0 get known {  % Check whether to use ll or ml latch</code>
<code>                                /pad ll enca def</code>
<code>                                /submode L def</code>
<code>                            } {</code>
<code>                                /pad ml enca def</code>
<code>                                /submode M def</code>
<code>                            } ifelse</code>
<code>                        } {</code>
<code>                        submode M eq {</code>
<code>                            charvals L get seq ti get 0 get known {  % Check whether to use ll, pl or al latch</code>
<code>                                /pad ll encm def</code>
<code>                                /submode L def</code>
<code>                            } {</code>
<code>                            charvals P get seq ti get 0 get known {</code>
<code>                                /pad pl encm def</code>
<code>                                /submode P def</code>
<code>                            } {</code>
<code>                                /pad al encm def</code>
<code>                                /submode A def</code>
<code>                            } ifelse } ifelse</code>
<code>                        } {  % L</code>
<code>                            /pad ml encl def  % Only latch available</code>
<code>                            /submode M def</code>
<code>                        } ifelse } ifelse</code>
<code>                    } {  % Otherwise use standard ps shift pad</code>
<code>                        /pad ps textencfuncs submode get load exec def</code>
<code>                    } ifelse</code>
<code>                } ifelse</code>
<code>                /text [ text aload pop pad ] def</code>
<code>            } if</code>
<code></code>
<code>            /out text length 2 idiv array def</code>
<code>            0 1 out length 1 sub {</code>
<code>                /k exch def</code>
<code>                out k text k 2 mul get 30 mul text k 2 mul 1 add get add put</code>
<code>            } for</code>
<code></code>
<code>            out</code>
<code></code>
<code>        } def</code>
<code></code>
<code>        /encn {</code>
<code>            /in exch def</code>
<code>            /out [] def</code>
<code>            0 44 in length 1 sub {</code>
<code>                /k exch def</code>
<code>                /gmod [</code>
<code>                    1 in k in length k sub dup 44 gt {pop 44} if getinterval</code>
<code>                    {48 sub} forall</code>
<code>                ] def</code>
<code>                /cwn [] def {</code>
<code>                    /dv 900 def</code>
<code>                    /gmul [] def /val 0 def {</code>
<code>                        gmod length 0 eq {exit} if</code>
<code>                        /val val 10 mul gmod 0 get add def</code>
<code>                        /gmod gmod 1 gmod length 1 sub getinterval def</code>
<code>                        val dv lt {</code>
<code>                            gmul length 0 ne {</code>
<code>                                /gmul [ gmul aload pop 0 ] def</code>
<code>                            } if</code>
<code>                        } {</code>
<code>                            /gmul [ gmul aload pop val dv idiv ] def</code>
<code>                        } ifelse</code>
<code>                        /val val dv mod def</code>
<code>                    } loop</code>
<code>                    /dv val def</code>
<code>                    /cwn [ dv cwn aload pop ] def</code>
<code>                    /gmod gmul def</code>
<code>                    gmul length 0 eq {exit} if</code>
<code>                } loop</code>
<code>                /out [ out aload pop cwn aload pop ] def</code>
<code>            } for</code>
<code>            out</code>
<code>        } def</code>
<code></code>
<code>        /ence {</code>
<code>            0 get neg 1000000 sub</code>
<code>                dup 000899 le {  % ECI 000000 - 000899</code>
<code>                927 exch 2 array astore</code>
<code>            } { dup 810899 le {  % ECI 000900 - 810899</code>
<code>                926 exch dup 900 idiv 1 sub exch 900 mod 3 array astore</code>
<code>            } { dup 811799 le {  % ECI 810900 - 811799</code>
<code>                925 exch 810900 sub 2 array astore</code>
<code>            } {</code>
<code>                /bwipp.pdf417badECI (PDF417 supports ECIs 000000 to 811799) //raiseerror exec</code>
<code>            } ifelse } ifelse } ifelse</code>
<code>        } def</code>
<code></code>
<code>        /encfuncs [ /enct /encn /encb ] def</code>
<code></code>
<code>        /addtocws {</code>
<code>            dup datcws j 3 -1 roll putinterval</code>
<code>            length j add /j exch def</code>
<code>        } def</code>
<code></code>
<code>        % Encode the sequence</code>
<code>        % No need to set state as seq will always begin with a latch, unlike for pdf417</code>
<code>        /datcws seqlen array def</code>
<code>        /i 0 def /j 0 def {</code>
<code>            i seq length ge {exit} if</code>
<code>            /chars seq i get def</code>
<code>            chars type /arraytype eq {  % Encode data according to mode</code>
<code>                chars 0 get -1000000 le {  % ECI</code>
<code>                    chars ence addtocws</code>
<code>                } {  % Encode data according to mode</code>
<code>                    chars encfuncs state get load exec addtocws</code>
<code>                } ifelse</code>
<code>            } {  % Encode the latch to new state, byte shift or macro</code>
<code>                [ latchcws chars get ] addtocws</code>
<code>                chars tl eq {/state T def /submode A def} if</code>
<code>                chars nl eq {/state N def} if</code>
<code>                chars bl eq chars bl6 eq or {/state B def} if</code>
<code>                chars bs eq {</code>
<code>                    /i i 1 add def</code>
<code>                    seq i get encb addtocws</code>
<code>                } if</code>
<code>                chars m05 eq {</code>
<code>                    i 1 add seq length lt {</code>
<code>                        seq i 1 add get nl eq {  % Latch to numeric mode is implied</code>
<code>                            /i i 1 add def</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    /state N def</code>
<code>                } if</code>
<code>                chars m06 eq {</code>
<code>                    i 1 add seq length lt {</code>
<code>                        seq i 1 add get tl eq {  % Latch to mixed text submode is implied</code>
<code>                            /i i 1 add def</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    /state T def /submode M def</code>
<code>                } if</code>
<code>            } ifelse</code>
<code>            /i i 1 add def</code>
<code>        } loop</code>
<code>        /datcws datcws 0 j getinterval def</code>
<code>    } if</code>
<code></code>
<code>{</code>
<code>    % Basic metrics for the each symbol</code>
<code>    %     c  r ecw  rl rc rr</code>
<code>    /ccametrics [</code>
<code>        [ 2  5   4  39  0 19 ]</code>
<code>        [ 2  6   4   1  0 33 ]</code>
<code>        [ 2  7   5  32  0 12 ]</code>
<code>        [ 2  8   5   8  0 40 ]</code>
<code>        [ 2  9   6  14  0 46 ]</code>
<code>        [ 2 10   6  43  0 23 ]</code>
<code>        [ 2 12   7  20  0 52 ]</code>
<code>        [ 3  4   4  11 43 23 ]</code>
<code>        [ 3  5   5   1 33 13 ]</code>
<code>        [ 3  6   6   5 37 17 ]</code>
<code>        [ 3  7   7  15 47 27 ]</code>
<code>        [ 3  8   7  21  1 33 ]</code>
<code>        [ 4  3   4  40 20 52 ]</code>
<code>        [ 4  4   5  43 23  3 ]</code>
<code>        [ 4  5   6  46 26  6 ]</code>
<code>        [ 4  6   7  34 14 46 ]</code>
<code>        [ 4  7   8  29  9 41 ]</code>
<code>    ] def</code>
<code></code>
<code>    % Basic metrics for the each symbol</code>
<code>    %     c  r ecw  rl rc rr</code>
<code>    /nonccametrics [</code>
<code>        [ 1 11   7   1  0  9 ]</code>
<code>        [ 1 14   7   8  0  8 ]</code>
<code>        [ 1 17   7  36  0 36 ]</code>
<code>        [ 1 20   8  19  0 19 ]</code>
<code>        [ 1 24   8   9  0 17 ]</code>
<code>        [ 1 28   8  25  0 33 ]</code>
<code>        [ 2  8   8   1  0  1 ]</code>
<code>        [ 2 11   9   1  0  9 ]</code>
<code>        [ 2 14   9   8  0  8 ]</code>
<code>        [ 2 17  10  36  0 36 ]</code>
<code>        [ 2 20  11  19  0 19 ]</code>
<code>        [ 2 23  13   9  0 17 ]</code>
<code>        [ 2 26  15  27  0 35 ]</code>
<code>        [ 3  6  12   1  1  1 ]</code>
<code>        [ 3  8  14   7  7  7 ]</code>
<code>        [ 3 10  16  15 15 15 ]</code>
<code>        [ 3 12  18  25 25 25 ]</code>
<code>        [ 3 15  21  37 37 37 ]</code>
<code>        [ 3 20  26   1 17 33 ]</code>
<code>        [ 3 26  32   1  9 17 ]</code>
<code>        [ 3 32  38  21 29 37 ]</code>
<code>        [ 3 38  44  15 31 47 ]</code>
<code>        [ 3 44  50   1 25 49 ]</code>
<code>        [ 4  4   8  47 19 43 ]</code>
<code>        [ 4  6  12   1  1  1 ]</code>
<code>        [ 4  8  14   7  7  7 ]</code>
<code>        [ 4 10  16  15 15 15 ]</code>
<code>        [ 4 12  18  25 25 25 ]</code>
<code>        [ 4 15  21  37 37 37 ]</code>
<code>        [ 4 20  26   1 17 33 ]</code>
<code>        [ 4 26  32   1  9 17 ]</code>
<code>        [ 4 32  38  21 29 37 ]</code>
<code>        [ 4 38  44  15 31 47 ]</code>
<code>        [ 4 44  50   1 25 49 ]</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /metrics cca {ccametrics} {nonccametrics} ifelse def</code>
<code></code>
<code>    % Select metrics of an appropriate symbol</code>
<code>    /urows rows def</code>
<code>    /ucols columns def</code>
<code>    metrics {</code>
<code>        /m exch def</code>
<code>        /c    m 0 get def        % Columns in symbol</code>
<code>        /r    m 1 get def        % Rows in symbol</code>
<code>        /k    m 2 get def        % Error correction codewords</code>
<code>        /rapl m 3 get def        % Left row address pattern</code>
<code>        /rapc m 4 get def        % Centre row address pattern</code>
<code>        /rapr m 5 get def        % Right row address pattern</code>
<code>        /ncws r c mul k sub def  % Data codewords</code>
<code>        /okay true def</code>
<code>        datcws length ncws gt     {/okay false def} if</code>
<code>        urows 0 ne urows r ne and {/okay false def} if</code>
<code>        ucols 0 ne ucols c ne and {/okay false def} if</code>
<code>        okay {exit} if</code>
<code>    } forall</code>
<code></code>
<code>    okay not {</code>
<code>        /bwipp.micropdf417noValidSymbol (Maximum length exceeded or invalid size) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Create codewords array with one extra working space element and add padding</code>
<code>    /m datcws length def</code>
<code>    /n c r mul k sub def</code>
<code>    /cws c r mul 1 add array def</code>
<code>    cws 0 datcws putinterval</code>
<code>    cws m [ n m sub {900} repeat ] putinterval</code>
<code>    cws n [ k {0} repeat 0 ] putinterval</code>
<code></code>
<code>    % Calculate the log and anti-log tables</code>
<code>{</code>
<code>    /rsalog [ 1 928 {dup 3 mul 929 mod} repeat ] def</code>
<code>    /rslog 929 array def</code>
<code>    1 1 928 {dup rsalog exch get exch rslog 3 1 roll put} for</code>
<code>} ctxdef</code>
<code></code>
<code>    % Function to calculate the product in the field</code>
<code>    /rsprod {</code>
<code>        2 copy 0 ne exch 0 ne and {</code>
<code>            rslog exch get exch rslog exch get add 928 mod rsalog exch get</code>
<code>        } {</code>
<code>            pop pop 0</code>
<code>        } ifelse</code>
<code>    } def</code>
<code></code>
<code>    % Generate the coefficients</code>
<code>    /coeffs [ 1 k {0} repeat ] def</code>
<code>    1 1 k {</code>
<code>        /i exch def</code>
<code>        coeffs i coeffs i 1 sub get put</code>
<code>        i 1 sub -1 1 {</code>
<code>            /j exch def</code>
<code>            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod add 929 mod put</code>
<code>        } for</code>
<code>        coeffs 0 coeffs 0 get rsalog i get rsprod put</code>
<code>    } for</code>
<code>    /coeffs coeffs 0 coeffs length 1 sub getinterval def</code>
<code>    coeffs length 1 sub -2 0 {coeffs exch 2 copy get 929 exch sub put} for</code>
<code></code>
<code>    % Derive the error codewords</code>
<code>    0 1 n 1 sub {</code>
<code>        /t exch cws exch get cws n get add 929 mod def</code>
<code>        0 1 k 1 sub {</code>
<code>            /j exch def</code>
<code>            cws n j add cws n j add 1 add get 929 t coeffs k j sub 1 sub get mul 929 mod sub add 929 mod put</code>
<code>        } for</code>
<code>    } for</code>
<code>    n 1 n k add { dup cws exch 929 cws 5 -1 roll get sub 929 mod put } for</code>
<code></code>
<code>    % Trim the working space from the end of the codewords</code>
<code>    /cws cws 0 cws length 1 sub getinterval def</code>
<code></code>
<code>    options /debugcws known { /bwipp.debugcws cws //raiseerror exec } if</code>
<code></code>
<code>{</code>
<code>    % Base 10 encoding of the bar space successions for the codewords in each cluster</code>
<code>    /clusters [</code>
<code>        [</code>
<code>            120256 125680 128380 120032 125560 128318 108736 119920 108640  86080 108592  86048</code>
<code>            110016 120560 125820 109792 120440 125758  88256 109680  88160  89536 110320 120700</code>
<code>             89312 110200 120638  89200 110140  89840 110460  89720 110398  89980 128506 119520</code>
<code>            125304 128190 107712 119408 125244 107616 119352  84032 107568 119324  84000 107544</code>
<code>             83984 108256 119672 125374  85184 108144 119612  85088 108088 119582  85040 108060</code>
<code>             85728 108408 119742  85616 108348  85560 108318  85880 108478  85820  85790 107200</code>
<code>            119152 125116 107104 119096 125086  83008 107056 119068  82976 107032  82960  82952</code>
<code>             83648 107376 119228  83552 107320 119198  83504 107292  83480  83468  83824 107452</code>
<code>             83768 107422  83740  83900 106848 118968 125022  82496 106800 118940  82464 106776</code>
<code>            118926  82448 106764  82440 106758  82784 106936 119006  82736 106908  82712 106894</code>
<code>             82700  82694 106974  82830  82240 106672 118876  82208 106648 118862  82192 106636</code>
<code>             82184 106630  82180  82352  82328  82316  82080 118830 106572 106566  82050 117472</code>
<code>            124280 127678 103616 117360 124220 103520 117304 124190  75840 103472  75808 104160</code>
<code>            117624 124350  76992 104048 117564  76896 103992  76848  76824  77536 104312 117694</code>
<code>             77424 104252  77368  77340  77688 104382  77628  77758 121536 126320 128700 121440</code>
<code>            126264 128670 111680 121392 126236 111648 121368 126222 111632 121356 103104 117104</code>
<code>            124092 112320 103008 117048 124062 112224 121656 126366  93248  74784 102936 117006</code>
<code>             93216 112152  93200  75456 103280 117180  93888  75360 103224 117150  93792 112440</code>
<code>            121758  93744  75288  93720  75632 103356  94064  75576 103326  94008 112542  93980</code>
<code>             75708  94140  75678  94110 121184 126136 128606 111168 121136 126108 111136 121112</code>
<code>            126094 111120 121100 111112 111108 102752 116920 123998 111456 102704 116892  91712</code>
<code>             74272 121244 116878  91680  74256 102668  91664 111372 102662  74244  74592 102840</code>
<code>            116958  92000  74544 102812  91952 111516 102798  91928  74508  74502  74680 102878</code>
<code>             92088  74652  92060  74638  92046  92126 110912 121008 126044 110880 120984 126030</code>
<code>            110864 120972 110856 120966 110852 110850  74048 102576 116828  90944  74016 102552</code>
<code>            116814  90912 111000 121038  90896  73992 102534  90888 110982  90884  74160 102620</code>
<code>             91056  74136 102606  91032 111054  91020  74118  91014  91100  91086 110752 120920</code>
<code>            125998 110736 120908 110728 120902 110724 110722  73888 102488 116782  90528  73872</code>
<code>            102476  90512 110796 102470  90504  73860  90500  73858  73944  90584  90572  90566</code>
<code>            120876 120870 110658 102444  73800  90312  90308  90306 101056 116080 123580 100960</code>
<code>            116024  70720 100912 115996  70688 100888  70672  70664  71360 101232 116156  71264</code>
<code>            101176 116126  71216 101148  71192  71180  71536 101308  71480 101278  71452  71612</code>
<code>             71582 118112 124600 127838 105024 118064 124572 104992 118040 124558 104976 118028</code>
<code>            104968 118022 100704 115896 123486 105312 100656 115868  79424  70176 118172 115854</code>
<code>             79392 105240 100620  79376  70152  79368  70496 100792 115934  79712  70448 118238</code>
<code>             79664 105372 100750  79640  70412  79628  70584 100830  79800  70556  79772  70542</code>
<code>             70622  79838 122176 126640 128860 122144 126616 128846 122128 126604 122120 126598</code>
<code>            122116 104768 117936 124508 113472 104736 126684 124494 113440 122264 126670 113424</code>
<code>            104712 117894 113416 122246 104706  69952 100528 115804  78656  69920 100504 115790</code>
<code>             96064  78624 104856 117966  96032 113560 122318 100486  96016  78600 104838  96008</code>
<code>             69890  70064 100572  78768  70040 100558  96176  78744 104910  96152 113614  70022</code>
<code>             78726  70108  78812  70094  96220  78798 122016 126552 128814 122000 126540 121992</code>
<code>            126534 121988 121986 104608 117848 124462 113056 104592 126574 113040 122060 117830</code>
<code>            113032 104580 113028 104578 113026  69792 100440 115758  78240  69776 100428  95136</code>
<code>             78224 104652 100422  95120 113100  69764  95112  78212  69762  78210  69848 100462</code>
<code>             78296  69836  95192  78284  69830  95180  78278  69870  95214 121936 126508 121928</code>
<code>            126502 121924 121922 104528 117804 112848 104520 117798 112840 121958 112836 104514</code>
<code>            112834  69712 100396  78032  69704 100390  94672  78024 104550  94664 112870  69698</code>
<code>             94660  78018  94658  78060  94700  94694 126486 121890 117782 104484 104482  69672</code>
<code>             77928  94440  69666  77922  99680  68160  99632  68128  99608 115342  68112  99596</code>
<code>             68104  99590  68448  99768 115422  68400  99740  68376  99726  68364  68358  68536</code>
<code>             99806  68508  68494  68574 101696 116400 123740 101664 116376 101648 116364 101640</code>
<code>            116358 101636  67904  99504 115292  72512  67872 116444 115278  72480 101784 116430</code>
<code>             72464  67848  99462  72456 101766  67842  68016  99548  72624  67992  99534  72600</code>
<code>            101838  72588  67974  68060  72668  68046  72654 118432 124760 127918 118416 124748</code>
<code>            118408 124742 118404 118402 101536 116312 105888 101520 116300 105872 118476 116294</code>
<code>            105864 101508 105860 101506 105858  67744  99416  72096  67728 116334  80800  72080</code>
<code>            101580  99398  80784 105932  67716  80776  72068  67714  72066  67800  99438  72152</code>
<code>             67788  80856  72140  67782  80844  72134  67822  72174  80878 126800 128940 126792</code>
<code>            128934 126788 126786 118352 124716 122576 126828 124710 122568 126822 122564 118338</code>
<code>            122562 101456 116268 105680 101448 116262 114128 105672 118374 114120 122598 101442</code>
<code>            114116 105666 114114  67664  99372  71888  67656  99366  80336  71880 101478  97232</code>
<code>             80328 105702  67650  97224 114150  71874  97220  67692  71916  67686  80364  71910</code>
<code>             97260  80358  97254 126760 128918 126756 126754 118312 124694 122472 126774 122468</code>
<code>            118306 122466 101416 116246 105576 101412 113896 105572 101410 113892 105570 113890</code>
<code>             67624  99350  71784 101430  80104  71780  67618  96744  80100  71778  96740  80098</code>
<code>             96738  71798  96758 126738 122420 122418 105524 113780 113778  71732  79988  96500</code>
<code>             96498  66880  66848  98968  66832  66824  66820  66992  66968  66956  66950  67036</code>
<code>             67022 100000  99984 115532  99976 115526  99972  99970  66720  98904  69024 100056</code>
<code>             98892  69008 100044  69000 100038  68996  66690  68994  66776  98926  69080 100078</code>
<code>             69068  66758  69062  66798  69102 116560 116552 116548 116546  99920 102096 116588</code>
<code>            115494 102088 116582 102084  99906 102082  66640  68816  66632  98854  73168  68808</code>
<code>             66628  73160  68804  66626  73156  68802  66668  68844  66662  73196  68838  73190</code>
<code>            124840 124836 124834 116520 118632 124854 118628 116514 118626  99880 115478 101992</code>
<code>            116534 106216 101988  99874 106212 101986 106210  66600  98838  68712  99894  72936</code>
<code>             68708  66594  81384  72932  68706  81380  72930  66614  68726  72950  81398 128980</code>
<code>            128978 124820 126900 124818 126898 116500 118580 116498 122740 118578 122738  99860</code>
<code>            101940  99858 106100 101938 114420</code>
<code>        ] [</code>
<code>            128352 129720 125504 128304 129692 125472 128280 129678 125456 128268 125448 128262</code>
<code>            125444 125792 128440 129758 120384 125744 128412 120352 125720 128398 120336 125708</code>
<code>            120328 125702 120324 120672 125880 128478 110144 120624 125852 110112 120600 125838</code>
<code>            110096 120588 110088 120582 110084 110432 120760 125918  89664 110384 120732  89632</code>
<code>            110360 120718  89616 110348  89608 110342  89952 110520 120798  89904 110492  89880</code>
<code>            110478  89868  90040 110558  90012  89998 125248 128176 129628 125216 128152 129614</code>
<code>            125200 128140 125192 128134 125188 125186 119616 125360 128220 119584 125336 128206</code>
<code>            119568 125324 119560 125318 119556 119554 108352 119728 125404 108320 119704 125390</code>
<code>            108304 119692 108296 119686 108292 108290  85824 108464 119772  85792 108440 119758</code>
<code>             85776 108428  85768 108422  85764  85936 108508  85912 108494  85900  85894  85980</code>
<code>             85966 125088 128088 129582 125072 128076 125064 128070 125060 125058 119200 125144</code>
<code>            128110 119184 125132 119176 125126 119172 119170 107424 119256 125166 107408 119244</code>
<code>            107400 119238 107396 107394  83872 107480 119278  83856 107468  83848 107462  83844</code>
<code>             83842  83928 107502  83916  83910  83950 125008 128044 125000 128038 124996 124994</code>
<code>            118992 125036 118984 125030 118980 118978 106960 119020 106952 119014 106948 106946</code>
<code>             82896 106988  82888 106982  82884  82882  82924  82918 124968 128022 124964 124962</code>
<code>            118888 124982 118884 118882 106728 118902 106724 106722  82408 106742  82404  82402</code>
<code>            124948 124946 118836 118834 106612 106610 124224 127664 129372 124192 127640 129358</code>
<code>            124176 127628 124168 127622 124164 124162 117568 124336 127708 117536 124312 127694</code>
<code>            117520 124300 117512 124294 117508 117506 104256 117680 124380 104224 117656 124366</code>
<code>            104208 117644 104200 117638 104196 104194  77632 104368 117724  77600 104344 117710</code>
<code>             77584 104332  77576 104326  77572  77744 104412  77720 104398  77708  77702  77788</code>
<code>             77774 128672 129880  93168 128656 129868  92664 128648 129862  92412 128644 128642</code>
<code>            124064 127576 129326 126368 124048 129902 126352 128716 127558 126344 124036 126340</code>
<code>            124034 126338 117152 124120 127598 121760 117136 124108 121744 126412 124102 121736</code>
<code>            117124 121732 117122 121730 103328 117208 124142 112544 103312 117196 112528 121804</code>
<code>            117190 112520 103300 112516 103298 112514  75680 103384 117230  94112  75664 103372</code>
<code>             94096 112588 103366  94088  75652  94084  75650  75736 103406  94168  75724  94156</code>
<code>             75718  94150  75758 128592 129836  91640 128584 129830  91388 128580  91262 128578</code>
<code>            123984 127532 126160 123976 127526 126152 128614 126148 123970 126146 116944 124012</code>
<code>            121296 116936 124006 121288 126182 121284 116930 121282 102864 116972 111568 102856</code>
<code>            116966 111560 121318 111556 102850 111554  74704 102892  92112  74696 102886  92104</code>
<code>            111590  92100  74690  92098  74732  92140  74726  92134 128552 129814  90876 128548</code>
<code>             90750 128546 123944 127510 126056 128566 126052 123938 126050 116840 123958 121064</code>
<code>            116836 121060 116834 121058 102632 116854 111080 121078 111076 102626 111074  74216</code>
<code>            102646  91112  74212  91108  74210  91106  74230  91126 128532  90494 128530 123924</code>
<code>            126004 123922 126002 116788 120948 116786 120946 102516 110836 102514 110834  73972</code>
<code>             90612  73970  90610 128522 123914 125978 116762 120890 102458 110714 123552 127320</code>
<code>            129198 123536 127308 123528 127302 123524 123522 116128 123608 127342 116112 123596</code>
<code>            116104 123590 116100 116098 101280 116184 123630 101264 116172 101256 116166 101252</code>
<code>            101250  71584 101336 116206  71568 101324  71560 101318  71556  71554  71640 101358</code>
<code>             71628  71622  71662 127824 129452  79352 127816 129446  79100 127812  78974 127810</code>
<code>            123472 127276 124624 123464 127270 124616 127846 124612 123458 124610 115920 123500</code>
<code>            118224 115912 123494 118216 124646 118212 115906 118210 100816 115948 105424 100808</code>
<code>            115942 105416 118246 105412 100802 105410  70608 100844  79824  70600 100838  79816</code>
<code>            105446  79812  70594  79810  70636  79852  70630  79846 129960  95728 113404 129956</code>
<code>             95480 113278 129954  95356  95294 127784 129430  78588 128872 129974  95996  78462</code>
<code>            128868 127778  95870 128866 123432 127254 124520 123428 126696 128886 123426 126692</code>
<code>            124514 126690 115816 123446 117992 115812 122344 117988 115810 122340 117986 122338</code>
<code>            100584 115830 104936 100580 113640 104932 100578 113636 104930 113634  70120 100598</code>
<code>             78824  70116  96232  78820  70114  96228  78818  96226  70134  78838 129940  94968</code>
<code>            113022 129938  94844  94782 127764  78206 128820 127762  95102 128818 123412 124468</code>
<code>            123410 126580 124466 126578 115764 117876 115762 122100 117874 122098 100468 104692</code>
<code>            100466 113140 104690 113138  69876  78324  69874  95220  78322  95218 129930  94588</code>
<code>             94526 127754 128794 123402 124442 126522 115738 117818 121978 100410 104570 112890</code>
<code>             69754  78074  94714  94398 123216 127148 123208 127142 123204 123202 115408 123244</code>
<code>            115400 123238 115396 115394  99792 115436  99784 115430  99780  99778  68560  99820</code>
<code>             68552  99814  68548  68546  68588  68582 127400 129238  72444 127396  72318 127394</code>
<code>            123176 127126 123752 123172 123748 123170 123746 115304 123190 116456 115300 116452</code>
<code>            115298 116450  99560 115318 101864  99556 101860  99554 101858  68072  99574  72680</code>
<code>             68068  72676  68066  72674  68086  72694 129492  80632 105854 129490  80508  80446</code>
<code>            127380  72062 127924 127378  80766 127922 123156 123700 123154 124788 123698 124786</code>
<code>            115252 116340 115250 118516 116338 118514  99444 101620  99442 105972 101618 105970</code>
<code>             67828  72180  67826  80884  72178  80882  97008 114044  96888 113982  96828  96798</code>
<code>            129482  80252 130010  97148  80190  97086 127370 127898 128954 123146 123674 124730</code>
<code>            126842 115226 116282 118394 122618  99386 101498 105722 114170  67706  71930  80378</code>
<code>             96632 113854  96572  96542  80062  96702  96444  96414  96350 123048 123044 123042</code>
<code>            115048 123062 115044 115042  99048 115062  99044  99042  67048  99062  67044  67042</code>
<code>             67062 127188  68990 127186 123028 123316 123026 123314 114996 115572 114994 115570</code>
<code>             98932 100084  98930 100082  66804  69108  66802  69106 129258  73084  73022 127178</code>
<code>            127450 123018 123290 123834 114970 115514 116602  98874  99962 102138  66682  68858</code>
<code>             73210  81272 106174  81212  81182  72894  81342  97648 114364  97592 114334  97564</code>
<code>             97550  81084  97724  81054  97694  97464 114270  97436  97422  80990  97502  97372</code>
<code>             97358  97326 114868 114866  98676  98674  66292  66290 123098 114842 115130  98618</code>
<code>             99194  66170  67322  69310  73404  73374  81592 106334  81564  81550  73310  81630</code>
<code>             97968 114524  97944 114510  97932  97926  81500  98012  81486  97998  97880 114478</code>
<code>             97868  97862  81454  97902  97836  97830  69470  73564  73550  81752 106414  81740</code>
<code>             81734  73518  81774  81708  81702</code>
<code>        ] [</code>
<code>            109536 120312  86976 109040 120060  86496 108792 119934  86256 108668  86136 129744</code>
<code>             89056 110072 129736  88560 109820 129732  88312 109694 129730  88188 128464 129772</code>
<code>             89592 128456 129766  89340 128452  89214 128450 125904 128492 125896 128486 125892</code>
<code>            125890 120784 125932 120776 125926 120772 120770 110544 120812 110536 120806 110532</code>
<code>             84928 108016 119548  84448 107768 119422  84208 107644  84088 107582  84028 129640</code>
<code>             85488 108284 129636  85240 108158 129634  85116  85054 128232 129654  85756 128228</code>
<code>             85630 128226 125416 128246 125412 125410 119784 125430 119780 119778 108520 119798</code>
<code>            108516 108514  83424 107256 119166  83184 107132  83064 107070  83004  82974 129588</code>
<code>             83704 107390 129586  83580  83518 128116  83838 128114 125172 125170 119284 119282</code>
<code>            107508 107506  82672 106876  82552 106814  82492  82462 129562  82812  82750 128058</code>
<code>            125050 119034  82296 106686  82236  82206  82366  82108  82078  76736 103920 117500</code>
<code>             76256 103672 117374  76016 103548  75896 103486  75836 129384  77296 104188 129380</code>
<code>             77048 104062 129378  76924  76862 127720 129398  77564 127716  77438 127714 124392</code>
<code>            127734 124388 124386 117736 124406 117732 117730 104424 117750 104420 104418 112096</code>
<code>            121592 126334  92608 111856 121468  92384 111736 121406  92272 111676  92216 111646</code>
<code>             92188  75232 103160 117118  93664  74992 103036  93424 112252 102974  93304  74812</code>
<code>             93244  74782  93214 129332  75512 103294 129908 129330  93944  75388 129906  93820</code>
<code>             75326  93758 127604  75646 128756 127602  94078 128754 124148 126452 124146 126450</code>
<code>            117236 121844 117234 121842 103412 103410  91584 111344 121212  91360 111224 121150</code>
<code>             91248 111164  91192 111134  91164  91150  74480 102780  91888  74360 102718  91768</code>
<code>            111422  91708  74270  91678 129306  74620 129850  92028  74558  91966 127546 128634</code>
<code>            124026 126202 116986 121338 102906  90848 110968 121022  90736 110908  90680 110878</code>
<code>             90652  90638  74104 102590  91000  74044  90940  74014  90910  74174  91070  90480</code>
<code>            110780  90424 110750  90396  90382  73916  90556  73886  90526  90296 110686  90268</code>
<code>             90254  73822  90334  90204  90190  71136 101112 116094  70896 100988  70776 100926</code>
<code>             70716  70686 129204  71416 101246 129202  71292  71230 127348  71550 127346 123636</code>
<code>            123634 116212 116210 101364 101362  79296 105200 118140  79072 105080 118078  78960</code>
<code>            105020  78904 104990  78876  78862  70384 100732  79600  70264 100670  79480 105278</code>
<code>             79420  70174  79390 129178  70524 129466  79740  70462  79678 127290 127866 123514</code>
<code>            124666 115962 118266 100858 113376 122232 126654  95424 113264 122172  95328 113208</code>
<code>            122142  95280 113180  95256 113166  95244  78560 104824 117950  95968  78448 104764</code>
<code>             95856 113468 104734  95800  78364  95772  78350  95758  70008 100542  78712  69948</code>
<code>             96120  78652  69918  96060  78622  96030  70078  78782  96190  94912 113008 122044</code>
<code>             94816 112952 122014  94768 112924  94744 112910  94732  94726  78192 104636  95088</code>
<code>             78136 104606  95032 113054  95004  78094  94990  69820  78268  69790  95164  78238</code>
<code>             95134  94560 112824 121950  94512 112796  94488 112782  94476  94470  78008 104542</code>
<code>             94648  77980  94620  77966  94606  69726  78046  94686  94384 112732  94360 112718</code>
<code>             94348  94342  77916  94428  77902  94414  94296 112686  94284  94278  77870  94318</code>
<code>             94252  94246  68336  99708  68216  99646  68156  68126  68476  68414 127162 123258</code>
<code>            115450  99834  72416 101752 116414  72304 101692  72248 101662  72220  72206  67960</code>
<code>             99518  72568  67900  72508  67870  72478  68030  72638  80576 105840 118460  80480</code>
<code>            105784 118430  80432 105756  80408 105742  80396  80390  72048 101564  80752  71992</code>
<code>            101534  80696  71964  80668  71950  80654  67772  72124  67742  80828  72094  80798</code>
<code>            114016 122552 126814  96832 113968 122524  96800 113944 122510  96784 113932  96776</code>
<code>            113926  96772  80224 105656 118366  97120  80176 105628  97072 114076 105614  97048</code>
<code>             80140  97036  80134  97030  71864 101470  80312  71836  97208  80284  71822  97180</code>
<code>             80270  97166  67678  71902  80350  97246  96576 113840 122460  96544 113816 122446</code>
<code>             96528 113804  96520 113798  96516  96514  80048 105564  96688  80024 105550  96664</code>
<code>            113870  96652  80006  96646  71772  80092  71758  96732  80078  96718  96416 113752</code>
<code>            122414  96400 113740  96392 113734  96388  96386  79960 105518  96472  79948  96460</code>
<code>             79942  96454  71726  79982  96494  96336 113708  96328 113702  96324  96322  79916</code>
<code>             96364  79910  96358  96296 113686  96292  96290  79894  96310  66936  99006  66876</code>
<code>             66846  67006  68976 100028  68920  99998  68892  68878  66748  69052  66718  69022</code>
<code>             73056 102072 116574  73008 102044  72984 102030  72972  72966  68792  99934  73144</code>
<code>             68764  73116  68750  73102  66654  68830  73182  81216 106160 118620  81184 106136</code>
<code>            118606  81168 106124  81160 106118  81156  81154  72880 101980  81328  72856 101966</code>
<code>             81304 106190  81292  72838  81286  68700  72924  68686  81372  72910  81358 114336</code>
<code>            122712 126894 114320 122700 114312 122694 114308 114306  81056 106072 118574  97696</code>
<code>             81040 106060  97680 114380 106054  97672  81028  97668  81026  97666  72792 101934</code>
<code>             81112  72780  97752  81100  72774  97740  81094  97734  68654  72814  81134  97774</code>
<code>            114256 122668 114248 122662 114244 114242  80976 106028  97488  80968 106022  97480</code>
<code>            114278  97476  80962  97474  72748  81004  72742  97516  80998  97510 114216 122646</code>
<code>            114212 114210  80936 106006  97384  80932  97380  80930  97378  72726  80950  97398</code>
<code>            114196 114194  80916  97332  80914  97330  66236  66206  67256  99166  67228  67214</code>
<code>             66142  67294  69296 100188  69272 100174  69260  69254  67164  69340  67150  69326</code>
<code>             73376 102232 116654  73360 102220  73352 102214  73348  73346  69208 100142  73432</code>
<code>            102254  73420  69190  73414  67118  69230  73454 106320 118700 106312 118694 106308</code>
<code>            106306  73296 102188  81616 106348 102182  81608  73284  81604  73282  81602  69164</code>
<code>             73324  69158  81644  73318  81638 122792 126934 122788 122786 106280 118678 114536</code>
<code>            106276 114532 106274 114530  73256 102166  81512  73252  98024  81508  73250  98020</code>
<code>             81506  98018  69142  73270  81526  98038 122772 122770 106260 114484 106258 114482</code>
<code>             73236  81460  73234  97908  81458  97906 122762 106250 114458  73226  81434  97850</code>
<code>             66396  66382  67416  99246  67404  67398  66350  67438  69456 100268  69448 100262</code>
<code>             69444  69442  67372  69484  67366  69478 102312 116694 102308 102306  69416 100246</code>
<code>             73576 102326  73572  69410  73570  67350  69430  73590 118740 118738 102292 106420</code>
<code>            102290 106418  69396  73524  69394  81780  73522  81778 118730 102282 106394  69386</code>
<code>             73498  81722  66476  66470  67496  99286  67492  67490  66454  67510 100308 100306</code>
<code>             67476  69556  67474  69554 116714</code>
<code>        ]</code>
<code>    ] def</code>
<code></code>
<code>    % Row address patterns</code>
<code>    /raps [</code>
<code>        [  % Left and right</code>
<code>            802 930 946 818 882 890 826 954 922 986 970 906 778</code>
<code>            794 786 914 978 982 980 916 948 932 934 942 940 936</code>
<code>            808 812 814 806 822 950 918 790 788 820 884 868 870</code>
<code>            878 876 872 840 856 860 862 846 844 836 838 834 866</code>
<code>        ] [  % Centre</code>
<code>            718 590 622 558 550 566 534 530 538 570 562 546 610</code>
<code>            626 634 762 754 758 630 628 612 614 582 578 706 738</code>
<code>            742 740 748 620 556 552 616 744 712 716 708 710 646</code>
<code>            654 652 668 664 696 688 656 720 592 600 604 732 734</code>
<code>        ]</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Return the 17 bits for a codeword in a given cluster</code>
<code>    /cwtobits {</code>
<code>        clusters exch get exch get /v exch def</code>
<code>        [ 17 {0} repeat v 2 17 string cvrs {48 sub} forall ]</code>
<code>        dup length 17 sub 17 getinterval</code>
<code>    } def</code>
<code></code>
<code>    % Return the 10 bits for a row address pattern</code>
<code>    /raptobits {</code>
<code>        raps exch get exch get /v exch def</code>
<code>        [ 10 {0} repeat v 2 10 string cvrs {48 sub} forall ]</code>
<code>        dup length 10 sub 10 getinterval</code>
<code>    } def</code>
<code></code>
<code>    % Populate bitmap for the image</code>
<code>    /rwid [38 55 82 99] c 1 sub get def</code>
<code>    c 3 eq cca and {/rwid 72 def} if</code>
<code>    /pixs rwid r mul rowmult mul array def</code>
<code></code>
<code>    0 1 r 1 sub {</code>
<code>        /i exch def</code>
<code>        /clst i rapl add 1 sub 3 mod def</code>
<code>        [</code>
<code>            c 1 eq {</code>
<code>                i rapl add 1 sub 52 mod 0 raptobits aload pop</code>
<code>                cws i get clst cwtobits aload pop</code>
<code>                i rapr add 1 sub 52 mod 0 raptobits aload pop</code>
<code>            } if</code>
<code>            c 2 eq {</code>
<code>                i rapl add 1 sub 52 mod 0 raptobits aload pop</code>
<code>                cws i 2 mul get clst cwtobits aload pop</code>
<code>                cws i 2 mul 1 add get clst cwtobits aload pop</code>
<code>                i rapr add 1 sub 52 mod 0 raptobits aload pop</code>
<code>            } if</code>
<code>            c 3 eq {</code>
<code>                cca not {</code>
<code>                    i rapl add 1 sub 52 mod 0 raptobits aload pop</code>
<code>                } if</code>
<code>                cws i 3 mul get clst cwtobits aload pop</code>
<code>                i rapc add 1 sub 52 mod 1 raptobits aload pop</code>
<code>                cws i 3 mul 1 add get clst cwtobits aload pop</code>
<code>                cws i 3 mul 2 add get clst cwtobits aload pop</code>
<code>                i rapr add 1 sub 52 mod 0 raptobits aload pop</code>
<code>            } if</code>
<code>            c 4 eq {</code>
<code>                i rapl add 1 sub 52 mod 0 raptobits aload pop</code>
<code>                cws i 4 mul get clst cwtobits aload pop</code>
<code>                cws i 4 mul 1 add get clst cwtobits aload pop</code>
<code>                i rapc add 1 sub 52 mod 1 raptobits aload pop</code>
<code>                cws i 4 mul 2 add get clst cwtobits aload pop</code>
<code>                cws i 4 mul 3 add get clst cwtobits aload pop</code>
<code>                i rapr add 1 sub 52 mod 0 raptobits aload pop</code>
<code>            } if</code>
<code>            1</code>
<code>        ]</code>
<code>        0 1 rowmult 1 sub {</code>
<code>            i rowmult mul add rwid mul pixs exch 2 index putinterval</code>
<code>        } for</code>
<code>        pop</code>
<code>    } for</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renmatrix</code>
<code>    /pixs pixs</code>
<code>    /pixx rwid</code>
<code>    /pixy r rowmult mul</code>
<code>    /height r rowmult mul 72 div</code>
<code>    /width rwid 72 div</code>
<code>    /borderleft 1.0</code>
<code>    /borderright 1.0</code>
<code>    /bordertop 1.0</code>
<code>    /borderbottom 1.0</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /micropdf417 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER micropdf417--</code>
<code></code>
<code>% --BEGIN ENCODER datamatrix--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix--</code>
<code>% --DESC: Data Matrix</code>
<code>% --EXAM: This is Data Matrix!</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp datamatrix 0.0 2024010300 216644 238847</code>
<code>%%BeginData:        956 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/datamatrix {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /columns 0 def</code>
<code>    /rows 0 def</code>
<code>    /format (unset) def    % square or rectangle</code>
<code>    /version (unset) def</code>
<code>    /parse false def</code>
<code>    /parsefnc false def</code>
<code>    /c40headerlength -1 def</code>
<code>    /raw false def</code>
<code>    /dmre false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.datamatrixEmptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    version (unset) ne rows 0 ne columns 0 ne or and {</code>
<code>        /bwipp.datamatrixVersionRowsCols (rows and columns must not be given if version is specified) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Parse version=RxC into rows and columns</code>
<code>    version (unset) ne {</code>
<code>        version (x) search {</code>
<code>            exch pop</code>
<code>            2 copy 2 array astore {</code>
<code>                true</code>
<code>                1 index length 0 eq { pop false } if</code>
<code>                exch {</code>
<code>                    dup 48 lt exch 57 gt or { pop false } if</code>
<code>                } forall</code>
<code>                not {</code>
<code>                    /bwipp.datamatrixVersionBadRowOrColumn (version must be formatted as RxC) //raiseerror exec</code>
<code>                } if</code>
<code>            } forall</code>
<code>            /rows exch cvi def</code>
<code>            /columns exch cvi def</code>
<code>            /format rows columns eq { (square) } { (rectangle) } ifelse def</code>
<code>        } {</code>
<code>            pop /bwipp.datamatrixVersionFormat (version must be formatted as RxC) //raiseerror exec</code>
<code>        } ifelse</code>
<code>    } {</code>
<code>        format (unset) eq {</code>
<code>            /format dmre { (rectangle) } { (square) } ifelse def</code>
<code>        } if</code>
<code>    } ifelse</code>
<code></code>
<code>    format (square) ne format (rectangle) ne and {</code>
<code>        /bwipp.datamatrixInvalidFormat (The format must be either square or rectangle) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /datamatrix //loadctx exec</code>
<code></code>
<code>    % Basic metrics for the each symbol</code>
<code>    %    rows  cols  regh  regv  rscw  rsbl  dmre</code>
<code>{</code>
<code>    /metrics [</code>
<code>        % Standard square symbols</code>
<code>        [  10    10     1     1     5     1     0 ]</code>
<code>        [  12    12     1     1     7     1     0 ]</code>
<code>        [  14    14     1     1    10     1     0 ]</code>
<code>        [  16    16     1     1    12     1     0 ]</code>
<code>        [  18    18     1     1    14     1     0 ]</code>
<code>        [  20    20     1     1    18     1     0 ]</code>
<code>        [  22    22     1     1    20     1     0 ]</code>
<code>        [  24    24     1     1    24     1     0 ]</code>
<code>        [  26    26     1     1    28     1     0 ]</code>
<code>        [  32    32     2     2    36     1     0 ]</code>
<code>        [  36    36     2     2    42     1     0 ]</code>
<code>        [  40    40     2     2    48     1     0 ]</code>
<code>        [  44    44     2     2    56     1     0 ]</code>
<code>        [  48    48     2     2    68     1     0 ]</code>
<code>        [  52    52     2     2    84     2     0 ]</code>
<code>        [  64    64     4     4   112     2     0 ]</code>
<code>        [  72    72     4     4   144     4     0 ]</code>
<code>        [  80    80     4     4   192     4     0 ]</code>
<code>        [  88    88     4     4   224     4     0 ]</code>
<code>        [  96    96     4     4   272     4     0 ]</code>
<code>        [ 104   104     4     4   336     6     0 ]</code>
<code>        [ 120   120     6     6   408     6     0 ]</code>
<code>        [ 132   132     6     6   496     8     0 ]</code>
<code>        [ 144   144     6     6   620    10     0 ]</code>
<code>        % Optional rectangular symbols</code>
<code>        [   8    18     1     1     7     1     0 ]</code>
<code>        [   8    32     1     2    11     1     0 ]</code>
<code>        [   8    48     1     2    15     1     1 ]</code>
<code>        [   8    64     1     4    18     1     1 ]</code>
<code>        [   8    80     1     4    22     1     1 ]</code>
<code>        [   8    96     1     4    28     1     1 ]</code>
<code>        [   8   120     1     6    32     1     1 ]</code>
<code>        [   8   144     1     6    36     1     1 ]</code>
<code>        [  12    26     1     1    14     1     0 ]</code>
<code>        [  12    36     1     2    18     1     0 ]</code>
<code>        [  12    64     1     4    27     1     1 ]</code>
<code>        [  12    88     1     4    36     1     1 ]</code>
<code>        [  16    36     1     2    24     1     0 ]</code>
<code>        [  16    48     1     2    28     1     0 ]</code>
<code>        [  16    64     1     4    36     1     1 ]</code>
<code>        [  20    36     1     2    28     1     1 ]</code>
<code>        [  20    44     1     2    34     1     1 ]</code>
<code>        [  20    64     1     4    42     1     1 ]</code>
<code>        [  22    48     1     2    38     1     1 ]</code>
<code>        [  24    48     1     2    41     1     1 ]</code>
<code>        [  24    64     1     4    46     1     1 ]</code>
<code>        [  26    40     1     2    38     1     1 ]</code>
<code>        [  26    48     1     2    42     1     1 ]</code>
<code>        [  26    64     1     4    50     1     1 ]</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Create array of codewords remaining to make a full symbol</code>
<code>    /urows rows def</code>
<code>    /ucols columns def</code>
<code>    /fullcws [] def</code>
<code>    metrics {</code>
<code>        /m exch def</code>
<code>        /rows m 0 get def                          % Rows in symbol</code>
<code>        /cols m 1 get def                          % Columns in symbol</code>
<code>        /regh m 2 get def                          % Horizontal regions</code>
<code>        /regv m 3 get def                          % Vertical regions</code>
<code>        /rscw m 4 get def                          % Error correction codewords</code>
<code>        /rsbl m 5 get def                          % Error correction blocks</code>
<code>        /doly m 6 get def                          % DMRE-only model</code>
<code>        /mrows rows 2 regh mul sub def             % Rows in the mapping matrix</code>
<code>        /mcols cols 2 regv mul sub def             % Columns in the mapping matrix</code>
<code>        /ncws mrows mcols mul 8 idiv rscw sub def  % Data codewords</code>
<code>        /okay true def</code>
<code>        urows 0 ne urows rows ne and {/okay false def} if</code>
<code>        ucols 0 ne ucols cols ne and {/okay false def} if</code>
<code>        format (square) eq rows cols ne and {/okay false def} if</code>
<code>        format (rectangle) eq rows cols eq and {/okay false def} if</code>
<code>        dmre not doly 1 eq and {/okay false def} if</code>
<code>        okay {/fullcws [ fullcws aload pop ncws ] def} if</code>
<code>    } forall</code>
<code>    /numremcws [ 1558 {10000} repeat ] def</code>
<code>    fullcws {numremcws exch 1 sub 1 put} forall</code>
<code>    1556 -1 0 {</code>
<code>        /i exch def</code>
<code>        numremcws i get 1 ne {</code>
<code>            numremcws i numremcws i 1 add get 1 add put</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>{</code>
<code>    % Special characters</code>
<code>    /fnc1  -1 def  /prog  -2 def  /m05   -3 def  /m06   -4 def</code>
<code>    /lC    -5 def  /lB    -6 def  /lX    -7 def  /lT    -8 def  /lE    -9 def  /unl -10 def</code>
<code>    /sapp -11 def  /usft -12 def  /sft1 -13 def  /sft2 -14 def  /sft3 -15 def  /eci -16 def  /pad -17 def</code>
<code>    /unlcw 254 def</code>
<code></code>
<code>    /Avals &lt;&lt;</code>
<code>        0 1 128 {dup 1 add} for</code>
<code>        pad 129</code>
<code>        0 1 99 {  % Double digits</code>
<code>            dup 10 2 string cvrs (00) 2 string copy dup 2 3 index length sub 4 -1 roll putinterval</code>
<code>            exch 130 add</code>
<code>        } for</code>
<code>        229 [ lC lB fnc1 sapp prog usft m05 m06 lX lT lE eci ] {exch 1 add dup} forall pop</code>
<code>    &gt;&gt; def</code>
<code>    /Avals &lt;&lt;</code>
<code>        Avals {[exch]} forall</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /CNvals &lt;&lt;</code>
<code>        sft1 0</code>
<code>        sft2 1</code>
<code>        sft3 2</code>
<code>        32   3</code>
<code>        48 1 57 {dup 44 sub} for  % 0-9</code>
<code>        65 1 90 {dup 51 sub} for  % A-Z</code>
<code>    &gt;&gt; def</code>
<code>    /C1vals &lt;&lt; 0 1 31 {dup} for &gt;&gt; def</code>
<code>    /C2vals &lt;&lt;</code>
<code>        33 1 47 {dup 33 sub} for</code>
<code>        58 1 64 {dup 43 sub} for</code>
<code>        91 1 95 {dup 69 sub} for</code>
<code>        fnc1 27</code>
<code>        usft 30</code>
<code>    &gt;&gt; def</code>
<code>    /C3vals &lt;&lt; 96 1 127 {dup 96 sub} for &gt;&gt; def</code>
<code>    /Cvals &lt;&lt;</code>
<code>        CNvals {[exch]} forall</code>
<code>        C1vals {[exch CNvals sft1 get exch]} forall</code>
<code>        C2vals {[exch CNvals sft2 get exch]} forall</code>
<code>        C3vals {[exch CNvals sft3 get exch]} forall</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /TNvals &lt;&lt;</code>
<code>        sft1 0</code>
<code>        sft2 1</code>
<code>        sft3 2</code>
<code>        32   3</code>
<code>        48 1  57 {dup 44 sub} for  % 0-9</code>
<code>        97 1 122 {dup 83 sub} for  % a-z</code>
<code>    &gt;&gt; def</code>
<code>    /T1vals &lt;&lt; 0 1 31 {dup} for &gt;&gt; def</code>
<code>    /T2vals &lt;&lt;</code>
<code>        33 1 47 {dup 33 sub} for</code>
<code>        58 1 64 {dup 43 sub} for</code>
<code>        91 1 95 {dup 69 sub} for</code>
<code>        fnc1 27</code>
<code>        usft 30</code>
<code>    &gt;&gt; def</code>
<code>    /T3vals &lt;&lt;</code>
<code>         96 0</code>
<code>         65 1  90 {dup 64 sub} for</code>
<code>        123 1 127 {dup 96 sub} for</code>
<code>    &gt;&gt; def</code>
<code>    /Tvals &lt;&lt;</code>
<code>        TNvals {[exch]} forall</code>
<code>        T1vals {[exch TNvals sft1 get exch]} forall</code>
<code>        T2vals {[exch TNvals sft2 get exch]} forall</code>
<code>        T3vals {[exch TNvals sft3 get exch]} forall</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    % Extended ASCII mappings</code>
<code>    128 1 255 {</code>
<code>        /i exch def</code>
<code>        Avals i [ Avals usft get aload pop Avals i 128 sub get aload pop ] put</code>
<code>        Cvals i [ Cvals usft get aload pop Cvals i 128 sub get aload pop ] put</code>
<code>        Tvals i [ Tvals usft get aload pop Tvals i 128 sub get aload pop ] put</code>
<code>    } for</code>
<code></code>
<code>    /Xvals &lt;&lt;</code>
<code>        13 0</code>
<code>        42 1</code>
<code>        62 2</code>
<code>        32 3</code>
<code>        48 1 57 {dup 44 sub} for</code>
<code>        65 1 90 {dup 51 sub} for</code>
<code>    &gt;&gt; def</code>
<code>    /Xvals &lt;&lt;</code>
<code>        Xvals {[exch]} forall</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /Evals &lt;&lt;</code>
<code>        64 1 94 {dup 64 sub} for</code>
<code>        unl 31</code>
<code>        32 1 63 {dup} for</code>
<code>    &gt;&gt; def</code>
<code>    /Evals &lt;&lt;</code>
<code>        Evals {[exch]} forall</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /Bvals &lt;&lt;</code>
<code>        0 1 255 {dup} for</code>
<code>    &gt;&gt; def</code>
<code>    /Bvals &lt;&lt;</code>
<code>        Bvals {[exch]} forall</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /encvals [ Avals Cvals Tvals Xvals Evals Bvals ] def</code>
<code></code>
<code>    /A 0 def  /C 1 def  /T 2 def  /X 3 def  /E 4 def  /B 5 def</code>
<code>} ctxdef</code>
<code></code>
<code>    raw {</code>
<code></code>
<code>        /cws barcode length array def</code>
<code>        /i 0 def /j 0 def</code>
<code>        { % loop</code>
<code>            i barcode length eq {exit} if</code>
<code>            /cw barcode i 1 add 3 getinterval cvi def</code>
<code>            cws j cw put</code>
<code>            /i i 4 add def</code>
<code>            /j j 1 add def</code>
<code>        } loop</code>
<code>        /cws cws 0 j getinterval def</code>
<code></code>
<code>    } {</code>
<code></code>
<code>        % Parse the input</code>
<code>        /fncvals &lt;&lt;</code>
<code>            /parse parse</code>
<code>            /parsefnc parsefnc</code>
<code>            /eci true</code>
<code>            (FNC1) fnc1</code>
<code>            (PROG) prog</code>
<code>%            (MAC5) m05    Encoded automatically</code>
<code>%            (MAC6) m06    Encoded automatically</code>
<code>        &gt;&gt; def</code>
<code>        /msg barcode fncvals //parseinput exec def</code>
<code>        /msglen msg length def</code>
<code></code>
<code>        % Macro 05/06 compression of [)&gt;{RS}05/06{GS}...{RS}{EOT} structured data</code>
<code>        msglen 9 ge {</code>
<code>            msg 0 7 getinterval aload pop</code>
<code>            29 eq exch pop exch 48 eq and exch  % [)&gt;{RS}0*{GS}...</code>
<code>            30 eq and exch 62 eq and exch 41 eq and exch 91 eq and {</code>
<code>                msg msglen 2 sub 2 getinterval aload pop</code>
<code>                4 eq exch 30 eq and {           %              ...{RS}{EOT}</code>
<code>                    msg 5 get 53 eq {           %      ...5...</code>
<code>                        /msg [ m05 msg 7 msg length 9 sub getinterval aload pop ] def</code>
<code>                    } {</code>
<code>                        msg 5 get 54 eq {       %      ...6...</code>
<code>                            /msg [ m06 msg 7 msg length 9 sub getinterval aload pop ] def</code>
<code>                        } if</code>
<code>                    } ifelse</code>
<code>                } if</code>
<code>            } if</code>
<code>        } if</code>
<code>        /msglen msg length def</code>
<code></code>
<code>        /numD      [ msglen {0} repeat 0 ] def</code>
<code>        /nextXterm [ msglen {0} repeat 9999 ] def</code>
<code>        /nextNonX  [ msglen {0} repeat 9999 ] def</code>
<code>        /isECI     [ msglen {false} repeat false ] def</code>
<code>        msglen 1 sub -1 0 {</code>
<code>            /i exch def</code>
<code>            /barchar msg i get def</code>
<code>            barchar 48 ge barchar 57 le and {</code>
<code>                numD i numD i 1 add get 1 add put</code>
<code>            } if</code>
<code>            barchar 13 eq barchar 42 eq or barchar 62 eq or {</code>
<code>                nextXterm i 0 put</code>
<code>            } {</code>
<code>                nextXterm i nextXterm i 1 add get 1 add put</code>
<code>            } ifelse</code>
<code>            Xvals barchar known not {</code>
<code>                nextNonX i 0 put</code>
<code>            } {</code>
<code>                nextNonX i nextNonX i 1 add get 1 add put</code>
<code>            } ifelse</code>
<code>            isECI i barchar -1000000 le put</code>
<code>        } for</code>
<code>        /nextXterm [nextXterm {dup 10000 gt {pop 10000} if} forall] def</code>
<code>        /nextNonX  [nextNonX  {dup 10000 gt {pop 10000} if} forall] def</code>
<code></code>
<code>        /isD  {char 48 ge char 57 le and} def</code>
<code>        /isC  {CNvals char known} def</code>
<code>        /isT  {TNvals char known} def</code>
<code>        /isX  {Xvals char known} def</code>
<code>        /isE  {Evals char known} def</code>
<code>        /isEA {char 127 gt} def</code>
<code>        /isFN {char 0 lt} def</code>
<code>        /XtermFirst {dup nextXterm exch get exch nextNonX exch get lt} def</code>
<code></code>
<code>        % TODO To avoid roundoff, consider increasing the scores by a scale factor of 12 to convert to integers</code>
<code>        /lookup {</code>
<code>            /ac 1.0 def /cc 2.0 def /tc 2.0 def /xc 2.0 def /ec 2.0 def /bc 2.25 def</code>
<code>            mode A eq {/ac 0.0 def /cc 1.0 def /tc 1.0 def /xc 1.0 def /ec 1.0 def /bc 1.25 def} if</code>
<code>            mode C eq {/cc 0.0 def} if</code>
<code>            mode T eq {/tc 0.0 def} if</code>
<code>            mode X eq {/xc 0.0 def} if</code>
<code>            mode E eq {/ec 0.0 def} if</code>
<code>            mode B eq {/bc 0.0 def} if</code>
<code>            1 {  % common exit</code>
<code>                isECI i get {A exit} if  % ECI only in ASCII</code>
<code>                c40headerlength -1 ne i c40headerlength lt and {C exit} if  % C40 only for c40headerlength characters</code>
<code>                /k 0 def {  % loop</code>
<code>                    i k add msglen eq {</code>
<code>                        [/ac /cc /tc /xc /ec /bc] {dup load ceiling def} forall</code>
<code>                        true [   cc tc xc ec bc] {ac exch le and} forall {A exit} if</code>
<code>                        true [ac cc tc xc ec   ] {bc exch lt and} forall {B exit} if</code>
<code>                        true [ac cc tc xc    bc] {ec exch lt and} forall {E exit} if</code>
<code>                        true [ac cc    xc ec bc] {tc exch lt and} forall {T exit} if</code>
<code>                        true [ac cc tc    ec bc] {xc exch lt and} forall {X exit} if</code>
<code>                        C exit</code>
<code>                    } if</code>
<code>                    /char msg i k add get def</code>
<code>                    /ac ac isD {1 2 div add} {isEA {ceiling 2 add} {ceiling 1 add} ifelse} ifelse def</code>
<code>                    /cc cc isC { 0.6666667 add} {isEA { 2.6666667 add } { 1.3333334 add } ifelse} ifelse def</code>
<code>                    /tc tc isT { 0.6666667 add} {isEA { 2.6666667 add } { 1.3333334 add } ifelse} ifelse def</code>
<code>                    /xc xc isX { 0.6666667 add} {isEA { 4.3333334 add } { 3.3333334 add } ifelse} ifelse def</code>
<code>                    /ec ec isE {3 4 div add} {isEA {17 4 div add } {13 4 div add } ifelse} ifelse def</code>
<code>                    /bc bc isFN {4 add} {1 add} ifelse def</code>
<code>                    k 4 ge {</code>
<code>                        true [   cc tc xc ec bc] {ac 1 add exch le and} forall {A exit} if</code>
<code>                        bc 1 add ac le {B exit} if</code>
<code>                        true [   cc tc xc ec   ] {bc 1 add exch lt and} forall {B exit} if</code>
<code>                        true [ac cc tc xc    bc] {ec 1 add exch lt and} forall {E exit} if</code>
<code>                        true [ac cc    xc ec bc] {tc 1 add exch lt and} forall {T exit} if</code>
<code>                        true [ac cc tc    ec bc] {xc 1 add exch lt and} forall {X exit} if</code>
<code>                        true [ac    tc    ec bc] {cc 1 add exch lt and} forall {</code>
<code>                            cc xc lt {C exit} if</code>
<code>                            cc xc eq {i k add 1 add XtermFirst {X exit} {C exit} ifelse} if</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    /k k 1 add def</code>
<code>                } loop</code>
<code>            } repeat</code>
<code>        } def</code>
<code></code>
<code>        /addtocws {</code>
<code>            dup cws exch j exch putinterval</code>
<code>            /j exch length j add def</code>
<code>        } def</code>
<code></code>
<code>        /ECItocws {</code>
<code>            neg 1000000 sub</code>
<code>                dup 000126 le {  % ECI 000000 - 000126</code>
<code>                1 add</code>
<code>                1 array astore</code>
<code>            } { dup 016382 le {  % ECI 000127 - 016382</code>
<code>                127 sub</code>
<code>                dup 254 idiv 128 add exch</code>
<code>                    254 mod 1 add</code>
<code>                2 array astore</code>
<code>            } {                  % ECI 016383 - 999999</code>
<code>                16383 sub</code>
<code>                dup 64516 idiv         192 add exch</code>
<code>                dup   254 idiv 254 mod   1 add exch</code>
<code>                               254 mod   1 add</code>
<code>                3 array astore</code>
<code>            } ifelse } ifelse</code>
<code>        } def</code>
<code></code>
<code>        /encA {</code>
<code>            1 {  % Common exit</code>
<code>                isECI i get {</code>
<code>                    Avals eci get addtocws</code>
<code>                    msg i get ECItocws addtocws</code>
<code>                    /i i 1 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                numD i get 2 ge {</code>
<code>                    2 string dup 0 msg i get put dup 1 msg i 1 add get put Avals exch get addtocws</code>
<code>                    /i i 2 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                /newmode lookup def</code>
<code>                newmode mode ne {</code>
<code>                    Avals [-1 lC lT lX lE lB] newmode get get addtocws</code>
<code>                    /mode newmode def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                Avals msg i get get addtocws</code>
<code>                /i i 1 add def</code>
<code>                exit</code>
<code>            } repeat</code>
<code>        } def</code>
<code></code>
<code>        /CTXvalstocws {</code>
<code>            /in exch def</code>
<code>            mark</code>
<code>            0 3 in length 1 sub {</code>
<code>                in exch 3 getinterval 0 exch {add 40 mul} forall 40 idiv 1 add</code>
<code>                dup 256 idiv exch 256 mod</code>
<code>            } for</code>
<code>            counttomark array astore exch pop</code>
<code>        } def</code>
<code></code>
<code>        /encCTX {</code>
<code>            /p 0 def</code>
<code>            /ctxvals 2500 array def</code>
<code>            /done false def</code>
<code></code>
<code>            % Lookup the values for each character</code>
<code>            {</code>
<code>                i msglen eq {exit} if</code>
<code>                encvals mode get msg i get known not {exit} if</code>
<code>                p 3 mod 0 eq {</code>
<code>                    p 0 gt {</code>
<code>                        /newmode lookup def</code>
<code>                        newmode mode ne {</code>
<code>                            ctxvals 0 p getinterval CTXvalstocws addtocws</code>
<code>                            [unlcw] addtocws</code>
<code>                            newmode A ne {</code>
<code>                                Avals [-1 lC lT lX lE lB] newmode get get addtocws</code>
<code>                            } if</code>
<code>                            /mode newmode def</code>
<code>                            /done true def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    msglen i sub 3 le {  % Check end of data conditions</code>
<code>                        /remcws numremcws j p 3 idiv 2 mul add get def</code>
<code>                        /remvals [</code>
<code>                            msg i msglen i sub getinterval {</code>
<code>                                dup encvals mode get exch known {</code>
<code>                                    encvals mode get exch get aload pop</code>
<code>                                } {  % Unencodable X12 characters</code>
<code>                                    pop -1 -1 -1 -1</code>
<code>                                } ifelse</code>
<code>                            } forall</code>
<code>                        ] def</code>
<code>                        remcws 2 eq remvals length 3 eq and {</code>
<code>                            % Encode and omit unlatch</code>
<code>                            [</code>
<code>                                ctxvals 0 p getinterval aload pop</code>
<code>                                remvals aload pop</code>
<code>                            ] CTXvalstocws addtocws</code>
<code>                            /mode A def</code>
<code>                            /i msglen def</code>
<code>                            /done true def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                        remcws 2 eq remvals length 2 eq and mode X ne and {</code>
<code>                            % Encode with sft1 as third value, omit unlatch</code>
<code>                            [</code>
<code>                                ctxvals 0 p getinterval aload pop</code>
<code>                                remvals aload pop</code>
<code>                                encvals mode get sft1 get aload pop</code>
<code>                            ] CTXvalstocws addtocws</code>
<code>                            /mode A def</code>
<code>                            /i msglen def</code>
<code>                            /done true def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                        remcws 2 eq remvals length 1 eq and {</code>
<code>                            % Unlatch to ASCII</code>
<code>                            ctxvals 0 p getinterval CTXvalstocws addtocws</code>
<code>                            [unlcw] addtocws</code>
<code>                            Avals msg i get get addtocws</code>
<code>                            /mode A def</code>
<code>                            /i msglen def</code>
<code>                            /done true def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                        remcws 1 eq remvals length 1 eq and {</code>
<code>                            % Implied unlatch to ASCII</code>
<code>                            ctxvals 0 p getinterval CTXvalstocws addtocws</code>
<code>                            Avals msg i get get addtocws</code>
<code>                            /mode A def</code>
<code>                            /i msglen def</code>
<code>                            /done true def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                } if</code>
<code>                encvals mode get msg i get get</code>
<code>                dup ctxvals exch p exch putinterval</code>
<code>                /p exch length p add def</code>
<code>                /i i 1 add def</code>
<code>            } loop</code>
<code></code>
<code>            % Backtrack to a boundary and return to ASCII</code>
<code>            done not {</code>
<code>                {</code>
<code>                    p 3 mod 0 eq {exit} if</code>
<code>                    /i i 1 sub def</code>
<code>                    /p p encvals mode get msg i get get length sub def</code>
<code>                } loop</code>
<code>                [</code>
<code>                    ctxvals 0 p getinterval aload pop</code>
<code>                ] CTXvalstocws addtocws</code>
<code>                [unlcw] addtocws</code>
<code>                /mode A def</code>
<code>                % Encode something to avoid latching immediately back</code>
<code>                i msglen ne isECI i get not and {</code>
<code>                    numD i get 2 ge {</code>
<code>                        2 string dup 0 msg i get put dup 1 msg i 1 add get put Avals exch get addtocws</code>
<code>                        /i i 2 add def</code>
<code>                    } {</code>
<code>                        Avals msg i get get addtocws</code>
<code>                        /i i 1 add def</code>
<code>                    } ifelse</code>
<code>                } if</code>
<code>            } if</code>
<code></code>
<code>        } def</code>
<code></code>
<code>        /Evalstocws {</code>
<code>            /in exch def</code>
<code>            /inlen in length def</code>
<code>            /outlen in length 4 div 3 mul ceiling cvi def</code>
<code>            /in [ in aload pop 0 0 0 ] def</code>
<code>            mark</code>
<code>            0 4 inlen 1 sub {</code>
<code>                in exch 4 getinterval 0 exch {or 6 bitshift} forall -6 bitshift</code>
<code>                dup -16 bitshift 255 and exch</code>
<code>                dup -8 bitshift 255 and exch</code>
<code>                255 and</code>
<code>            } for</code>
<code>            counttomark array astore exch pop</code>
<code>            0 outlen getinterval</code>
<code>        } def</code>
<code></code>
<code>        /encE {</code>
<code>            /p 0 def</code>
<code>            /edifactvals 2100 array def</code>
<code></code>
<code>            % Lookup the values for each character</code>
<code>            {</code>
<code>                i msglen eq {exit} if</code>
<code>                Evals msg i get known not {exit} if</code>
<code>                p 4 mod 0 eq {</code>
<code>                    msglen i sub 2 le {  % Check end of data condition</code>
<code>                        /remcws numremcws j p 4 idiv 3 mul add get def</code>
<code>                        /remvals [</code>
<code>                            msg i msglen i sub getinterval {</code>
<code>                                Avals exch get aload pop</code>
<code>                            } forall</code>
<code>                        ] def</code>
<code>                        remcws 1 eq remcws 2 eq or remvals length remcws le and {</code>
<code>                            % Implied unlatch to ASCII</code>
<code>                            edifactvals 0 p getinterval Evalstocws addtocws</code>
<code>                            remvals addtocws</code>
<code>                            /mode A def</code>
<code>                            /i msglen def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    lookup mode ne {exit} if</code>
<code>                } if</code>
<code>                Evals msg i get get</code>
<code>                dup edifactvals exch p exch putinterval</code>
<code>                /p exch length p add def</code>
<code>                /i i 1 add def</code>
<code>            } loop</code>
<code></code>
<code>            % Unlatch and pad with zeros until boundary</code>
<code>            mode A ne {</code>
<code>                /remcws numremcws j p 4 idiv 3 mul add 1 sub get 1 sub def</code>
<code>                p 4 mod 0 ne i msglen ne or remcws 3 ge or {  % Unlatch unless less than 3 codewords remain</code>
<code>                    Evals unl get</code>
<code>                    dup edifactvals exch p exch putinterval</code>
<code>                    /p exch length p add def</code>
<code>                } if</code>
<code>                edifactvals 0 p getinterval Evalstocws addtocws</code>
<code>                /mode A def</code>
<code>                % Encode something to avoid latching immediately back</code>
<code>                i msglen ne isECI i get not and {</code>
<code>                    numD i get 2 ge {</code>
<code>                        2 string dup 0 msg i get put dup 1 msg i 1 add get put Avals exch get addtocws</code>
<code>                        /i i 2 add def</code>
<code>                    } {</code>
<code>                        Avals msg i get get addtocws</code>
<code>                        /i i 1 add def</code>
<code>                    } ifelse</code>
<code>                } if</code>
<code>            } if</code>
<code></code>
<code>        } def</code>
<code></code>
<code>        /encB {</code>
<code>            /p 0 def /bvals 1558 array def {</code>
<code>                i msglen eq {exit} if</code>
<code>                lookup mode ne {exit} if</code>
<code>                bvals p msg i get put</code>
<code>                /p p 1 add def</code>
<code>                /i i 1 add def</code>
<code>            } loop</code>
<code>            /remcws numremcws j p add get 1 sub def</code>
<code>            /bvals [</code>
<code>                remcws 0 eq i msglen eq and {  % Terminates symbol</code>
<code>                    0</code>
<code>                } {</code>
<code>                    p 250 lt {p} {p 250 idiv 249 add p 250 mod} ifelse</code>
<code>                } ifelse</code>
<code>                bvals 0 p getinterval aload pop</code>
<code>            ] def</code>
<code>            0 1 bvals length 1 sub {  % Pseudo-randomise based on codeword position</code>
<code>                /p exch def</code>
<code>                j p add 1 add 149 mul 255 mod 1 add bvals p get add</code>
<code>                dup 256 ge {256 sub} if</code>
<code>                bvals exch p exch put</code>
<code>            } for</code>
<code>            bvals addtocws</code>
<code>            /mode A def</code>
<code>        } def</code>
<code></code>
<code>        % Derive the codewords</code>
<code>        /cws 1558 array def</code>
<code>        /mode A def /i 0 def /j 0 def {</code>
<code>            i msglen ge {exit} if</code>
<code>            [ /encA /encCTX /encCTX /encCTX /encE /encB ] mode get load exec</code>
<code>        } loop</code>
<code>        /cws cws 0 j getinterval def</code>
<code></code>
<code>    } ifelse</code>
<code></code>
<code>    % Extend codewords to fill symbol with pseudo-randomised pad characters</code>
<code>    /datlen cws length def</code>
<code>    /remcws numremcws j 1 sub get 1 sub def</code>
<code>    remcws 0 gt {</code>
<code>        /cws [ cws aload pop remcws {129} repeat ] def</code>
<code>        datlen 1 add 1 datlen remcws add 1 sub {</code>
<code>            /i exch def</code>
<code>            i 1 add 149 mul 253 mod 1 add 129 add</code>
<code>            dup 254 gt {254 sub} if</code>
<code>            cws exch i exch put</code>
<code>        } for</code>
<code>    } if</code>
<code></code>
<code>    options /debugcws known { /bwipp.debugcws cws //raiseerror exec } if</code>
<code></code>
<code>    % Lookup symbol metrics based on number of codewords and user specification</code>
<code>    metrics {</code>
<code>        /m exch def</code>
<code>        /rows m 0 get def                          % Rows in symbol</code>
<code>        /cols m 1 get def                          % Columns in symbol</code>
<code>        /regh m 2 get def                          % Horizontal regions</code>
<code>        /regv m 3 get def                          % Vertical regions</code>
<code>        /rscw m 4 get def                          % Error correction codewords</code>
<code>        /rsbl m 5 get def                          % Error correction blocks</code>
<code>        /doly m 6 get def                          % DMRE-only model</code>
<code>        /mrows rows 2 regh mul sub def             % Rows in the mapping matrix</code>
<code>        /mcols cols 2 regv mul sub def             % Columns in the mapping matrix</code>
<code>        /rrows mrows regh idiv def                 % Rows per region</code>
<code>        /rcols mcols regv idiv def                 % Columns per region</code>
<code>        /ncws mrows mcols mul 8 idiv rscw sub def  % Data codewords</code>
<code>        /okay true def</code>
<code>        cws length ncws ne           {/okay false def} if</code>
<code>        urows 0 ne urows rows ne and {/okay false def} if</code>
<code>        ucols 0 ne ucols cols ne and {/okay false def} if</code>
<code>        format (square) eq rows cols ne and {/okay false def} if</code>
<code>        format (rectangle) eq rows cols eq and {/okay false def} if</code>
<code>        dmre not doly 1 eq and {/okay false def} if</code>
<code>        okay {exit} if</code>
<code>    } forall</code>
<code></code>
<code>    okay not {</code>
<code>        /bwipp.datamatrixNoValidSymbol (Maximum length exceeded or invalid size) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % De-interleave the codewords into blocks</code>
<code>    /cwbs rsbl array def  % Array of data codeword blocks</code>
<code>    /ecbs rsbl array def  % Array of error correction blocks</code>
<code>    0 1 rsbl 1 sub {</code>
<code>        /i exch def</code>
<code>        cws length 1558 ne {</code>
<code>            /cwbsize cws length rsbl idiv def</code>
<code>        } {</code>
<code>            i 7 le {/cwbsize 156 def} {/cwbsize 155 def} ifelse</code>
<code>        } ifelse</code>
<code>        /cwb cwbsize array def</code>
<code>        0 1 cwbsize 1 sub {</code>
<code>            /j exch def</code>
<code>            cwb j cws j rsbl mul i add get put</code>
<code>        } for</code>
<code>        cwbs i cwb put</code>
<code>        ecbs i [ rscw rsbl idiv {0} repeat ] put</code>
<code>    } for</code>
<code></code>
<code>    % Calculate the log and anti-log tables</code>
<code>{</code>
<code>    /rsalog [ 1 255 { dup 2 mul dup 256 ge {301 xor} if } repeat ] def</code>
<code>    /rslog 256 array def</code>
<code>    1 1 255 {dup rsalog exch get exch rslog 3 1 roll put} for</code>
<code>} ctxdef</code>
<code></code>
<code>    % Function to calculate the product in the field</code>
<code>    /rsprod {</code>
<code>        2 copy 0 ne exch 0 ne and {</code>
<code>            rslog exch get exch rslog exch get add 255 mod rsalog exch get</code>
<code>        } {</code>
<code>            pop pop 0</code>
<code>        } ifelse</code>
<code>    } def</code>
<code></code>
<code>    % Generate the coefficients</code>
<code>    /coeffs [ 1 rscw rsbl idiv {0} repeat ] def</code>
<code>    1 1 rscw rsbl idiv {</code>
<code>        /i exch def</code>
<code>        coeffs i coeffs i 1 sub get put</code>
<code>        i 1 sub -1 1 {</code>
<code>            /j exch def</code>
<code>            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put</code>
<code>        } for</code>
<code>        coeffs 0 coeffs 0 get rsalog i get rsprod put</code>
<code>    } for</code>
<code>    /coeffs coeffs 0 coeffs length 1 sub getinterval def</code>
<code></code>
<code>    % Calculate the error correction codewords for each block</code>
<code>    0 1 cwbs length 1 sub {</code>
<code>        /i exch def</code>
<code>        /cwb cwbs i get def</code>
<code>        /ecb ecbs i get def</code>
<code>        0 1 cwb length 1 sub {</code>
<code>            /t exch cwb exch get ecb 0 get xor def</code>
<code>            ecb length 1 sub -1 0 {</code>
<code>                /j exch def</code>
<code>                /p ecb length j sub 1 sub def</code>
<code>                ecb p t coeffs j get rsprod put</code>
<code>                j 0 gt { ecb p ecb p 1 add get ecb p get xor put } if</code>
<code>            } for</code>
<code>        } for</code>
<code>    } for</code>
<code></code>
<code>    % Strange fixup for 144x144 symbols</code>
<code>    ncws 1558 eq {</code>
<code>        /ecbs [ ecbs 8 2 getinterval {} forall ecbs 0 8 getinterval {} forall ] def</code>
<code>    } if</code>
<code></code>
<code>    % Extend codewords with the interleaved error correction codes</code>
<code>    /cws [ cws {} forall rscw {0} repeat ] def</code>
<code>    0 1 rscw 1 sub {</code>
<code>        /i exch def</code>
<code>        cws ncws i add ecbs i rsbl mod get i rsbl idiv get put</code>
<code>    } for</code>
<code></code>
<code>    % Place the codewords into the matrix</code>
<code>    /module {</code>
<code>        % cw row col shape</code>
<code>        4 -1 roll</code>
<code>        (00000000) 8 string copy dup 3 -1 roll 2 8 string cvrs</code>
<code>        dup length 8 exch sub exch putinterval</code>
<code>        7 -1 0 {1 index exch get 48 sub exch} for pop</code>
<code>        11 -3 roll</code>
<code>        % 1 2 4 8 16 32 64 128 row col shape</code>
<code>        {  % Place each bit of the codeword in the shape, MSB first</code>
<code>            exec</code>
<code>            1 index 0 lt {</code>
<code>                exch mrows add exch</code>
<code>                4 mrows 4 add 8 mod sub add</code>
<code>            } if</code>
<code>            dup 0 lt {</code>
<code>                mcols add exch</code>
<code>                4 mcols 4 add 8 mod sub add exch</code>
<code>            } if</code>
<code>            1 index mrows ge {</code>
<code>                exch mrows sub exch</code>
<code>            } if</code>
<code>            exch mcols mul add</code>
<code>            mmat exch 5 -1 roll put</code>
<code>        } forall</code>
<code>    } def</code>
<code></code>
<code>    % Placement patterns</code>
<code>    /dmn [</code>
<code>        { 2 copy 2 sub exch 2 sub exch } bind  { 2 copy 1 sub exch 2 sub exch } bind</code>
<code>        { 2 copy 2 sub exch 1 sub exch } bind  { 2 copy 1 sub exch 1 sub exch } bind</code>
<code>        { 2 copy exch 1 sub exch } bind        { 2 copy 2 sub } bind</code>
<code>        { 2 copy 1 sub } bind                  { 2 copy } bind</code>
<code>    ] def</code>
<code></code>
<code>    /dmc1 [</code>
<code>        { mrows 1 sub 0 } bind  { mrows 1 sub 1 } bind</code>
<code>        { mrows 1 sub 2 } bind  { 0 mcols 2 sub } bind</code>
<code>        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind</code>
<code>        { 2 mcols 1 sub } bind  { 3 mcols 1 sub } bind</code>
<code>    ] def</code>
<code></code>
<code>    /dmc2 [</code>
<code>        { mrows 3 sub 0 } bind  { mrows 2 sub 0 } bind</code>
<code>        { mrows 1 sub 0 } bind  { 0 mcols 4 sub } bind</code>
<code>        { 0 mcols 3 sub } bind  { 0 mcols 2 sub } bind</code>
<code>        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind</code>
<code>    ] def</code>
<code></code>
<code>    /dmc3 [</code>
<code>        { mrows 3 sub 0 } bind  { mrows 2 sub 0 } bind</code>
<code>        { mrows 1 sub 0 } bind  { 0 mcols 2 sub } bind</code>
<code>        { 0 mcols 1 sub } bind  { 1 mcols 1 sub } bind</code>
<code>        { 2 mcols 1 sub } bind  { 3 mcols 1 sub } bind</code>
<code>    ] def</code>
<code></code>
<code>    /dmc4 [</code>
<code>        { mrows 1 sub 0 } bind  { mrows 1 sub mcols 1 sub } bind</code>
<code>        { 0 mcols 3 sub } bind  { 0 mcols 2 sub } bind</code>
<code>        { 0 mcols 1 sub } bind  { 1 mcols 3 sub } bind</code>
<code>        { 1 mcols 2 sub } bind  { 1 mcols 1 sub } bind</code>
<code>    ] def</code>
<code></code>
<code>    /mmat [ mrows mcols mul {-1} repeat ] def</code>
<code>    cws length 1 sub -1 0 {cws exch get} for  % Reverse cws onto stack</code>
<code>    4 0  % Starting row and column</code>
<code>    { % loop</code>
<code>        2 copy 0 eq exch mrows eq and {</code>
<code>            dmc1 module</code>
<code>        } if</code>
<code>        2 copy 0 eq exch mrows 2 sub eq and mcols 4 mod 0 ne and {</code>
<code>            dmc2 module</code>
<code>        } if</code>
<code>        2 copy 0 eq exch mrows 2 sub eq and mcols 8 mod 4 eq and {</code>
<code>            dmc3 module</code>
<code>        } if</code>
<code>        2 copy 2 eq exch mrows 4 add eq and mcols 8 mod 0 eq and {</code>
<code>            dmc4 module</code>
<code>        } if</code>
<code></code>
<code>        { % loop for sweeping upwards</code>
<code>            2 copy 0 ge exch mrows lt and {</code>
<code>                2 copy exch mcols mul add mmat exch get -1 eq {</code>
<code>                    dmn module</code>
<code>                } if</code>
<code>            } if</code>
<code>            2 add exch 2 sub exch</code>
<code>            2 copy mcols lt exch 0 ge and not {exit} if</code>
<code>        } loop</code>
<code>        3 add exch 1 add exch</code>
<code></code>
<code>        { % loop for sweeping downwards</code>
<code>            2 copy mcols lt exch 0 ge and {</code>
<code>                2 copy exch mcols mul add mmat exch get -1 eq {</code>
<code>                    dmn module</code>
<code>                } if</code>
<code>            } if</code>
<code>            2 sub exch 2 add exch</code>
<code>            2 copy 0 ge exch mrows lt and not {exit} if</code>
<code>        } loop</code>
<code>        1 add exch 3 add exch</code>
<code></code>
<code>        2 copy mcols lt exch mrows lt or not {pop pop exit} if</code>
<code></code>
<code>    } loop</code>
<code></code>
<code>    % Set checker pattern if required</code>
<code>    mmat mrows mcols mul 1 sub get -1 eq {</code>
<code>        mmat mrows mcols 1 sub mul 2 sub [1 0] putinterval</code>
<code>        mmat mrows mcols mul 2 sub [0 1] putinterval</code>
<code>    } if</code>
<code></code>
<code>    % Place the modules onto a pixel map between alignment patterns</code>
<code>    /pixs rows cols mul array def</code>
<code>    /cwpos 0 def</code>
<code>    0 1 rows 1 sub {</code>
<code>        /i exch def</code>
<code>        i rrows 2 add mod 0 eq { pixs i cols mul [ cols 2 idiv {1 0} repeat ] putinterval } if</code>
<code>        i rrows 2 add mod rrows 1 add eq { pixs i cols mul [ cols {1} repeat ] putinterval } if</code>
<code>        i rrows 2 add mod 0 ne i rrows 2 add mod rrows 1 add ne and {</code>
<code>            0 1 cols 1 sub {</code>
<code>                /j exch def</code>
<code>                j rcols 2 add mod 0 eq { pixs i cols mul j add 1 put } if</code>
<code>                j rcols 2 add mod rcols 1 add eq { pixs i cols mul j add i 2 mod put } if</code>
<code>                j rcols 2 add mod 0 ne j rcols 2 add mod rcols 1 add ne and {</code>
<code>                    pixs i cols mul j add mmat cwpos get put</code>
<code>                    /cwpos cwpos 1 add def</code>
<code>                } if</code>
<code>            } for</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renmatrix</code>
<code>    /pixs pixs</code>
<code>    /pixx cols</code>
<code>    /pixy rows</code>
<code>    /height rows 2 mul 72 div</code>
<code>    /width cols 2 mul 72 div</code>
<code>    /borderleft 1.0</code>
<code>    /borderright 1.0</code>
<code>    /bordertop 1.0</code>
<code>    /borderbottom 1.0</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /datamatrix dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER datamatrix--</code>
<code></code>
<code>% --BEGIN ENCODER datamatrixrectangular--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix datamatrix--</code>
<code>% --DESC: Data Matrix Rectangular</code>
<code>% --EXAM: 1234</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp datamatrixrectangular 0.0 2024010300 63145 63104</code>
<code>%%BeginData:         36 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /datamatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/datamatrixrectangular {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Get the result of encoding with datamatrix with format=rectangle</code>
<code>    options (dontdraw) true put</code>
<code>    options (format) (rectangle) put</code>
<code></code>
<code>    /args barcode options //datamatrix exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /datamatrixrectangular dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER datamatrixrectangular--</code>
<code></code>
<code>% --BEGIN ENCODER datamatrixrectangularextension--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix datamatrix--</code>
<code>% --DESC: Data Matrix Rectangular Extension</code>
<code>% --EXAM: 1234</code>
<code>% --EXOP: version=8x96</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp datamatrixrectangularextension 0.0 2024010300 63554 63504</code>
<code>%%BeginData:         36 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 20 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /datamatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/datamatrixrectangularextension {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Get the result of encoding with datamatrix</code>
<code>    options (dontdraw) true put</code>
<code>    options (dmre) true put</code>
<code></code>
<code>    /args barcode options //datamatrix exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /datamatrixrectangularextension dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER datamatrixrectangularextension--</code>
<code></code>
<code>% --BEGIN ENCODER mailmark--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix datamatrix--</code>
<code>% --DESC: Royal Mail Mailmark</code>
<code>% --EXAM: JGB 012100123412345678AB19XY1A 0             www.xyz.com</code>
<code>% --EXOP: type=29</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp mailmark 0.0 2024010300 67768 67632</code>
<code>%%BeginData:         74 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /datamatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/mailmark {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /type (unset) def  % 7, 9 or 29</code>
<code>    /parse false def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Parse ordinals of the form ^NNN to ASCII</code>
<code>    /fncvals &lt;&lt;</code>
<code>        /parse parse</code>
<code>        /parseonly true</code>
<code>        /parsefnc false</code>
<code>    &gt;&gt; def</code>
<code>    /barcode barcode fncvals //parseinput exec def</code>
<code>    /barlen barcode length def</code>
<code>    options (parse) undef</code>
<code></code>
<code>    % Map the given type to a format and version of Data Matrix</code>
<code>    /type load dup (7) ne exch dup (9) ne exch (29) ne and and {</code>
<code>        /bwipp.mailmarkBadType (Royal Mail Mailmark type must be 7, 9 or 29) //raiseerror exec</code>
<code>    } if</code>
<code>    &lt;&lt;</code>
<code>        (7)  (24x24)</code>
<code>        (9)  (32x32)</code>
<code>        (29) (16x48)</code>
<code>    &gt;&gt; /type load get /version exch def</code>
<code></code>
<code>    &lt;&lt;</code>
<code>        (7)  (square)</code>
<code>        (9)  (square)</code>
<code>        (29) (rectangle)</code>
<code>    &gt;&gt; /type load get /format exch def</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode length 45 lt {</code>
<code>        /bwipp.mailmarkBadLength (Royal Mail Mailmark must contain at least 45 characters of Mailmark formatted data, including any required space padding) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode 0 4 getinterval (JGB ) ne {</code>
<code>        /bwipp.mailmarkBadIndicator (Royal Mail Mailmark must begin with JGB&lt;space&gt; identifier) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Get the result of encoding with datamatrix</code>
<code>    options (dontdraw) true put</code>
<code>    options (version) version put</code>
<code>    options (format) format put</code>
<code>    options (c40headerlength) 45 put</code>
<code>    /args barcode options //datamatrix exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /mailmark dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER mailmark--</code>
<code></code>
<code>% --BEGIN ENCODER qrcode--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix--</code>
<code>% --DESC: QR Code</code>
<code>% --EXAM: http://goo.gl/0bis</code>
<code>% --EXOP: eclevel=M</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp qrcode 0.0 2024010300 340361 387555</code>
<code>%%BeginData:       1399 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/qrcode {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /format (unset) def    % full or micro. rMQR symbols are specified using version</code>
<code>    /version (unset) def   % 1-40 or M1-M4 or R7x43, etc</code>
<code>    /eclevel (unset) def   % full: L, M, Q, H; micro: L, M, Q; rmqr: M, H</code>
<code>    /parse false def</code>
<code>    /parsefnc false def</code>
<code>    /mask -1 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /qrcode //loadctx exec</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.qrcodeEmptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % If version is supplied and format is not given then set format to correspond</code>
<code>    version (unset) ne {</code>
<code>        format (unset) eq {</code>
<code>            (full)</code>
<code>            version 0 1 getinterval (M) eq { pop (micro) } if</code>
<code>            version 0 1 getinterval (R) eq { pop (rmqr) } if</code>
<code>            /format exch def</code>
<code>        } if</code>
<code>    } {</code>
<code>        format (unset) eq { /format (full) def } if  % Default to full</code>
<code>    } ifelse</code>
<code></code>
<code>    format (full) ne format (micro) ne format (rmqr) ne and and {</code>
<code>        /bwipp.qrcodeInvalidFormat (The format must be either full, micro or rmqr) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    format (rmqr) eq version (unset) eq and {</code>
<code>        /bwipp.qrcodeRMQRwithoutVersion (A version must be provided for RMQR) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Default error correction level</code>
<code>    eclevel (unset) eq {/eclevel format (micro) ne {(M)} {(L)} ifelse def} if</code>
<code></code>
<code>    eclevel (L) ne eclevel (M) ne eclevel (Q) ne eclevel (H) ne and and and {</code>
<code>        /bwipp.qrcodeInvalidEClevel (Error correction level must be either L, M, Q, or H) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    mask -1 ne format (rmqr) eq and {</code>
<code>        /bwipp.qrcodeRMQRmask (A mask cannot be supplied for RMQR) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    mask -1 ne {</code>
<code>        mask 1 lt mask format (full) eq {8} {4} ifelse gt or {</code>
<code>            /bwipp.qrcodeBadMask (An invalid mask was supplied) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    % Parse the input</code>
<code>    /fn1 -1 def</code>
<code>    /fncvals &lt;&lt;</code>
<code>        /parse parse</code>
<code>        /parsefnc parsefnc</code>
<code>        /eci true</code>
<code>        (FNC1) fn1</code>
<code>    &gt;&gt; def</code>
<code>    /msg barcode fncvals //parseinput exec def</code>
<code>    /msglen msg length def</code>
<code></code>
<code>    % If FNC1 in first position then escape % as %%</code>
<code>    /fnc1first false def</code>
<code>    msglen 0 gt {</code>
<code>        msg 0 get fn1 eq {</code>
<code>            /fnc1first true def</code>
<code>            /msg [ msg 1 msglen 1 sub getinterval { dup 37 eq {dup} if } forall ] def</code>
<code>            /msglen msg length def</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>{  % context</code>
<code></code>
<code>    % Enumerate vergrps</code>
<code>    [</code>
<code>        /v1to9    /v10to26  /v27to40</code>
<code>        /vM1      /vM2      /vM3      /vM4</code>
<code>        /vR7x43   /vR7x59   /vR7x77   /vR7x99   /vR7x139</code>
<code>        /vR9x43   /vR9x59   /vR9x77   /vR9x99   /vR9x139</code>
<code>        /vR11x27  /vR11x43  /vR11x59  /vR11x77  /vR11x99   /vR11x139</code>
<code>        /vR13x27  /vR13x43  /vR13x59  /vR13x77  /vR13x99   /vR13x139</code>
<code>        /vR15x43  /vR15x59  /vR15x77  /vR15x99  /vR15x139</code>
<code>        /vR17x43  /vR17x59  /vR17x77  /vR17x99  /vR17x139</code>
<code>    ] 0 exch {1 index def 1 add} forall pop</code>
<code></code>
<code>    % Convert from input into message bitstream</code>
<code>    %</code>
<code>    % Modes: (N)umeric, (A)lphanumeric, (B)yte, (K)anji, (E)CI</code>
<code>    %</code>
<code>    /N 0 def  /A 1 def  /B 2 def  /K 3 def  /E 4 def</code>
<code></code>
<code>    /Nexcl &lt;&lt;</code>
<code>       [</code>
<code>           16#30 1 16#39 {} for</code>
<code>       ] {-1} forall</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /Aexcl &lt;&lt;</code>
<code>        [</code>
<code>            16#20 16#24 16#25 16#2A 16#2B 16#2D 16#2E 16#2F 16#3A</code>
<code>            16#41 1 16#5A {} for</code>
<code>            fn1</code>
<code>        ] {-1} forall</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    % Binary exclusives calculated from "not others"</code>
<code></code>
<code>    /Kexcl &lt;&lt;</code>
<code>        [</code>
<code>            16#81 1 16#9F {} for</code>
<code>            16#E0 1 16#EB {} for</code>
<code>        ] {-1} forall</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /mids [</code>
<code>        %    N      A      B      K      E</code>
<code>        [ (0001) (0010) (0100) (1000) (0111) ]  % v1to9</code>
<code>        [ (0001) (0010) (0100) (1000) (0111) ]  % v10to26</code>
<code>        [ (0001) (0010) (0100) (1000) (0111) ]  % v27to40</code>
<code>        [     ()   -1     -1     -1     -1   ]  % vM1</code>
<code>        [    (0)    (1)   -1     -1     -1   ]  % vM2</code>
<code>        [   (00)   (01)   (10)   (11)   -1   ]  % vM3</code>
<code>        [  (000)  (001)  (010)  (011)   -1   ]  % vM4</code>
<code>      32 {</code>
<code>        [  (001)  (010)  (011)  (100)  (111) ]  % rMQR</code>
<code>      } repeat</code>
<code>    ] def</code>
<code></code>
<code>    /cclens [  % N  A  B  K</code>
<code>        [ 10  9  8  8 ]  % v1to9</code>
<code>        [ 12 11 16 10 ]  % v10to26</code>
<code>        [ 14 13 16 12 ]  % v27to40</code>
<code>        [  3 -1 -1 -1 ]  % vM1</code>
<code>        [  4  3 -1 -1 ]  % vM2</code>
<code>        [  5  4  4  3 ]  % vM3</code>
<code>        [  6  5  5  4 ]  % vM4</code>
<code>        [  4  3  3  2 ]  % vR7x43</code>
<code>        [  5  5  4  3 ]  % vR7x59</code>
<code>        [  6  5  5  4 ]  % vR7x77</code>
<code>        [  7  6  5  5 ]  % vR7x99</code>
<code>        [  7  6  6  5 ]  % vR7x139</code>
<code>        [  5  5  4  3 ]  % vR9x43</code>
<code>        [  6  5  5  4 ]  % vR9x59</code>
<code>        [  7  6  5  5 ]  % vR9x77</code>
<code>        [  7  6  6  5 ]  % vR9x99</code>
<code>        [  8  7  6  6 ]  % vR9x139</code>
<code>        [  4  4  3  2 ]  % vR11x27</code>
<code>        [  6  5  5  4 ]  % vR11x43</code>
<code>        [  7  6  5  5 ]  % vR11x59</code>
<code>        [  7  6  6  5 ]  % vR11x77</code>
<code>        [  8  7  6  6 ]  % vR11x99</code>
<code>        [  8  7  7  6 ]  % vR11x139</code>
<code>        [  5  5  4  3 ]  % vR13x27</code>
<code>        [  6  6  5  5 ]  % vR13x43</code>
<code>        [  7  6  6  5 ]  % vR13x59</code>
<code>        [  7  7  6  6 ]  % vR13x77</code>
<code>        [  8  7  7  6 ]  % vR13x99</code>
<code>        [  8  8  7  7 ]  % vR13x139</code>
<code>        [  7  6  6  5 ]  % vR15x43</code>
<code>        [  7  7  6  5 ]  % vR15x59</code>
<code>        [  8  7  7  6 ]  % vR15x77</code>
<code>        [  8  7  7  6 ]  % vR15x99</code>
<code>        [  9  8  7  7 ]  % vR15x139</code>
<code>        [  7  6  6  5 ]  % vR17x43</code>
<code>        [  8  7  6  6 ]  % vR17x59</code>
<code>        [  8  7  7  6 ]  % vR17x77</code>
<code>        [  8  8  7  6 ]  % vR17x99</code>
<code>        [  9  8  8  7 ]  % vR17x139</code>
<code>    ] def</code>
<code></code>
<code>    /termlens [</code>
<code>      3 {</code>
<code>        4  % Full</code>
<code>      } repeat</code>
<code>        3  % vM1</code>
<code>        5  % vM2</code>
<code>        7  % vM3</code>
<code>        9  % vM4</code>
<code>      32 {</code>
<code>        3  % rMQR</code>
<code>      } repeat</code>
<code>    ] def</code>
<code></code>
<code>    /padstrs [ (11101100) (00010001) ] def</code>
<code></code>
<code>    % Alphanumeric character to value map</code>
<code>    /charmap (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:) def</code>
<code>    /charvals 44 dict def</code>
<code>    0 1 44 {dup charmap exch get exch charvals 3 1 roll put} for</code>
<code></code>
<code>} ctxdef</code>
<code></code>
<code>    % Encoding functions</code>
<code>    /tobin {</code>
<code>        string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for</code>
<code>        dup 3 -1 roll 2 2 index length string cvrs dup length 2 index length exch sub exch putinterval</code>
<code>    } def</code>
<code></code>
<code>    /encA {</code>
<code>        /in exch def</code>
<code>        fnc1first {  % FNC1 as %</code>
<code>            /in [ in { dup fn1 eq {pop 37} if } forall ] def</code>
<code>        } if</code>
<code>        /out in length 11 mul 2 idiv 1 add string def</code>
<code>        /k 0 def /m 0 def {</code>
<code>            k in length eq {exit} if</code>
<code>            k in length 1 sub lt {</code>
<code>                charvals in k get get 45 mul charvals in k 1 add get get add 11 tobin</code>
<code>                /k k 2 add def</code>
<code>            } {  % Final character</code>
<code>                charvals in k get get 6 tobin</code>
<code>                /k k 1 add def</code>
<code>            } ifelse</code>
<code>            dup out exch m exch putinterval</code>
<code>            length m add /m exch def</code>
<code>        } loop</code>
<code>        out 0 m getinterval</code>
<code>    } def</code>
<code></code>
<code>    /encN {</code>
<code>        /in exch def</code>
<code>        /out in length 10 mul 3 idiv 1 add string def</code>
<code>        /k 0 def /m 0 def {</code>
<code>            k in length eq {exit} if</code>
<code>            k in length 2 sub lt {</code>
<code>                in k 3 getinterval 0 exch {exch 10 mul 48 sub add} forall 10 tobin</code>
<code>                /k k 3 add def</code>
<code>            } {</code>
<code>                k in length 2 sub eq {  % Two final digits</code>
<code>                    in k 2 getinterval 0 exch {exch 10 mul 48 sub add} forall 7 tobin</code>
<code>                    /k k 2 add def</code>
<code>                } {  % One final digit</code>
<code>                    in k 1 getinterval 0 exch {exch 10 mul 48 sub add} forall 4 tobin</code>
<code>                    /k k 1 add def</code>
<code>                } ifelse</code>
<code>            } ifelse</code>
<code>            dup out exch m exch putinterval</code>
<code>            length m add /m exch def</code>
<code>        } loop</code>
<code>        out 0 m getinterval</code>
<code>    } def</code>
<code></code>
<code>    /encB {</code>
<code>        /in exch def</code>
<code>        fnc1first {  % FNC1 as GS</code>
<code>            /in [ in { dup fn1 eq {pop 29} if } forall ] def</code>
<code>        } if</code>
<code>        /out in length 8 mul string def</code>
<code>        0 1 in length 1 sub {</code>
<code>            /k exch def</code>
<code>            in k get cvi 8 tobin</code>
<code>            out k 8 mul 3 -1 roll putinterval</code>
<code>        } for</code>
<code>        out</code>
<code>    } def</code>
<code></code>
<code>    /encK {</code>
<code>        /in exch def</code>
<code>        /out in length 2 idiv 13 mul string def</code>
<code>        /k 0 def /m 0 def {</code>
<code>            k in length eq {exit} if</code>
<code>            in k get 256 mul in k 1 add get add</code>
<code>            dup 16#E040 lt {16#8140} {16#C140} ifelse sub</code>
<code>            dup -8 bitshift 16#C0 mul exch 16#00FF and add</code>
<code>            13 tobin dup out exch m exch putinterval</code>
<code>            length m add /m exch def</code>
<code>            /k k 2 add def</code>
<code>        } loop</code>
<code>        out</code>
<code>    } def</code>
<code></code>
<code>    /encE {</code>
<code>        0 get neg 1000000 sub</code>
<code>            dup 000127 le {  % ECI 000000 - 000127</code>
<code>            8 tobin</code>
<code>        } { dup 016383 le {  % ECI 000128 - 016383</code>
<code>                2#1000000000000000 add 16 tobin</code>
<code>        } {                  % ECI 016384 - 999999</code>
<code>                2#110000000000000000000000 add 24 tobin</code>
<code>        } ifelse } ifelse</code>
<code>    } def</code>
<code></code>
<code>    /encfuncs [ /encN /encA /encB /encK /encE ] def</code>
<code></code>
<code>    /addtobits {</code>
<code>        dup bits j 3 -1 roll putinterval</code>
<code>        length j add /j exch def</code>
<code>    } def</code>
<code></code>
<code>    /numNs [ msglen {0} repeat 0 ] def</code>
<code>    /numAs [ msglen {0} repeat 0 ] def</code>
<code>    /numAorNs [ msglen {0} repeat 0 ] def</code>
<code>    /numBs [ msglen {0} repeat 0 ] def</code>
<code>    /numKs [ msglen {0} repeat 0 ] def</code>
<code>    /nextNs [ msglen {0} repeat 9999 ] def</code>
<code>    /nextBs [ msglen {0} repeat 9999 ] def</code>
<code>    /nextAs [ msglen {0} repeat 9999 ] def</code>
<code>    /nextKs [ msglen {0} repeat 9999 ] def</code>
<code>    /isECI msglen array def</code>
<code>    msglen 1 sub -1 0 {</code>
<code>        /i exch def</code>
<code>        /barchar msg i get def</code>
<code>        Kexcl barchar known {</code>
<code>            /sjis i 1 add msglen lt { barchar 256 mul msg i 1 add get add } {0} ifelse def  % Zero if last char</code>
<code>            sjis 16#8140 ge sjis 16#9FFC le and sjis 16#E040 ge sjis 16#EBBF le and or {</code>
<code>                nextKs i 0 put</code>
<code>                numKs i numKs i 2 add get 1 add put</code>
<code>            } {</code>
<code>                nextKs i nextKs i 1 add get 1 add put</code>
<code>            } ifelse</code>
<code>        } {</code>
<code>            nextKs i nextKs i 1 add get 1 add put</code>
<code>        } ifelse</code>
<code>        Nexcl barchar known {</code>
<code>            nextNs i 0 put</code>
<code>            numNs i numNs i 1 add get 1 add put</code>
<code>            numAorNs i numAorNs i 1 add get 1 add put</code>
<code>        } {</code>
<code>            nextNs i nextNs i 1 add get 1 add put</code>
<code>        } ifelse</code>
<code>        Aexcl barchar known {</code>
<code>            nextAs i 0 put</code>
<code>            numAs i numAs i 1 add get 1 add put</code>
<code>            numAorNs i numAorNs i 1 add get 1 add put</code>
<code>        } {</code>
<code>            nextAs i nextAs i 1 add get 1 add put</code>
<code>        } ifelse</code>
<code>        isECI i barchar -1000000 le put</code>
<code>    } for</code>
<code>    0 1 msglen 1 sub {  % Scan forward to set any "2nd byte 1st byte" Kanji matches to zero</code>
<code>        /i exch def</code>
<code>        numKs i get 0 gt {</code>
<code>            numKs i 1 add 0 put</code>
<code>            nextKs i 1 add nextKs i 1 add get 1 add put</code>
<code>        } if</code>
<code>    } for</code>
<code>    msglen 1 sub -1 0 {  % Finally scan backwards again to set numBs/nextBs from "not others"</code>
<code>        /i exch def</code>
<code>        numNs i get numAs i get numKs i get add add 0 eq isECI i get not and {</code>
<code>            nextBs i 0 put</code>
<code>            numBs i numBs i 1 add get 1 add put</code>
<code>        } {</code>
<code>            nextBs i nextBs i 1 add get 1 add put</code>
<code>        } ifelse</code>
<code>    } for</code>
<code></code>
<code>    /KbeforeB {numK exch ver get ge nextBs numK 2 mul i add get 0 eq and} def</code>
<code>    /KbeforeA {numK exch ver get ge nextAs numK 2 mul i add get 0 eq and} def</code>
<code>    /KbeforeN {numK exch ver get ge nextNs numK 2 mul i add get 0 eq and} def</code>
<code>    /KbeforeE {numK exch ver get ge numK 2 mul i add msglen eq and} def</code>
<code>    /AbeforeK {numA exch ver get ge nextKs numA i add get 0 eq and} def</code>
<code>    /AbeforeB {numA exch ver get ge nextBs numA i add get 0 eq and} def</code>
<code>    /AbeforeN {numA exch ver get ge nextNs numA i add get 0 eq and} def</code>
<code>    /AbeforeE {numA exch ver get ge numA i add msglen eq and} def</code>
<code>    /NbeforeK {numN exch ver get ge nextKs numN i add get 0 eq and} def</code>
<code>    /NbeforeB {numN exch ver get ge nextBs numN i add get 0 eq and} def</code>
<code>    /NbeforeA {numN exch ver get ge nextAs numN i add get 0 eq and} def</code>
<code>    /NbeforeE {numN exch ver get ge numN i add msglen eq and} def</code>
<code>    /AorNbeforeB {numAorN exch ver get ge nextBs numAorN i add get 0 eq and} def</code>
<code>    /AorNbeforeE {numAorN exch ver get ge numAorN i add msglen eq and} def</code>
<code></code>
<code>    /nextNslt { nextNs i get msglen ge { pop true } { numNs nextNs i get i add get exch ver get lt } ifelse } def</code>
<code></code>
<code>    % Elements of the encoded message have differing lengths based on the</code>
<code>    % resulting symbol size. The symbol sizes with different element lengths</code>
<code>    % are batched into vergrps. To pick the smallest symbol that holds our</code>
<code>    % content we encode the message according to each available vergrp, based</code>
<code>    % on the format of symbol.</code>
<code></code>
<code>    % Determine which groups we need to encode</code>
<code>{</code>
<code>    /versetmap &lt;&lt;</code>
<code>        (full) &lt;&lt;</code>
<code>             0 1  9 { 10 2 string cvrs v1to9   } for</code>
<code>            10 1 26 { 10 2 string cvrs v10to26 } for</code>
<code>            27 1 40 { 10 2 string cvrs v27to40 } for</code>
<code>        &gt;&gt;</code>
<code>        (micro) &lt;&lt;</code>
<code>            (M1) vM1  (M2) vM2  (M3) vM3  (M4) vM4</code>
<code>        &gt;&gt;</code>
<code>        (rmqr) &lt;&lt;</code>
<code>                              (R7x43)  vR7x43   (R7x59)  vR7x59   (R7x77)  vR7x77   (R7x99)  vR7x99   (R7x139)  vR7x139</code>
<code>                              (R9x43)  vR9x43   (R9x59)  vR9x59   (R9x77)  vR9x77   (R9x99)  vR9x99   (R9x139)  vR9x139</code>
<code>            (R11x27) vR11x27  (R11x43) vR11x43  (R11x59) vR11x59  (R11x77) vR11x77  (R11x99) vR11x99  (R11x139) vR11x139</code>
<code>            (R13x27) vR13x27  (R13x43) vR13x43  (R13x59) vR13x59  (R13x77) vR13x77  (R13x99) vR13x99  (R13x139) vR13x139</code>
<code>                              (R15x43) vR15x43  (R15x59) vR15x59  (R15x77) vR15x77  (R15x99) vR15x99  (R15x139) vR15x139</code>
<code>                              (R17x43) vR17x43  (R17x59) vR17x59  (R17x77) vR17x77  (R17x99) vR17x99  (R17x139) vR17x139</code>
<code>        &gt;&gt;</code>
<code>    &gt;&gt; def</code>
<code>    /versetfull  [v1to9 v10to26 v27to40] def</code>
<code>    /versetmicro [vM1 vM2 vM3 vM4] def</code>
<code>} ctxdef</code>
<code>    version (unset) ne {</code>
<code>        % A specific version of symbol is given so encode in just the corresponding vergrp</code>
<code>        versetmap format get version 2 copy known not {</code>
<code>            pop pop</code>
<code>            format (full) eq {</code>
<code>                /bwipp.qrcodeInvalidFullVersion (Valid versions for QR Code symbols are 1 to 40) //raiseerror exec</code>
<code>            } {</code>
<code>            format (micro) eq {</code>
<code>                /bwipp.qrcodeInvalidMicroVersion (Valid versions for Micro QR Code symbols are M1 to M4) //raiseerror exec</code>
<code>            } {  % rmqr</code>
<code>                /bwipp.qrcodeInvalidRMQRversion (Invalid version for an RMQR symbol) //raiseerror exec</code>
<code>            } ifelse } ifelse</code>
<code>        } if</code>
<code>        get [ exch ] /verset exch def</code>
<code>    } {</code>
<code>        % Just the format is specified so encode in each vergrp for the type of symbol</code>
<code>        format (full)  eq { /verset versetfull  def } if</code>
<code>        format (micro) eq { /verset versetmicro def } if</code>
<code>        % rMQR symbols are accessed with an explicit version</code>
<code>    } ifelse</code>
<code></code>
<code>    % Encode unterminated bitstream for each compatible vergrp separately</code>
<code>    /msgbits [ 39 {-1} repeat ] def</code>
<code>    /e 10000 def</code>
<code></code>
<code>    % Number of before characters per vergrp, depending on current mode, for optimising modes</code>
<code>    % Generated by contrib/development/build-qr-mode-optim-arrs.php</code>
<code>    %                Full     Micro    R7         R9           R11             R13              R15             R17</code>
<code>{</code>
<code>    /mode0forceKB  [ 1  1  1  e e 1 1  1 1 1 1 1  1 1 1 1  1   1 1 1 1  1  1   1 1 1  1  1  1   1  1  1  1  1   1  1  1  1  1] def</code>
<code>    /mode0forceA   [ 1  1  1  e 1 1 1  1 1 1 1 1  1 1 1 1  1   1 1 1 1  1  1   1 1 1  1  1  1   1  1  1  1  1   1  1  1  1  1] def</code>
<code>    /mode0forceN   [ 1  1  1  1 1 1 1  1 1 1 1 1  1 1 1 1  1   1 1 1 1  1  1   1 1 1  1  1  1   1  1  1  1  1   1  1  1  1  1] def</code>
<code></code>
<code>    /mode0NbeforeB [ 4  4  5  e e 2 3  2 2 3 3 3  2 3 3 3  3   2 3 3 3  3  3   2 3 3  3  3  3   3  3  3  3  3   3  3  3  3  3] def</code>
<code></code>
<code>    /modeBKbeforeB [ 9 12 13  e e 4 6  4 5 6 6 6  5 6 6 6  7   4 6 6 6  7  7   5 6 6  7  7  7   6  6  7  7  7   6  7  7  7  8] def</code>
<code>    /modeBKbeforeA [ 8 10 11  e e 4 5  4 5 5 6 6  5 5 6 6  6   4 5 6 6  6  6   5 6 6  6  6  7   6  6  6  6  7   6  6  6  7  7] def</code>
<code>    /modeBKbeforeN [ 8  9 11  e e 3 5  3 4 5 5 5  4 5 5 5  6   3 5 5 5  6  6   4 5 5  6  6  6   5  5  6  6  7   5  6  6  6  7] def</code>
<code>    /modeBKbeforeE [ 5  5  6  e e 2 3  2 3 3 3 3  3 3 3 3  4   2 3 3 3  4  4   3 3 3  4  4  4   3  3  4  4  4   3  4  4  4  4] def</code>
<code></code>
<code>    /modeBAbeforeK [11 12 14  e e 5 7  5 6 7 8 8  6 7 8 8  8   6 7 8 8  8  8   6 8 8  8  8  9   8  8  8  8  9   8  8  8  9  9] def</code>
<code>    /modeBAbeforeB [11 15 16  e e 6 7  6 7 7 8 8  7 7 8 8  8   6 7 8 8  8  9   7 8 8  8  9  9   8  8  9  9  9   8  8  9  9 10] def</code>
<code>    /modeBAbeforeN [12 13 15  e e 6 8  6 7 8 8 8  7 8 8 8  9   6 8 8 8  9  9   7 8 8  9  9 10   8  9  9  9 10   8  9  9 10 10] def</code>
<code>    /modeBAbeforeE [ 6  7  8  e e 3 4  3 4 4 4 4  4 4 4 4  5   4 4 4 4  5  5   4 4 4  5  5  5   4  5  5  5  5   4  5  5  5  5] def</code>
<code></code>
<code>    /modeBNbeforeK [ 6  7  8  e e 3 4  3 4 4 5 5  4 4 5 5  5   3 4 5 5  5  5   4 4 5  5  5  5   5  5  5  5  5   5  5  5  5  5] def</code>
<code>    /modeBNbeforeB [ 6  8  9  e e 3 4  3 4 4 5 5  4 4 5 5  5   3 4 5 5  5  5   4 4 5  5  5  5   5  5  5  5  5   5  5  5  5  6] def</code>
<code>    /modeBNbeforeA [ 6  7  8  e e 3 4  3 4 4 5 5  4 4 5 5  5   4 4 5 5  5  5   4 5 5  5  5  5   5  5  5  5  6   5  5  5  5  6] def</code>
<code>    /modeBNbeforeE [ 3  4  4  e e 2 3  2 2 3 3 3  2 3 3 3  3   2 3 3 3  3  3   2 3 3  3  3  3   3  3  3  3  3   3  3  3  3  3] def</code>
<code></code>
<code>    /modeANbeforeA [13 15 17  e 5 7 9  7 8 9 9 9  8 9 9 9 11   7 9 9 9 11 11   8 9 9 10 11 11   9 10 11 11 11   9 11 11 11 11] def</code>
<code>    /modeANbeforeB [13 17 18  e e 7 9  7 8 9 9 9  8 9 9 9 10   7 9 9 9 10 11   8 9 9  9 11 11   9  9 11 11 11   9 10 11 11 11] def</code>
<code>    /modeANbeforeE [ 7  8  9  e 3 4 5  4 5 5 5 5  5 5 5 5  6   4 5 5 5  6  6   5 5 5  5  6  6   5  5  6  6  6   5  6  6  6  6] def</code>
<code>} ctxdef</code>
<code></code>
<code>    verset {</code>
<code>        /ver exch def</code>
<code></code>
<code>        % Derive optimal sequence</code>
<code>        /mode -1 def /seq [] def /i 0 def {</code>
<code>            i msglen ge {exit} if</code>
<code>            /numK numKs i get def</code>
<code>            /numB numBs i get def</code>
<code>            /numA numAs i get def</code>
<code>            /numN numNs i get def</code>
<code>            /numAorN numAorNs i get def</code>
<code>            /eci isECI i get def</code>
<code>            ver vM1 eq numA 1 ge and {/seq -1 def exit} if</code>
<code>            ver vM1 eq numB 1 ge and {/seq -1 def exit} if</code>
<code>            ver vM1 eq numK 1 ge and {/seq -1 def exit} if</code>
<code>            ver vM1 eq eci and       {/seq -1 def exit} if</code>
<code>            ver vM2 eq numB 1 ge and {/seq -1 def exit} if</code>
<code>            ver vM2 eq numK 1 ge and {/seq -1 def exit} if</code>
<code>            ver vM2 eq eci and       {/seq -1 def exit} if</code>
<code>            ver vM3 eq eci and       {/seq -1 def exit} if</code>
<code>            ver vM4 eq eci and       {/seq -1 def exit} if</code>
<code>            {  % common exit</code>
<code>                eci {</code>
<code>                    E exit</code>
<code>                } if</code>
<code>                mode -1 eq {  % Set initial mode (or mode after ECI)</code>
<code>                    mode0forceKB  KbeforeA {K exit} if</code>
<code>                    mode0forceKB  KbeforeN {K exit} if</code>
<code>                    modeBKbeforeE KbeforeB {K exit} if  % Re-using modeB KbeforeE array</code>
<code>                    mode0forceKB  KbeforeE {K exit} if</code>
<code>                    numK 1 ge {B exit} if</code>
<code>                    mode0NbeforeB NbeforeB {N exit} if</code>
<code>                    mode0forceKB  NbeforeB {B exit} if</code>
<code>                    modeANbeforeE NbeforeA {N exit} if  % Re-using modeA NbeforeE array</code>
<code>                    mode0forceN   NbeforeE {N exit} if</code>
<code>                    modeBAbeforeE AbeforeK {A exit} if  % Re-using modeB AbeforeE array</code>
<code>                    modeBAbeforeE AorNbeforeB {A exit} if  % Re-using modeB AbeforeE array</code>
<code>                    mode0forceA   AorNbeforeE {A exit} if</code>
<code>                    B exit</code>
<code>                } if</code>
<code>                mode B eq {</code>
<code>                    modeBKbeforeB KbeforeB {K exit} if</code>
<code>                    modeBKbeforeA KbeforeA {K exit} if</code>
<code>                    modeBKbeforeN KbeforeN {K exit} if</code>
<code>                    modeBKbeforeE KbeforeE {K exit} if</code>
<code>                    modeBAbeforeK AbeforeK {A exit} if</code>
<code>                    modeBAbeforeB AbeforeB {A exit} if</code>
<code>                    modeBAbeforeN AbeforeN {A exit} if</code>
<code>                    modeBAbeforeE AbeforeE {A exit} if</code>
<code>                    modeBNbeforeK NbeforeK {N exit} if</code>
<code>                    modeBNbeforeB NbeforeB {N exit} if</code>
<code>                    modeBNbeforeA NbeforeA {N exit} if</code>
<code>                    modeBNbeforeE NbeforeE {N exit} if</code>
<code>                    modeBAbeforeE AorNbeforeE numAorN modeBAbeforeN ver get le and {  % If A/N sequence at end and short</code>
<code>                        modeBNbeforeA nextNslt {A exit} if  % And next N sequence shorter than NbeforeA</code>
<code>                    } if</code>
<code>                    B exit</code>
<code>                } if</code>
<code>                mode A eq {</code>
<code>                    numK 1 ge {K exit} if</code>
<code>                    numB 1 ge {B exit} if</code>
<code>                    modeANbeforeA NbeforeA {N exit} if</code>
<code>                    modeANbeforeB NbeforeB {N exit} if</code>
<code>                    modeANbeforeE NbeforeE {N exit} if</code>
<code>                    numA 1 ge numN 1 ge or {A exit} if</code>
<code>                    B exit</code>
<code>                } if</code>
<code>                mode N eq {</code>
<code>                    numK 1 ge {K exit} if</code>
<code>                    numB 1 ge {B exit} if</code>
<code>                    numA 1 ge {A exit} if</code>
<code>                    numN 1 ge {N exit} if</code>
<code>                    B exit</code>
<code>                } if</code>
<code>                mode K eq {</code>
<code>                    numB 1 ge {B exit} if</code>
<code>                    numA 1 ge {A exit} if</code>
<code>                    numN 1 ge {N exit} if</code>
<code>                    numK 1 ge {K exit} if</code>
<code>                    B exit</code>
<code>                } if</code>
<code>            } loop</code>
<code>            dup K eq fnc1first and {pop B} if  % No kanji with fnc1first</code>
<code>            dup mode eq {  % Same mode encode directly</code>
<code>                pop</code>
<code>                /dat msg i mode K eq {2} {1} ifelse getinterval def</code>
<code>                /seq [</code>
<code>                    seq aload pop</code>
<code>                    [ exch aload pop dat aload pop ]</code>
<code>                ] def</code>
<code>            } {  % Change mode</code>
<code>                /mode exch def</code>
<code>                mode K eq {K msg i numK 2 mul getinterval} if</code>
<code>                mode B eq {B msg i numB getinterval} if</code>
<code>                mode A eq {A msg i numA getinterval} if</code>
<code>                mode N eq {N msg i numN getinterval} if</code>
<code>                mode E eq {E msg i 1 getinterval  /mode -1 def} if</code>
<code>                /dat exch def /sw exch def</code>
<code>                /seq [ seq aload pop sw dat ] def</code>
<code>            } ifelse</code>
<code>            /i i dat length add def</code>
<code>        } loop</code>
<code></code>
<code>        % Encode the sequence</code>
<code>        {  % common exit</code>
<code>            seq -1 eq {exit} if  % Sequence not available</code>
<code>            /bits 23648 string def</code>
<code>            /j 0 def</code>
<code>            fnc1first {</code>
<code>                ver vR7x43 lt { (0101) } { (101) } ifelse addtobits</code>
<code>            } if</code>
<code>            /abort false def</code>
<code>            0 2 seq length 1 sub {</code>
<code>                /i exch def</code>
<code>                /mode seq i get def</code>
<code>                mids ver get mode get addtobits</code>
<code>                /chars seq i 1 add get def</code>
<code>                /charslen chars length mode K eq {2 idiv} if def</code>
<code>                mode E ne {</code>
<code>                    /cclen cclens ver get mode get def</code>
<code>                    charslen 2 cclen exp cvi ge {  % Too many characters for cc indicator</code>
<code>                        /abort true def exit</code>
<code>                    } if</code>
<code>                    charslen cclen tobin addtobits</code>
<code>                } if</code>
<code>                chars encfuncs mode get load exec addtobits</code>
<code>            } for</code>
<code>            abort {exit} if</code>
<code>            /bits bits 0 j getinterval def</code>
<code>            msgbits ver bits put</code>
<code>            exit</code>
<code>        } loop</code>
<code>    } forall</code>
<code></code>
<code>    % Lookup the most appropriate symbol specification</code>
<code>{</code>
<code>    /metrics [</code>
<code>        % format   vers       vergrp  rows cols align modules    error codewords        error correction blocks</code>
<code>        %                                                        L    M    Q    H       L1 L2 M1 M2 Q1 Q2 H1 H2</code>
<code>        [ (micro)  (M1)       vM1       11  11  98 99     36  [   2   99   99   99 ]  [  1  0 -1 -1 -1 -1 -1 -1 ] ]</code>
<code>        [ (micro)  (M2)       vM2       13  13  98 99     80  [   5    6   99   99 ]  [  1  0  1  0 -1 -1 -1 -1 ] ]</code>
<code>        [ (micro)  (M3)       vM3       15  15  98 99    132  [   6    8   99   99 ]  [  1  0  1  0 -1 -1 -1 -1 ] ]</code>
<code>        [ (micro)  (M4)       vM4       17  17  98 99    192  [   8   10   14   99 ]  [  1  0  1  0  1  0 -1 -1 ] ]</code>
<code>        [ (full)   (1)        v1to9     21  21  98 99    208  [   7   10   13   17 ]  [  1  0  1  0  1  0  1  0 ] ]</code>
<code>        [ (full)   (2)        v1to9     25  25  18 99    359  [  10   16   22   28 ]  [  1  0  1  0  1  0  1  0 ] ]</code>
<code>        [ (full)   (3)        v1to9     29  29  22 99    567  [  15   26   36   44 ]  [  1  0  1  0  2  0  2  0 ] ]</code>
<code>        [ (full)   (4)        v1to9     33  33  26 99    807  [  20   36   52   64 ]  [  1  0  2  0  2  0  4  0 ] ]</code>
<code>        [ (full)   (5)        v1to9     37  37  30 99   1079  [  26   48   72   88 ]  [  1  0  2  0  2  2  2  2 ] ]</code>
<code>        [ (full)   (6)        v1to9     41  41  34 99   1383  [  36   64   96  112 ]  [  2  0  4  0  4  0  4  0 ] ]</code>
<code>        [ (full)   (7)        v1to9     45  45  22 38   1568  [  40   72  108  130 ]  [  2  0  4  0  2  4  4  1 ] ]</code>
<code>        [ (full)   (8)        v1to9     49  49  24 42   1936  [  48   88  132  156 ]  [  2  0  2  2  4  2  4  2 ] ]</code>
<code>        [ (full)   (9)        v1to9     53  53  26 46   2336  [  60  110  160  192 ]  [  2  0  3  2  4  4  4  4 ] ]</code>
<code>        [ (full)   (10)       v10to26   57  57  28 50   2768  [  72  130  192  224 ]  [  2  2  4  1  6  2  6  2 ] ]</code>
<code>        [ (full)   (11)       v10to26   61  61  30 54   3232  [  80  150  224  264 ]  [  4  0  1  4  4  4  3  8 ] ]</code>
<code>        [ (full)   (12)       v10to26   65  65  32 58   3728  [  96  176  260  308 ]  [  2  2  6  2  4  6  7  4 ] ]</code>
<code>        [ (full)   (13)       v10to26   69  69  34 62   4256  [ 104  198  288  352 ]  [  4  0  8  1  8  4 12  4 ] ]</code>
<code>        [ (full)   (14)       v10to26   73  73  26 46   4651  [ 120  216  320  384 ]  [  3  1  4  5 11  5 11  5 ] ]</code>
<code>        [ (full)   (15)       v10to26   77  77  26 48   5243  [ 132  240  360  432 ]  [  5  1  5  5  5  7 11  7 ] ]</code>
<code>        [ (full)   (16)       v10to26   81  81  26 50   5867  [ 144  280  408  480 ]  [  5  1  7  3 15  2  3 13 ] ]</code>
<code>        [ (full)   (17)       v10to26   85  85  30 54   6523  [ 168  308  448  532 ]  [  1  5 10  1  1 15  2 17 ] ]</code>
<code>        [ (full)   (18)       v10to26   89  89  30 56   7211  [ 180  338  504  588 ]  [  5  1  9  4 17  1  2 19 ] ]</code>
<code>        [ (full)   (19)       v10to26   93  93  30 58   7931  [ 196  364  546  650 ]  [  3  4  3 11 17  4  9 16 ] ]</code>
<code>        [ (full)   (20)       v10to26   97  97  34 62   8683  [ 224  416  600  700 ]  [  3  5  3 13 15  5 15 10 ] ]</code>
<code>        [ (full)   (21)       v10to26  101 101  28 50   9252  [ 224  442  644  750 ]  [  4  4 17  0 17  6 19  6 ] ]</code>
<code>        [ (full)   (22)       v10to26  105 105  26 50  10068  [ 252  476  690  816 ]  [  2  7 17  0  7 16 34  0 ] ]</code>
<code>        [ (full)   (23)       v10to26  109 109  30 54  10916  [ 270  504  750  900 ]  [  4  5  4 14 11 14 16 14 ] ]</code>
<code>        [ (full)   (24)       v10to26  113 113  28 54  11796  [ 300  560  810  960 ]  [  6  4  6 14 11 16 30  2 ] ]</code>
<code>        [ (full)   (25)       v10to26  117 117  32 58  12708  [ 312  588  870 1050 ]  [  8  4  8 13  7 22 22 13 ] ]</code>
<code>        [ (full)   (26)       v10to26  121 121  30 58  13652  [ 336  644  952 1110 ]  [ 10  2 19  4 28  6 33  4 ] ]</code>
<code>        [ (full)   (27)       v27to40  125 125  34 62  14628  [ 360  700 1020 1200 ]  [  8  4 22  3  8 26 12 28 ] ]</code>
<code>        [ (full)   (28)       v27to40  129 129  26 50  15371  [ 390  728 1050 1260 ]  [  3 10  3 23  4 31 11 31 ] ]</code>
<code>        [ (full)   (29)       v27to40  133 133  30 54  16411  [ 420  784 1140 1350 ]  [  7  7 21  7  1 37 19 26 ] ]</code>
<code>        [ (full)   (30)       v27to40  137 137  26 52  17483  [ 450  812 1200 1440 ]  [  5 10 19 10 15 25 23 25 ] ]</code>
<code>        [ (full)   (31)       v27to40  141 141  30 56  18587  [ 480  868 1290 1530 ]  [ 13  3  2 29 42  1 23 28 ] ]</code>
<code>        [ (full)   (32)       v27to40  145 145  34 60  19723  [ 510  924 1350 1620 ]  [ 17  0 10 23 10 35 19 35 ] ]</code>
<code>        [ (full)   (33)       v27to40  149 149  30 58  20891  [ 540  980 1440 1710 ]  [ 17  1 14 21 29 19 11 46 ] ]</code>
<code>        [ (full)   (34)       v27to40  153 153  34 62  22091  [ 570 1036 1530 1800 ]  [ 13  6 14 23 44  7 59  1 ] ]</code>
<code>        [ (full)   (35)       v27to40  157 157  30 54  23008  [ 570 1064 1590 1890 ]  [ 12  7 12 26 39 14 22 41 ] ]</code>
<code>        [ (full)   (36)       v27to40  161 161  24 50  24272  [ 600 1120 1680 1980 ]  [  6 14  6 34 46 10  2 64 ] ]</code>
<code>        [ (full)   (37)       v27to40  165 165  28 54  25568  [ 630 1204 1770 2100 ]  [ 17  4 29 14 49 10 24 46 ] ]</code>
<code>        [ (full)   (38)       v27to40  169 169  32 58  26896  [ 660 1260 1860 2220 ]  [  4 18 13 32 48 14 42 32 ] ]</code>
<code>        [ (full)   (39)       v27to40  173 173  26 54  28256  [ 720 1316 1950 2310 ]  [ 20  4 40  7 43 22 10 67 ] ]</code>
<code>        [ (full)   (40)       v27to40  177 177  30 58  29648  [ 750 1372 2040 2430 ]  [ 19  6 18 31 34 34 20 61 ] ]</code>
<code>        [ (rmqr)   (R7x43)    vR7x43     7  43  22 99    104  [  99    7   99   10 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]</code>
<code>        [ (rmqr)   (R7x59)    vR7x59     7  59  20 40    171  [  99    9   99   14 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]</code>
<code>        [ (rmqr)   (R7x77)    vR7x77     7  77  26 52    261  [  99   12   99   22 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]</code>
<code>        [ (rmqr)   (R7x99)    vR7x99     7  99  24 50    358  [  99   16   99   30 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]</code>
<code>        [ (rmqr)   (R7x139)   vR7x139    7 139  28 56    545  [  99   24   99   44 ]  [ -1 -1  1  0 -1 -1  2  0 ] ]</code>
<code>        [ (rmqr)   (R9x43)    vR9x43     9  43  22 99    170  [  99    9   99   14 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]</code>
<code>        [ (rmqr)   (R9x59)    vR9x59     9  59  20 40    267  [  99   12   99   22 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]</code>
<code>        [ (rmqr)   (R9x77)    vR9x77     9  77  26 52    393  [  99   18   99   32 ]  [ -1 -1  1  0 -1 -1  1  1 ] ]</code>
<code>        [ (rmqr)   (R9x99)    vR9x99     9  99  24 50    532  [  99   24   99   44 ]  [ -1 -1  1  0 -1 -1  2  0 ] ]</code>
<code>        [ (rmqr)   (R9x139)   vR9x139    9 139  28 56    797  [  99   36   99   66 ]  [ -1 -1  1  1 -1 -1  3  0 ] ]</code>
<code>        [ (rmqr)   (R11x27)   vR11x27   11  27  98 99    122  [  99    8   99   10 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]</code>
<code>        [ (rmqr)   (R11x43)   vR11x43   11  43  22 99    249  [  99   12   99   20 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]</code>
<code>        [ (rmqr)   (R11x59)   vR11x59   11  59  20 40    376  [  99   16   99   32 ]  [ -1 -1  1  0 -1 -1  1  1 ] ]</code>
<code>        [ (rmqr)   (R11x77)   vR11x77   11  77  26 52    538  [  99   24   99   44 ]  [ -1 -1  1  0 -1 -1  1  1 ] ]</code>
<code>        [ (rmqr)   (R11x99)   vR11x99   11  99  24 50    719  [  99   32   99   60 ]  [ -1 -1  1  1 -1 -1  1  1 ] ]</code>
<code>        [ (rmqr)   (R11x139)  vR11x139  11 139  28 56   1062  [  99   48   99   90 ]  [ -1 -1  2  0 -1 -1  3  0 ] ]</code>
<code>        [ (rmqr)   (R13x27)   vR13x27   13  27  98 99    172  [  99    9   99   14 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]</code>
<code>        [ (rmqr)   (R13x43)   vR13x43   13  43  22 99    329  [  99   14   99   28 ]  [ -1 -1  1  0 -1 -1  1  0 ] ]</code>
<code>        [ (rmqr)   (R13x59)   vR13x59   13  59  20 40    486  [  99   22   99   40 ]  [ -1 -1  1  0 -1 -1  2  0 ] ]</code>
<code>        [ (rmqr)   (R13x77)   vR13x77   13  77  26 52    684  [  99   32   99   56 ]  [ -1 -1  1  1 -1 -1  1  1 ] ]</code>
<code>        [ (rmqr)   (R13x99)   vR13x99   13  99  24 50    907  [  99   40   99   78 ]  [ -1 -1  1  1 -1 -1  1  2 ] ]</code>
<code>        [ (rmqr)   (R13x139)  vR13x139  13 139  28 56   1328  [  99   60   99  112 ]  [ -1 -1  2  1 -1 -1  2  2 ] ]</code>
<code>        [ (rmqr)   (R15x43)   vR15x43   15  43  22 99    409  [  99   18   99   36 ]  [ -1 -1  1  0 -1 -1  1  1 ] ]</code>
<code>        [ (rmqr)   (R15x59)   vR15x59   15  59  20 40    596  [  99   26   99   48 ]  [ -1 -1  1  0 -1 -1  2  0 ] ]</code>
<code>        [ (rmqr)   (R15x77)   vR15x77   15  77  26 52    830  [  99   36   99   72 ]  [ -1 -1  1  1 -1 -1  2  1 ] ]</code>
<code>        [ (rmqr)   (R15x99)   vR15x99   15  99  24 50   1095  [  99   48   99   88 ]  [ -1 -1  2  0 -1 -1  4  0 ] ]</code>
<code>        [ (rmqr)   (R15x139)  vR15x139  15 139  28 56   1594  [  99   72   99  130 ]  [ -1 -1  2  1 -1 -1  1  4 ] ]</code>
<code>        [ (rmqr)   (R17x43)   vR17x43   17  43  22 99    489  [  99   22   99   40 ]  [ -1 -1  1  0 -1 -1  1  1 ] ]</code>
<code>        [ (rmqr)   (R17x59)   vR17x59   17  59  20 40    706  [  99   32   99   60 ]  [ -1 -1  2  0 -1 -1  2  0 ] ]</code>
<code>        [ (rmqr)   (R17x77)   vR17x77   17  77  26 52    976  [  99   44   99   84 ]  [ -1 -1  2  0 -1 -1  1  2 ] ]</code>
<code>        [ (rmqr)   (R17x99)   vR17x99   17  99  24 50   1283  [  99   60   99  104 ]  [ -1 -1  2  1 -1 -1  4  0 ] ]</code>
<code>        [ (rmqr)   (R17x139)  vR17x139  17 139  28 56   1860  [  99   80   99  156 ]  [ -1 -1  4  0 -1 -1  2  4 ] ]</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /eclval (LMQH) eclevel search pop length exch pop exch pop def</code>
<code>    0 1 metrics length 1 sub {</code>
<code>        /i exch def</code>
<code>        /m metrics i get def</code>
<code>        /frmt m 0 get def                             % Format of the symbol</code>
<code>        /vers m 1 get def                             % Version of symbol</code>
<code>        /vergrp m 2 get def                           % Version group</code>
<code>        /verind i 44 sub def                          % Version indicator for rMQR format info</code>
<code>        /rows m 3 get def                             % Length of side</code>
<code>        /cols m 4 get def                             % Length of side</code>
<code>        /asp2 m 5 get def                             % Position of second alignment symbol</code>
<code>        /asp3 m 6 get def                             % Position of third alignment symbol</code>
<code>        /nmod m 7 get def                             % Number of modules</code>
<code>        /ncws nmod 8 idiv def                         % Total number of codewords</code>
<code>        /rbit nmod 8 mod def                          % Number of remainder bits</code>
<code>        /lc4b false def                               % Last data codeword is 4 bits long</code>
<code>        vers (M1) eq vers (M3) eq or {                % Adjustments for M1 and M3 symbols</code>
<code>            /ncws ncws 1 add def</code>
<code>            /rbit 0 def</code>
<code>            /lc4b true def</code>
<code>        } if</code>
<code>        /ecws m 8 get eclval get def                  % Number of error correction codewords</code>
<code>        /dcws ncws ecws sub def                       % Number of data codewords</code>
<code>        /dmod dcws 8 mul lc4b {4} {0} ifelse sub def  % Number of data modules</code>
<code>        /ecb1 m 9 get eclval 2 mul get def            % First error correction blocks</code>
<code>        /ecb2 m 9 get eclval 2 mul 1 add get def      % Second error correction blocks</code>
<code>        /okay true def</code>
<code>        format frmt ne {/okay false def} if           % The format must match that supplied</code>
<code>        frmt (micro) eq fnc1first and {/okay false def} if  % FNC1 mode is only available in full and rmqr</code>
<code>        version (unset) ne version vers ne and {/okay false def} if  % The version must match that supplied</code>
<code>        ecb1 -1 eq ecb2 -1 eq or {/okay false def} if % Error correction level must be valid</code>
<code>        /verbits msgbits vergrp get def</code>
<code>        verbits -1 eq {                               % Bitstream must be available</code>
<code>            /okay false def</code>
<code>        } {</code>
<code>            verbits length dmod gt {/okay false def} if  % and fit into data modules</code>
<code>        } ifelse</code>
<code>        /term (000000000) 0 termlens vergrp get getinterval def</code>
<code>        okay {exit} if</code>
<code>    } for</code>
<code></code>
<code>    okay not {</code>
<code>        /bwipp.qrcodeNoValidSymbol (Maximum length exceeded or invalid content) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /format frmt def</code>
<code>    /version vers def</code>
<code>    /msgbits verbits def</code>
<code>    /dcpb dcws ecb1 ecb2 add idiv def                 % Base data codewords per block</code>
<code>    /ecpb ncws ecb1 ecb2 add idiv dcpb sub def        % Error correction codewords per block</code>
<code></code>
<code>    % Complete the message bits by adding the terminator, truncated if necessary</code>
<code>    /term term 0 dmod msgbits length sub term length 2 copy gt {exch} if pop getinterval def</code>
<code>    msgbits length term length add string</code>
<code>    dup 0 msgbits putinterval</code>
<code>    dup msgbits length term putinterval</code>
<code>    /msgbits exch def</code>
<code></code>
<code>    % Expand the message bits by adding padding as necessary</code>
<code>    /pad dmod string def</code>
<code>    0 1 pad length 1 sub {pad exch 48 put} for</code>
<code>    pad 0 msgbits putinterval</code>
<code>    /padnum 0 def</code>
<code>    msgbits length 8 div ceiling 8 mul cvi 8 dmod lc4b {5} {1} ifelse sub {</code>
<code>        pad exch padstrs padnum get putinterval</code>
<code>        /padnum padnum 1 add 2 mod def</code>
<code>    } for</code>
<code></code>
<code>    % Evaluate the padded message into codewords</code>
<code>    /cws dcws array def</code>
<code>    0 1 cws length 1 sub {</code>
<code>        /c exch def</code>
<code>        /bpcw 8 def</code>
<code>        lc4b c cws length 1 sub eq and {/bpcw 4 def} if</code>
<code>        /cwb pad c 8 mul bpcw getinterval def</code>
<code>        /cw 0 def</code>
<code>        0 1 bpcw 1 sub {</code>
<code>            /i exch def</code>
<code>            /cw cw 2 bpcw i sub 1 sub exp cvi cwb i get 48 sub mul add def</code>
<code>        } for</code>
<code>        cws c cw put</code>
<code>    } for</code>
<code></code>
<code>    % Short final data byte in M1 and M3 symbols has high-order value</code>
<code>    lc4b {cws cws length 1 sub 2 copy get 4 bitshift put} if</code>
<code></code>
<code>    options /debugcws known { /bwipp.debugcws cws //raiseerror exec } if</code>
<code></code>
<code>    % Calculate the log and anti-log tables</code>
<code>{</code>
<code>    /rsalog [ 1 255 { dup 2 mul dup 256 ge {285 xor} if } repeat ] def</code>
<code>    /rslog 256 array def</code>
<code>    1 1 255 {dup rsalog exch get exch rslog 3 1 roll put} for</code>
<code>} ctxdef</code>
<code></code>
<code>    % Function to calculate the product in the field</code>
<code>    /rsprod {</code>
<code>        2 copy 0 ne exch 0 ne and {</code>
<code>            rslog exch get exch rslog exch get add 255 mod rsalog exch get</code>
<code>        } {</code>
<code>            pop pop 0</code>
<code>        } ifelse</code>
<code>    } def</code>
<code></code>
<code>    % Generate the coefficients for the Reed-Solomon algorithm</code>
<code>    /coeffs [ 1 ecpb {0} repeat ] def</code>
<code>    0 1 ecpb 1 sub {</code>
<code>        /i exch def</code>
<code>        coeffs i 1 add coeffs i get put</code>
<code>        i -1 1 {</code>
<code>            /j exch def</code>
<code>            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put</code>
<code>        } for</code>
<code>        coeffs 0 coeffs 0 get rsalog i get rsprod put</code>
<code>    } for</code>
<code>    /coeffs coeffs 0 coeffs length 1 sub getinterval def</code>
<code></code>
<code>    % Reed-Solomon algorithm to derive the error correction codewords</code>
<code>    /rscodes {</code>
<code>        /rscws exch def</code>
<code>        /rsnd rscws length def</code>
<code>        /rscws [ rscws {} forall ecpb {0} repeat ] def</code>
<code>        0 1 rsnd 1 sub {</code>
<code>            /m exch def</code>
<code>            /k rscws m get def</code>
<code>            0 1 ecpb 1 sub {</code>
<code>                /j exch def</code>
<code>                rscws m j add 1 add coeffs ecpb j sub 1 sub get k rsprod rscws m j add 1 add get xor put</code>
<code>            } for</code>
<code>        } for</code>
<code>        rscws rsnd ecpb getinterval</code>
<code>    } def</code>
<code></code>
<code>    % Divide codewords into two groups of blocks and calculate the error correction codewords</code>
<code>    /dcwsb ecb1 ecb2 add array def</code>
<code>    /ecwsb ecb1 ecb2 add array def</code>
<code>    0 1 ecb1 1 sub {  % First group of blocks has smaller number of data codewords</code>
<code>        /i exch def</code>
<code>        dcwsb i cws i dcpb mul dcpb getinterval put</code>
<code>        ecwsb i dcwsb i get rscodes put</code>
<code>    } for</code>
<code>    0 1 ecb2 1 sub {  % Second group of blocks has larger number of data codewords</code>
<code>        /i exch def</code>
<code>        dcwsb ecb1 i add cws ecb1 dcpb mul i dcpb 1 add mul add dcpb 1 add getinterval put</code>
<code>        ecwsb ecb1 i add dcwsb ecb1 i add get rscodes put</code>
<code>    } for</code>
<code></code>
<code>    % Reassemble the codewords</code>
<code>    /cws ncws array def</code>
<code>    /cw 0 def</code>
<code>    0 1 dcpb {  % Interleave the data codeword blocks</code>
<code>        /i exch def</code>
<code>        0 1 ecb1 ecb2 add 1 sub {</code>
<code>            /j exch def</code>
<code>            i dcwsb j get length lt {  % Ignore the end of short blocks</code>
<code>                cws cw dcwsb j get i get put</code>
<code>                /cw cw 1 add def</code>
<code>            } if</code>
<code>        } for</code>
<code>    } for</code>
<code>    0 1 ecpb 1 sub {  % Interleave the error codeword blocks</code>
<code>        /i exch def</code>
<code>        0 1 ecb1 ecb2 add 1 sub {</code>
<code>            /j exch def</code>
<code>            cws cw ecwsb j get i get put</code>
<code>            /cw cw 1 add def</code>
<code>        } for</code>
<code>    } for</code>
<code></code>
<code>    % Extend codewords by one if there are remainder bits</code>
<code>    rbit 0 gt {</code>
<code>        /pad cws length 1 add array def</code>
<code>        pad 0 cws putinterval</code>
<code>        pad pad length 1 sub 0 put</code>
<code>        /cws pad def</code>
<code>    } if</code>
<code></code>
<code>    % Fixups for the short final data byte in M1 and M3 symbols</code>
<code>    lc4b {</code>
<code>        cws dcws 1 sub 2 copy get -4 bitshift put</code>
<code>        dcws 1 sub 1 ncws 2 sub {</code>
<code>            /i exch def</code>
<code>            cws i cws i get 15 and 4 bitshift put</code>
<code>            cws i cws i 1 add get -4 bitshift 15 and cws i get or put</code>
<code>        } for</code>
<code>        cws ncws 1 sub cws ncws 1 sub get 15 and 4 bitshift put</code>
<code>    } if</code>
<code></code>
<code>    options /debugecc known { /bwipp.debugecc cws //raiseerror exec } if</code>
<code></code>
<code>    % Create the bitmap</code>
<code>    /pixs [ rows cols mul {-1} repeat ] def</code>
<code>    /qmv {cols mul add} def</code>
<code></code>
<code>    % Timing patterns</code>
<code>    format (full) eq {</code>
<code>        8 1 cols 9 sub {</code>
<code>            /i exch def</code>
<code>            pixs i 6 qmv i 1 add 2 mod put</code>
<code>            pixs 6 i qmv i 1 add 2 mod put</code>
<code>        } for</code>
<code>    } if</code>
<code>    format (micro) eq {</code>
<code>        8 1 cols 1 sub {</code>
<code>            /i exch def</code>
<code>            pixs i 0 qmv i 1 add 2 mod put</code>
<code>            pixs 0 i qmv i 1 add 2 mod put</code>
<code>        } for</code>
<code>    } if</code>
<code>    format (rmqr) eq {</code>
<code>        3 1 cols 4 sub {  % Along top and bottom</code>
<code>            /i exch def</code>
<code>            pixs i 0 qmv i 1 add 2 mod put</code>
<code>            pixs i rows 1 sub qmv i 1 add 2 mod put</code>
<code>        } for</code>
<code>        3 1 rows 4 sub {  % Along left and right</code>
<code>            /i exch def</code>
<code>            pixs 0 i qmv i 1 add 2 mod put</code>
<code>            pixs cols 1 sub i qmv i 1 add 2 mod put</code>
<code>        } for</code>
<code>        asp2 1 sub asp3 asp2 sub cols 13 sub {  % Down interior</code>
<code>            /i exch def</code>
<code>            3 1 rows 4 sub {</code>
<code>                /j exch def</code>
<code>                pixs i j qmv j 1 add 2 mod put</code>
<code>            } for</code>
<code>        } for</code>
<code>    } if</code>
<code></code>
<code>    % Finder patterns</code>
<code>{</code>
<code>    /fpat [</code>
<code>        [ 1 1 1 1 1 1 1 0 ]</code>
<code>        [ 1 0 0 0 0 0 1 0 ]</code>
<code>        [ 1 0 1 1 1 0 1 0 ]</code>
<code>        [ 1 0 1 1 1 0 1 0 ]</code>
<code>        [ 1 0 1 1 1 0 1 0 ]</code>
<code>        [ 1 0 0 0 0 0 1 0 ]</code>
<code>        [ 1 1 1 1 1 1 1 0 ]</code>
<code>        [ 0 0 0 0 0 0 0 0 ]</code>
<code>    ] def</code>
<code>    /fsubpat [</code>
<code>        [ 1 1 1 1 1 9 9 9 ]</code>
<code>        [ 1 0 0 0 1 9 9 9 ]</code>
<code>        [ 1 0 1 0 1 9 9 9 ]</code>
<code>        [ 1 0 0 0 1 9 9 9 ]</code>
<code>        [ 1 1 1 1 1 9 9 9 ]</code>
<code>        [ 9 9 9 9 9 9 9 9 ]</code>
<code>        [ 9 9 9 9 9 9 9 9 ]</code>
<code>        [ 9 9 9 9 9 9 9 9 ]</code>
<code>    ] def</code>
<code>    /fcorpat [</code>
<code>        [ 1 1 1 9 9 9 9 9 ]</code>
<code>        [ 1 0 9 9 9 9 9 9 ]</code>
<code>        [ 1 9 9 9 9 9 9 9 ]</code>
<code>        [ 9 9 9 9 9 9 9 9 ]</code>
<code>        [ 9 9 9 9 9 9 9 9 ]</code>
<code>        [ 9 9 9 9 9 9 9 9 ]</code>
<code>        [ 9 9 9 9 9 9 9 9 ]</code>
<code>        [ 9 9 9 9 9 9 9 9 ]</code>
<code>    ] def</code>
<code>    /fnullpat [</code>
<code>        [ 9 9 9 9 9 9 9 9 ]</code>
<code>        [ 9 9 9 9 9 9 9 9 ]</code>
<code>        [ 9 9 9 9 9 9 9 9 ]</code>
<code>        [ 9 9 9 9 9 9 9 9 ]</code>
<code>        [ 9 9 9 9 9 9 9 9 ]</code>
<code>        [ 9 9 9 9 9 9 9 9 ]</code>
<code>        [ 9 9 9 9 9 9 9 9 ]</code>
<code>        [ 9 9 9 9 9 9 9 9 ]</code>
<code>    ] def</code>
<code>    /fpatmap &lt;&lt;</code>
<code>        %          TL     TR       BL       BR</code>
<code>        (full)  [ fpat fpat     fpat     fnullpat ]</code>
<code>        (micro) [ fpat fnullpat fnullpat fnullpat ]</code>
<code>        (rmqr)  [ fpat fcorpat  fcorpat  fsubpat  ]</code>
<code>    &gt;&gt; def</code>
<code>} ctxdef</code>
<code>    /fpats fpatmap format get def</code>
<code>    0 1 7 {</code>
<code>      /y exch def</code>
<code>      0 1 7 {</code>
<code>        /x exch def</code>
<code>        /fpb0 fpats 0 get y get x get def</code>
<code>        /fpb1 fpats 1 get y get x get def</code>
<code>        /fpb2 fpats 2 get y get x get def</code>
<code>        /fpb3 fpats 3 get y get x get def</code>
<code>        fpb0 9 ne y rows lt and {pixs x y qmv fpb0 put} if</code>
<code>        fpb1 9 ne {pixs cols x sub 1 sub y qmv fpb1 put} if</code>
<code>        fpb2 9 ne {pixs x rows y sub 1 sub qmv fpb2 put} if</code>
<code>        fpb3 9 ne {pixs cols x sub 1 sub rows y sub 1 sub qmv fpb3 put} if</code>
<code>      } for</code>
<code>    } for</code>
<code></code>
<code>    % Alignment patterns</code>
<code>{</code>
<code>    /algnpatfull [</code>
<code>        [ 1 1 1 1 1 ]</code>
<code>        [ 1 0 0 0 1 ]</code>
<code>        [ 1 0 1 0 1 ]</code>
<code>        [ 1 0 0 0 1 ]</code>
<code>        [ 1 1 1 1 1 ]</code>
<code>    ] def</code>
<code>    /algnpatrmqr [</code>
<code>        [ 1 1 1 9 9 ]</code>
<code>        [ 1 0 1 9 9 ]</code>
<code>        [ 1 1 1 9 9 ]</code>
<code>        [ 9 9 9 9 9 ]</code>
<code>        [ 9 9 9 9 9 ]</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /putalgnpat {</code>
<code>        /py exch def</code>
<code>        /px exch def</code>
<code>        0 1 4 {</code>
<code>            /pb exch def</code>
<code>            0 1 4 {</code>
<code>                /pa exch def</code>
<code>                /algnb algnpat pb get pa get def</code>
<code>                algnb 9 ne {</code>
<code>                    pixs px pa add py pb add qmv algnb put</code>
<code>                } if</code>
<code>            } for</code>
<code>        } for</code>
<code>    } def</code>
<code>    format (full) eq {</code>
<code>        /algnpat algnpatfull def</code>
<code>        asp2 2 sub asp3 asp2 sub cols 13 sub {</code>
<code>            /i exch def</code>
<code>            i 4 putalgnpat</code>
<code>            4 i putalgnpat</code>
<code>        } for</code>
<code>        asp2 2 sub asp3 asp2 sub cols 9 sub {</code>
<code>            /x exch def</code>
<code>            asp2 2 sub asp3 asp2 sub rows 9 sub {</code>
<code>                /y exch def</code>
<code>                x y putalgnpat</code>
<code>            } for</code>
<code>        } for</code>
<code>    } if</code>
<code>    format (rmqr) eq {</code>
<code>        /algnpat algnpatrmqr def</code>
<code>        asp2 2 sub asp3 asp2 sub cols 13 sub {</code>
<code>            /i exch def</code>
<code>            i 0 putalgnpat</code>
<code>            i rows 3 sub putalgnpat</code>
<code>        } for</code>
<code>    } if</code>
<code></code>
<code>    % Format information modules</code>
<code>{</code>
<code>    /formatmapmicro [</code>
<code>            [ [ 1 8 ] ]  [ [ 2 8 ] ]  [ [ 3 8 ] ]  [ [ 4 8 ] ]  [ [ 5 8 ] ]</code>
<code>            [ [ 6 8 ] ]  [ [ 7 8 ] ]  [ [ 8 8 ] ]  [ [ 8 7 ] ]  [ [ 8 6 ] ]</code>
<code>            [ [ 8 5 ] ]  [ [ 8 4 ] ]  [ [ 8 3 ] ]  [ [ 8 2 ] ]  [ [ 8 1 ] ]</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code>    /formatmap &lt;&lt;</code>
<code>        (full) [</code>
<code>            [ [ 0 8 ] [ 8 cols 1 sub ] ]  [ [ 1 8 ] [ 8 cols 2 sub ] ]  [ [ 2 8 ] [ 8 cols 3 sub ] ]</code>
<code>            [ [ 3 8 ] [ 8 cols 4 sub ] ]  [ [ 4 8 ] [ 8 cols 5 sub ] ]  [ [ 5 8 ] [ 8 cols 6 sub ] ]</code>
<code>            [ [ 7 8 ] [ 8 cols 7 sub ] ]  [ [ 8 8 ] [ cols 8 sub 8 ] ]  [ [ 8 7 ] [ cols 7 sub 8 ] ]</code>
<code>            [ [ 8 5 ] [ cols 6 sub 8 ] ]  [ [ 8 4 ] [ cols 5 sub 8 ] ]  [ [ 8 3 ] [ cols 4 sub 8 ] ]</code>
<code>            [ [ 8 2 ] [ cols 3 sub 8 ] ]  [ [ 8 1 ] [ cols 2 sub 8 ] ]  [ [ 8 0 ] [ cols 1 sub 8 ] ]</code>
<code>        ]</code>
<code>        (micro) formatmapmicro</code>
<code>        (rmqr) [</code>
<code>            [ [ 11 3 ] [ cols 3 sub rows 6 sub ] ]  [ [ 11 2 ] [ cols 4 sub rows 6 sub ] ]  [ [ 11 1 ] [ cols 5 sub rows 6 sub ] ]</code>
<code>            [ [ 10 5 ] [ cols 6 sub rows 2 sub ] ]  [ [ 10 4 ] [ cols 6 sub rows 3 sub ] ]  [ [ 10 3 ] [ cols 6 sub rows 4 sub ] ]</code>
<code>            [ [ 10 2 ] [ cols 6 sub rows 5 sub ] ]  [ [ 10 1 ] [ cols 6 sub rows 6 sub ] ]  [ [  9 5 ] [ cols 7 sub rows 2 sub ] ]</code>
<code>            [ [  9 4 ] [ cols 7 sub rows 3 sub ] ]  [ [  9 3 ] [ cols 7 sub rows 4 sub ] ]  [ [  9 2 ] [ cols 7 sub rows 5 sub ] ]</code>
<code>            [ [  9 1 ] [ cols 7 sub rows 6 sub ] ]  [ [  8 5 ] [ cols 8 sub rows 2 sub ] ]  [ [  8 4 ] [ cols 8 sub rows 3 sub ] ]</code>
<code>            [ [  8 3 ] [ cols 8 sub rows 4 sub ] ]  [ [  8 2 ] [ cols 8 sub rows 5 sub ] ]  [ [  8 1 ] [ cols 8 sub rows 6 sub ] ]</code>
<code>        ]</code>
<code>    &gt;&gt; format get def</code>
<code>    formatmap {</code>
<code>        { {} forall qmv pixs exch 1 put } forall</code>
<code>    } forall</code>
<code></code>
<code>    % Version information modules</code>
<code>    format (full) eq cols 45 ge and {</code>
<code>        /versionmap [</code>
<code>            [ [ cols  9 sub 5 ] [ 5 cols  9 sub ] ]  [ [ cols 10 sub 5 ] [ 5 cols 10 sub ] ]</code>
<code>            [ [ cols 11 sub 5 ] [ 5 cols 11 sub ] ]  [ [ cols  9 sub 4 ] [ 4 cols  9 sub ] ]</code>
<code>            [ [ cols 10 sub 4 ] [ 4 cols 10 sub ] ]  [ [ cols 11 sub 4 ] [ 4 cols 11 sub ] ]</code>
<code>            [ [ cols  9 sub 3 ] [ 3 cols  9 sub ] ]  [ [ cols 10 sub 3 ] [ 3 cols 10 sub ] ]</code>
<code>            [ [ cols 11 sub 3 ] [ 3 cols 11 sub ] ]  [ [ cols  9 sub 2 ] [ 2 cols  9 sub ] ]</code>
<code>            [ [ cols 10 sub 2 ] [ 2 cols 10 sub ] ]  [ [ cols 11 sub 2 ] [ 2 cols 11 sub ] ]</code>
<code>            [ [ cols  9 sub 1 ] [ 1 cols  9 sub ] ]  [ [ cols 10 sub 1 ] [ 1 cols 10 sub ] ]</code>
<code>            [ [ cols 11 sub 1 ] [ 1 cols 11 sub ] ]  [ [ cols  9 sub 0 ] [ 0 cols  9 sub ] ]</code>
<code>            [ [ cols 10 sub 0 ] [ 0 cols 10 sub ] ]  [ [ cols 11 sub 0 ] [ 0 cols 11 sub ] ]</code>
<code>        ] def</code>
<code>    } {</code>
<code>        /versionmap [] def</code>
<code>    } ifelse</code>
<code>    versionmap {</code>
<code>        { {} forall qmv pixs exch 0 put } forall</code>
<code>    } forall</code>
<code></code>
<code>    % Reserve the solitary dark module in full symbols</code>
<code>    format (full) eq {</code>
<code>        pixs 8 rows 8 sub qmv 0 put</code>
<code>    } if</code>
<code></code>
<code>    % Calculate the mask patterns</code>
<code>    /maskfuncs &lt;&lt;</code>
<code>        (full) [</code>
<code>            {add 2 mod}</code>
<code>            {exch pop 2 mod}</code>
<code>            {pop 3 mod}</code>
<code>            {add 3 mod}</code>
<code>            {2 idiv exch 3 idiv add 2 mod}</code>
<code>            {mul dup 2 mod exch 3 mod add}</code>
<code>            {mul dup 2 mod exch 3 mod add 2 mod}</code>
<code>            {2 copy mul 3 mod 3 1 roll add 2 mod add 2 mod}</code>
<code>        ]</code>
<code>        (micro) [</code>
<code>            {exch pop 2 mod}</code>
<code>            {2 idiv exch 3 idiv add 2 mod}</code>
<code>            {mul dup 2 mod exch 3 mod add 2 mod}</code>
<code>            {2 copy mul 3 mod 3 1 roll add 2 mod add 2 mod}</code>
<code>        ]</code>
<code>        (rmqr) [</code>
<code>            {2 idiv exch 3 idiv add 2 mod}</code>
<code>        ]</code>
<code>    &gt;&gt; format get def</code>
<code>    mask -1 ne {  % User specifies a mask</code>
<code>        /maskfuncs [maskfuncs mask 1 sub get] def</code>
<code>        /bestmaskval mask 1 sub def</code>
<code>    } if</code>
<code>    /masks maskfuncs length array def</code>
<code>    0 1 masks length 1 sub {</code>
<code>        /m exch def</code>
<code>        /mask rows cols mul array def</code>
<code>        0 1 rows 1 sub {</code>
<code>            /j exch def</code>
<code>            0 1 cols 1 sub {</code>
<code>                /i exch def</code>
<code>                i j maskfuncs m get exec 0 eq</code>
<code>                pixs i j qmv get -1 eq and {1} {0} ifelse</code>
<code>                mask i j qmv 3 -1 roll put</code>
<code>            } for</code>
<code>        } for</code>
<code>        masks m mask put</code>
<code>    } for</code>
<code></code>
<code>    % Walk the symbol placing the bitstream</code>
<code>    /posx cols format (rmqr) ne {1} {2} ifelse sub def</code>
<code>    /posy rows 1 sub def</code>
<code>    /dir -1 def  % -1 is upwards, 1 is downwards</code>
<code>    /col 1 def   % 0 is left bit, 1 is right bit</code>
<code>    /num 0 def</code>
<code>    { % loop</code>
<code>        posx 0 lt {exit} if</code>
<code>        pixs posx posy qmv get -1 eq {</code>
<code>            cws num 8 idiv get 7 num 8 mod sub neg bitshift 1 and</code>
<code>            pixs posx posy qmv 3 -1 roll put</code>
<code>            /num num 1 add def</code>
<code>        } if</code>
<code>        col 1 eq {</code>
<code>            /col 0 def</code>
<code>            /posx posx 1 sub def</code>
<code>        } {</code>
<code>            /col 1 def</code>
<code>            /posx posx 1 add def</code>
<code>            /posy posy dir add def</code>
<code>            posy 0 lt posy rows ge or {  % Turn around at top and bottom</code>
<code>                /dir dir -1 mul def</code>
<code>                /posy posy dir add def</code>
<code>                /posx posx 2 sub def</code>
<code>                % Hop over the timing pattern in full size symbols</code>
<code>                format (full) eq posx 6 eq and {/posx posx 1 sub def} if</code>
<code>            } if</code>
<code>        } ifelse</code>
<code>    } loop</code>
<code></code>
<code>    % Evaluate runlength encoded rows or columns in full symbols</code>
<code>    /evalfulln1n3 {</code>
<code>        /scrle exch def</code>
<code>        % Detect runs of 5 or more like modules</code>
<code>        /scr1 0 scrle { dup 5 ge {add 2 sub dup} if pop } forall def</code>
<code>        % Detect 1:1:3:1:1 ratio next to 4 modules of whitespace</code>
<code>        /scr3 0 def</code>
<code>        3 2 scrle length 3 sub {  % Scan odd (dark) runs within bounds</code>
<code>            /j exch def</code>
<code>            scrle j get 3 mod 0 eq {  % Multiple of 3 black modules</code>
<code>                /fact scrle j get 3 idiv def</code>
<code>                scrle j 2 sub 5 getinterval {fact eq} forall and exch pop and and {</code>
<code>                    j 3 eq j 4 add scrle length ge or {  % At either extent of run</code>
<code>                        /scr3 scr3 40 add def</code>
<code>                    } {  % Bounded by dark modules</code>
<code>                        scrle j 3 sub get 4 ge scrle j 3 add get 4 ge or {</code>
<code>                            /scr3 scr3 40 add def</code>
<code>                        } if</code>
<code>                    } ifelse</code>
<code>                } if</code>
<code>            } if</code>
<code>        } for</code>
<code>        scr1 scr3</code>
<code>    } def</code>
<code></code>
<code>    % Evaluation algorithm for full symbols</code>
<code>    /evalfull {</code>
<code>        /sym exch def</code>
<code></code>
<code>        /n1 0 def /n2 0 def /n3 0 def</code>
<code>        /rle cols 1 add array def</code>
<code>        /lastpairs cols array def</code>
<code>        /thispairs cols array def</code>
<code>        /colsadd1 cols 1 add def</code>
<code>        0 1 cols 1 sub {</code>
<code>            /i exch def</code>
<code></code>
<code>            % Runlength encode (light, dark, light, ...) and evaluate each column</code>
<code>            mark 0 0</code>
<code>            i cols dup dup mul 1 sub {</code>
<code>                sym exch get exch 1 index eq {exch 1 add exch} {1 exch} ifelse</code>
<code>            } for</code>
<code>            pop</code>
<code>            rle 0 counttomark 2 sub getinterval astore</code>
<code>            evalfulln1n3 n3 add /n3 exch def n1 add /n1 exch def</code>
<code>            pop</code>
<code></code>
<code>            % Runlength encode (light, dark, light, ...) and evaluate each row</code>
<code>            /symrow sym i cols mul cols getinterval def</code>
<code>            mark 0 0</code>
<code>            symrow {</code>
<code>                exch 1 index eq {exch 1 add exch} {1 exch} ifelse</code>
<code>            } forall</code>
<code>            pop</code>
<code>            rle 0 counttomark 2 sub getinterval astore</code>
<code>            evalfulln1n3 n3 add /n3 exch def n1 add /n1 exch def</code>
<code>            pop</code>
<code></code>
<code>            % Count and score same coloured blocks</code>
<code>            /lastpairs thispairs /thispairs lastpairs def def</code>
<code>            symrow 0 get 1 eq {0} {1} ifelse</code>
<code>            symrow {exch 1 index add exch} forall</code>
<code>            pop</code>
<code>            thispairs astore pop</code>
<code>            i 0 gt {</code>
<code>                mark</code>
<code>                lastpairs aload pop thispairs aload pop</code>
<code>                n2 cols { exch colsadd1 index add 3 and 0 eq {3 add} if } repeat</code>
<code>                /n2 exch def</code>
<code>                cleartomark</code>
<code>            } if</code>
<code></code>
<code>        } for</code>
<code></code>
<code>        % Score dark/light imbalance</code>
<code>        /dark 0 sym {add} forall def</code>
<code>        /n4 dark 100 mul cols dup mul div 50 sub abs 5 div cvi 10 mul def</code>
<code></code>
<code>        n1 n2 add n3 add n4 add</code>
<code>    } def</code>
<code></code>
<code>    % Evaluation algorithm for micro symbols</code>
<code>    /evalmicro {</code>
<code>        /sym exch def</code>
<code>        /dkrhs 0 def /dkbot 0 def</code>
<code>        1 1 cols 1 sub {</code>
<code>            /i exch def</code>
<code>            /dkrhs dkrhs sym cols 1 sub i qmv get add def</code>
<code>            /dkbot dkbot sym i cols 1 sub qmv get add def</code>
<code>        } for</code>
<code>        dkrhs dkbot le {</code>
<code>            dkrhs 16 mul dkbot add neg</code>
<code>        } {</code>
<code>            dkbot 16 mul dkrhs add neg</code>
<code>        } ifelse</code>
<code>    } def</code>
<code></code>
<code>    % Evaluate the masked symbols to find the most suitable</code>
<code>    /bestscore 999999999 def</code>
<code>    0 1 masks length 1 sub {</code>
<code>        /m exch def</code>
<code>        /masksym rows cols mul array def</code>
<code>        0 1 rows cols mul 1 sub {</code>
<code>            /i exch def</code>
<code>            masksym i pixs i get masks m get i get xor put</code>
<code>        } for</code>
<code>        masks length 1 ne {  % Not rMQR nor user-specified mask</code>
<code>            format (full) eq {</code>
<code>                masksym evalfull /score exch def</code>
<code>            } {</code>
<code>                masksym evalmicro /score exch def</code>
<code>            } ifelse</code>
<code>            score bestscore lt {</code>
<code>                /bestsym masksym def</code>
<code>                /bestmaskval m def</code>
<code>                /bestscore score def</code>
<code>            } if</code>
<code>        } {</code>
<code>            /bestsym masksym def</code>
<code>        } ifelse</code>
<code>    } for</code>
<code>    /pixs bestsym def</code>
<code></code>
<code>    % Set the solitary dark module in full symbols</code>
<code>    format (full) eq {</code>
<code>        pixs 8 cols 8 sub qmv 1 put</code>
<code>    } if</code>
<code></code>
<code>    % Add the format information</code>
<code>{</code>
<code>    /fmtvalsfull [</code>
<code>        16#5412 16#5125 16#5e7c 16#5b4b 16#45f9 16#40ce 16#4f97 16#4aa0</code>
<code>        16#77c4 16#72f3 16#7daa 16#789d 16#662f 16#6318 16#6c41 16#6976</code>
<code>        16#1689 16#13be 16#1ce7 16#19d0 16#0762 16#0255 16#0d0c 16#083b</code>
<code>        16#355f 16#3068 16#3f31 16#3a06 16#24b4 16#2183 16#2eda 16#2bed</code>
<code>    ] def</code>
<code>    /fmtvalsmicro [</code>
<code>        16#4445 16#4172 16#4e2b 16#4b1c 16#55ae 16#5099 16#5fc0 16#5af7</code>
<code>        16#6793 16#62a4 16#6dfd 16#68ca 16#7678 16#734f 16#7c16 16#7921</code>
<code>        16#06de 16#03e9 16#0cb0 16#0987 16#1735 16#1202 16#1d5b 16#186c</code>
<code>        16#2508 16#203f 16#2f66 16#2a51 16#34e3 16#31d4 16#3e8d 16#3bba</code>
<code>    ] def</code>
<code>    /fmtvalsrmqr1 [</code>
<code>        16#1fab2 16#1e597 16#1dbdd 16#1c4f8 16#1b86c 16#1a749 16#19903 16#18626</code>
<code>        16#17f0e 16#1602b 16#15e61 16#14144 16#13dd0 16#122f5 16#11cbf 16#1039a</code>
<code>        16#0f1ca 16#0eeef 16#0d0a5 16#0cf80 16#0b314 16#0ac31 16#0927b 16#08d5e</code>
<code>        16#07476 16#06b53 16#05519 16#04a3c 16#036a8 16#0298d 16#017c7 16#008e2</code>
<code>        16#3f367 16#3ec42 16#3d208 16#3cd2d 16#3b1b9 16#3ae9c 16#390d6 16#38ff3</code>
<code>        16#376db 16#369fe 16#357b4 16#34891 16#33405 16#32b20 16#3156a 16#30a4f</code>
<code>        16#2f81f 16#2e73a 16#2d970 16#2c655 16#2bac1 16#2a5e4 16#29bae 16#2848b</code>
<code>        16#27da3 16#26286 16#25ccc 16#243e9 16#23f7d 16#22058 16#21e12 16#20137</code>
<code>    ] def</code>
<code>    /fmtvalsrmqr2 [</code>
<code>        16#20a7b 16#2155e 16#22b14 16#23431 16#248a5 16#25780 16#269ca 16#276ef</code>
<code>        16#28fc7 16#290e2 16#2aea8 16#2b18d 16#2cd19 16#2d23c 16#2ec76 16#2f353</code>
<code>        16#30103 16#31e26 16#3206c 16#33f49 16#343dd 16#35cf8 16#362b2 16#37d97</code>
<code>        16#384bf 16#39b9a 16#3a5d0 16#3baf5 16#3c661 16#3d944 16#3e70e 16#3f82b</code>
<code>        16#003ae 16#01c8b 16#022c1 16#03de4 16#04170 16#05e55 16#0601f 16#07f3a</code>
<code>        16#08612 16#09937 16#0a77d 16#0b858 16#0c4cc 16#0dbe9 16#0e5a3 16#0fa86</code>
<code>        16#108d6 16#117f3 16#129b9 16#1369c 16#14a08 16#1552d 16#16b67 16#17442</code>
<code>        16#18d6a 16#1924f 16#1ac05 16#1b320 16#1cfb4 16#1d091 16#1eedb 16#1f1fe</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code>    format (full) eq {</code>
<code>        /ecid (MLHQ) eclevel search pop length exch pop exch pop def</code>
<code>        /fmtval fmtvalsfull ecid 3 bitshift bestmaskval add get def</code>
<code>        0 1 formatmap length 1 sub {</code>
<code>            /i exch def</code>
<code>            formatmap i get {</code>
<code>                pixs exch aload pop qmv fmtval 14 i sub neg bitshift 1 and put</code>
<code>            } forall</code>
<code>        } for</code>
<code>    } if</code>
<code>    format (micro) eq {</code>
<code>        /symid [ [0] [1 2] [3 4] [5 6 7] ] cols 11 sub 2 idiv get eclval get def</code>
<code>        /fmtval fmtvalsmicro symid 2 bitshift bestmaskval add get def</code>
<code>        0 1 formatmap length 1 sub {</code>
<code>            /i exch def</code>
<code>            pixs formatmap i get 0 get aload pop qmv fmtval 14 i sub neg bitshift 1 and put</code>
<code>        } for</code>
<code>    } if</code>
<code>    format (rmqr) eq {</code>
<code>        /fmtvalu (MH) eclevel search pop length exch pop exch pop 5 bitshift verind add def</code>
<code>        /fmtval1 fmtvalsrmqr1 fmtvalu get def</code>
<code>        /fmtval2 fmtvalsrmqr2 fmtvalu get def</code>
<code>        0 1 formatmap length 1 sub {</code>
<code>            /i exch def</code>
<code>            pixs formatmap i get 0 get aload pop qmv fmtval1 17 i sub neg bitshift 1 and put</code>
<code>            pixs formatmap i get 1 get aload pop qmv fmtval2 17 i sub neg bitshift 1 and put</code>
<code>        } for</code>
<code>    } if</code>
<code></code>
<code>    % Add the version information</code>
<code>{</code>
<code>    /vervals [</code>
<code>        16#07c94 16#085bc 16#09a99 16#0a4d3 16#0bbf6 16#0c762 16#0d847</code>
<code>        16#0e60d 16#0f928 16#10b78 16#1145d 16#12a17 16#13532 16#149a6</code>
<code>        16#15683 16#168c9 16#177ec 16#18ec4 16#191e1 16#1afab 16#1b08e</code>
<code>        16#1cc1a 16#1d33f 16#1ed75 16#1f250 16#209d5 16#216f0 16#228ba</code>
<code>        16#2379f 16#24b0b 16#2542e 16#26a64 16#27541 16#28c69</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code>    format (full) eq cols 45 ge and {</code>
<code>        /verval vervals cols 17 sub 4 idiv 7 sub get def</code>
<code>        0 1 versionmap length 1 sub {</code>
<code>            /i exch def</code>
<code>            versionmap i get {</code>
<code>                pixs exch {} forall qmv verval 17 i sub neg bitshift 1 and put</code>
<code>            } forall</code>
<code>        } for</code>
<code>    } if</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renmatrix</code>
<code>    /pixs pixs</code>
<code>    /pixx cols</code>
<code>    /pixy rows</code>
<code>    /height rows 2 mul 72 div</code>
<code>    /width cols 2 mul 72 div</code>
<code>    /borderleft format (full) eq {4.0} {2.0} ifelse</code>
<code>    /borderright format (full) eq {4.0} {2.0} ifelse</code>
<code>    /bordertop format (full) eq {4.0} {2.0} ifelse</code>
<code>    /borderbottom format (full) eq {4.0} {2.0} ifelse</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /qrcode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER qrcode--</code>
<code></code>
<code>% --BEGIN ENCODER swissqrcode--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix qrcode--</code>
<code>% --DESC: Swiss QR Code</code>
<code>% --EXAM:</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp swissqrcode 0.0 2024010300 72309 72208</code>
<code>%%BeginData:        117 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /qrcode dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/swissqrcode {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /parse false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Parse ordinals of the form ^NNN to ASCII</code>
<code>    /fncvals &lt;&lt;</code>
<code>        /parse parse</code>
<code>        /parseonly true</code>
<code>        /parsefnc false</code>
<code>    &gt;&gt; def</code>
<code>    /barcode barcode fncvals //parseinput exec def</code>
<code>    /barlen barcode length def</code>
<code>    options (parse) undef</code>
<code></code>
<code>    % Validate the input length</code>
<code>    barcode length 997 gt {</code>
<code>        /bwipp.swissqrcodeBadLength (Swiss QR Code input must not exceed 997 digits) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Get the result of encoding with qrcode</code>
<code>    options (dontdraw) true put</code>
<code>    /args barcode options //qrcode exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    % The 7mm-wide Swiss Cross is defined by the specification as being an</code>
<code>    % overlaid image, i.e. not made out of "modules", so very likely a</code>
<code>    % different pitch. It cannot therefore be represented by our standard image</code>
<code>    % dictionary and would be a nightmare to gridfit. The application assumes a</code>
<code>    % sufficient high-resolution print process that such issues do not matter.</code>
<code>    %</code>
<code>    % So for now we simply do as we're told and paint over the top of the</code>
<code>    % barcode image that has been scaled to 46mm, user be damned!</code>
<code>    %</code>
<code>    dontdraw not {</code>
<code></code>
<code>        gsave</code>
<code>        currentpoint translate</code>
<code>        72 25.4 div dup scale  % pt to mm</code>
<code></code>
<code>        % Clipping path with 7mm hole for the Swiss Cross</code>
<code>        gsave</code>
<code>        newpath</code>
<code>         0  0 moveto</code>
<code>        46  0 lineto</code>
<code>        46 46 lineto</code>
<code>         0 46 lineto</code>
<code>        closepath</code>
<code>        19.5 19.5 moveto</code>
<code>        19.5 26.5 lineto</code>
<code>        26.5 26.5 lineto</code>
<code>        26.5 19.5 lineto</code>
<code>        closepath</code>
<code>        clip</code>
<code></code>
<code>        % Scale the QR Code to fit within 46mm</code>
<code>        gsave</code>
<code>        0 0 moveto</code>
<code>        46 args (pixx) get div 2 div dup scale</code>
<code>        //renmatrix exec</code>
<code>        grestore</code>
<code></code>
<code>        grestore  % Clipping</code>
<code></code>
<code>        % Draw Swiss Cross</code>
<code>        19.5 dup translate</code>
<code>        7 83 div dup scale</code>
<code></code>
<code>        newpath</code>
<code>         6  6 moveto</code>
<code>         6 77 lineto</code>
<code>        77 77 lineto</code>
<code>        77  6 lineto</code>
<code>        closepath</code>
<code>        49 18 moveto</code>
<code>        49 34 lineto</code>
<code>        65 34 lineto</code>
<code>        65 49 lineto</code>
<code>        49 49 lineto</code>
<code>        49 65 lineto</code>
<code>        34 65 lineto</code>
<code>        34 49 lineto</code>
<code>        18 49 lineto</code>
<code>        18 34 lineto</code>
<code>        34 34 lineto</code>
<code>        34 18 lineto</code>
<code>        closepath</code>
<code>        0 0 0 setrgbcolor fill</code>
<code></code>
<code>        grestore</code>
<code></code>
<code>    } if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /swissqrcode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER swissqrcode--</code>
<code></code>
<code>% --BEGIN ENCODER microqrcode--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix qrcode--</code>
<code>% --DESC: Micro QR Code</code>
<code>% --EXAM: 1234</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp microqrcode 0.0 2024010300 63569 66972</code>
<code>%%BeginData:         36 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /qrcode dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/microqrcode {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Get the result of encoding with qrcode with format=micro</code>
<code>    options (dontdraw) true put</code>
<code>    options (format) (micro) put</code>
<code></code>
<code>    /args barcode options //qrcode exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /microqrcode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER microqrcode--</code>
<code></code>
<code>% --BEGIN ENCODER rectangularmicroqrcode--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix qrcode--</code>
<code>% --DESC: Rectangular Micro QR Code</code>
<code>% --EXAM: 1234</code>
<code>% --EXOP: version=R17x139</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp rectangularmicroqrcode 0.0 2024010300 63612 67004</code>
<code>%%BeginData:         36 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /qrcode dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/rectangularmicroqrcode {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Get the result of encoding with qrcode with format=micro</code>
<code>    options (dontdraw) true put</code>
<code>    options (format) (rmqr) put</code>
<code></code>
<code>    /args barcode options //qrcode exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /rectangularmicroqrcode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER rectangularmicroqrcode--</code>
<code></code>
<code>% --BEGIN ENCODER maxicode--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmaximatrix--</code>
<code>% --DESC: MaxiCode</code>
<code>% --EXAM: [)&gt;^03001^02996152382802^029840^029001^0291Z00004951^029UPSN^02906X610^029159^0291234567^0291/1^029^029Y^029634 ALPHA DR^029PITTSBURGH^029PA^029^004</code>
<code>% --EXOP: mode=2 parse</code>
<code>% --RNDR: renmaximatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp maxicode 0.0 2024010300 145168 147563</code>
<code>%%BeginData:        670 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmaximatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/maxicode {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /mode -1 def</code>
<code>    /sam -1 def</code>
<code>    /parse false def</code>
<code>    /parsefnc false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.maxicodeEmptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    mode -1 ne mode 2 lt mode 6 gt or and {</code>
<code>       /bwipp.maxicodeBadMode (Mode must be 2 to 6) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    sam -1 ne {</code>
<code>        true</code>
<code>        1 {</code>
<code>            sam dup 12 lt exch 88 gt or { pop false exit } if</code>
<code>            sam 10 mod dup 2 lt exch 8 gt or { pop false exit } if</code>
<code>            sam 10 idiv sam 10 mod gt { pop false exit } if</code>
<code>        } repeat</code>
<code>        not {</code>
<code>            /bwipp.maxicodeBadSAM (SAM must be formatted as "NM" for Nth of M symbols, from 2 to 8 symbols) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    /maxicode //loadctx exec</code>
<code></code>
<code>    % Parse the input</code>
<code>    /fncvals &lt;&lt;</code>
<code>        /parse parse</code>
<code>        /parsefnc parsefnc</code>
<code>        /eci true</code>
<code>        % ECIs only</code>
<code>    &gt;&gt; def</code>
<code>    /msg barcode fncvals //parseinput exec def</code>
<code>    /msglen msg length def</code>
<code></code>
<code>    % Special message handling for modes 2 and 3</code>
<code>    mode 2 eq mode 3 eq or {</code>
<code></code>
<code>        % Convert to a string for extracting the structured data</code>
<code>        /barcode msglen string def</code>
<code>        0 1 msglen 1 sub {</code>
<code>            /i exch def</code>
<code>            msg i get 0 gt {</code>
<code>                barcode i msg i get put</code>
<code>            } if</code>
<code>        } for</code>
<code>        /barlen barcode length def</code>
<code></code>
<code>        % Normalise messages that begin with a field identifier [)&gt;{RS}01{GS}yy</code>
<code>        /fid () def</code>
<code>        barlen 7 ge {</code>
<code>            barcode 0 7 getinterval &lt;5b293e1e30311d&gt; eq {</code>
<code>                /fid barcode 0 9 getinterval def</code>
<code>                /barcode barcode 9 barlen 9 sub getinterval def</code>
<code>            } if</code>
<code>        } if</code>
<code></code>
<code>        % Read the postcode, country code and service code fields separated by GS</code>
<code>        barcode</code>
<code>        &lt;1d&gt; search {</code>
<code>            /pcode exch def pop</code>
<code>            mode 2 eq {</code>
<code>                true</code>
<code>                1 {</code>
<code>                    pcode length 9 gt { pop false exit } if</code>
<code>                    pcode { dup 48 lt exch 57 gt or { pop false exit } if } forall</code>
<code>                } repeat</code>
<code>                not {</code>
<code>                    pop /bwipp.maxicodeBadMode2PostCode (A mode 2 postcode must not exceed 9 digits) //raiseerror exec</code>
<code>                } if</code>
<code>            } {  % mode=3</code>
<code>                pcode {</code>
<code>                         dup     32 eq                    % SP</code>
<code>                    exch dup dup 34 ge exch 58 le and     % punct, 0-9, :</code>
<code>                    exch dup 65 ge exch 90 le and         % A-Z</code>
<code>                    or or not {</code>
<code>                        pop /bwipp.maxicodeBadMode3PostCode (A mode 3 postcode must not exceed 6 characters) //raiseerror exec</code>
<code>                    } if</code>
<code>                } forall</code>
<code>            } ifelse</code>
<code>        } {</code>
<code>            pop /bwipp.maxicodeExpectedPostCode (Expected postcode followed by group separator character) //raiseerror exec</code>
<code>        } ifelse</code>
<code>        &lt;1d&gt; search {</code>
<code>            /ccode exch def pop</code>
<code>            true</code>
<code>            1 {</code>
<code>                ccode length 3 ne { pop false exit } if</code>
<code>                ccode { dup 48 lt exch 57 gt or { pop false exit } if } forall</code>
<code>            } repeat</code>
<code>            not {</code>
<code>                pop /bwipp.maxicodeBadCountryCode (Country code must be three digits) //raiseerror exec</code>
<code>            } if</code>
<code>        } {</code>
<code>            pop /bwipp.maxicodeExpectedCountryCode (Expected country code followed by group separator character) //raiseerror exec</code>
<code>        } ifelse</code>
<code>        &lt;1d&gt; search {</code>
<code>            /scode exch def pop</code>
<code>            true</code>
<code>            1 {</code>
<code>                scode length 3 ne { pop false exit } if</code>
<code>                scode { dup 48 lt exch 57 gt or { pop false exit } if } forall</code>
<code>            } repeat</code>
<code>            not {</code>
<code>                pop /bwipp.maxicodeBadServiceClass (Service class must be three digits) //raiseerror exec</code>
<code>            } if</code>
<code>        } {</code>
<code>            pop /bwipp.maxicodeExpectedServiceClass (Expected service class followed by group separator character) //raiseerror exec</code>
<code>        } ifelse</code>
<code>        /barcode exch def</code>
<code></code>
<code>        % Prepend the field identifier</code>
<code>        barcode length fid length add string dup</code>
<code>        0 fid putinterval dup</code>
<code>        fid length barcode putinterval</code>
<code>        /barcode exch def</code>
<code>        /barlen barcode length def</code>
<code></code>
<code>        /msg [ barcode {} forall ] def</code>
<code>        /msglen msg length def</code>
<code></code>
<code>    } if</code>
<code></code>
<code>{</code>
<code>    % Special function characters</code>
<code>    /eci -1 def  /pad -2 def  /ns -3 def</code>
<code>    /la  -4 def  /lb  -5 def</code>
<code>    /sa  -6 def  /sb  -7 def  /sc -8 def  /sd -9 def  /se -10 def</code>
<code>    /sa2 -11 def /sa3 -12 def</code>
<code>    /lkc -13 def /lkd -14 def /lke -15 def</code>
<code>    /pd2 -16 def /pd3 -17 def</code>
<code></code>
<code>    % Character maps for each state</code>
<code>    /charmaps [</code>
<code>        %  A    B    C    D    E</code>
<code>        [  13  (`)  192  224    0 ]  % 0</code>
<code>        [ (A)  (a)  193  225    1 ]  % 1</code>
<code>        [ (B)  (b)  194  226    2 ]  % 2</code>
<code>        [ (C)  (c)  195  227    3 ]  % 3</code>
<code>        [ (D)  (d)  196  228    4 ]  % 4</code>
<code>        [ (E)  (e)  197  229    5 ]  % 5</code>
<code>        [ (F)  (f)  198  230    6 ]  % 6</code>
<code>        [ (G)  (g)  199  231    7 ]  % 7</code>
<code>        [ (H)  (h)  200  232    8 ]  % 8</code>
<code>        [ (I)  (i)  201  233    9 ]  % 9</code>
<code>        [ (J)  (j)  202  234   10 ]  % 10</code>
<code>        [ (K)  (k)  203  235   11 ]  % 11</code>
<code>        [ (L)  (l)  204  236   12 ]  % 12</code>
<code>        [ (M)  (m)  205  237   13 ]  % 13</code>
<code>        [ (N)  (n)  206  238   14 ]  % 14</code>
<code>        [ (O)  (o)  207  239   15 ]  % 15</code>
<code>        [ (P)  (p)  208  240   16 ]  % 16</code>
<code>        [ (Q)  (q)  209  241   17 ]  % 17</code>
<code>        [ (R)  (r)  210  242   18 ]  % 18</code>
<code>        [ (S)  (s)  211  243   19 ]  % 19</code>
<code>        [ (T)  (t)  212  244   20 ]  % 20</code>
<code>        [ (U)  (u)  213  245   21 ]  % 21</code>
<code>        [ (V)  (v)  214  246   22 ]  % 22</code>
<code>        [ (W)  (w)  215  247   23 ]  % 23</code>
<code>        [ (X)  (x)  216  248   24 ]  % 24</code>
<code>        [ (Y)  (y)  217  249   25 ]  % 25</code>
<code>        [ (Z)  (z)  218  250   26 ]  % 26</code>
<code>        [ eci  eci  eci  eci  eci ]  % 27</code>
<code>        [  28   28   28   28  pad ]  % 28</code>
<code>        [  29   29   29   29  pad ]  % 29</code>
<code>        [  30   30   30   30   27 ]  % 30</code>
<code>        [  ns   ns   ns   ns   ns ]  % 31</code>
<code>        [ ( )  ({)  219  251   28 ]  % 32</code>
<code>        [ pad  pad  220  252   29 ]  % 33</code>
<code>        [ (")  (})  221  253   30 ]  % 34</code>
<code>        [ (#)  (~)  222  254   31 ]  % 35</code>
<code>        [ ($)  127  223  255  159 ]  % 36</code>
<code>        [ (%)  (;)  170  161  160 ]  % 37</code>
<code>        [ (&amp;)  (&lt;)  172  168  162 ]  % 38</code>
<code>        [ (')  (=)  177  171  163 ]  % 39</code>
<code>        [  40  (&gt;)  178  175  164 ]  % 40</code>
<code>        [  41  (?)  179  176  165 ]  % 41</code>
<code>        [ (*)  ([)  181  180  166 ]  % 42</code>
<code>        [ (+)   92  185  183  167 ]  % 43</code>
<code>        [ (,)  (])  186  184  169 ]  % 44</code>
<code>        [ (-)  (^)  188  187  173 ]  % 45</code>
<code>        [ (.)  (_)  189  191  174 ]  % 46</code>
<code>        [ (/)  ( )  190  138  182 ]  % 47</code>
<code>        [ (0)  (,)  128  139  149 ]  % 48</code>
<code>        [ (1)  (.)  129  140  150 ]  % 49</code>
<code>        [ (2)  (/)  130  141  151 ]  % 50</code>
<code>        [ (3)  (:)  131  142  152 ]  % 51</code>
<code>        [ (4)  (@)  132  143  153 ]  % 52</code>
<code>        [ (5)  (!)  133  144  154 ]  % 53</code>
<code>        [ (6)  (|)  134  145  155 ]  % 54</code>
<code>        [ (7)  pd2  135  146  156 ]  % 55</code>
<code>        [ (8)  sa2  136  147  157 ]  % 56</code>
<code>        [ (9)  sa3  137  148  158 ]  % 57</code>
<code>        [ (:)  pd3   la   la   la ]  % 58</code>
<code>        [  sb   sa  ( )  ( )  ( ) ]  % 59</code>
<code>        [  sc   sc  lkc   sc   sc ]  % 60</code>
<code>        [  sd   sd   sd  lkd   sd ]  % 61</code>
<code>        [  se   se   se   se  lke ]  % 62</code>
<code>        [  lb   la   lb   lb   lb ]  % 63</code>
<code>    ] def</code>
<code></code>
<code>    % Invert charmaps to give character to value maps for each state</code>
<code>    /charvals [ 64 dict 64 dict 64 dict 64 dict 64 dict ] def</code>
<code>    0 1 charmaps length 1 sub {</code>
<code>        /i exch def</code>
<code>        /encs charmaps i get def</code>
<code>        0 1 4 {</code>
<code>            /j exch def</code>
<code>            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required</code>
<code>            charvals j get exch i put</code>
<code>        } for</code>
<code>    } for</code>
<code>    /seta charvals 0 get def</code>
<code>    /setb charvals 1 get def</code>
<code>    /setc charvals 2 get def</code>
<code>    /setd charvals 3 get def</code>
<code>    /sete charvals 4 get def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Compute numeric runlengths</code>
<code>    /nseq [ msglen 1 add {0} repeat ] def</code>
<code>    msglen 1 sub -1 0 {</code>
<code>        /i exch def</code>
<code>        msg i get dup 48 ge exch 57 le and {</code>
<code>            nseq i nseq i 1 add get 1 add put</code>
<code>        } {</code>
<code>            nseq i 0 put</code>
<code>        } ifelse</code>
<code>    } for</code>
<code>    /nseq nseq 0 msglen getinterval def</code>
<code></code>
<code>    % Encode the message from ASCII to codewords</code>
<code>    /prefixinset {</code>
<code>        0 {</code>
<code>            2 copy exch length ge {exit} if</code>
<code>            2 copy get 3 index exch known {1 add} {exit} ifelse</code>
<code>        } loop</code>
<code>        exch pop exch pop</code>
<code>    } def</code>
<code></code>
<code>    /enc {</code>
<code>        exch get out exch j exch put</code>
<code>        /j j 1 add def</code>
<code>    } def</code>
<code></code>
<code>    /out 144 array def</code>
<code>    /i 0 def /j 0 def /cset (seta) def</code>
<code>    { % loop</code>
<code>        % Exit when no characters remain latching back to A if necessary</code>
<code>        i msglen eq {</code>
<code>            cset (seta) ne cset (setb) ne and {</code>
<code>                la cset load enc</code>
<code>                /cset (seta) def</code>
<code>            } if</code>
<code>            exit</code>
<code>        } if</code>
<code>        { % not a loop but common exit point</code>
<code>            % Immediately encode an ECI</code>
<code>            msg i get -1000000 le {</code>
<code>                eci cset load enc</code>
<code>                msg i get neg 1000000 sub</code>
<code>                    dup 000031 le {  % ECI 000000 - 000031</code>
<code>                                         63 and</code>
<code>                        1 array astore</code>
<code>                } { dup 001023 le {  % ECI 000032 - 001023</code>
<code>                        dup  -6 bitshift 31 and 32 or exch</code>
<code>                                         63 and</code>
<code>                        2 array astore</code>
<code>                } { dup 032767 le {  % ECI 001024 - 032767</code>
<code>                        dup -12 bitshift 47 and 48 or exch</code>
<code>                        dup  -6 bitshift 63 and       exch</code>
<code>                                         63 and</code>
<code>                        3 array astore</code>
<code>                } {                  % ECI 032768 - 999999</code>
<code>                        dup -18 bitshift 55 and 56 or exch</code>
<code>                        dup -12 bitshift 63 and       exch</code>
<code>                        dup  -6 bitshift 63 and       exch</code>
<code>                                         63 and</code>
<code>                        4 array astore</code>
<code>                } ifelse } ifelse } ifelse</code>
<code>                dup out exch j exch putinterval</code>
<code>                length j add /j exch def</code>
<code>                /i i 1 add def</code>
<code>                exit</code>
<code>            } if</code>
<code></code>
<code>            % If 9 numerals available then use NS</code>
<code>            nseq i get 9 ge {</code>
<code>                msg i 9 getinterval 0 exch {48 sub add 10 mul} forall 10 idiv</code>
<code>                4 { dup 63 and exch -6 bitshift } repeat cset load ns get</code>
<code>                0 2 10 {index} for 6 array astore 7 1 roll 6 {pop} repeat</code>
<code>                out exch j exch putinterval</code>
<code>                /i i 9 add def</code>
<code>                /j j 6 add def</code>
<code>                exit</code>
<code>            } if</code>
<code></code>
<code>            % Read next three characters</code>
<code>            /char1 msg i get def</code>
<code>            /char2 i 1 add msglen lt {msg i 1 add get} {-99} ifelse def</code>
<code>            /char3 i 2 add msglen lt {msg i 2 add get} {-99} ifelse def</code>
<code></code>
<code>            % If current mode is sufficient then directly encode</code>
<code>            cset load char1 known {</code>
<code>                char1 cset load enc</code>
<code>                /i i 1 add def</code>
<code>                exit</code>
<code>            } if</code>
<code></code>
<code>            % For switching from A to B</code>
<code>            cset (seta) eq setb char1 known and {</code>
<code>                setb char2 known {</code>
<code>                    lb seta enc</code>
<code>                    /cset (setb) def</code>
<code>                } {</code>
<code>                    sb seta enc</code>
<code>                    char1 setb enc</code>
<code>                    /i i 1 add def</code>
<code>                } ifelse</code>
<code>                exit</code>
<code>            } if</code>
<code></code>
<code>            % For switching from B to A encode according to length of prefix</code>
<code>            cset (setb) eq seta char1 known and {</code>
<code>                /p seta msg i 4 msglen i sub 2 copy gt {exch} if pop getinterval prefixinset def</code>
<code>                p 1 eq {</code>
<code>                    sa setb enc</code>
<code>                    char1 seta enc</code>
<code>                    /i i 1 add def</code>
<code>                } if</code>
<code>                p 2 eq {</code>
<code>                    sa2 setb enc</code>
<code>                    char1 seta enc</code>
<code>                    char2 seta enc</code>
<code>                    /i i 2 add def</code>
<code>                } if</code>
<code>                p 3 eq {</code>
<code>                    sa3 setb enc</code>
<code>                    char1 seta enc</code>
<code>                    char2 seta enc</code>
<code>                    char3 seta enc</code>
<code>                    /i i 3 add def</code>
<code>                } if</code>
<code>                p 4 ge {</code>
<code>                    la setb enc</code>
<code>                    /cset (seta) def</code>
<code>                } if</code>
<code>                exit</code>
<code>            } if</code>
<code></code>
<code>            % If character is in A or B then directly latch</code>
<code>            seta char1 known {</code>
<code>                la cset load enc</code>
<code>                /cset (seta) def</code>
<code>                exit</code>
<code>            } if</code>
<code>            setb char1 known {</code>
<code>                lb cset load enc</code>
<code>                /cset (setb) def</code>
<code>                exit</code>
<code>            } if</code>
<code></code>
<code>            % Determine which one of sets C, D or E the character is in</code>
<code>            setc char1 known {/setx (setc) def /sx sc def /lkx lkc def} if</code>
<code>            setd char1 known {/setx (setd) def /sx sd def /lkx lkd def} if</code>
<code>            sete char1 known {/setx (sete) def /sx se def /lkx lke def} if</code>
<code></code>
<code>            % Encode according to the length of the prefix</code>
<code>            /p setx load msg i 4 msglen i sub 2 copy gt {exch} if pop getinterval prefixinset def</code>
<code>            p 1 eq {</code>
<code>                sx cset load enc</code>
<code>                char1 setx load enc</code>
<code>                /i i 1 add def</code>
<code>            } if</code>
<code>            p 2 eq {</code>
<code>                sx cset load enc</code>
<code>                char1 setx load enc</code>
<code>                sx cset load enc</code>
<code>                char2 setx load enc</code>
<code>                /i i 2 add def</code>
<code>            } if</code>
<code>            p 3 eq {</code>
<code>                sx cset load enc</code>
<code>                char1 setx load enc</code>
<code>                sx cset load enc</code>
<code>                char2 setx load enc</code>
<code>                sx cset load enc</code>
<code>                char3 setx load enc</code>
<code>                /i i 3 add def</code>
<code>            } if</code>
<code>            p 4 ge {</code>
<code>                sx cset load enc</code>
<code>                lkx setx load enc</code>
<code>                /cset setx def</code>
<code>            } if</code>
<code></code>
<code>            exit</code>
<code>        } loop  % out</code>
<code>    } loop</code>
<code>    /encmsg out 0 j getinterval def</code>
<code>    /padval cset load pad get def</code>
<code></code>
<code>    % Prefix the encoded message with the structured append insert</code>
<code>    /sami sam -1 ne { [ seta pad get sam 10 idiv 1 sub 8 mul sam 10 mod 1 sub add ] } { [] } ifelse def</code>
<code>    /encmsg [ sami aload pop encmsg aload pop ] def</code>
<code></code>
<code>    % Derive the primary and secondary codewords for modes 2 and 3</code>
<code>    mode 2 eq mode 3 eq or {</code>
<code></code>
<code>        encmsg length 84 gt {</code>
<code>            /bwipp.maxicodeMode23TooLong (The secondary message is too long) //raiseerror exec</code>
<code>        } if</code>
<code></code>
<code>        % Calculate the fixed-width binary values for the mode, postcode, country code and service</code>
<code>        /mdb (0000) 4 string copy dup mode cvi 2 4 string cvrs dup length 4 exch sub exch putinterval def</code>
<code>        /ccb (0000000000) 10 string copy dup ccode cvi 2 10 string cvrs dup length 10 exch sub exch putinterval def</code>
<code>        /scb (0000000000) 10 string copy dup scode cvi 2 10 string cvrs dup length 10 exch sub exch putinterval def</code>
<code>        /pcb (000000000000000000000000000000000000) 36 string copy def</code>
<code>        mode 2 eq {</code>
<code>            % For numeric postcode, first six bits represent length and remaining 30 bits the value</code>
<code>            pcb pcode length 2 6 string cvrs dup length 6 exch sub exch putinterval</code>
<code>            pcb pcode cvi 2 30 string cvrs dup length 36 exch sub exch putinterval</code>
<code>        } {  % mode=3</code>
<code>            % For alphanumeric postcode, trim or pad with spaces to 6 chars and encode to binary</code>
<code>            /pccw [</code>
<code>                (      ) 6 string copy dup 0 pcode length 6 gt {pcode 0 6 getinterval} {pcode} ifelse putinterval</code>
<code>                {seta exch get} forall</code>
<code>            ] def</code>
<code>            0 1 5 {</code>
<code>                /i exch def</code>
<code>                pcb pccw i get 2 6 string cvrs dup length 6 i mul 6 add exch sub exch putinterval</code>
<code>            } for</code>
<code>        } ifelse</code>
<code></code>
<code>        % Convolute the binary values into the structured carrier message</code>
<code>        /scm 60 string def</code>
<code>        scm 2  mdb putinterval</code>
<code>        scm 38 pcb 0  4 getinterval putinterval</code>
<code>        scm 30 pcb 4  6 getinterval putinterval</code>
<code>        scm 24 pcb 10 6 getinterval putinterval</code>
<code>        scm 18 pcb 16 6 getinterval putinterval</code>
<code>        scm 12 pcb 22 6 getinterval putinterval</code>
<code>        scm 6  pcb 28 6 getinterval putinterval</code>
<code>        scm 0  pcb 34 2 getinterval putinterval</code>
<code>        scm 52 ccb 0  2 getinterval putinterval</code>
<code>        scm 42 ccb 2  6 getinterval putinterval</code>
<code>        scm 36 ccb 8  2 getinterval putinterval</code>
<code>        scm 54 scb 0  6 getinterval putinterval</code>
<code>        scm 48 scb 6  4 getinterval putinterval</code>
<code></code>
<code>        % Evaluate the structured carrier message as codewords</code>
<code>        /pri [ 0 0 0 0 0 0 0 0 0 0 ] def</code>
<code>        0 1 59 {</code>
<code>            /i exch def</code>
<code>            /ps i 6 idiv def</code>
<code>            /ep 2 5 i 6 mod sub exp cvi scm i get 48 sub mul def</code>
<code>            pri ps pri ps get ep add put</code>
<code>        } for</code>
<code></code>
<code>        % Pad the encoded message into the secondary component</code>
<code>        /sec [ 84 {padval} repeat ] def</code>
<code>        sec 0 encmsg putinterval</code>
<code></code>
<code>    } if</code>
<code></code>
<code>    % Derive the primary and secondary codewords for modes 4, 5 and 6</code>
<code>    mode 4 eq mode 5 eq or mode 6 eq or mode -1 eq or {</code>
<code></code>
<code>        % If mode isn't specified then use EEC if message fits, otherwise SEC</code>
<code>        mode -1 eq {</code>
<code>            /mode encmsg length 77 le {5} {4} ifelse def</code>
<code>        } if</code>
<code></code>
<code>        /cws [ mode 5 eq {78} {94} ifelse {padval} repeat ] def</code>
<code>        encmsg length cws length 1 sub gt {</code>
<code>            /bwipp.maxicodeMode56TooLong (The message is too long) //raiseerror exec</code>
<code>        } if</code>
<code>        cws 0 mode put</code>
<code>        cws 1 encmsg putinterval</code>
<code></code>
<code>        % Fit the message into the primary and secondary components</code>
<code>        /pri cws 0 10 getinterval def</code>
<code>        /sec cws 10 cws length 10 sub getinterval def</code>
<code></code>
<code>    } if</code>
<code></code>
<code>    % Calculate the log and anti-log tables</code>
<code>{</code>
<code>    /rsalog [ 1 63 { dup 2 mul dup 64 ge {67 xor} if } repeat ] def</code>
<code>    /rslog 64 array def</code>
<code>    1 1 63 {dup rsalog exch get exch rslog 3 1 roll put} for</code>
<code>} ctxdef</code>
<code></code>
<code>    % Function to calculate the product in the field</code>
<code>    /rsprod {</code>
<code>        2 copy 0 ne exch 0 ne and {</code>
<code>            rslog exch get exch rslog exch get add 63 mod rsalog exch get</code>
<code>        } {</code>
<code>            pop pop 0</code>
<code>        } ifelse</code>
<code>    } def</code>
<code></code>
<code>    % Generate error correction codewords</code>
<code>    /rscodes {</code>
<code></code>
<code>        /rsnum exch def</code>
<code>        /cwb exch def</code>
<code></code>
<code>        % Generate the coefficients</code>
<code>        /coeffs [ 1 rsnum {0} repeat ] def</code>
<code>        1 1 rsnum {</code>
<code>            /i exch def</code>
<code>            coeffs i coeffs i 1 sub get put</code>
<code>            i 1 sub -1 1 {</code>
<code>                /j exch def</code>
<code>                coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put</code>
<code>            } for</code>
<code>            coeffs 0 coeffs 0 get rsalog i get rsprod put</code>
<code>        } for</code>
<code>        /coeffs coeffs 0 coeffs length 1 sub getinterval def</code>
<code></code>
<code>        % Calculate the error correction codewords</code>
<code>        /ecb [ rsnum {0} repeat ] def</code>
<code>        0 1 cwb length 1 sub {</code>
<code>            /t exch cwb exch get ecb 0 get xor def</code>
<code>            ecb length 1 sub -1 0 {</code>
<code>                /i exch def</code>
<code>                /p ecb length i sub 1 sub def</code>
<code>                ecb p t coeffs i get rsprod put</code>
<code>                i 0 gt { ecb p ecb p 1 add get ecb p get xor put } if</code>
<code>            } for</code>
<code>        } for</code>
<code></code>
<code>        ecb</code>
<code></code>
<code>    } def</code>
<code></code>
<code>    % Split secondary codeword into odd and even elements</code>
<code>    /seco [ 0 2 sec length 1 sub { sec exch get } for ] def</code>
<code>    /sece [ 1 2 sec length 1 sub { sec exch get } for ] def</code>
<code></code>
<code>    % Calculate the parity codewords for secondary codeword parts based on mode</code>
<code>    /scodes sec length 84 eq {20} {28} ifelse def  % SEC/EEC mode</code>
<code>    /secochk seco scodes rscodes def</code>
<code>    /secechk sece scodes rscodes def</code>
<code></code>
<code>    % Recompose the secondary parity codewords</code>
<code>    /secchk [ 0 1 scodes 1 sub { dup secochk exch get exch secechk exch get } for ] def</code>
<code></code>
<code>    % Concatenate the data into final codewords</code>
<code>    /codewords [</code>
<code>        pri aload pop</code>
<code>        pri 10 rscodes aload pop</code>
<code>        sec aload pop</code>
<code>        secchk aload pop</code>
<code>    ] def</code>
<code></code>
<code>    % Convert the codewords into module bits</code>
<code>    /mods [ 864 {0} repeat ] def</code>
<code>    0 1 143 {</code>
<code>        /i exch def</code>
<code>        /cw [ codewords i get 2 6 string cvrs {48 sub} forall ] def</code>
<code>        mods 6 i mul 6 cw length sub add cw putinterval</code>
<code>    } for</code>
<code></code>
<code>    % Maps modules to pixels in the grid</code>
<code>{</code>
<code>    /modmap [</code>
<code>        469 529 286 316 347 346 673 672 703 702 647 676 283 282 313 312 370 610 618 379</code>
<code>        378 409 408 439 705 704 559 589 588 619 458 518 640 701 675 674 285 284 315 314</code>
<code>        310 340 531 289 288 319 349 348 456 486 517 516 471 470 369 368 399 398 429 428</code>
<code>        549 548 579 578 609 608 649 648 679 678 709 708 639 638 669 668 699 698 279 278</code>
<code>        309 308 339 338 381 380 411 410 441 440 561 560 591 590 621 620 547 546 577 576</code>
<code>        607 606 367 366 397 396 427 426 291 290 321 320 351 350 651 650 681 680 711 710</code>
<code>        1   0   31  30  61  60  3   2   33  32  63  62  5   4   35  34  65  64  7   6</code>
<code>        37  36  67  66  9   8   39  38  69  68  11  10  41  40  71  70  13  12  43  42</code>
<code>        73  72  15  14  45  44  75  74  17  16  47  46  77  76  19  18  49  48  79  78</code>
<code>        21  20  51  50  81  80  23  22  53  52  83  82  25  24  55  54  85  84  27  26</code>
<code>        57  56  87  86  117 116 147 146 177 176 115 114 145 144 175 174 113 112 143 142</code>
<code>        173 172 111 110 141 140 171 170 109 108 139 138 169 168 107 106 137 136 167 166</code>
<code>        105 104 135 134 165 164 103 102 133 132 163 162 101 100 131 130 161 160 99  98</code>
<code>        129 128 159 158 97  96  127 126 157 156 95  94  125 124 155 154 93  92  123 122</code>
<code>        153 152 91  90  121 120 151 150 181 180 211 210 241 240 183 182 213 212 243 242</code>
<code>        185 184 215 214 245 244 187 186 217 216 247 246 189 188 219 218 249 248 191 190</code>
<code>        221 220 251 250 193 192 223 222 253 252 195 194 225 224 255 254 197 196 227 226</code>
<code>        257 256 199 198 229 228 259 258 201 200 231 230 261 260 203 202 233 232 263 262</code>
<code>        205 204 235 234 265 264 207 206 237 236 267 266 297 296 327 326 357 356 295 294</code>
<code>        325 324 355 354 293 292 323 322 353 352 277 276 307 306 337 336 275 274 305 304</code>
<code>        335 334 273 272 303 302 333 332 271 270 301 300 331 330 361 360 391 390 421 420</code>
<code>        363 362 393 392 423 422 365 364 395 394 425 424 383 382 413 412 443 442 385 384</code>
<code>        415 414 445 444 387 386 417 416 447 446 477 476 507 506 537 536 475 474 505 504</code>
<code>        535 534 473 472 503 502 533 532 455 454 485 484 515 514 453 452 483 482 513 512</code>
<code>        451 450 481 480 511 510 541 540 571 570 601 600 543 542 573 572 603 602 545 544</code>
<code>        575 574 605 604 563 562 593 592 623 622 565 564 595 594 625 624 567 566 597 596</code>
<code>        627 626 657 656 687 686 717 716 655 654 685 684 715 714 653 652 683 682 713 712</code>
<code>        637 636 667 666 697 696 635 634 665 664 695 694 633 632 663 662 693 692 631 630</code>
<code>        661 660 691 690 721 720 751 750 781 780 723 722 753 752 783 782 725 724 755 754</code>
<code>        785 784 727 726 757 756 787 786 729 728 759 758 789 788 731 730 761 760 791 790</code>
<code>        733 732 763 762 793 792 735 734 765 764 795 794 737 736 767 766 797 796 739 738</code>
<code>        769 768 799 798 741 740 771 770 801 800 743 742 773 772 803 802 745 744 775 774</code>
<code>        805 804 747 746 777 776 807 806 837 836 867 866 897 896 835 834 865 864 895 894</code>
<code>        833 832 863 862 893 892 831 830 861 860 891 890 829 828 859 858 889 888 827 826</code>
<code>        857 856 887 886 825 824 855 854 885 884 823 822 853 852 883 882 821 820 851 850</code>
<code>        881 880 819 818 849 848 879 878 817 816 847 846 877 876 815 814 845 844 875 874</code>
<code>        813 812 843 842 873 872 811 810 841 840 871 870 901 900 931 930 961 960 903 902</code>
<code>        933 932 963 962 905 904 935 934 965 964 907 906 937 936 967 966 909 908 939 938</code>
<code>        969 968 911 910 941 940 971 970 913 912 943 942 973 972 915 914 945 944 975 974</code>
<code>        917 916 947 946 977 976 919 918 949 948 979 978 921 920 951 950 981 980 923 922</code>
<code>        953 952 983 982 925 924 955 954 985 984 927 926 957 956 987 986 58  89  88  118</code>
<code>        149 148 178 209 208 238 269 268 298 329 328 358 389 388 418 449 448 478 509 508</code>
<code>        538 569 568 598 629 628 658 689 688 718 749 748 778 809 808 838 869 868 898 929</code>
<code>        928 958 989 988</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Lookup pixels for enabled modules from modmap</code>
<code>    /pixs 864 array def</code>
<code>    /j 0 def</code>
<code>    0 1 mods length 1 sub {</code>
<code>        /i exch def</code>
<code>        mods i get 1 eq {</code>
<code>            pixs j modmap i get put</code>
<code>            /j j 1 add def</code>
<code>        } if</code>
<code>    } for</code>
<code>    /pixs [ pixs 0 j getinterval aload pop 28 29 280 281 311 457 488 500 530 670 700 677 707 ] def</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renmaximatrix</code>
<code>    /pixs pixs</code>
<code>    /borderleft 1.0</code>
<code>    /borderright 1.0</code>
<code>    /bordertop 1.0</code>
<code>    /borderbottom 1.0</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renmaximatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /maxicode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER maxicode--</code>
<code></code>
<code>% --BEGIN ENCODER azteccode--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix--</code>
<code>% --DESC: Aztec Code</code>
<code>% --EXAM: This is Aztec Code</code>
<code>% --EXOP: format=full</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp azteccode 0.0 2024010300 195169 206938</code>
<code>%%BeginData:        825 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/azteccode {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /format (full) def    % full, compact or rune</code>
<code>    /readerinit false def</code>
<code>    /layers -1 def</code>
<code>    /eclevel 23 def</code>
<code>    /ecaddchars 3 def</code>
<code>    /raw false def</code>
<code>    /parse false def</code>
<code>    /parsefnc false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /azteccode //loadctx exec</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.aztecEmptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    eclevel 5 lt eclevel 95 gt or {</code>
<code>        /bwipp.aztecInvalidEClevel (The EC percentage must be from 5 to 95) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    ecaddchars 3 lt {</code>
<code>        /bwipp.aztecInvalidECaddChars (The number of additional EC codewords must be 3 or more) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    format (full) ne format (compact) ne format (rune) ne and and {</code>
<code>        /bwipp.aztecInvalidFormat (The format must be either full, compact or rune) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    format (full) eq {</code>
<code>        readerinit layers 1 lt layers 22 gt or and {</code>
<code>            /bwipp.aztecFullInitInvalidLayers (Full-range symbols for reader programming must specify from 1 to 22 layers) //raiseerror exec</code>
<code>        } if</code>
<code>        layers -1 ne layers 1 lt layers 32 gt or and {</code>
<code>            /bwipp.aztecFullInvalidLayers (Layers for full-range symbols must be from 1 to 32) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    format (compact) eq {</code>
<code>        readerinit {</code>
<code>            layers -1 ne layers 1 ne and {</code>
<code>                /bwipp.aztecCompactInitInvalidLayers (Compact symbols for reader programming must have 1 layer) //raiseerror exec</code>
<code>            } if</code>
<code>            /layers 1 def</code>
<code>        } if</code>
<code>        layers -1 ne layers 1 lt layers 4 gt or and {</code>
<code>            /bwipp.aztecCompactInvalidLayers (Layers for compact symbols must be from 1 to 4) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    format (rune) eq {</code>
<code>        layers -1 ne {</code>
<code>            /bwipp.aztecRuneInvalidLayers (It is not valid to specify layers for runes) //raiseerror exec</code>
<code>        } if</code>
<code>        readerinit {</code>
<code>            /bwipp.aztecRuneReaderInit (Reader initialisation is not compactible with Aztec Runes) //raiseerror exec</code>
<code>        } if</code>
<code>        barcode length 0 eq {</code>
<code>            /bwipp.aztecRuneNotNumeric (Aztec runes must be numeric) //raiseerror exec</code>
<code>        } if</code>
<code>        barcode {</code>
<code>            dup 48 lt exch 57 gt or {</code>
<code>                /bwipp.aztecRuneNotNumeric (Aztec runes must be numeric) //raiseerror exec</code>
<code>            } if</code>
<code>        } forall</code>
<code>        barcode cvi dup 0 lt exch 255 gt or {</code>
<code>            /bwipp.aztecRuneInvalid (Aztec runes must be 0 to 255) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    % Parse the input</code>
<code>    /fn1 -1 def</code>
<code>    /fncvals &lt;&lt;</code>
<code>        /parse parse</code>
<code>        /parsefnc parsefnc</code>
<code>        /eci true</code>
<code>        (FNC1) fn1</code>
<code>    &gt;&gt; def</code>
<code>    /msg barcode fncvals //parseinput exec def</code>
<code>    /msglen msg length def</code>
<code></code>
<code>{</code>
<code>    % State key: "U"pper, "L"ower, "M"ixed, "P"unctuation, "D"igit, "B"inary</code>
<code>    /U 0 def  /L 1 def  /M 2 def  /P 3 def  /D 4 def  /B 5 def</code>
<code></code>
<code>    % Special function characters</code>
<code>    /lu -2 def  /ll -3 def  /lm -4 def</code>
<code>    /lp -5 def  /ld -6 def  /su -7 def</code>
<code>    /sp -8 def  /sb -9 def  /fl -10 def</code>
<code>    /p2 -11 def /p3 -12 def /p4 -13 def /p5 -14 def</code>
<code></code>
<code>    % Character maps for each state</code>
<code>    /charmaps [</code>
<code>        %  U    L    M    P    D</code>
<code>        [  sp   sp   sp   fl   sp ]  % 0</code>
<code>        [  32   32   32   13   32 ]  % 1</code>
<code>        [ (A)  (a)    1   p2  (0) ]  % 2     p2 = CR LF</code>
<code>        [ (B)  (b)    2   p3  (1) ]  % 3     p3 = ". "</code>
<code>        [ (C)  (c)    3   p4  (2) ]  % 4     p4 = ", "</code>
<code>        [ (D)  (d)    4   p5  (3) ]  % 5     p5 = ": "</code>
<code>        [ (E)  (e)    5  (!)  (4) ]  % 6</code>
<code>        [ (F)  (f)    6  (")  (5) ]  % 7</code>
<code>        [ (G)  (g)    7  (#)  (6) ]  % 8</code>
<code>        [ (H)  (h)    8  ($)  (7) ]  % 9</code>
<code>        [ (I)  (i)    9  (%)  (8) ]  % 10</code>
<code>        [ (J)  (j)   10  (&amp;)  (9) ]  % 11</code>
<code>        [ (K)  (k)   11  (')  (,) ]  % 12</code>
<code>        [ (L)  (l)   12   40  (.) ]  % 13</code>
<code>        [ (M)  (m)   13   41   lu ]  % 14</code>
<code>        [ (N)  (n)   27  (*)   su ]  % 15</code>
<code>        [ (O)  (o)   28  (+)  -99 ]  % 16</code>
<code>        [ (P)  (p)   29  (,)  -99 ]  % 17</code>
<code>        [ (Q)  (q)   30  (-)  -99 ]  % 18</code>
<code>        [ (R)  (r)   31  (.)  -99 ]  % 19</code>
<code>        [ (S)  (s)  (@)  (/)  -99 ]  % 20</code>
<code>        [ (T)  (t)   92  (:)  -99 ]  % 21</code>
<code>        [ (U)  (u)  (^)  (;)  -99 ]  % 22</code>
<code>        [ (V)  (v)  (_)  (&lt;)  -99 ]  % 23</code>
<code>        [ (W)  (w)  (`)  (=)  -99 ]  % 24</code>
<code>        [ (X)  (x)  (|)  (&gt;)  -99 ]  % 25</code>
<code>        [ (Y)  (y)  (~)  (?)  -99 ]  % 26</code>
<code>        [ (Z)  (z)  127  ([)  -99 ]  % 27</code>
<code>        [  ll   su   ll  (])  -99 ]  % 28</code>
<code>        [  lm   lm   lu  ({)  -99 ]  % 29</code>
<code>        [  ld   ld   lp  (})  -99 ]  % 30</code>
<code>        [  sb   sb   sb   lu  -99 ]  % 31</code>
<code>    ] def</code>
<code></code>
<code>    % Invert charmaps to give character to value maps for each state</code>
<code>    /charvals [ 32 dict 32 dict 32 dict 32 dict 16 dict ] def</code>
<code>    0 1 charmaps length 1 sub {</code>
<code>        /i exch def</code>
<code>        /encs charmaps i get def</code>
<code>        0 1 4 {</code>
<code>            /j exch def</code>
<code>            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required</code>
<code>            charvals j get exch i put</code>
<code>        } for</code>
<code>    } for</code>
<code></code>
<code>    % Punctuation compression</code>
<code>    /pcomp &lt;&lt;</code>
<code>        &lt;0d0a&gt; p2   % CR LF</code>
<code>        (. )   p3</code>
<code>        (, )   p4</code>
<code>        (: )   p5</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /e 1000000 def  % "Empty"</code>
<code></code>
<code>    /latlen [  % Bit length of latch between states</code>
<code>    % To:  U  L  M  P  D  B      From</code>
<code>        [  0  5  5 10  5 10 ]  % U</code>
<code>        [  9  0  5 10  5 10 ]  % L</code>
<code>        [  5  5  0  5 10 10 ]  % M</code>
<code>        [  5 10 10  0 10 15 ]  % P</code>
<code>        [  4  9  9 14  0 14 ]  % D</code>
<code>        [  0  0  0  0  0  0 ]  % B</code>
<code>    ] def</code>
<code></code>
<code>    /latseq [  % Latch sequences between states</code>
<code>    % To: U       L       M       P          D       B          From</code>
<code>        [ []      [ll]    [lm]    [lm lp]    [ld]    [sb]    ]  % U</code>
<code>        [ [ld lu] []      [lm]    [lm lp]    [ld]    [sb]    ]  % L</code>
<code>        [ [lu]    [ll]    []      [lp]       [lu ld] [sb]    ]  % M</code>
<code>        [ [lu]    [lu ll] [lu lm] []         [lu ld] [lu sb] ]  % P</code>
<code>        [ [lu]    [lu ll] [lu lm] [lu lm lp] []      [lu sb] ]  % D</code>
<code>        [ [lu]    [ll]    [lm]    []         []      []      ]  % B</code>
<code>    ] def</code>
<code></code>
<code>    /shftlen [  % Bit length of shift to state</code>
<code>    % To:  U  L  M  P  D      From</code>
<code>        [  e  e  e  5  e ]  % U</code>
<code>        [  5  e  e  5  e ]  % L</code>
<code>        [  e  e  e  5  e ]  % M</code>
<code>        [  e  e  e  e  e ]  % P</code>
<code>        [  4  e  e  4  e ]  % D</code>
<code>    ] def</code>
<code></code>
<code>} ctxdef</code>
<code></code>
<code>    % Convert from input into message bitstream</code>
<code>    /msgbits () def</code>
<code>    format (rune) ne raw and {/msgbits barcode def} if</code>
<code>    format (rune) ne raw not and {</code>
<code></code>
<code>        /charsize {</code>
<code>            dup 0 ge {</code>
<code>                %      U   L   M   P   D   B</code>
<code>                pop [  5   5   5   5   4   8 ] exch get</code>
<code>            } {  % FNC or ECI in P</code>
<code>                exch pop</code>
<code>                dup fn1 eq {  % FNC1: PS{Flg(0)} + 3</code>
<code>                    pop 8</code>
<code>                } {  % ECI: PS{Flg(n)} + 3 + 4n</code>
<code>                    neg 1000000 sub dup 0 eq {pop 1} if</code>
<code>                    ln 10 ln div cvi 1 add 4 mul 8 add</code>
<code>                } ifelse</code>
<code>            } ifelse</code>
<code>        } def</code>
<code></code>
<code>        %          U  L  M  P  D  B</code>
<code>        /curlen [  0  e  e  e  e  e ] def</code>
<code>        /curseq [ [] [] [] [] [] [] ] def</code>
<code></code>
<code>        /backto U def  % U</code>
<code>        /lastchar () def</code>
<code></code>
<code>        % Derive the optimal sequences ending in each state</code>
<code>        msg {</code>
<code></code>
<code>            /char exch def</code>
<code></code>
<code>            % Check for optimisations in the current sequences by latching from x to y</code>
<code>            {  % loop</code>
<code>                /imp false def</code>
<code>                [ U L M P D B ] {</code>
<code>                    /x exch def</code>
<code>                    [ U L M P D B ] {</code>
<code>                        /y exch def</code>
<code>                        x B ne y backto eq or {  % Only B -&gt; backto</code>
<code>                            /cost curlen x get latlen x get y get add def</code>
<code>                            cost curlen y get lt {</code>
<code>                                curlen y cost put</code>
<code>                                curseq y [</code>
<code>                                    curseq x get aload pop</code>
<code>                                    latseq x get y get aload pop</code>
<code>                                ] put</code>
<code>                                y B eq {  % Set backto to previous state</code>
<code>                                    /backto x P eq x D eq or {U} {x} ifelse def</code>
<code>                                } if</code>
<code>                                /imp true def</code>
<code>                            } if</code>
<code>                        } if</code>
<code>                    } forall</code>
<code>                } forall</code>
<code>                imp not {exit} if  % Repeat unless no improvement</code>
<code>            } loop</code>
<code></code>
<code>            % Determine optimal next sequences for each valid encoding</code>
<code>            /nxtlen [ e e e e e e ] def</code>
<code>            /nxtseq 6 array def</code>
<code></code>
<code>            [ U L M P D B ] {</code>
<code>                /x exch def</code>
<code></code>
<code>                { % loop for common exit</code>
<code></code>
<code>                    % Skip states that cannot encode character</code>
<code>                    char 0 ge {</code>
<code>                        x B ne {charvals x get char known not {exit} if} if</code>
<code>                    } {</code>
<code>                        x P ne {exit} if  % Only P can encode FNC1 and ECI</code>
<code>                    } ifelse</code>
<code></code>
<code>                    % Extend directly</code>
<code>                    /cost curlen x get x char charsize add def</code>
<code>                    cost nxtlen x get lt {</code>
<code>                        nxtlen x cost put</code>
<code>                        nxtseq x [ curseq x get aload pop char ] put</code>
<code>                    } if</code>
<code></code>
<code>                    % Optimise for direct shifts from y to x</code>
<code>                    x B eq {exit} if  % B is treated as a latch</code>
<code>                    [ U L M P D ] {</code>
<code>                        /y exch def</code>
<code>                        x y ne {</code>
<code>                            /cost curlen y get shftlen y get x get add x char charsize add def</code>
<code>                            cost nxtlen y get lt {</code>
<code>                                nxtlen y cost put</code>
<code>                                nxtseq y [</code>
<code>                                    curseq y get aload pop</code>
<code>                                    x U eq {su} {sp} ifelse</code>
<code>                                    char</code>
<code>                                ] put</code>
<code>                            } if</code>
<code>                        } if</code>
<code>                    } forall</code>
<code></code>
<code>                    exit</code>
<code>                } loop</code>
<code></code>
<code>            } forall</code>
<code></code>
<code>            % Optimise using P compression</code>
<code>            lastchar () ne char 0 ge and {</code>
<code>                /pchars 2 string dup 0 lastchar put dup 1 char put def</code>
<code>                pcomp pchars known {</code>
<code>                    [ U L M P D ] {</code>
<code>                        /i exch def</code>
<code>                        /inP true def  % U and L can't encode CR, comma, dot or colon</code>
<code>                        i M eq {  % M can encode CR</code>
<code>                            lastchar 13 eq { /inP false def } if</code>
<code>                        } {</code>
<code>                            i D eq {  % D can encode comma and dot</code>
<code>                                lastchar 44 eq lastchar 46 eq or { /inP false def } if</code>
<code>                            } if</code>
<code>                        } ifelse</code>
<code>                        inP curlen i get nxtlen i get lt and {</code>
<code>                            /curseqi curseq i get def</code>
<code>                            /lastld false def</code>
<code>                            /lastsp false def</code>
<code>                            /lastidx -1 def</code>
<code>                            curseqi length 1 sub -1 0 {  % Search backwards for lastchar</code>
<code>                                /idx exch def</code>
<code>                                /ch curseqi idx get def</code>
<code>                                lastidx -1 eq {</code>
<code>                                    ch lastchar eq {</code>
<code>                                        /lastidx idx def</code>
<code>                                        idx 0 gt {</code>
<code>                                            curseqi idx 1 sub get sp eq { /lastsp true def } if  % Preceded by P/S</code>
<code>                                        } if</code>
<code>                                    } if</code>
<code>                                } {  % Found lastchar, check latch</code>
<code>                                    ch 0 lt ch ld ge and {  % If have latch</code>
<code>                                        i P eq {</code>
<code>                                            ch ld eq { /lastld true def } if  % Set flag if D/L for adjustment below</code>
<code>                                        } {</code>
<code>                                            ch lp ne { /inP lastsp def } if  % If not P/L only in P if have P/S</code>
<code>                                        } ifelse</code>
<code>                                        exit</code>
<code>                                    } if</code>
<code>                                } ifelse</code>
<code>                            } for</code>
<code>                            inP lastidx 0 ge and {</code>
<code>                                nxtlen i curlen i get put</code>
<code>                                lastidx curseqi length 1 sub lt {  % If lastchar not at end of sequence</code>
<code>                                    i P eq {</code>
<code>                                        lastld { nxtlen i nxtlen i get 1 add put } if  % Adjust count if D/L</code>
<code>                                        % Move lastchar to end and replace</code>
<code>                                        nxtseq i [ curseqi aload pop curseqi length lastidx sub -1 roll pop pcomp pchars get ] put</code>
<code>                                    } {</code>
<code>                                        % Replace lastchar in situ</code>
<code>                                        nxtseq i [ curseqi aload pop ] put</code>
<code>                                        nxtseq i get lastidx pcomp pchars get put</code>
<code>                                    } ifelse</code>
<code>                                } {</code>
<code>                                    nxtseq i [ curseqi aload pop pop pcomp pchars get ] put</code>
<code>                                } ifelse</code>
<code>                            } if</code>
<code>                        } if</code>
<code>                    } forall</code>
<code>                } if</code>
<code>            } if</code>
<code></code>
<code>            % Account for binary extension for 32 or more bytes</code>
<code>            nxtseq B get null ne {</code>
<code>                /numbytes 0 def</code>
<code>                nxtseq B get {</code>
<code>                    sb eq {0} {numbytes 1 add} ifelse /numbytes exch def</code>
<code>                } forall</code>
<code>                numbytes 32 eq {nxtlen B nxtlen B get 11 add put} if</code>
<code>            } if</code>
<code></code>
<code>            /curlen nxtlen def</code>
<code>            /curseq nxtseq def</code>
<code>            /lastchar char 0 ge {char} {()} ifelse def</code>
<code></code>
<code>        } forall</code>
<code></code>
<code>        % Select the optimal sequence</code>
<code>        /minseq e def</code>
<code>        [ U L M P D B ] {</code>
<code>            /i exch def</code>
<code>            curlen i get minseq lt {</code>
<code>                /minseq curlen i get def</code>
<code>                /seq curseq i get def</code>
<code>            } if</code>
<code>        } forall</code>
<code></code>
<code>        % Encoding functions</code>
<code>        /tobin {</code>
<code>            string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for</code>
<code>            dup 3 -1 roll 2 2 index length string cvrs dup length 2 index length exch sub exch putinterval</code>
<code>        } def</code>
<code></code>
<code>        /encu {charvals U get exch get 5 tobin} def</code>
<code>        /encl {charvals L get exch get 5 tobin} def</code>
<code>        /encm {charvals M get exch get 5 tobin} def</code>
<code>        /encd {charvals D get exch get 4 tobin} def</code>
<code></code>
<code>        /encp {</code>
<code>            dup fn1 eq {  % FNC1: Flg(0)</code>
<code>                pop (00000000)</code>
<code>            } {</code>
<code>            dup -1000000 le {  % ECI: Flg(n) + n-Digits</code>
<code>                neg 1000000 sub dup dup 0 eq {pop 1} if</code>
<code>                ln 10 ln div cvi</code>
<code>                dup 1 add 4 mul 8 add string</code>
<code>                dup 0 (00000) putinterval  % Flg(n)</code>
<code>                dup 2 index 1 add 3 tobin 5 exch putinterval  % len</code>
<code>                3 1 roll -1 0 {  % ECI digits in "Digit" encoding</code>
<code>                    4 mul 8 add exch</code>
<code>                    dup 10 idiv 3 index 4 2 roll</code>
<code>                    10 mod 2 add 4 tobin putinterval</code>
<code>                } for</code>
<code>                pop</code>
<code>            } {</code>
<code>                charvals P get exch get 5 tobin</code>
<code>            } ifelse } ifelse</code>
<code>        } def</code>
<code></code>
<code>        /encfuncs [ /encu /encl /encm /encp /encd ] def</code>
<code></code>
<code>        /addtomsgbits {</code>
<code>            /v exch def</code>
<code>            msgbits j v putinterval</code>
<code>            /j j v length add def</code>
<code>        } def</code>
<code></code>
<code>        % Encode the sequence</code>
<code>        /state U def</code>
<code>        /msgbits minseq string def</code>
<code>        /i 0 def /j 0 def {</code>
<code>            i seq length ge {exit} if</code>
<code></code>
<code>            state B ne {</code>
<code></code>
<code>                /char seq i get def</code>
<code></code>
<code>                % Encode character</code>
<code>                char encfuncs state get load exec addtomsgbits</code>
<code>                /i i 1 add def</code>
<code></code>
<code>                % Encode shifted next character</code>
<code>                char su eq char sp eq or {</code>
<code>                    seq i get char su eq {encu} {encp} ifelse addtomsgbits</code>
<code>                    /i i 1 add def</code>
<code>                } if</code>
<code></code>
<code>                % Latches to new state</code>
<code>                char lu eq {/state U def} if</code>
<code>                char ll eq {/state L def} if</code>
<code>                char lm eq {/state M def} if</code>
<code>                char lp eq {/state P def} if</code>
<code>                char ld eq {/state D def} if</code>
<code>                char sb eq {/state B def} if</code>
<code></code>
<code>            } {  % Binary</code>
<code></code>
<code>                % Find number of bytes before latch or end</code>
<code>                /numbytes 0 def {</code>
<code>                    i numbytes add seq length ge {exit} if</code>
<code>                    seq i numbytes add get 0 lt {exit} if</code>
<code>                    /numbytes numbytes 1 add def</code>
<code>                } loop</code>
<code></code>
<code>                % Encode length</code>
<code>                numbytes 31 le {</code>
<code>                    numbytes 5 tobin addtomsgbits</code>
<code>                } {</code>
<code>                    0 5 tobin addtomsgbits</code>
<code>                    numbytes 31 sub 11 tobin addtomsgbits</code>
<code>                } ifelse</code>
<code></code>
<code>                % Encode bytes</code>
<code>                numbytes {</code>
<code>                    seq i get 8 tobin addtomsgbits</code>
<code>                    /i i 1 add def</code>
<code>                } repeat</code>
<code></code>
<code>                % Return to previous state as indicated</code>
<code>                i seq length lt {</code>
<code>                    /char seq i get def</code>
<code>                    /i i 1 add def</code>
<code>                    char lu eq {/state U def} if</code>
<code>                    char ll eq {/state L def} if</code>
<code>                    char lm eq {/state M def} if</code>
<code>                } if</code>
<code></code>
<code>            } ifelse</code>
<code></code>
<code>        } loop</code>
<code></code>
<code>    } if</code>
<code></code>
<code>    % Lookup the most appropriate symbol specification</code>
<code>{</code>
<code>    /metrics [</code>
<code>        [ (rune)     0 0    0  6 ]  % Special metric for rune symbols</code>
<code>        [ (compact)  1 1   17  6 ] [ (full)     1 1   21  6 ] [ (compact)  2 0   40  6 ]</code>
<code>        [ (full)     2 1   48  6 ] [ (compact)  3 0   51  8 ] [ (full)     3 1   60  8 ]</code>
<code>        [ (compact)  4 0   76  8 ] [ (full)     4 1   88  8 ] [ (full)     5 1  120  8 ]</code>
<code>        [ (full)     6 1  156  8 ] [ (full)     7 1  196  8 ] [ (full)     8 1  240  8 ]</code>
<code>        [ (full)     9 1  230 10 ] [ (full)    10 1  272 10 ] [ (full)    11 1  316 10 ]</code>
<code>        [ (full)    12 1  364 10 ] [ (full)    13 1  416 10 ] [ (full)    14 1  470 10 ]</code>
<code>        [ (full)    15 1  528 10 ] [ (full)    16 1  588 10 ] [ (full)    17 1  652 10 ]</code>
<code>        [ (full)    18 1  720 10 ] [ (full)    19 1  790 10 ] [ (full)    20 1  864 10 ]</code>
<code>        [ (full)    21 1  940 10 ] [ (full)    22 1 1020 10 ] [ (full)    23 0  920 12 ]</code>
<code>        [ (full)    24 0  992 12 ] [ (full)    25 0 1066 12 ] [ (full)    26 0 1144 12 ]</code>
<code>        [ (full)    27 0 1224 12 ] [ (full)    28 0 1306 12 ] [ (full)    29 0 1392 12 ]</code>
<code>        [ (full)    30 0 1480 12 ] [ (full)    31 0 1570 12 ] [ (full)    32 0 1664 12 ]</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    metrics {</code>
<code>        /m exch def</code>
<code>        /frmt m 0 get def                          % Format of the symbol</code>
<code>        /mlyr m 1 get def                          % Data layers</code>
<code>        /icap m 2 get def                          % Reader initialisation capable</code>
<code>        /ncws m 3 get def                          % Total of codewords</code>
<code>        /bpcw m 4 get def                          % Bits per codeword</code>
<code>        /numecw ncws eclevel mul 100 div ecaddchars add ceiling cvi def</code>
<code>        msgbits length 0 eq {/numecw 0 def} if     % Error correction codewords</code>
<code>        /numdcw ncws numecw sub def                % Data codewords</code>
<code>        /okay true def</code>
<code>        format frmt ne {/okay false def} if</code>
<code>        readerinit icap 1 ne and {/okay false def} if</code>
<code>        layers -1 ne layers mlyr ne and {/okay false def} if</code>
<code>        msgbits length bpcw div ceiling cvi numdcw gt {/okay false def} if</code>
<code>        okay {exit} if</code>
<code>    } forall</code>
<code></code>
<code>    okay not {</code>
<code>        /bwipp.azteccodeNoValidSymbol (Maximum length exceeded) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /layers mlyr def</code>
<code></code>
<code>    % Expand message bits into codewords avoiding codewords with all zeros or all ones</code>
<code>    /allzero {dup length (000000000000) 0 3 -1 roll getinterval eq} def</code>
<code>    /allones {dup length (111111111111) 0 3 -1 roll getinterval eq} def</code>
<code>    /cws ncws array def</code>
<code>    /m 0 def /c 0 def</code>
<code>    {</code>
<code>        msgbits length m le {exit} if</code>
<code>        msgbits length m sub bpcw ge {</code>
<code>            /cwb msgbits m bpcw 1 sub getinterval def        % All but last bit</code>
<code>            /cwf msgbits m bpcw add 1 sub 1 getinterval def  % Last bit</code>
<code>            cwb allzero {/cwf (1) def /m m 1 sub def} if     % Flip last bit to avoid zeros</code>
<code>            cwb allones {/cwf (0) def /m m 1 sub def} if     % Flip last bit to avoid ones</code>
<code>            % Concatenate the bits</code>
<code>            12 string dup 0 cwb putinterval</code>
<code>            dup bpcw 1 sub cwf putinterval</code>
<code>            0 bpcw getinterval</code>
<code>            /cwb exch def</code>
<code>        } {  %  Final codeword</code>
<code>            /cwb msgbits m msgbits length m sub getinterval def</code>
<code>            /cwb (111111111111) 12 string copy dup 0 cwb putinterval 0 bpcw getinterval def</code>
<code>            cwb allones {cwb cwb length 1 sub (0) putinterval} if  % Prevent all ones</code>
<code>        } ifelse</code>
<code>        % Conversion of binary data into byte array</code>
<code>        /cw 0 def</code>
<code>        0 1 bpcw 1 sub {</code>
<code>            /i exch def</code>
<code>            /cw cw 2 bpcw i sub 1 sub exp cvi cwb i get 48 sub mul add def</code>
<code>        } for</code>
<code>        cws c cw put</code>
<code>        /m m bpcw add def</code>
<code>        /c c 1 add def</code>
<code>    } loop</code>
<code>    /cws cws 0 c getinterval def</code>
<code></code>
<code>    options /debugcws known { /bwipp.debugcws cws //raiseerror exec } if</code>
<code></code>
<code>    % Reed-Solomon algorithm</code>
<code>    /rscodes {</code>
<code></code>
<code>        /rspm exch def</code>
<code>        /rsgf exch def</code>
<code>        /rsnc exch def</code>
<code>        /rscws exch def</code>
<code></code>
<code>        % Calculate the log and anti-log tables</code>
<code>        /rsalog [ 1 rsgf 1 sub { dup 2 mul dup rsgf ge {rspm xor} if } repeat ] def</code>
<code>        /rslog rsgf array def</code>
<code>        1 1 rsgf 1 sub {dup rsalog exch get exch rslog 3 1 roll put} for</code>
<code></code>
<code>        % Function to calculate the product in the field</code>
<code>        /rsprod {</code>
<code>            2 copy 0 ne exch 0 ne and {</code>
<code>                rslog exch get exch rslog exch get add rsgf 1 sub mod rsalog exch get</code>
<code>            } {</code>
<code>                pop pop 0</code>
<code>            } ifelse</code>
<code>        } def</code>
<code></code>
<code>        % Generate the coefficients</code>
<code>        /coeffs [ 1 rsnc {0} repeat ] def</code>
<code>        1 1 rsnc {</code>
<code>            /i exch def</code>
<code>            coeffs i coeffs i 1 sub get put</code>
<code>            i 1 sub -1 1 {</code>
<code>                /j exch def</code>
<code>                coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put</code>
<code>            } for</code>
<code>            coeffs 0 coeffs 0 get rsalog i get rsprod put</code>
<code>        } for</code>
<code></code>
<code>        % Extend the input with the error correction values</code>
<code>        /nd rscws length def</code>
<code>        /rscws [ rscws {} forall rsnc {0} repeat 0 ] def</code>
<code>        0 1 nd 1 sub {</code>
<code>            /k exch rscws exch get rscws nd get xor def</code>
<code>            0 1 rsnc 1 sub {</code>
<code>                /j exch def</code>
<code>                rscws nd j add rscws nd j add 1 add get k coeffs rsnc j sub 1 sub get rsprod xor put</code>
<code>            } for</code>
<code>        } for</code>
<code></code>
<code>        % Return all but the last codeword</code>
<code>        rscws 0 rscws length 1 sub getinterval</code>
<code></code>
<code>    } def</code>
<code></code>
<code>    % Create the codewords and bit string for the mode</code>
<code>    format (full) eq {</code>
<code>        /mode layers 1 sub 11 bitshift cws length 1 sub add def</code>
<code>        readerinit {/mode mode 2#0000010000000000 or def} if</code>
<code>        /mode [</code>
<code>            mode 2#1111000000000000 and -12 bitshift</code>
<code>            mode 2#0000111100000000 and -8 bitshift</code>
<code>            mode 2#0000000011110000 and -4 bitshift</code>
<code>            mode 2#0000000000001111 and</code>
<code>        ] def</code>
<code>        /mode mode 6 16 19 rscodes def</code>
<code>    } if</code>
<code>    format (compact) eq {</code>
<code>        /mode layers 1 sub 6 bitshift cws length 1 sub add def</code>
<code>        readerinit {/mode mode 2#00100000 or def} if</code>
<code>        /mode [</code>
<code>            mode 2#11110000 and -4 bitshift</code>
<code>            mode 2#00001111 and</code>
<code>        ] def</code>
<code>        /mode mode 5 16 19 rscodes def</code>
<code>    } if</code>
<code>    format (rune) eq {</code>
<code>        /mode barcode cvi def</code>
<code>        /mode [</code>
<code>            mode 2#11110000 and -4 bitshift</code>
<code>            mode 2#00001111 and</code>
<code>        ] def</code>
<code>        /mode mode 5 16 19 rscodes def</code>
<code>        /mode [mode {2#1010 xor} forall] def  % Invert alternate bits</code>
<code>    } if</code>
<code>    /modebits mode length 4 mul string def</code>
<code>    0 1 modebits length 1 sub {modebits exch (0) putinterval} for</code>
<code>    0 1 mode length 1 sub {</code>
<code>        /i exch def</code>
<code>        modebits mode i get 2 4 string cvrs dup length 4 exch sub 4 i mul add exch putinterval</code>
<code>    } for</code>
<code></code>
<code>    % Extend the data codewords with error correction codewords to create the bit string for the data</code>
<code>{</code>
<code>    /rsparams [</code>
<code>        [] [] [] [] [] []</code>
<code>        [ 64 67 ]      % 6-bit codewords</code>
<code>        []</code>
<code>        [ 256 301 ]    % 8-bit codewords</code>
<code>        []</code>
<code>        [ 1024 1033 ]  % 10-bit codewords</code>
<code>        []</code>
<code>        [ 4096 4201 ]  % 12-bit codewords</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code>    /cws cws ncws cws length sub rsparams bpcw get {} forall rscodes def</code>
<code>    format (full) eq {</code>
<code>        /databits layers layers mul 16 mul layers 112 mul add string def</code>
<code>    } {</code>
<code>        /databits layers layers mul 16 mul layers 88 mul add string def</code>
<code>    } ifelse</code>
<code>    0 1 databits length 1 sub {databits exch (0) putinterval} for</code>
<code>    0 1 ncws 1 sub {</code>
<code>        /i exch def</code>
<code>        databits cws i get 2 bpcw string cvrs</code>
<code>        dup length bpcw exch sub bpcw i mul add databits length ncws bpcw mul sub add</code>
<code>        exch putinterval</code>
<code>    } for</code>
<code></code>
<code>    % Move to a point in the cartesian plane centered on the bullseye</code>
<code>    /cmv {size mul sub mid add} def</code>
<code></code>
<code>    % Move to a bit position within a layer</code>
<code>    /lmv {</code>
<code>        /lbit exch def</code>
<code>        /llyr exch def</code>
<code>        /lwid fw llyr 4 mul add def</code>
<code>        /ldir lbit 2 idiv lwid idiv def</code>
<code>        ldir 0 eq {  % Top</code>
<code>            lwid 1 sub 2 idiv neg 1 add lbit 2 idiv lwid mod add</code>
<code>            fw 1 sub 2 idiv llyr 2 mul add lbit 2 mod add</code>
<code>            cmv</code>
<code>        } if</code>
<code>        ldir 1 eq {  % Right</code>
<code>            fw 2 idiv llyr 2 mul add lbit 2 mod add</code>
<code>            lwid 1 sub 2 idiv 1 sub lbit 2 idiv lwid mod sub</code>
<code>            cmv</code>
<code>        } if</code>
<code>        ldir 2 eq {  % Bottom</code>
<code>            lwid 2 idiv neg 1 add lbit 2 idiv lwid mod add neg</code>
<code>            fw 2 idiv llyr 2 mul add lbit 2 mod add neg</code>
<code>            cmv</code>
<code>        } if</code>
<code>        ldir 3 eq {  % Left</code>
<code>            fw 1 sub 2 idiv llyr 2 mul add lbit 2 mod add neg</code>
<code>            lwid 2 idiv 1 sub lbit 2 idiv lwid mod sub neg</code>
<code>            cmv</code>
<code>        } if</code>
<code>    } def</code>
<code></code>
<code>    % Create the pixel map</code>
<code>    % For full symbols we disregard the reference grid at this stage</code>
<code>    format (full) eq {/fw 12 def} {/fw 9 def} ifelse</code>
<code>    /size fw layers 4 mul add 2 add def</code>
<code>    /pixs [size size mul {-1} repeat] def</code>
<code>    /mid size 1 sub 2 idiv size mul size 1 sub 2 idiv add def</code>
<code></code>
<code>    % Data layers</code>
<code>    /i 0 def</code>
<code>    1 1 layers {</code>
<code>        /layer exch def</code>
<code>        0 1 fw layer 4 mul add 8 mul 1 sub {</code>
<code>            /pos exch def</code>
<code>            pixs layer pos lmv databits databits length i sub 1 sub get 48 sub put</code>
<code>            /i i 1 add def</code>
<code>        } for</code>
<code>    } for</code>
<code></code>
<code>    % For full symbols expand the pixel map by inserting the reference grid</code>
<code>    format (full) eq {</code>
<code>        /fw 13 def</code>
<code>        /size fw layers 4 mul add 2 add layers 10.5 add 7.5 div 1 sub cvi 2 mul add def</code>
<code>        /mid size size mul 2 idiv def</code>
<code>        /npixs [size size mul {-2} repeat] def</code>
<code>        0 16 size 2 idiv {</code>
<code>            /i exch def</code>
<code>            0 1 size 1 sub {</code>
<code>                /j exch def</code>
<code>                npixs size 2 idiv neg j add i cmv     [size 2 idiv j add i add 1 add 2 mod] putinterval</code>
<code>                npixs size 2 idiv neg j add i neg cmv [size 2 idiv j add i add 1 add 2 mod] putinterval</code>
<code>                npixs i size 2 idiv neg j add cmv     [size 2 idiv j add i add 1 add 2 mod] putinterval</code>
<code>                npixs i neg size 2 idiv neg j add cmv [size 2 idiv j add i add 1 add 2 mod] putinterval</code>
<code>            } for</code>
<code>        } for</code>
<code>        /j 0 def</code>
<code>        0 1 npixs length 1 sub {</code>
<code>            /i exch def</code>
<code>            npixs i get -2 eq {</code>
<code>                npixs i pixs j get put</code>
<code>                /j j 1 add def</code>
<code>            } if</code>
<code>        } for</code>
<code>        /pixs npixs def</code>
<code>    } if</code>
<code></code>
<code>    % Finder pattern</code>
<code>    /fw fw 2 idiv def</code>
<code>    fw neg 1 fw {</code>
<code>        /i exch def</code>
<code>        fw neg 1 fw {</code>
<code>            /j exch def</code>
<code>            pixs i j cmv</code>
<code>            i abs j abs gt {i abs} {j abs} ifelse 1 add 2 mod</code>
<code>            put</code>
<code>        } for</code>
<code>    } for</code>
<code></code>
<code>    % Orientation bits</code>
<code>    [ [ fw 1 add neg   fw             1 ] [ fw 1 add neg   fw 1 add       1 ]</code>
<code>      [ fw neg         fw 1 add       1 ] [ fw 1 add       fw 1 add       1 ]</code>
<code>      [ fw 1 add       fw             1 ] [ fw 1 add       fw neg         1 ]</code>
<code>      [ fw             fw 1 add       0 ] [ fw 1 add       fw 1 add neg   0 ]</code>
<code>      [ fw             fw 1 add neg   0 ] [ fw neg         fw 1 add neg   0 ]</code>
<code>      [ fw 1 add neg   fw 1 add neg   0 ] [ fw 1 add neg   fw neg         0 ]</code>
<code>    ] {pixs exch {} forall 3 1 roll cmv exch put} forall</code>
<code></code>
<code>    % Mode ring</code>
<code>{</code>
<code>    /modemapfull [</code>
<code>        [-5  7] [-4  7] [-3  7] [-2  7] [-1  7] [ 1  7] [ 2  7] [ 3  7] [ 4  7] [ 5  7]</code>
<code>        [ 7  5] [ 7  4] [ 7  3] [ 7  2] [ 7  1] [ 7 -1] [ 7 -2] [ 7 -3] [ 7 -4] [ 7 -5]</code>
<code>        [ 5 -7] [ 4 -7] [ 3 -7] [ 2 -7] [ 1 -7] [-1 -7] [-2 -7] [-3 -7] [-4 -7] [-5 -7]</code>
<code>        [-7 -5] [-7 -4] [-7 -3] [-7 -2] [-7 -1] [-7  1] [-7  2] [-7  3] [-7  4] [-7  5]</code>
<code>    ] def</code>
<code>    /modemapcompact [</code>
<code>        [-3  5] [-2  5] [-1  5] [ 0  5] [ 1  5] [ 2  5] [ 3  5]</code>
<code>        [ 5  3] [ 5  2] [ 5  1] [ 5  0] [ 5 -1] [ 5 -2] [ 5 -3]</code>
<code>        [ 3 -5] [ 2 -5] [ 1 -5] [ 0 -5] [-1 -5] [-2 -5] [-3 -5]</code>
<code>        [-5 -3] [-5 -2] [-5 -1] [-5  0] [-5  1] [-5  2] [-5  3]</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code>    /modemap format (full) eq {modemapfull} {modemapcompact} ifelse def</code>
<code>    0 1 modemap length 1 sub {</code>
<code>        /i exch def</code>
<code>        pixs modemap i get {} forall cmv modebits i get 48 sub put</code>
<code>    } for</code>
<code></code>
<code>    &lt;&lt;</code>
<code>    /ren //renmatrix</code>
<code>    /pixs pixs</code>
<code>    /pixx size</code>
<code>    /pixy size</code>
<code>    /height size 2 mul 72 div</code>
<code>    /width size 2 mul 72 div</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /azteccode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER azteccode--</code>
<code></code>
<code>% --BEGIN ENCODER azteccodecompact--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix azteccode--</code>
<code>% --DESC: Compact Aztec Code</code>
<code>% --EXAM: 1234</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp azteccodecompact 0.0 2024010300 63121 63085</code>
<code>%%BeginData:         36 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /azteccode dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/azteccodecompact {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Get the result of encoding with azteccode with format=compact</code>
<code>    options (dontdraw) true put</code>
<code>    options (format) (compact) put</code>
<code></code>
<code>    /args barcode options //azteccode exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /azteccodecompact dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER azteccodecompact--</code>
<code></code>
<code>% --BEGIN ENCODER aztecrune--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix azteccode--</code>
<code>% --DESC: Aztec Runes</code>
<code>% --EXAM: 1</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp aztecrune 0.0 2024010300 63090 63061</code>
<code>%%BeginData:         36 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /azteccode dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/aztecrune {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Get the result of encoding with azteccode with format=rune</code>
<code>    options (dontdraw) true put</code>
<code>    options (format) (rune) put</code>
<code></code>
<code>    /args barcode options //azteccode exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /aztecrune dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER aztecrune--</code>
<code></code>
<code>% --BEGIN ENCODER codeone--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix--</code>
<code>% --DESC: Code One</code>
<code>% --EXAM: Code One</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp codeone 0.0 2024010300 205866 224569</code>
<code>%%BeginData:        921 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/codeone {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /version (unset) def</code>
<code>    /parse false def</code>
<code>    /parsefnc false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    false [ (unset) (T-16) (T-32) (T-48) (S-10) (S-20) (S-30) (A) (B) (C) (D) (E) (F) (G) (H) ]</code>
<code>    { version eq or } forall not {</code>
<code>        /bwipp.codeoneBadVersion (version must be A to H, T-16, T-32, T-48, S-10, S-20 or S-30) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /codeone //loadctx exec</code>
<code></code>
<code>    /stype version 0 1 getinterval (S) eq def</code>
<code>    /ttype version 0 1 getinterval (T) eq def</code>
<code></code>
<code>{</code>
<code>    /stypevals [</code>
<code>        (1)</code>
<code>        (1010)</code>
<code>        (1100100)</code>
<code>        (1111101000)</code>
<code>        (10011100010000)</code>
<code>        (11000011010100000)</code>
<code>        (11110100001001000000)</code>
<code>        (100110001001011010000000)</code>
<code>        (101111101011110000100000000)</code>
<code>        (111011100110101100101000000000)</code>
<code>        (1001010100000010111110010000000000)</code>
<code>        (1011101001000011101101110100000000000)</code>
<code>        (1110100011010100101001010001000000000000)</code>
<code>        (10010001100001001110011100101010000000000000)</code>
<code>        (10110101111001100010000011110100100000000000000)</code>
<code>        (11100011010111111010100100110001101000000000000000)</code>
<code>        (100011100001101111001001101111110000010000000000000000)</code>
<code>        (101100011010001010111100001011101100010100000000000000000)</code>
<code>    ] def</code>
<code></code>
<code>    % Basic metrics for the each symbol</code>
<code>    %     ver    row col dcol dcws rscw rsbl  ro ri rl</code>
<code>    /stypemetrics [</code>
<code>        [ (S-10)   8  11   10    4    4    1  99 99 99 ]</code>
<code>        [ (S-20)   8  21   20    8    8    1  99 99 99 ]</code>
<code>        [ (S-30)   8  31   30   12   12    1  99 99 99 ]</code>
<code>    ] def</code>
<code></code>
<code>    % Basic metrics for the each symbol</code>
<code>    %     ver    row col dcol dcws rscw rsbl  ro ri rl</code>
<code>    /nonstypemetrics [</code>
<code>        [ (A)     16  18   16   10   10    1   4 99  6 ]</code>
<code>        [ (B)     22  22   20   19   16    1   4 99  8 ]</code>
<code>        [ (C)     28  32   28   44   26    1   4 22 11 ]</code>
<code>        [ (D)     40  42   36   91   44    1   4 16 16 ]</code>
<code>        [ (E)     52  54   48  182   70    1   4 22 22 ]</code>
<code>        [ (F)     70  76   68  370  140    2   4 22 31 ]</code>
<code>        [ (G)    104  98   88  732  280    4   6 21 47 ]</code>
<code>        [ (H)    148 134  120 1480  560    8   6 20 69 ]</code>
<code>        [ (T-16)  16  17   16   10   10    1  99 99 99 ]</code>
<code>        [ (T-32)  16  33   32   24   16    1  99 99 99 ]</code>
<code>        [ (T-48)  16  49   48   38   22    1  99 99 99 ]</code>
<code>    ] def</code>
<code></code>
<code>    % Special characters</code>
<code>    /fnc1 -1 def  /fnc3 -2 def</code>
<code>    /lC    -5 def  /lB    -6 def  /lX    -7 def  /lT    -8 def  /lD    -9 def  /unl -10 def</code>
<code>    /fnc2 -11 def  /fnc4 -12 def  /sft1 -13 def  /sft2 -14 def  /sft3 -15 def  /eci -16 def  /pad -17 def  /fnc1lD -18 def</code>
<code>    /unlcw 255 def</code>
<code></code>
<code>    /Avals &lt;&lt;</code>
<code>        0 1 128 {dup 1 add} for</code>
<code>        pad 129</code>
<code>        0 1 99 {  % Double digits</code>
<code>            dup 10 2 string cvrs (00) 2 string copy dup 2 3 index length sub 4 -1 roll putinterval</code>
<code>            exch 130 add</code>
<code>        } for</code>
<code>        229 [ lC lB fnc1 fnc2 fnc3 fnc4 fnc1lD ] {exch 1 add dup} forall pop</code>
<code>        lX 238</code>
<code>        lT 239</code>
<code>        % 240-255 lD + 4 bits</code>
<code>    &gt;&gt; def</code>
<code>    /Avals &lt;&lt;</code>
<code>        Avals {[exch]} forall</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /CNvals &lt;&lt;</code>
<code>        sft1 0</code>
<code>        sft2 1</code>
<code>        sft3 2</code>
<code>        32   3</code>
<code>        48 1 57 {dup 44 sub} for  % 0-9</code>
<code>        65 1 90 {dup 51 sub} for  % A-Z</code>
<code>    &gt;&gt; def</code>
<code>    /C1vals &lt;&lt; 0 1 31 {dup} for &gt;&gt; def</code>
<code>    /C2vals &lt;&lt;</code>
<code>        33 1 47 {dup 33 sub} for</code>
<code>        58 1 64 {dup 43 sub} for</code>
<code>        91 1 95 {dup 69 sub} for</code>
<code>        fnc1 27</code>
<code>        fnc2 28</code>
<code>        fnc3 29</code>
<code>        fnc4 30</code>
<code>        pad  31</code>
<code>    &gt;&gt; def</code>
<code>    /C3vals &lt;&lt; 96 1 127 {dup 96 sub} for &gt;&gt; def</code>
<code>    /Cvals &lt;&lt;</code>
<code>        CNvals {[exch]} forall</code>
<code>        C1vals {[exch CNvals sft1 get exch]} forall</code>
<code>        C2vals {[exch CNvals sft2 get exch]} forall</code>
<code>        C3vals {[exch CNvals sft3 get exch]} forall</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /TNvals &lt;&lt;</code>
<code>        sft1 0</code>
<code>        sft2 1</code>
<code>        sft3 2</code>
<code>        32   3</code>
<code>        48 1  57 {dup 44 sub} for  % 0-9</code>
<code>        97 1 122 {dup 83 sub} for  % a-z</code>
<code>    &gt;&gt; def</code>
<code>    /T1vals &lt;&lt; 0 1 31 {dup} for &gt;&gt; def</code>
<code>    /T2vals &lt;&lt;</code>
<code>        33 1 47 {dup 33 sub} for</code>
<code>        58 1 64 {dup 43 sub} for</code>
<code>        91 1 95 {dup 69 sub} for</code>
<code>        fnc1 27</code>
<code>        fnc2 28</code>
<code>        fnc3 29</code>
<code>        fnc4 30</code>
<code>        pad  31</code>
<code>    &gt;&gt; def</code>
<code>    /T3vals &lt;&lt;</code>
<code>         96 0</code>
<code>         65 1  90 {dup 64 sub} for</code>
<code>        123 1 127 {dup 96 sub} for</code>
<code>    &gt;&gt; def</code>
<code>    /Tvals &lt;&lt;</code>
<code>        TNvals {[exch]} forall</code>
<code>        T1vals {[exch TNvals sft1 get exch]} forall</code>
<code>        T2vals {[exch TNvals sft2 get exch]} forall</code>
<code>        T3vals {[exch TNvals sft3 get exch]} forall</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    % Extended ASCII mappings</code>
<code>    128 1 255 {</code>
<code>        /i exch def</code>
<code>        Avals i [ Avals fnc4 get aload pop Avals i 128 sub get aload pop ] put</code>
<code>        Cvals i [ Cvals fnc4 get aload pop Cvals i 128 sub get aload pop ] put</code>
<code>        Tvals i [ Tvals fnc4 get aload pop Tvals i 128 sub get aload pop ] put</code>
<code>    } for</code>
<code></code>
<code>    /Xvals &lt;&lt;</code>
<code>        13 0</code>
<code>        42 1</code>
<code>        62 2</code>
<code>        32 3</code>
<code>        48 1 57 {dup 44 sub} for</code>
<code>        65 1 90 {dup 51 sub} for</code>
<code>    &gt;&gt; def</code>
<code>    /Xvals &lt;&lt;</code>
<code>        Xvals {[exch]} forall</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /Bvals &lt;&lt;</code>
<code>        0 1 255 {dup} for</code>
<code>    &gt;&gt; def</code>
<code>    /Bvals &lt;&lt;</code>
<code>        Bvals {[exch]} forall</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /encvals [ Avals Cvals Tvals Xvals -1 Bvals ] def</code>
<code></code>
<code>    /A 0 def  /C 1 def  /T 2 def  /X 3 def  /D 4 def  /B 5 def</code>
<code>} ctxdef</code>
<code></code>
<code>    stype {</code>
<code></code>
<code>        barcode {</code>
<code>            dup 48 lt exch 57 gt or {</code>
<code>                /bwipp.codeoneStypeNonDigit (S-Type symbols can only contain digits) //raiseerror exec</code>
<code>            } if</code>
<code>        } forall</code>
<code></code>
<code>        /barlen barcode length def</code>
<code>        barlen 18 gt {</code>
<code>            /bwipp.codeoneStypeTooLong (Maximum length exceeded) //raiseerror exec</code>
<code>        } if</code>
<code></code>
<code>        /normalize {</code>
<code>            /base exch def</code>
<code>            /num exch def</code>
<code>            num length 1 sub -1 1 {</code>
<code>                /i exch def</code>
<code>                num i 1 sub 2 copy get num i get base idiv add put</code>
<code>                num i num i get base mod put</code>
<code>            } for</code>
<code>            { %loop - extend input as necessary</code>
<code>                num 0 get base lt {exit} if</code>
<code>                /num [0 num {} forall] def</code>
<code>                num 0 num 0 get num 1 get base idiv add put</code>
<code>                num 1 num 1 get base mod put</code>
<code>            } loop</code>
<code>            % Trim leading zeros</code>
<code>            /num [/i true def num {dup 0 eq i and {pop} {/i false def} ifelse} forall] def</code>
<code>            num length 0 eq {/num [0] def} if</code>
<code>            num</code>
<code>        } def</code>
<code></code>
<code>        /bigadd {</code>
<code>            2 copy length exch length</code>
<code>            2 copy sub abs /offset exch def</code>
<code>            lt {exch} if</code>
<code>            /a exch def /b exch def</code>
<code>            0 1 b length 1 sub {</code>
<code>                dup a exch offset add 2 copy get b 5 -1 roll get add put</code>
<code>            } for</code>
<code>            a</code>
<code>        } def</code>
<code></code>
<code>        /barlen barcode length def</code>
<code></code>
<code>        % Convert value plus one to binary</code>
<code>        /v [ 1 ] def</code>
<code>        0 1 barlen 1 sub {</code>
<code>            /i exch def</code>
<code>            [ stypevals i get {48 sub barcode barlen i sub 1 sub get 48 sub mul} forall ]</code>
<code>            v bigadd /v exch def</code>
<code>        } for</code>
<code>        /v v 2 normalize def</code>
<code></code>
<code>        % Split into 5-bit codewords</code>
<code>        /v [ 5 v length 5 mod sub 5 mod {0} repeat v aload pop ] def</code>
<code>        /cws v length 5 idiv array def</code>
<code>        0 1 cws length 1 sub {</code>
<code>            /i exch def</code>
<code>            v i 5 mul 5 getinterval</code>
<code>            0 exch {add 2 mul} forall 2 idiv</code>
<code>            cws exch i exch put</code>
<code>        } for</code>
<code></code>
<code>        /metrics stypemetrics def</code>
<code></code>
<code>    } {  % Standard and type-T</code>
<code></code>
<code>        % Convert input into bytes accounting for FNC characters</code>
<code>        /fncvals &lt;&lt;</code>
<code>            /parse parse</code>
<code>            /parsefnc parsefnc</code>
<code>            /eci true</code>
<code>            (FNC1) fnc1</code>
<code>            (FNC3) fnc3</code>
<code>        &gt;&gt; def</code>
<code>        /msg barcode fncvals //parseinput exec def</code>
<code>        /msglen msg length def</code>
<code></code>
<code>        % Code One stores ECIs in data</code>
<code>        /eciesc 16#5c def  % We choose \ as a typical default</code>
<code>        /numecis 0 msg { -1000000 le {1 add} if } forall def</code>
<code>        numecis 0 gt {</code>
<code>            /msgtmp msg length 2 mul numecis 6 mul add 2 add array def</code>
<code>            msgtmp 0 pad put</code>
<code>            msgtmp 1 eciesc put</code>
<code>            /j 2 def</code>
<code>            0 1 msg length 1 sub {</code>
<code>                msg exch get</code>
<code>                dup -1000000 le {</code>
<code>                    neg 10 7 string cvrs 1 6 getinterval {} forall 6 array astore</code>
<code>                    msgtmp exch j 1 add exch putinterval</code>
<code>                    msgtmp j eciesc put</code>
<code>                    /j j 7 add def</code>
<code>                } {</code>
<code>                    dup eciesc ne {</code>
<code>                        msgtmp exch j exch put</code>
<code>                        /j j 1 add def</code>
<code>                    } {</code>
<code>                        pop</code>
<code>                        msgtmp j eciesc put</code>
<code>                        msgtmp j 1 add eciesc put</code>
<code>                        /j j 2 add def</code>
<code>                    } ifelse</code>
<code>                } ifelse</code>
<code>            } for</code>
<code>            /msg msgtmp 0 j getinterval def</code>
<code>            /msglen msg length def</code>
<code>        } if</code>
<code></code>
<code>        /metrics nonstypemetrics def</code>
<code></code>
<code>        % Select metrics of an appropriate symbol</code>
<code>        /fullcws [] def</code>
<code>        metrics {</code>
<code>            /m exch def</code>
<code>            /vers m 0 get def           % Version of symbol</code>
<code>            /dcws m 4 get def           % Data codewords in symbol</code>
<code>            /okay true def</code>
<code>            version (unset) eq {</code>
<code>                vers length 1 ne {/okay false def} if</code>
<code>            } {</code>
<code>                version vers ne {/okay false def} if</code>
<code>            } ifelse</code>
<code>            okay {/fullcws [ fullcws aload pop dcws ] def} if</code>
<code>        } forall</code>
<code>        /numremcws [ 1480 {10000} repeat ] def</code>
<code>        fullcws {numremcws exch 1 sub 1 put} forall</code>
<code>        1478 -1 0 {</code>
<code>            /i exch def</code>
<code>            numremcws i get 1 ne {</code>
<code>                numremcws i numremcws i 1 add get 1 add put</code>
<code>            } if</code>
<code>        } for</code>
<code></code>
<code>        /numD [ msglen {0} repeat 0 ] def</code>
<code>        /nextXterm [ msglen {0} repeat 9999 ] def</code>
<code>        /nextNonX  [ msglen {0} repeat 9999 ] def</code>
<code>        msglen 1 sub -1 0 {</code>
<code>            /i exch def</code>
<code>            /barchar msg i get def</code>
<code>            barchar 48 ge barchar 57 le and {</code>
<code>                numD i numD i 1 add get 1 add put</code>
<code>            } if</code>
<code>            barchar 13 eq barchar 42 eq or barchar 62 eq or {</code>
<code>                nextXterm i 0 put</code>
<code>            } {</code>
<code>                nextXterm i nextXterm i 1 add get 1 add put</code>
<code>            } ifelse</code>
<code>            Xvals barchar known not {</code>
<code>                nextNonX i 0 put</code>
<code>            } {</code>
<code>                nextNonX i nextNonX i 1 add get 1 add put</code>
<code>            } ifelse</code>
<code>        } for</code>
<code>        /nextXterm [nextXterm {dup 10000 gt {pop 10000} if} forall] def</code>
<code>        /nextNonX  [nextNonX  {dup 10000 gt {pop 10000} if} forall] def</code>
<code></code>
<code>        /isD  {char 48 ge char 57 le and} def</code>
<code>        /isC  {CNvals char known} def</code>
<code>        /isT  {TNvals char known} def</code>
<code>        /isX  {Xvals char known} def</code>
<code>        /isEA {char 127 gt} def</code>
<code>        /isFN {char 0 lt} def</code>
<code>        /XtermFirst {dup nextXterm exch get exch nextNonX exch get lt} def</code>
<code></code>
<code>        /lookup {</code>
<code>            /ac 1 def /cc 2 def /tc 2 def /xc 2 def /bc 3 def</code>
<code>            mode A eq {/ac 0 def /cc 1 def /tc 1 def /xc 1 def /bc 2 def} if</code>
<code>            mode C eq {/cc 0 def} if</code>
<code>            mode T eq {/tc 0 def} if</code>
<code>            mode X eq {/xc 0 def} if  % Assume mistake in spec</code>
<code>            mode B eq {/bc 0 def} if</code>
<code>            1 {  % common exit</code>
<code>                /k 0 def {  % loop</code>
<code>                    i k add msglen eq {</code>
<code>                        true [ac cc tc xc   ] {bc         exch ceiling le and} forall {B exit} if</code>
<code>                        true [   cc tc xc bc] {ac         exch ceiling le and} forall {A exit} if</code>
<code>                        true [      tc xc   ] {cc ceiling exch ceiling le and} forall {C exit} if</code>
<code>                        true [         xc   ] {tc ceiling exch ceiling le and} forall {T exit} if</code>
<code>                        X exit</code>
<code>                    } if</code>
<code>                    /char msg i k add get def</code>
<code>                    /ac ac isD {1 2 div add} {isEA {ceiling 2 add} {ceiling 1 add} ifelse} ifelse def</code>
<code>                    /cc cc isC { 0.6666667 add} {isEA { 2.6666667 add } { 1.3333334 add } ifelse} ifelse def</code>
<code>                    /tc tc isT { 0.6666667 add} {isEA { 2.6666667 add } { 1.3333334 add } ifelse} ifelse def</code>
<code>                    /xc xc isX { 0.6666667 add} {isEA { 4.3333334 add } { 3.3333334 add } ifelse} ifelse def</code>
<code>                    /bc bc isFN {3 add} {1 add} ifelse def</code>
<code>                    k 3 ge {  % Checking after at least 4 characters (cf. Data Matrix), not 3 as in spec Step Q</code>
<code>                        true [ac cc tc xc   ] {bc 1 add exch ceiling le and} forall {B exit} if</code>
<code>                        true [   cc tc xc bc] {ac 1 add exch ceiling le and} forall {A exit} if</code>
<code>                        true [ac cc    xc bc] {tc ceiling 1 add exch ceiling le and} forall {T exit} if</code>
<code>                        true [ac    tc      ] {cc ceiling 1 add exch ceiling le and} forall {</code>
<code>                            cc ceiling xc ceiling lt {C exit} if</code>
<code>                            cc xc eq {i k add 1 add XtermFirst {X exit} {C exit} ifelse} if</code>
<code>                        } if</code>
<code>                        true [ac cc tc    bc] {xc ceiling 1 add exch ceiling le and} forall {X exit} if</code>
<code>                    } if</code>
<code>                    /k k 1 add def</code>
<code>                } loop</code>
<code>            } repeat</code>
<code>        } def</code>
<code></code>
<code>        /addtocws {</code>
<code>            dup length j add 1480 gt {</code>
<code>                pop /bwipp.codeoneTooLong (Maximum length exceeded) //raiseerror exec</code>
<code>            } if</code>
<code>            dup cws exch j exch putinterval</code>
<code>            /j exch length j add def</code>
<code>        } def</code>
<code></code>
<code>        /tobin {</code>
<code>            string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for</code>
<code>            dup 3 -1 roll 2 2 index length string cvrs dup length 2 index length exch sub exch putinterval</code>
<code>            [ exch {48 sub} forall ]</code>
<code>        } def</code>
<code></code>
<code>        /encA {</code>
<code>            1 {  % Common exit</code>
<code>                numD i get 21 ge {</code>
<code>                    /Dbits [ 1 1 1 1 ] def</code>
<code>                    /mode D def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                numD i get dup 13 ge exch i add msglen eq and {</code>
<code>                    /Dbits [ 1 1 1 1 ] def</code>
<code>                    /mode D def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                numD i get 2 ge {</code>
<code>                    2 string dup 0 msg i get put dup 1 msg i 1 add get put Avals exch get addtocws</code>
<code>                    /i i 2 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                msg i get fnc1 eq {</code>
<code>                    numD i 1 add get 15 ge {</code>
<code>                        Avals fnc1lD get addtocws</code>
<code>                        /i i 1 add def</code>
<code>                        /Dbits [] def</code>
<code>                        /mode D def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    numD i 1 add get dup 7 ge exch i add 1 add msglen eq and {</code>
<code>                        Avals fnc1lD get addtocws</code>
<code>                        /i i 1 add def</code>
<code>                        /Dbits [] def</code>
<code>                        /mode D def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                } if</code>
<code>                /newmode lookup def</code>
<code>                newmode mode ne {</code>
<code>                    Avals [-1 lC lT lX lD lB] newmode get get addtocws</code>
<code>                    /mode newmode def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                Avals msg i get get addtocws</code>
<code>                /i i 1 add def</code>
<code>                exit</code>
<code>            } repeat</code>
<code>        } def</code>
<code></code>
<code>        /CTXvalstocws {</code>
<code>            /in exch def</code>
<code>            mark</code>
<code>            0 3 in length 1 sub {</code>
<code>                in exch 3 getinterval 0 exch {add 40 mul} forall 40 idiv 1 add</code>
<code>                dup 256 idiv exch 256 mod</code>
<code>            } for</code>
<code>            counttomark array astore exch pop</code>
<code>        } def</code>
<code></code>
<code>        /encCTX {</code>
<code>            /p 0 def</code>
<code>            /ctxvals 2220 array def</code>
<code></code>
<code>            % Lookup the values for each character</code>
<code>            {</code>
<code>                i msglen eq {exit} if</code>
<code>                p 3 mod 0 eq {</code>
<code>                    numD i get 12 ge {</code>
<code>                        ctxvals 0 p getinterval CTXvalstocws addtocws</code>
<code>                        [unlcw] addtocws</code>
<code>                        /mode A def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    numD i get dup 8 ge exch i add msglen eq and {</code>
<code>                        ctxvals 0 p getinterval CTXvalstocws addtocws</code>
<code>                        [unlcw] addtocws</code>
<code>                        /mode A def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    mode X eq {  % Steps E1c, E2</code>
<code>                        Xvals msg i get known not {</code>
<code>                            ctxvals 0 p getinterval CTXvalstocws addtocws</code>
<code>                            % Unlatch to ASCII unless one codeword left and single ASCII to encode</code>
<code>                            numremcws j get 1 ne msg i get 127 gt or {</code>
<code>                                [unlcw] addtocws</code>
<code>                            } if</code>
<code>                            /mode A def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                        i 1 add msglen lt {</code>
<code>                            Xvals msg i 1 add get known not {exit} if</code>
<code>                            i 2 add msglen lt {</code>
<code>                                Xvals msg i 2 add get known not {exit} if</code>
<code>                            } if</code>
<code>                        } if</code>
<code>                    } {</code>
<code>                        lookup mode ne {</code>
<code>                            ctxvals 0 p getinterval CTXvalstocws addtocws</code>
<code>                            [unlcw] addtocws</code>
<code>                            /mode A def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } ifelse</code>
<code>                    msglen i sub 3 le {  % Check end of data conditions</code>
<code>                        /remcws numremcws j p 3 idiv 2 mul add get def</code>
<code>                        /remvals [</code>
<code>                            msg i msglen i sub getinterval {</code>
<code>                                dup encvals mode get exch known {</code>
<code>                                    encvals mode get exch get aload pop</code>
<code>                                } {  % Unencodable X12 characters</code>
<code>                                    pop -1 -1 -1 -1</code>
<code>                                } ifelse</code>
<code>                            } forall</code>
<code>                        ] def</code>
<code>                        remcws 2 eq remvals length 3 eq and {</code>
<code>                            % Encode and omit unlatch</code>
<code>                            [</code>
<code>                                ctxvals 0 p getinterval aload pop</code>
<code>                                remvals aload pop</code>
<code>                            ] CTXvalstocws addtocws</code>
<code>                            /mode A def</code>
<code>                            /i msglen def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                        remcws 2 eq remvals length 2 eq and mode X ne and {</code>
<code>                            % Encode with sft1 as third value, omit unlatch</code>
<code>                            [</code>
<code>                                ctxvals 0 p getinterval aload pop</code>
<code>                                remvals aload pop</code>
<code>                                encvals mode get sft1 get aload pop</code>
<code>                            ] CTXvalstocws addtocws</code>
<code>                            /mode A def</code>
<code>                            /i msglen def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                        remcws 2 eq remvals length 1 eq and {</code>
<code>                            % Unlatch to ASCII</code>
<code>                            ctxvals 0 p getinterval CTXvalstocws addtocws</code>
<code>                            [unlcw] addtocws</code>
<code>                            Avals msg i get get addtocws</code>
<code>                            /mode A def</code>
<code>                            /i msglen def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                        remcws 1 eq remvals length 1 eq and {</code>
<code>                            % Implied unlatch to ASCII</code>
<code>                            ctxvals 0 p getinterval CTXvalstocws addtocws</code>
<code>                            Avals msg i get get addtocws</code>
<code>                            /mode A def</code>
<code>                            /i msglen def</code>
<code>                            exit</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                } if</code>
<code>                encvals mode get msg i get get</code>
<code>                dup ctxvals exch p exch putinterval</code>
<code>                /p exch length p add def</code>
<code>                /i i 1 add def</code>
<code>            } loop</code>
<code></code>
<code>            % Backtrack to a boundary and return to ASCII</code>
<code>            mode A ne {</code>
<code>                {</code>
<code>                    p 3 mod 0 eq {exit} if</code>
<code>                    /i i 1 sub def</code>
<code>                    /p p encvals mode get msg i get get length sub def</code>
<code>                } loop</code>
<code>                [</code>
<code>                    ctxvals 0 p getinterval aload pop</code>
<code>                ] CTXvalstocws addtocws</code>
<code>                [unlcw] addtocws</code>
<code>                /mode A def</code>
<code>                % Encode something to avoid latching immediately back</code>
<code>                i msglen ne {</code>
<code>                    numD i get 2 ge {</code>
<code>                        2 string dup 0 msg i get put dup 1 msg i 1 add get put Avals exch get addtocws</code>
<code>                        /i i 2 add def</code>
<code>                    } {</code>
<code>                        Avals msg i get get addtocws</code>
<code>                        /i i 1 add def</code>
<code>                    } ifelse</code>
<code>                } if</code>
<code>            } if</code>
<code></code>
<code>        } def</code>
<code></code>
<code>        /encD {</code>
<code></code>
<code>            {  % loop</code>
<code></code>
<code>                numD i get 3 lt {</code>
<code></code>
<code>                    /Drem 8 Dbits length 8 mod sub 8 mod def</code>
<code>                    /remcws numremcws j Dbits length 8 idiv add get def</code>
<code></code>
<code>                    % Final codeword with no data</code>
<code>                    numremcws j Dbits length 8 idiv add 1 sub get 1 sub 0 eq Drem 0 eq and  % No remaining codewords and no bits</code>
<code>                    remcws 1 eq Drem 0 ne and or  % Or 1 remaining codeword and some bits</code>
<code>                    i msglen eq and {</code>
<code>                        Drem 4 eq Drem 6 eq or { /Dbits [ Dbits aload pop 1 1 1 1 ] def } if</code>
<code>                        Drem 2 eq Drem 6 eq or { /Dbits [ Dbits aload pop 0 1 ] def } if</code>
<code>                        exit</code>
<code>                    } if</code>
<code></code>
<code>                    % Final digit or double-digit into final codeword as ASCII</code>
<code>                    i msglen 1 sub eq numD i get 1 eq and</code>
<code>                    i msglen 2 sub eq numD i get 2 eq and or</code>
<code>                    remcws 1 eq and Drem 0 eq and {exit} if</code>
<code></code>
<code>                    % Latch to ASCII unless 4 or 6 bits remain in final codeword</code>
<code>                    i msglen 1 sub eq numD i get 1 eq and</code>
<code>                    remcws 1 eq and Drem 4 eq Drem 6 eq or and not {</code>
<code>                      /Dbits [ Dbits aload pop 1 1 1 1 1 1 ] def</code>
<code>                      /Drem 8 Dbits length 8 mod sub 8 mod def</code>
<code>                    } if</code>
<code></code>
<code>                    % Try to encode a digit in remaining bits</code>
<code>                    Drem 4 eq Drem 6 eq or {</code>
<code>                        numD i get 1 ge {</code>
<code>                            /Dbits [ Dbits aload pop msg i get 48 sub 1 add 4 tobin aload pop ] def</code>
<code>                            /i i 1 add def</code>
<code>                        } {</code>
<code>                            /Dbits [ Dbits aload pop 1 1 1 1 ] def</code>
<code>                        } ifelse</code>
<code>                        /Drem Drem 4 sub def</code>
<code>                    } if</code>
<code>                    Drem 2 eq {</code>
<code>                        /Dbits [ Dbits aload pop 0 1 ] def</code>
<code>                        /Drem 0 def</code>
<code>                    } if</code>
<code></code>
<code>                    exit</code>
<code></code>
<code>                } if</code>
<code></code>
<code>                % Three digit value plus one to ten bits</code>
<code>                /Dbits [</code>
<code>                    Dbits aload pop</code>
<code>                    0 msg i 3 getinterval {48 sub add 10 mul} forall 10 idiv</code>
<code>                    1 add 10 tobin aload pop</code>
<code>                ] def</code>
<code>                /i i 3 add def</code>
<code></code>
<code>            } loop</code>
<code></code>
<code>            mark</code>
<code>            0 8 Dbits length 1 sub {</code>
<code>                Dbits exch 8 getinterval 0 exch {add 2 mul} forall 2 idiv</code>
<code>            } for</code>
<code>            counttomark array astore exch pop addtocws</code>
<code>            /mode A def</code>
<code></code>
<code>        } def</code>
<code></code>
<code>        /encB {</code>
<code>            /p 0 def /bvals 1480 array def {</code>
<code>                i msglen eq {exit} if</code>
<code>                msg i get 0 lt {exit} if  % Function character</code>
<code>                lookup mode ne {exit} if</code>
<code>                bvals p msg i get put</code>
<code>                /p p 1 add def</code>
<code>                /i i 1 add def</code>
<code>            } loop</code>
<code>            /remcws numremcws j p add get 1 sub def</code>
<code>            /bvals [</code>
<code>                remcws 0 eq i msglen eq and {  % Terminates symbol</code>
<code>                    0</code>
<code>                } {</code>
<code>                    p 250 lt {p} {p 250 idiv 249 add p 250 mod} ifelse</code>
<code>                } ifelse</code>
<code>                bvals 0 p getinterval aload pop</code>
<code>            ] def</code>
<code>            bvals addtocws</code>
<code>            /mode A def</code>
<code>        } def</code>
<code></code>
<code>        % Derive the codewords</code>
<code>        /cws 1480 array def</code>
<code>        /mode A def /i 0 def /j 0 def {</code>
<code>            i msglen ge {exit} if</code>
<code>            [ /encA /encCTX /encCTX /encCTX /encD /encB ] mode get load exec</code>
<code>        } loop</code>
<code>        /cws cws 0 j getinterval def</code>
<code></code>
<code>    } ifelse</code>
<code></code>
<code>    % Select metrics of an appropriate symbol</code>
<code>    metrics {</code>
<code>        /m exch def</code>
<code>        /vers m 0 get def           % Version of symbol</code>
<code>        /rows m 1 get def           % Rows in symbol</code>
<code>        /cols m 2 get def           % Columns in symbol</code>
<code>        /dcol m 3 get def           % Data columns in symbol</code>
<code>        /dcws m 4 get def           % Data codewords in symbol</code>
<code>        /rscw m 5 get def           % Error correction codewords</code>
<code>        /rsbl m 6 get def           % Error correction blocks</code>
<code>        /riso m 7 get def           % Riser offset</code>
<code>        /risi m 8 get def           % Riser interval</code>
<code>        /risl m 9 get def           % Riser length</code>
<code>        /dcpb dcws rsbl idiv def    % Data codewords per block</code>
<code>        /ecpb rscw rsbl idiv def    % Error codewords per block</code>
<code>        /okay true def</code>
<code>        version (unset) ne version vers ne and {/okay false def} if  % The version must match that supplied</code>
<code>        cws length dcws gt {/okay false def} if</code>
<code>        okay {exit} if</code>
<code>    } forall</code>
<code></code>
<code>    okay not {</code>
<code>        /bwipp.codeoneNoValidSymbol (Maximum length exceeded) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Extend cws to ncws codewords by addition of pad characters</code>
<code>    stype not {</code>
<code>        /cws [ cws aload pop dcws cws length sub {129} repeat ] def</code>
<code>    } {</code>
<code>        /cws [ dcws cws length sub {0} repeat cws aload pop ] def</code>
<code>    } ifelse</code>
<code></code>
<code>    options /debugcws known { /bwipp.debugcws cws //raiseerror exec } if</code>
<code></code>
<code>    % De-interleave the codewords into blocks</code>
<code>    /cwbs rsbl array def  % Array of data codeword blocks</code>
<code>    /ecbs rsbl array def  % Array of error correction blocks</code>
<code>    0 1 rsbl 1 sub {</code>
<code>        /i exch def</code>
<code>        /cwb dcpb array def</code>
<code>        0 1 dcpb 1 sub {</code>
<code>            /j exch def</code>
<code>            cwb j cws j rsbl mul i add get put</code>
<code>        } for</code>
<code>        cwbs i cwb put</code>
<code>    } for</code>
<code></code>
<code>    % Log and anti-log tables and function to calculate product in the field</code>
<code>    /gf stype {32} {256} ifelse def</code>
<code>    /gf-1 gf 1 sub def</code>
<code>    /pm stype {37} {301} ifelse def</code>
<code>    /rsalog [ 1 gf-1 { dup 2 mul dup gf ge {pm xor} if } repeat ] def</code>
<code>    /rslog gf array def</code>
<code>    1 1 gf-1 {dup rsalog exch get exch rslog 3 1 roll put} for</code>
<code>    /rsprod {</code>
<code>        2 copy 0 ne exch 0 ne and {</code>
<code>            rslog exch get exch rslog exch get add gf-1 mod rsalog exch get</code>
<code>        } {</code>
<code>            pop pop 0</code>
<code>        } ifelse</code>
<code>    } def</code>
<code></code>
<code>    % Generate the coefficients for the Reed-Solomon algorithm</code>
<code>    /coeffs [ 1 ecpb {0} repeat ] def</code>
<code>    0 1 ecpb 1 sub {</code>
<code>        /i exch def</code>
<code>        coeffs i 1 add coeffs i get put</code>
<code>        i -1 1 {</code>
<code>            /j exch def</code>
<code>            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put</code>
<code>        } for</code>
<code>        coeffs 0 coeffs 0 get rsalog i get rsprod put</code>
<code>    } for</code>
<code>    /coeffs coeffs 0 coeffs length 1 sub getinterval def</code>
<code></code>
<code>    % Reed-Solomon algorithm to derive the error correction codewords</code>
<code>    0 1 cwbs length 1 sub {</code>
<code>        /i exch def</code>
<code>        /rscws [ cwbs i get aload pop ecpb {0} repeat ] def</code>
<code>        0 1 dcpb 1 sub {</code>
<code>            /m exch def</code>
<code>            /k rscws m get def</code>
<code>            0 1 ecpb 1 sub {</code>
<code>                /j exch def</code>
<code>                rscws m j add 1 add coeffs ecpb j sub 1 sub get k rsprod rscws m j add 1 add get xor put</code>
<code>            } for</code>
<code>        } for</code>
<code>        ecbs i rscws dcpb ecpb getinterval put</code>
<code>    } for</code>
<code></code>
<code>    % Extend codewords with the interleaved error correction codes</code>
<code>    /cws [ cws aload pop rscw {0} repeat ] def</code>
<code>    0 1 rscw 1 sub {</code>
<code>        /i exch def</code>
<code>        cws dcws i add ecbs i rsbl mod get i rsbl idiv get put</code>
<code>    } for</code>
<code></code>
<code>    % Module matrix for layout of the codewords</code>
<code>    /mmat dcws rscw add stype {5} {8} ifelse mul array def</code>
<code>    /r 0 def /c 0 def</code>
<code>    0 stype {2} {1} ifelse cws length 1 sub {</code>
<code>        /i exch def</code>
<code>        stype not {</code>
<code>            (00000000) 8 string copy dup cws i get 2 8 string cvrs</code>
<code>            dup length 8 exch sub exch putinterval [ exch {48 sub} forall ]</code>
<code>            dup 0 4 getinterval /top exch def</code>
<code>            4 4 getinterval /bot exch def</code>
<code>        } {</code>
<code>            (00000) 5 string copy dup cws i get 2 5 string cvrs</code>
<code>            dup length 5 exch sub exch putinterval [ exch {48 sub} forall ]</code>
<code>            /c1 exch def</code>
<code>            (00000) 5 string copy dup cws i 1 add get 2 5 string cvrs</code>
<code>            dup length 5 exch sub exch putinterval [ exch {48 sub} forall ]</code>
<code>            /c2 exch def</code>
<code>            /top [ c1 0 3 getinterval aload pop c2 0 2 getinterval aload pop ] def</code>
<code>            /bot [ c1 3 2 getinterval aload pop c2 2 3 getinterval aload pop ] def</code>
<code>        } ifelse</code>
<code>        mmat r dcol mul c add top putinterval</code>
<code>        mmat r 1 add dcol mul c add bot putinterval</code>
<code>        /c c top length add def</code>
<code>        c dcol eq {/c 0 def /r r 2 add def} if</code>
<code>    } for</code>
<code></code>
<code>    % Create bitmap and add finder patterns</code>
<code>    /mmv {cols mul add} def</code>
<code>    /pixs [ rows cols mul {-1} repeat ] def</code>
<code></code>
<code>    % Centre pattern</code>
<code>    /artifact [</code>
<code>        {cols {0} repeat} bind</code>
<code>        {cols {1} repeat} bind</code>
<code>        {0   cols 2 sub {1} repeat   0} bind</code>
<code>        {0 1 cols 4 sub {0} repeat 1 0} bind</code>
<code>        {cols 1 sub 2 idiv {-1} repeat 1 cols 1 sub 2 idiv {-1} repeat} bind</code>
<code>        {cols 1 sub 2 idiv {-1} repeat 0 cols 1 sub 2 idiv {-1} repeat} bind</code>
<code>        {1   cols 2 sub {0} repeat   1} bind</code>
<code>        {1 0 cols 4 sub {1} repeat 0 1} bind</code>
<code>    ] def</code>
<code>{</code>
<code>    /cpatmap &lt;&lt;</code>
<code>        /A (121343)</code>
<code>        /B (12134343)</code>
<code>        /C (12121343)</code>
<code>        /D (1213434343)</code>
<code>        /E (1212134343)</code>
<code>        /F (1212121343)</code>
<code>        /G (121213434343)</code>
<code>        /H (121212134343)</code>
<code>        /S (56661278)</code>
<code>        /T (5666666666127878)</code>
<code>    &gt;&gt; def</code>
<code>} ctxdef</code>
<code>    /cpat cpatmap vers 0 1 getinterval get def</code>
<code>    pixs 0 rows cpat length sub 2 idiv mmv</code>
<code>    [ cpat {artifact exch 49 sub get exec} forall ] putinterval</code>
<code></code>
<code>    % Risers</code>
<code>    0 1 risl 1 sub {</code>
<code>        /i exch def</code>
<code>        riso risi cols 1 sub {</code>
<code>            /j exch def</code>
<code>            [ 1 i 12 mod 0 eq {1} {0} ifelse ] dup</code>
<code>            pixs j i mmv</code>
<code>            3 -1 roll putinterval</code>
<code>            i risl 1 sub ne {</code>
<code>                pixs cols j sub 2 sub rows i sub 1 sub mmv</code>
<code>                3 -1 roll putinterval</code>
<code>            } {pop} ifelse</code>
<code>        } for</code>
<code>    } for</code>
<code></code>
<code>    % Black dots</code>
<code>{</code>
<code>    /blackdotmap &lt;&lt;</code>
<code>        /A [ [12 5] ]</code>
<code>        /B [ [16 7] ]</code>
<code>        /C [ [26 12] ]</code>
<code>        /D []</code>
<code>        /E [ [26 23] ]</code>
<code>        /F [ [26 32] [70 32] [26 34] [70 34] ]</code>
<code>        /G [ [27 48] [69 48] ]</code>
<code>        /H [ [26 70] [66 70] [106 70] [26 72] [66 72] [106 72] ]</code>
<code>        /S-10 []</code>
<code>        /S-20 [ [10 4] ]</code>
<code>        /S-30 [ [15 4] [15 6] ]</code>
<code>        /T-16 [ [8 10] ]</code>
<code>        /T-32 [ [16 10] [16 12] ]</code>
<code>        /T-48 [ [24 10] [24 12] [24 14] ]</code>
<code>    &gt;&gt; def</code>
<code>} ctxdef</code>
<code>    blackdotmap vers get {pixs exch aload pop mmv 1 put} forall</code>
<code></code>
<code>    % Place the modules onto a pixel map between alignment patterns</code>
<code>    /j 0 def</code>
<code>    0 1 pixs length 1 sub {</code>
<code>        /i exch def</code>
<code>        pixs i get -1 eq {</code>
<code>            pixs i mmat j get put</code>
<code>            /j j 1 add def</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renmatrix</code>
<code>    /pixs pixs</code>
<code>    /pixx cols</code>
<code>    /pixy rows</code>
<code>    /height rows 72 div 2 mul</code>
<code>    /width cols 72 div 2 mul</code>
<code>    stype ttype or {</code>
<code>        /borderleft 1.0</code>
<code>        /borderright 1.0</code>
<code>        /bordertop 0.0</code>
<code>        /borderbottom 1.0</code>
<code>    } if</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /codeone dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER codeone--</code>
<code></code>
<code>% --BEGIN ENCODER hanxin--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix--</code>
<code>% --DESC: Han Xin Code</code>
<code>% --EXAM: This is Han Xin</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp hanxin 0.0 2024010300 313245 359891</code>
<code>%%BeginData:        882 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/hanxin {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /version (unset) def   % 1-84</code>
<code>    /eclevel (L2) def   % L1, L2, L3 or L4</code>
<code>    /parse false def</code>
<code>    /parsefnc false def</code>
<code>    /mask -1 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.hanxinEmptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    version (unset) ne {</code>
<code>        version length dup 1 ge exch 2 le and dup {</code>
<code>            pop</code>
<code>            true version {dup 48 lt exch 57 gt or { pop false } if } forall dup {</code>
<code>                pop version cvi dup 1 ge exch 84 le and</code>
<code>            } if</code>
<code>        } if</code>
<code>        not {</code>
<code>            /bwipp.hanxinInvalidVersion (Valid versions are 1 to 84) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    eclevel length 2 eq dup {</code>
<code>        pop eclevel 0 1 getinterval (L) dup eq {</code>
<code>            pop eclevel 1 get 48 sub dup 1 ge exch 4 le and</code>
<code>        } if</code>
<code>    } if</code>
<code>    not {</code>
<code>        /bwipp.hanxinInvalidErrorCorrectionLevel (Valid error correction levels are L1 to L4) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    mask -1 ne {</code>
<code>        mask 1 lt mask 4 gt or {</code>
<code>            /bwipp.hanxinInvalidErrorCorrectionLevel (The valid masks are 1 to 4) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    /hanxin //loadctx exec</code>
<code></code>
<code>    % Parse the input</code>
<code>    /fncvals &lt;&lt;</code>
<code>        /parse parse</code>
<code>        /parsefnc parsefnc</code>
<code>        % No FNC characters defined</code>
<code>    &gt;&gt; def</code>
<code>    /msg barcode fncvals //parseinput exec def</code>
<code>    /msglen msg length def</code>
<code></code>
<code>    /tobin {</code>
<code>        string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for</code>
<code>        dup 3 -1 roll 2 2 index length string cvrs</code>
<code>        dup length 2 index length exch sub exch putinterval</code>
<code>    } def</code>
<code></code>
<code>    % Encode the data using byte mode encoding</code>
<code>    /bits 4 13 add msglen 8 mul add string def</code>
<code>    bits 0 (0011) putinterval</code>
<code>    bits 4 msglen 13 tobin putinterval</code>
<code>    0 1 msglen 1 sub {</code>
<code>        /i exch def</code>
<code>        bits 17 i 8 mul add msg i get 8 tobin putinterval</code>
<code>    } for</code>
<code></code>
<code>    % Lookup the most appropriate symbol specification</code>
<code>{</code>
<code>    /metrics [</code>
<code>        % vers size  align  modules            error correction blocks</code>
<code>        [ (1)    23  -1  0    205  [  1  21   4 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  17   8 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  13  12 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1   9  16 ] [  0  -1  -1 ] [  0  -1  -1 ] ]</code>
<code>        [ (2)    25  -1  0    301  [  1  31   6 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  25  12 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  19  18 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  15  22 ] [  0  -1  -1 ] [  0  -1  -1 ] ]</code>
<code>        [ (3)    27  -1  0    405  [  1  42   8 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  34  16 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  26  24 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  20  30 ] [  0  -1  -1 ] [  0  -1  -1 ] ]</code>
<code>        [ (4)    29  14  1    439  [  1  46   8 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  38  16 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  30  24 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  22  32 ] [  0  -1  -1 ] [  0  -1  -1 ] ]</code>
<code>        [ (5)    31  16  1    555  [  1  57  12 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  49  20 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  37  32 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  14  20 ] [  1  13  22 ] [  0  -1  -1 ] ]</code>
<code>        [ (6)    33  16  1    675  [  1  70  14 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  58  26 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  24  20 ] [  1  22  18 ] [  0  -1  -1 ]</code>
<code>                                   [  1  16  24 ] [  1  18  26 ] [  0  -1  -1 ] ]</code>
<code>        [ (7)    35  17  1    805  [  1  84  16 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  70  30 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  26  22 ] [  1  28  24 ] [  0  -1  -1 ]</code>
<code>                                   [  2  14  20 ] [  1  12  20 ] [  0  -1  -1 ] ]</code>
<code>        [ (8)    37  18  1    943  [  1  99  18 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  40  18 ] [  1  41  18 ] [  0  -1  -1 ]</code>
<code>                                   [  1  31  26 ] [  1  32  28 ] [  0  -1  -1 ]</code>
<code>                                   [  2  16  24 ] [  1  15  22 ] [  0  -1  -1 ] ]</code>
<code>        [ (9)    39  19  1   1089  [  1 114  22 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  2  48  20 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  2  24  20 ] [  1  26  22 ] [  0  -1  -1 ]</code>
<code>                                   [  2  18  28 ] [  1  18  26 ] [  0  -1  -1 ] ]</code>
<code>        [ (10)   41  20  1   1243  [  1 131  24 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  52  22 ] [  1  57  24 ] [  0  -1  -1 ]</code>
<code>                                   [  2  27  24 ] [  1  29  24 ] [  0  -1  -1 ]</code>
<code>                                   [  2  21  32 ] [  1  19  30 ] [  0  -1  -1 ] ]</code>
<code>        [ (11)   43  14  2   1289  [  1 135  26 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  56  24 ] [  1  57  24 ] [  0  -1  -1 ]</code>
<code>                                   [  2  28  24 ] [  1  31  26 ] [  0  -1  -1 ]</code>
<code>                                   [  2  22  32 ] [  1  21  32 ] [  0  -1  -1 ] ]</code>
<code>        [ (12)   45  15  2   1455  [  1 153  28 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  1  62  26 ] [  1  65  28 ] [  0  -1  -1 ]</code>
<code>                                   [  2  32  28 ] [  1  33  28 ] [  0  -1  -1 ]</code>
<code>                                   [  3  17  26 ] [  1  22  30 ] [  0  -1  -1 ] ]</code>
<code>        [ (13)   47  16  2   1629  [  1  86  16 ] [  1  85  16 ] [  0  -1  -1 ]</code>
<code>                                   [  1  71  30 ] [  1  72  30 ] [  0  -1  -1 ]</code>
<code>                                   [  2  37  32 ] [  1  35  30 ] [  0  -1  -1 ]</code>
<code>                                   [  3  20  30 ] [  1  21  32 ] [  0  -1  -1 ] ]</code>
<code>        [ (14)   49  16  2   1805  [  1  94  18 ] [  1  95  18 ] [  0  -1  -1 ]</code>
<code>                                   [  2  51  22 ] [  1  55  24 ] [  0  -1  -1 ]</code>
<code>                                   [  3  30  26 ] [  1  31  26 ] [  0  -1  -1 ]</code>
<code>                                   [  4  18  28 ] [  1  17  24 ] [  0  -1  -1 ] ]</code>
<code>        [ (15)   51  17  2   1995  [  1 104  20 ] [  1 105  20 ] [  0  -1  -1 ]</code>
<code>                                   [  2  57  24 ] [  1  61  26 ] [  0  -1  -1 ]</code>
<code>                                   [  3  33  28 ] [  1  36  30 ] [  0  -1  -1 ]</code>
<code>                                   [  4  20  30 ] [  1  19  30 ] [  0  -1  -1 ] ]</code>
<code>        [ (16)   53  17  2   2187  [  1 115  22 ] [  1 114  22 ] [  0  -1  -1 ]</code>
<code>                                   [  2  65  28 ] [  1  61  26 ] [  0  -1  -1 ]</code>
<code>                                   [  3  38  32 ] [  1  33  30 ] [  0  -1  -1 ]</code>
<code>                                   [  5  19  28 ] [  1  14  24 ] [  0  -1  -1 ] ]</code>
<code>        [ (17)   55  18  2   2393  [  1 126  24 ] [  1 125  24 ] [  0  -1  -1 ]</code>
<code>                                   [  2  70  30 ] [  1  69  30 ] [  0  -1  -1 ]</code>
<code>                                   [  4  33  28 ] [  1  29  26 ] [  0  -1  -1 ]</code>
<code>                                   [  5  20  30 ] [  1  19  30 ] [  0  -1  -1 ] ]</code>
<code>        [ (18)   57  19  2   2607  [  1 136  26 ] [  1 137  26 ] [  0  -1  -1 ]</code>
<code>                                   [  3  56  24 ] [  1  59  26 ] [  0  -1  -1 ]</code>
<code>                                   [  5  35  30 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  6  18  28 ] [  1  21  28 ] [  0  -1  -1 ] ]</code>
<code>        [ (19)   59  20  2   2829  [  1 148  28 ] [  1 149  28 ] [  0  -1  -1 ]</code>
<code>                                   [  3  61  26 ] [  1  64  28 ] [  0  -1  -1 ]</code>
<code>                                   [  7  24  20 ] [  1  23  22 ] [  0  -1  -1 ]</code>
<code>                                   [  6  20  30 ] [  1  21  32 ] [  0  -1  -1 ] ]</code>
<code>        [ (20)   61  20  2   3053  [  3 107  20 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  3  65  28 ] [  1  72  30 ] [  0  -1  -1 ]</code>
<code>                                   [  7  26  22 ] [  1  23  22 ] [  0  -1  -1 ]</code>
<code>                                   [  7  19  28 ] [  1  20  32 ] [  0  -1  -1 ] ]</code>
<code>        [ (21)   63  21  2   3291  [  3 115  22 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  4  56  24 ] [  1  63  28 ] [  0  -1  -1 ]</code>
<code>                                   [  7  28  24 ] [  1  25  22 ] [  0  -1  -1 ]</code>
<code>                                   [  8  18  28 ] [  1  21  22 ] [  0  -1  -1 ] ]</code>
<code>        [ (22)   65  16  3   3383  [  2 116  22 ] [  1 122  24 ] [  0  -1  -1 ]</code>
<code>                                   [  4  56  24 ] [  1  72  30 ] [  0  -1  -1 ]</code>
<code>                                   [  7  28  24 ] [  1  32  26 ] [  0  -1  -1 ]</code>
<code>                                   [  8  18  28 ] [  1  24  30 ] [  0  -1  -1 ] ]</code>
<code>        [ (23)   67  17  3   3631  [  3 127  24 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  5  51  22 ] [  1  62  26 ] [  0  -1  -1 ]</code>
<code>                                   [  7  30  26 ] [  1  35  26 ] [  0  -1  -1 ]</code>
<code>                                   [  8  20  30 ] [  1  21  32 ] [  0  -1  -1 ] ]</code>
<code>        [ (24)   69  17  3   3887  [  2 135  26 ] [  1 137  26 ] [  0  -1  -1 ]</code>
<code>                                   [  5  56  24 ] [  1  59  26 ] [  0  -1  -1 ]</code>
<code>                                   [  7  33  28 ] [  1  30  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 11  16  24 ] [  1  19  26 ] [  0  -1  -1 ] ]</code>
<code>        [ (25)   71  18  3   4151  [  3 105  20 ] [  1 121  22 ] [  0  -1  -1 ]</code>
<code>                                   [  5  61  26 ] [  1  57  26 ] [  0  -1  -1 ]</code>
<code>                                   [  9  28  24 ] [  1  28  22 ] [  0  -1  -1 ]</code>
<code>                                   [ 10  19  28 ] [  1  18  30 ] [  0  -1  -1 ] ]</code>
<code>        [ (26)   73  18  3   4423  [  2 157  30 ] [  1 150  28 ] [  0  -1  -1 ]</code>
<code>                                   [  5  65  28 ] [  1  61  26 ] [  0  -1  -1 ]</code>
<code>                                   [  8  33  28 ] [  1  34  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 10  19  28 ] [  2  15  26 ] [  0  -1  -1 ] ]</code>
<code>        [ (27)   75  19  3   4703  [  3 126  24 ] [  1 115  22 ] [  0  -1  -1 ]</code>
<code>                                   [  7  51  22 ] [  1  54  22 ] [  0  -1  -1 ]</code>
<code>                                   [  8  35  30 ] [  1  37  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 15  15  22 ] [  1  10  22 ] [  0  -1  -1 ] ]</code>
<code>        [ (28)   77  19  3   4991  [  4 105  20 ] [  1 103  20 ] [  0  -1  -1 ]</code>
<code>                                   [  7  56  24 ] [  1  45  18 ] [  0  -1  -1 ]</code>
<code>                                   [ 10  31  26 ] [  1  27  26 ] [  0  -1  -1 ]</code>
<code>                                   [ 10  17  26 ] [  3  20  28 ] [  1  21  28 ] ]</code>
<code>        [ (29)   79  20  3   5287  [  3 139  26 ] [  1 137  28 ] [  0  -1  -1 ]</code>
<code>                                   [  6  66  28 ] [  1  66  30 ] [  0  -1  -1 ]</code>
<code>                                   [  9  36  30 ] [  1  34  32 ] [  0  -1  -1 ]</code>
<code>                                   [ 13  19  28 ] [  1  17  32 ] [  0  -1  -1 ] ]</code>
<code>        [ (30)   81  20  3   5591  [  6  84  16 ] [  1  82  16 ] [  0  -1  -1 ]</code>
<code>                                   [  6  70  30 ] [  1  68  30 ] [  0  -1  -1 ]</code>
<code>                                   [  7  35  30 ] [  3  33  28 ] [  1  32  28 ]</code>
<code>                                   [ 13  20  30 ] [  1  20  28 ] [  0  -1  -1 ] ]</code>
<code>        [ (31)   83  21  3   5903  [  5 105  20 ] [  1  94  18 ] [  0  -1  -1 ]</code>
<code>                                   [  6  74  32 ] [  1  71  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 11  33  28 ] [  1  34  32 ] [  0  -1  -1 ]</code>
<code>                                   [ 13  19  28 ] [  3  16  26 ] [  0  -1  -1 ] ]</code>
<code>        [ (32)   85  17  4   6033  [  4 127  24 ] [  1 126  24 ] [  0  -1  -1 ]</code>
<code>                                   [  7  66  28 ] [  1  66  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 12  30  24 ] [  1  24  28 ] [  1  24  30 ]</code>
<code>                                   [ 15  19  28 ] [  1  17  32 ] [  0  -1  -1 ] ]</code>
<code>        [ (33)   87  17  4   6353  [  7  84  16 ] [  1  78  16 ] [  0  -1  -1 ]</code>
<code>                                   [  7  70  30 ] [  1  66  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 12  33  28 ] [  1  32  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 14  21  32 ] [  1  24  28 ] [  0  -1  -1 ] ]</code>
<code>        [ (34)   89  18  4   6689  [  5 117  22 ] [  1 117  24 ] [  0  -1  -1 ]</code>
<code>                                   [  8  66  28 ] [  1  58  26 ] [  0  -1  -1 ]</code>
<code>                                   [ 11  38  32 ] [  1  34  32 ] [  0  -1  -1 ]</code>
<code>                                   [ 15  20  30 ] [  2  17  26 ] [  0  -1  -1 ] ]</code>
<code>        [ (35)   91  18  4   7025  [  4 148  28 ] [  1 146  28 ] [  0  -1  -1 ]</code>
<code>                                   [  8  68  30 ] [  1  70  24 ] [  0  -1  -1 ]</code>
<code>                                   [ 10  36  32 ] [  3  38  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 16  19  28 ] [  3  16  26 ] [  0  -1  -1 ] ]</code>
<code>        [ (36)   93  19  4   7377  [  4 126  24 ] [  2 135  26 ] [  0  -1  -1 ]</code>
<code>                                   [  8  70  28 ] [  2  43  26 ] [  0  -1  -1 ]</code>
<code>                                   [ 13  32  28 ] [  2  41  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 17  19  28 ] [  3  15  26 ] [  0  -1  -1 ] ]</code>
<code>        [ (37)   95  19  4   7729  [  5 136  26 ] [  1 132  24 ] [  0  -1  -1 ]</code>
<code>                                   [  5  67  30 ] [  4  68  28 ] [  1  69  28 ]</code>
<code>                                   [ 14  35  30 ] [  1  32  24 ] [  0  -1  -1 ]</code>
<code>                                   [ 18  18  26 ] [  3  16  28 ] [  1  14  28 ] ]</code>
<code>        [ (38)   97  19  4   8089  [  3 142  26 ] [  3 141  28 ] [  0  -1  -1 ]</code>
<code>                                   [  8  70  30 ] [  1  73  32 ] [  1  74  32 ]</code>
<code>                                   [ 12  34  30 ] [  3  34  26 ] [  1  35  28 ]</code>
<code>                                   [ 18  21  32 ] [  1  27  30 ] [  0  -1  -1 ] ]</code>
<code>        [ (39)   99  20  4   8465  [  5 116  22 ] [  2 103  20 ] [  1 102  20 ]</code>
<code>                                   [  9  74  32 ] [  1  74  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 14  34  28 ] [  2  32  32 ] [  1  32  30 ]</code>
<code>                                   [ 19  21  32 ] [  1  25  26 ] [  0  -1  -1 ] ]</code>
<code>        [ (40)  101  20  4   8841  [  7 116  22 ] [  1 117  22 ] [  0  -1  -1 ]</code>
<code>                                   [ 11  65  28 ] [  1  58  24 ] [  0  -1  -1 ]</code>
<code>                                   [ 15  38  32 ] [  1  27  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 20  20  30 ] [  1  20  32 ] [  1  21  32 ] ]</code>
<code>        [ (41)  103  17  5   9009  [  6 136  26 ] [  1 130  24 ] [  0  -1  -1 ]</code>
<code>                                   [ 11  66  28 ] [  1  62  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 14  34  28 ] [  3  34  32 ] [  1  30  30 ]</code>
<code>                                   [ 18  20  30 ] [  3  20  28 ] [  2  15  26 ] ]</code>
<code>        [ (42)  105  17  5   9401  [  5 105  20 ] [  2 115  22 ] [  2 116  22 ]</code>
<code>                                   [ 10  75  32 ] [  1  73  32 ] [  0  -1  -1 ]</code>
<code>                                   [ 16  38  32 ] [  1  27  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 22  19  28 ] [  2  16  30 ] [  1  19  30 ] ]</code>
<code>        [ (43)  107  18  5   9799  [  6 147  28 ] [  1 146  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 11  66  28 ] [  2  65  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 18  33  28 ] [  2  33  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 22  21  32 ] [  1  28  30 ] [  0  -1  -1 ] ]</code>
<code>        [ (44)  109  18  5  10207  [  6 116  22 ] [  3 125  24 ] [  0  -1  -1 ]</code>
<code>                                   [ 11  75  32 ] [  1  68  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 13  35  28 ] [  6  34  32 ] [  1  30  30 ]</code>
<code>                                   [ 23  21  32 ] [  1  26  30 ] [  0  -1  -1 ] ]</code>
<code>        [ (45)  111  18  5  10623  [  7 105  20 ] [  4  95  18 ] [  0  -1  -1 ]</code>
<code>                                   [ 12  67  28 ] [  1  63  30 ] [  1  62  32 ]</code>
<code>                                   [ 21  31  26 ] [  2  33  32 ] [  0  -1  -1 ]</code>
<code>                                   [ 23  21  32 ] [  2  24  30 ] [  0  -1  -1 ] ]</code>
<code>        [ (46)  113  19  5  11045  [ 10 116  22 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [ 12  74  32 ] [  1  78  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 18  37  32 ] [  1  39  30 ] [  1  41  28 ]</code>
<code>                                   [ 25  21  32 ] [  1  27  28 ] [  0  -1  -1 ] ]</code>
<code>        [ (47)  115  19  5  11477  [  5 126  24 ] [  4 115  22 ] [  1 114  22 ]</code>
<code>                                   [ 12  67  28 ] [  2  66  32 ] [  1  68  30 ]</code>
<code>                                   [ 21  35  30 ] [  1  39  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 26  21  32 ] [  1  28  28 ] [  0  -1  -1 ] ]</code>
<code>        [ (48)  117  19  5  11917  [  9 126  24 ] [  1 117  22 ] [  0  -1  -1 ]</code>
<code>                                   [ 13  75  32 ] [  1  68  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 20  35  30 ] [  3  35  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 27  21  32 ] [  1  28  30 ] [  0  -1  -1 ] ]</code>
<code>        [ (49)  119  17  6  12111  [  9 126  24 ] [  1 137  26 ] [  0  -1  -1 ]</code>
<code>                                   [ 13  71  30 ] [  2  68  32 ] [  0  -1  -1 ]</code>
<code>                                   [ 20  37  32 ] [  1  39  28 ] [  1  38  28 ]</code>
<code>                                   [ 24  20  32 ] [  5  25  28 ] [  0  -1  -1 ] ]</code>
<code>        [ (50)  121  17  6  12559  [  8 147  28 ] [  1 141  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 10  73  32 ] [  4  74  30 ] [  1  73  30 ]</code>
<code>                                   [ 16  36  32 ] [  6  39  30 ] [  1  37  30 ]</code>
<code>                                   [ 27  21  32 ] [  3  20  26 ] [  0  -1  -1 ] ]</code>
<code>        [ (51)  123  18  6  13025  [  9 137  26 ] [  1 135  26 ] [  0  -1  -1 ]</code>
<code>                                   [ 12  70  30 ] [  4  75  32 ] [  0  -1  -1 ]</code>
<code>                                   [ 24  35  30 ] [  1  40  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 23  20  32 ] [  8  24  30 ] [  0  -1  -1 ] ]</code>
<code>        [ (52)  125  18  6  13489  [ 14  95  18 ] [  1  86  18 ] [  0  -1  -1 ]</code>
<code>                                   [ 13  73  32 ] [  3  77  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 24  35  30 ] [  2  35  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 26  21  32 ] [  5  21  30 ] [  1  23  30 ] ]</code>
<code>        [ (53)  127  18  6  13961  [  9 147  28 ] [  1 142  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 10  73  30 ] [  6  70  32 ] [  1  71  32 ]</code>
<code>                                   [ 25  35  30 ] [  2  34  26 ] [  0  -1  -1 ]</code>
<code>                                   [ 29  21  32 ] [  4  22  30 ] [  0  -1  -1 ] ]</code>
<code>        [ (54)  129  18  6  14441  [ 11 126  24 ] [  1 131  24 ] [  0  -1  -1 ]</code>
<code>                                   [ 16  74  32 ] [  1  79  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 25  38  32 ] [  1  25  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 33  21  32 ] [  1  28  28 ] [  0  -1  -1 ] ]</code>
<code>        [ (55)  131  19  6  14939  [ 14 105  20 ] [  1  99  18 ] [  0  -1  -1 ]</code>
<code>                                   [ 19  65  28 ] [  1  72  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 24  37  32 ] [  2  40  30 ] [  1  41  30 ]</code>
<code>                                   [ 31  21  32 ] [  4  24  32 ] [  0  -1  -1 ] ]</code>
<code>        [ (56)  133  19  6  15435  [ 10 147  28 ] [  1 151  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 15  71  30 ] [  3  71  32 ] [  1  73  32 ]</code>
<code>                                   [ 24  37  32 ] [  3  38  30 ] [  1  39  30 ]</code>
<code>                                   [ 36  19  30 ] [  3  29  26 ] [  0  -1  -1 ] ]</code>
<code>        [ (57)  135  19  6  15939  [ 15 105  20 ] [  1  99  18 ] [  0  -1  -1 ]</code>
<code>                                   [ 19  70  30 ] [  1  64  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 27  38  32 ] [  2  25  26 ] [  0  -1  -1 ]</code>
<code>                                   [ 38  20  30 ] [  2  18  28 ] [  0  -1  -1 ] ]</code>
<code>        [ (58)  137  17  7  16171  [ 14 105  20 ] [  1 113  22 ] [  1 114  22 ]</code>
<code>                                   [ 17  67  30 ] [  3  92  32 ] [  0  -1  -1 ]</code>
<code>                                   [ 30  35  30 ] [  1  41  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 36  21  32 ] [  1  26  30 ] [  1  27  30 ] ]</code>
<code>        [ (59)  139  17  7  16691  [ 11 146  28 ] [  1 146  26 ] [  0  -1  -1 ]</code>
<code>                                   [ 20  70  30 ] [  1  60  26 ] [  0  -1  -1 ]</code>
<code>                                   [ 29  38  32 ] [  1  24  32 ] [  0  -1  -1 ]</code>
<code>                                   [ 40  20  30 ] [  2  17  26 ] [  0  -1  -1 ] ]</code>
<code>        [ (60)  141  18  7  17215  [  3 137  26 ] [  1 136  26 ] [ 10 126  24 ]</code>
<code>                                   [ 22  65  28 ] [  1  75  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 30  37  32 ] [  1  51  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 42  20  30 ] [  1  21  30 ] [  0  -1  -1 ] ]</code>
<code>        [ (61)  143  18  7  17751  [ 12 126  24 ] [  2 118  22 ] [  1 116  22 ]</code>
<code>                                   [ 19  74  32 ] [  1  74  30 ] [  1  72  28 ]</code>
<code>                                   [ 30  38  32 ] [  2  29  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 39  20  32 ] [  2  37  26 ] [  1  38  26 ] ]</code>
<code>        [ (62)  145  18  7  18295  [ 12 126  24 ] [  3 136  26 ] [  0  -1  -1 ]</code>
<code>                                   [ 21  70  30 ] [  2  65  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 34  35  30 ] [  1  44  32 ] [  0  -1  -1 ]</code>
<code>                                   [ 42  20  30 ] [  2  19  28 ] [  2  18  28 ] ]</code>
<code>        [ (63)  147  18  7  18847  [ 12 126  24 ] [  3 117  22 ] [  1 116  22 ]</code>
<code>                                   [ 25  61  26 ] [  2  62  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 34  35  30 ] [  1  40  32 ] [  1  41  32 ]</code>
<code>                                   [ 45  20  30 ] [  1  20  32 ] [  1  21  32 ] ]</code>
<code>        [ (64)  149  19  7  19403  [ 15 105  20 ] [  2 115  22 ] [  2 116  22 ]</code>
<code>                                   [ 25  65  28 ] [  1  72  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 18  35  30 ] [ 17  37  32 ] [  1  50  32 ]</code>
<code>                                   [ 42  20  30 ] [  6  19  28 ] [  1  15  28 ] ]</code>
<code>        [ (65)  151  19  7  19971  [ 19 105  20 ] [  1 101  20 ] [  0  -1  -1 ]</code>
<code>                                   [ 33  51  22 ] [  1  65  22 ] [  0  -1  -1 ]</code>
<code>                                   [ 40  33  28 ] [  1  28  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 49  20  30 ] [  1  18  28 ] [  0  -1  -1 ] ]</code>
<code>        [ (66)  153  17  8  20229  [ 18 105  20 ] [  2 117  22 ] [  0  -1  -1 ]</code>
<code>                                   [ 26  65  28 ] [  1  80  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 35  35  30 ] [  3  35  28 ] [  1  36  28 ]</code>
<code>                                   [ 52  18  28 ] [  2  38  30 ] [  0  -1  -1 ] ]</code>
<code>        [ (67)  155  17  8  20805  [ 26  84  16 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [ 26  70  30 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [ 45  31  26 ] [  1   9  26 ] [  0  -1  -1 ]</code>
<code>                                   [ 52  20  30 ] [  0  -1  -1 ] [  0  -1  -1 ] ]</code>
<code>        [ (68)  157  17  8  21389  [ 16 126  24 ] [  1 114  22 ] [  1 115  22 ]</code>
<code>                                   [ 23  70  30 ] [  3  65  28 ] [  1  66  28 ]</code>
<code>                                   [ 40  35  30 ] [  1  43  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 46  20  30 ] [  7  19  28 ] [  1  16  28 ] ]</code>
<code>        [ (69)  159  18  8  21993  [ 19 116  22 ] [  1 105  22 ] [  0  -1  -1 ]</code>
<code>                                   [ 20  70  30 ] [  7  66  28 ] [  1  63  28 ]</code>
<code>                                   [ 40  35  30 ] [  1  42  32 ] [  1  43  32 ]</code>
<code>                                   [ 54  20  30 ] [  1  19  30 ] [  0  -1  -1 ] ]</code>
<code>        [ (70)  161  18  8  22593  [ 17 126  24 ] [  2 115  22 ] [  0  -1  -1 ]</code>
<code>                                   [ 24  70  30 ] [  4  74  32 ] [  0  -1  -1 ]</code>
<code>                                   [ 48  31  26 ] [  2  18  26 ] [  0  -1  -1 ]</code>
<code>                                   [ 54  19  28 ] [  6  15  26 ] [  1  14  26 ] ]</code>
<code>        [ (71)  163  18  8  23201  [ 29  84  16 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [ 29  70  30 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [  6  34  30 ] [  3  36  30 ] [ 38  33  28 ]</code>
<code>                                   [ 58  20  30 ] [  0  -1  -1 ] [  0  -1  -1 ] ]</code>
<code>        [ (72)  165  18  8  23817  [ 16 147  28 ] [  1 149  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 31  66  28 ] [  1  37  26 ] [  0  -1  -1 ]</code>
<code>                                   [ 48  33  28 ] [  1  23  26 ] [  0  -1  -1 ]</code>
<code>                                   [ 53  20  30 ] [  6  19  28 ] [  1  17  28 ] ]</code>
<code>        [ (73)  167  19  8  24453  [ 20 115  22 ] [  2 134  24 ] [  0  -1  -1 ]</code>
<code>                                   [ 29  66  28 ] [  2  56  26 ] [  2  57  26 ]</code>
<code>                                   [ 45  36  30 ] [  2  15  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 59  20  30 ] [  2  21  32 ] [  0  -1  -1 ] ]</code>
<code>        [ (74)  169  19  8  25085  [ 17 147  28 ] [  1 134  26 ] [  0  -1  -1 ]</code>
<code>                                   [ 26  70  30 ] [  5  75  32 ] [  0  -1  -1 ]</code>
<code>                                   [ 47  35  30 ] [  1  48  32 ] [  0  -1  -1 ]</code>
<code>                                   [ 64  18  28 ] [  2  33  30 ] [  1  35  30 ] ]</code>
<code>        [ (75)  171  17  9  25373  [ 22 115  22 ] [  1 133  24 ] [  0  -1  -1 ]</code>
<code>                                   [ 33  65  28 ] [  1  74  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 43  36  30 ] [  5  27  28 ] [  1  30  28 ]</code>
<code>                                   [ 57  20  30 ] [  5  21  32 ] [  1  24  32 ] ]</code>
<code>        [ (76)  173  17  9  26021  [ 18 136  26 ] [  2 142  26 ] [  0  -1  -1 ]</code>
<code>                                   [ 33  66  28 ] [  2  49  26 ] [  0  -1  -1 ]</code>
<code>                                   [ 48  35  30 ] [  2  38  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 64  20  30 ] [  1  20  32 ] [  0  -1  -1 ] ]</code>
<code>        [ (77)  175  17  9  26677  [ 19 126  24 ] [  2 135  26 ] [  1 136  26 ]</code>
<code>                                   [ 32  66  28 ] [  2  55  26 ] [  2  56  26 ]</code>
<code>                                   [ 49  36  30 ] [  2  18  32 ] [  0  -1  -1 ]</code>
<code>                                   [ 65  18  28 ] [  5  27  30 ] [  1  29  30 ] ]</code>
<code>        [ (78)  177  18  9  27335  [ 20 137  26 ] [  1 130  26 ] [  0  -1  -1 ]</code>
<code>                                   [ 30  75  32 ] [  2  71  32 ] [  0  -1  -1 ]</code>
<code>                                   [ 46  35  30 ] [  6  39  32 ] [  0  -1  -1 ]</code>
<code>                                   [  3  12  30 ] [ 70  19  28 ] [  0  -1  -1 ] ]</code>
<code>        [ (79)  179  18  9  28007  [ 20 147  28 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [ 35  70  30 ] [  0  -1  -1 ] [  0  -1  -1 ]</code>
<code>                                   [ 49  35  30 ] [  5  35  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 70  20  30 ] [  0  -1  -1 ] [  0  -1  -1 ] ]</code>
<code>        [ (80)  181  18  9  28687  [ 21 136  26 ] [  1 155  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 34  70  30 ] [  1  64  28 ] [  1  65  28 ]</code>
<code>                                   [ 54  35  30 ] [  1  45  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 68  20  30 ] [  3  18  28 ] [  1  19  28 ] ]</code>
<code>        [ (81)  183  18  9  29375  [ 19 126  24 ] [  5 115  22 ] [  1 114  22 ]</code>
<code>                                   [ 33  70  30 ] [  3  65  28 ] [  1  64  28 ]</code>
<code>                                   [ 52  35  30 ] [  3  41  32 ] [  1  40  32 ]</code>
<code>                                   [ 67  20  30 ] [  5  21  32 ] [  1  24  32 ] ]</code>
<code>        [ (82)  185  18  9  30071  [  2 150  28 ] [ 21 136  26 ] [  0  -1  -1 ]</code>
<code>                                   [ 32  70  30 ] [  6  65  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 52  38  32 ] [  2  27  32 ] [  0  -1  -1 ]</code>
<code>                                   [ 73  20  30 ] [  2  22  32 ] [  0  -1  -1 ] ]</code>
<code>        [ (83)  187  17 10  30387  [ 21 126  24 ] [  4 136  26 ] [  0  -1  -1 ]</code>
<code>                                   [ 30  74  32 ] [  6  73  30 ] [  0  -1  -1 ]</code>
<code>                                   [ 54  35  30 ] [  4  40  32 ] [  0  -1  -1 ]</code>
<code>                                   [ 75  20  30 ] [  1  20  28 ] [  0  -1  -1 ] ]</code>
<code>        [ (84)  189  17 10  31091  [ 30 105  20 ] [  1 114  22 ] [  0  -1  -1 ]</code>
<code>                                   [  3  45  22 ] [ 55  47  20 ] [  0  -1  -1 ]</code>
<code>                                   [  2  26  26 ] [ 62  33  28 ] [  0  -1  -1 ]</code>
<code>                                   [ 79  18  28 ] [  4  33  30 ] [  0  -1  -1 ] ]</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /eclval eclevel 1 get 49 sub def</code>
<code>    metrics {</code>
<code>        /m exch def</code>
<code>        /vers m 0 get def                             % Version of symbol</code>
<code>        /size m 1 get def                             % Length of side</code>
<code>        /alnk m 2 get def                             % Regular alignment pattern length</code>
<code>        /alnn m 3 get def                             % Number of alignment patterns</code>
<code>        /alnr size alnk alnn mul sub def              % Remainder alignment pattern length</code>
<code>        /nmod m 4 get def                             % Number of modules</code>
<code>        /ncws nmod 8 idiv def                         % Total number of codewords</code>
<code>        /rbit nmod 8 mod def                          % Number of remainder bits</code>
<code>        /ecbs m 5 eclval 3 mul add 3 getinterval def  % Error correction blocks</code>
<code>        /ecws 0 ecbs {dup 0 get exch 2 get mul add} forall def  % Number of error correction codewords</code>
<code>        /dcws ncws ecws sub def                       % Number of data codewords</code>
<code>        /dmod dcws 8 mul def                          % Number of data modules</code>
<code>        /okay true def</code>
<code>        version (unset) ne version vers ne and {/okay false def} if  % The version must match that supplied</code>
<code>        bits length dmod gt {/okay false def} if      % Bitstream must fit into data modules</code>
<code>        okay {exit} if</code>
<code>    } forall</code>
<code></code>
<code>    okay not {</code>
<code>        /bwipp.hanxinNoValidSymbol (Maximum length exceeded or invalid content) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /version vers def</code>
<code>    /msgbits bits def</code>
<code>    /e1nb   ecbs 0 get 0 get def  /e2nb   ecbs 1 get 0 get def  /e3nb   ecbs 2 get 0 get def</code>
<code>    /e1dcws ecbs 0 get 1 get def  /e2dcws ecbs 1 get 1 get def  /e3dcws ecbs 2 get 1 get def</code>
<code>    /e1ecws ecbs 0 get 2 get def  /e2ecws ecbs 1 get 2 get def  /e3ecws ecbs 2 get 2 get def</code>
<code></code>
<code>    % Expand the message bits by adding padding as necessary</code>
<code>    /pad dmod string def</code>
<code>    0 1 pad length 1 sub {pad exch 48 put} for</code>
<code>    pad 0 msgbits putinterval</code>
<code></code>
<code>    % Evaluate the padded message into codewords</code>
<code>    /cws dcws array def</code>
<code>    0 1 cws length 1 sub {</code>
<code>        /c exch def</code>
<code>        /cwb pad c 8 mul 8 getinterval def</code>
<code>        /cw 0 def</code>
<code>        0 1 7 {</code>
<code>            /i exch def</code>
<code>            /cw cw 2 8 i sub 1 sub exp cvi cwb i get 48 sub mul add def</code>
<code>        } for</code>
<code>        cws c cw put</code>
<code>    } for</code>
<code></code>
<code>    /rscodes {</code>
<code></code>
<code>        /rspm exch def</code>
<code>        /rsgf exch def</code>
<code>        /rsnc exch def</code>
<code>        /rscws exch def</code>
<code></code>
<code>        % Calculate the log and anti-log tables</code>
<code>        /rsalog [ 1 rsgf 1 sub { dup 2 mul dup rsgf ge {rspm xor} if } repeat ] def</code>
<code>        /rslog rsgf array def</code>
<code>        1 1 rsgf 1 sub {dup rsalog exch get exch rslog 3 1 roll put} for</code>
<code></code>
<code>        % Function to calculate the product in the field</code>
<code>        /rsprod {</code>
<code>            2 copy 0 ne exch 0 ne and {</code>
<code>                rslog exch get exch rslog exch get add rsgf 1 sub mod rsalog exch get</code>
<code>            } {</code>
<code>                pop pop 0</code>
<code>            } ifelse</code>
<code>        } def</code>
<code></code>
<code>        % Generate the coefficients</code>
<code>        /coeffs [ 1 rsnc {0} repeat ] def</code>
<code>        1 1 rsnc {</code>
<code>            /i exch def</code>
<code>            coeffs i coeffs i 1 sub get put</code>
<code>            i 1 sub -1 1 {</code>
<code>                /j exch def</code>
<code>                coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put</code>
<code>            } for</code>
<code>            coeffs 0 coeffs 0 get rsalog i get rsprod put</code>
<code>        } for</code>
<code></code>
<code>        % Extend the input with the error correction values</code>
<code>        /nd rscws length def</code>
<code>        /rscws [ rscws {} forall rsnc {0} repeat 0 ] def</code>
<code>        0 1 nd 1 sub {</code>
<code>            /k exch rscws exch get rscws nd get xor def</code>
<code>            0 1 rsnc 1 sub {</code>
<code>                /j exch def</code>
<code>                rscws nd j add rscws nd j add 1 add get k coeffs rsnc j sub 1 sub get rsprod xor put</code>
<code>            } for</code>
<code>        } for</code>
<code></code>
<code>        % Return all but the last codeword</code>
<code>        rscws 0 rscws length 1 sub getinterval</code>
<code></code>
<code>    } def</code>
<code></code>
<code>    % Divide codewords into two groups of blocks and calculate the error correction codewords</code>
<code>    /dcwsb e1nb e2nb add e3nb add array def</code>
<code>    /ecwsb dcwsb length array def</code>
<code>    /in 0 def  /out 0 def</code>
<code>    e1nb {</code>
<code>        cws in e1dcws getinterval e1ecws 256 355 rscodes</code>
<code>        dup 0 e1dcws getinterval dcwsb exch out exch put</code>
<code>        e1dcws e1ecws getinterval ecwsb exch out exch put</code>
<code>        /in in e1dcws add def  /out out 1 add def</code>
<code>    } repeat</code>
<code>    e2nb {</code>
<code>        cws in e2dcws getinterval e2ecws 256 355 rscodes</code>
<code>        dup 0 e2dcws getinterval dcwsb exch out exch put</code>
<code>        e2dcws e2ecws getinterval ecwsb exch out exch put</code>
<code>        /in in e2dcws add def  /out out 1 add def</code>
<code>    } repeat</code>
<code>    e3nb {</code>
<code>        cws in e3dcws getinterval e3ecws 256 355 rscodes</code>
<code>        dup 0 e3dcws getinterval dcwsb exch out exch put</code>
<code>        e3dcws e3ecws getinterval ecwsb exch out exch put</code>
<code>        /in in e3dcws add def  /out out 1 add def</code>
<code>    } repeat</code>
<code></code>
<code>    % Reassemble the codewords</code>
<code>    /cws ncws array def</code>
<code>    /cw 0 def</code>
<code>    0 1 dcwsb length 1 sub {</code>
<code>        /i exch def</code>
<code>        dcwsb i get dup cws exch cw exch putinterval length cw add /cw exch def</code>
<code>        ecwsb i get dup cws exch cw exch putinterval length cw add /cw exch def</code>
<code>    } for</code>
<code></code>
<code>    % Split codewords into groups of 13 and concatenate</code>
<code>    /cws [</code>
<code>        0 1 ncws 1 sub 12 2 copy gt {exch} if pop {</code>
<code>            13 ncws 1 sub { dup ncws lt {cws exch get} {pop} ifelse } for</code>
<code>        } for</code>
<code>    ] def</code>
<code></code>
<code>    % Extend codewords by one if there are remainder bits</code>
<code>    rbit 0 gt {</code>
<code>        /pad cws length 1 add array def</code>
<code>        pad 0 cws putinterval</code>
<code>        pad pad length 1 sub 0 put</code>
<code>        /cws pad def</code>
<code>    } if</code>
<code></code>
<code>    % Create the bitmap</code>
<code>    /pixs [ size size mul {-1} repeat ] def</code>
<code>    /qmv {size mul add} def</code>
<code></code>
<code>    % Alignment patterns</code>
<code>    alnn 0 ne {</code>
<code>        /trmv {size mul size add 1 sub exch sub} def</code>
<code>        /aplot {</code>
<code>            3 1 roll 3 copy exch trmv pixs exch 3 -1 roll put</code>
<code>            trmv pixs exch 3 -1 roll put</code>
<code>        } def</code>
<code>        /i 0 def /stag 0 def {</code>
<code>            i size ge {exit} if</code>
<code>            0 1 size 1 sub {</code>
<code>                /j exch def</code>
<code>                j alnr add size lt {</code>
<code>                    j alnk idiv stag add 2 mod 0 eq   % Staggered groups of k modules</code>
<code>                    i 0 eq j alnk lt and not and      % Keep clear at top right</code>
<code>                    j alnk mod 0 eq or                % Complete regular-spaced grid</code>
<code>                } {</code>
<code>                    alnn stag add 2 mod 0 eq          % Bottom right remainder</code>
<code>                } ifelse</code>
<code>                {</code>
<code>                    j i 1 aplot</code>
<code>                    j 1 add i 1 add 2 copy size lt exch size lt and {0 aplot} {pop pop} ifelse</code>
<code>                } if</code>
<code>            } for</code>
<code>            i alnr add size eq {</code>
<code>                /i i alnr add 1 sub def</code>
<code>            } {</code>
<code>                /i i alnk add def</code>
<code>            } ifelse</code>
<code>            /stag 1 stag sub def</code>
<code>        } loop</code>
<code>        alnk alnk size 2 sub {</code>
<code>            /i exch def</code>
<code>            i alnk idiv 2 mod 0 ne {</code>
<code>                pixs 0 i 1 sub trmv 0 put</code>
<code>                pixs 0 i 1 add trmv 0 put</code>
<code>                pixs 1 i 1 sub trmv 0 put</code>
<code>                pixs 1 i trmv 0 put</code>
<code>                pixs 1 i 1 add trmv 0 put</code>
<code>                pixs i 1 sub 0 trmv 0 put</code>
<code>                pixs i 1 add 0 trmv 0 put</code>
<code>                pixs i 1 sub 1 trmv 0 put</code>
<code>                pixs i 1 trmv 0 put</code>
<code>                pixs i 1 add 1 trmv 0 put</code>
<code>            } if</code>
<code>            pixs size 1 sub i 1 sub trmv get 1 ne {</code>
<code>                pixs size 1 sub i 1 sub trmv 0 put</code>
<code>                pixs size 2 sub i 1 sub trmv 0 put</code>
<code>                pixs size 2 sub i trmv 0 put</code>
<code>                pixs size 2 sub i 1 add trmv 0 put</code>
<code>                pixs size 1 sub i 1 add trmv 0 put</code>
<code>                pixs i 1 sub size 1 sub trmv 0 put</code>
<code>                pixs i 1 sub size 2 sub trmv 0 put</code>
<code>                pixs i size 2 sub trmv 0 put</code>
<code>                pixs i 1 add size 2 sub trmv 0 put</code>
<code>                pixs i 1 add size 1 sub trmv 0 put</code>
<code>            } if</code>
<code>        } for</code>
<code>    } if</code>
<code></code>
<code>    % Finder patterns</code>
<code>{</code>
<code>    /fpat [</code>
<code>        [ 1 1 1 1 1 1 1 0 ]</code>
<code>        [ 1 0 0 0 0 0 0 0 ]</code>
<code>        [ 1 0 1 1 1 1 1 0 ]</code>
<code>        [ 1 0 1 0 0 0 0 0 ]</code>
<code>        [ 1 0 1 0 1 1 1 0 ]</code>
<code>        [ 1 0 1 0 1 1 1 0 ]</code>
<code>        [ 1 0 1 0 1 1 1 0 ]</code>
<code>        [ 0 0 0 0 0 0 0 0 ]</code>
<code>    ] def</code>
<code>    /fpat2 [</code>
<code>        [ 1 1 1 0 1 0 1 0 ]</code>
<code>        [ 1 1 1 0 1 0 1 0 ]</code>
<code>        [ 1 1 1 0 1 0 1 0 ]</code>
<code>        [ 0 0 0 0 1 0 1 0 ]</code>
<code>        [ 1 1 1 1 1 0 1 0 ]</code>
<code>        [ 0 0 0 0 0 0 1 0 ]</code>
<code>        [ 1 1 1 1 1 1 1 0 ]</code>
<code>        [ 0 0 0 0 0 0 0 0 ]</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code>    0 1 fpat length 1 sub {</code>
<code>        /y exch def</code>
<code>        0 1 fpat 0 get length 1 sub {</code>
<code>            /x exch def</code>
<code>            /fpb fpat y get x get def</code>
<code>            /fpb2 fpat2 y get x get def</code>
<code>            pixs x y qmv fpb put</code>
<code>            pixs size x sub 1 sub y qmv fpb put</code>
<code>            pixs size x sub 1 sub size y sub 1 sub qmv fpb put</code>
<code>            pixs x size y sub 1 sub qmv fpb2 put</code>
<code>        } for</code>
<code>    } for</code>
<code></code>
<code>    % Format information modules</code>
<code>    /functionmap [</code>
<code>        [ [ 0 8 ] [ size 1 sub size 9 sub ] ]  [ [ 1 8 ] [ size 2 sub size 9 sub ] ]</code>
<code>        [ [ 2 8 ] [ size 3 sub size 9 sub ] ]  [ [ 3 8 ] [ size 4 sub size 9 sub ] ]</code>
<code>        [ [ 4 8 ] [ size 5 sub size 9 sub ] ]  [ [ 5 8 ] [ size 6 sub size 9 sub ] ]</code>
<code>        [ [ 6 8 ] [ size 7 sub size 9 sub ] ]  [ [ 7 8 ] [ size 8 sub size 9 sub ] ]</code>
<code>        [ [ 8 8 ] [ size 9 sub size 9 sub ] ]</code>
<code>        [ [ 8 7 ] [ size 9 sub size 8 sub ] ]  [ [ 8 6 ] [ size 9 sub size 7 sub ] ]</code>
<code>        [ [ 8 5 ] [ size 9 sub size 6 sub ] ]  [ [ 8 4 ] [ size 9 sub size 5 sub ] ]</code>
<code>        [ [ 8 3 ] [ size 9 sub size 4 sub ] ]  [ [ 8 2 ] [ size 9 sub size 3 sub ] ]</code>
<code>        [ [ 8 1 ] [ size 9 sub size 2 sub ] ]  [ [ 8 0 ] [ size 9 sub size 1 sub ] ]</code>
<code>        [ [ size 9 sub 0 ] [ 8 size 1 sub ] ]  [ [ size 9 sub 1 ] [ 8 size 2 sub ] ]</code>
<code>        [ [ size 9 sub 2 ] [ 8 size 3 sub ] ]  [ [ size 9 sub 3 ] [ 8 size 4 sub ] ]</code>
<code>        [ [ size 9 sub 4 ] [ 8 size 5 sub ] ]  [ [ size 9 sub 5 ] [ 8 size 6 sub ] ]</code>
<code>        [ [ size 9 sub 6 ] [ 8 size 7 sub ] ]  [ [ size 9 sub 7 ] [ 8 size 8 sub ] ]</code>
<code>        [ [ size 9 sub 8 ] [ 8 size 9 sub ] ]</code>
<code>        [ [ size 8 sub 8 ] [ 7 size 9 sub ] ]  [ [ size 7 sub 8 ] [ 6 size 9 sub ] ]</code>
<code>        [ [ size 6 sub 8 ] [ 5 size 9 sub ] ]  [ [ size 5 sub 8 ] [ 4 size 9 sub ] ]</code>
<code>        [ [ size 4 sub 8 ] [ 3 size 9 sub ] ]  [ [ size 3 sub 8 ] [ 2 size 9 sub ] ]</code>
<code>        [ [ size 2 sub 8 ] [ 1 size 9 sub ] ]  [ [ size 1 sub 8 ] [ 0 size 9 sub ] ]</code>
<code>    ] def</code>
<code>    functionmap {</code>
<code>        { {} forall qmv pixs exch 0 put } forall</code>
<code>    } forall</code>
<code></code>
<code>    /maskfuncs [</code>
<code>        {pop pop 1} bind</code>
<code>        {add 2 mod} bind</code>
<code>        {1 index add 3 mod exch 3 mod add 2 mod} bind</code>
<code>        {2 copy mod 3 1 roll 2 copy exch mod 3 1 roll 3 mod exch 3 mod</code>
<code>         add add add 2 mod} bind</code>
<code>    ] def</code>
<code>    mask -1 ne {  % User specifies a mask</code>
<code>        /maskfuncs [maskfuncs mask 1 sub get] def</code>
<code>        /bestmaskval mask 1 sub def</code>
<code>    } if</code>
<code>    /masks maskfuncs length array def</code>
<code>    0 1 masks length 1 sub {</code>
<code>        /m exch def</code>
<code>        /mask size size mul array def</code>
<code>        0 1 size 1 sub {</code>
<code>            /j exch def</code>
<code>            0 1 size 1 sub {</code>
<code>                /i exch def</code>
<code>                i 1 add j 1 add maskfuncs m get exec 0 eq</code>
<code>                pixs i j qmv get -1 eq and {1} {0} ifelse</code>
<code>                mask i j qmv 3 -1 roll put</code>
<code>            } for</code>
<code>        } for</code>
<code>        masks m mask put</code>
<code>    } for</code>
<code></code>
<code>    % Walk the symbol placing the bitstream</code>
<code>    /posx 0 def</code>
<code>    /posy 0 def</code>
<code>    /num 0 def</code>
<code>    { % loop</code>
<code>        posy size eq {exit} if</code>
<code>        pixs posx posy qmv get -1 eq {</code>
<code>            cws num 8 idiv get 7 num 8 mod sub neg bitshift 1 and</code>
<code>            pixs posx posy qmv 3 -1 roll put</code>
<code>            /num num 1 add def</code>
<code>        } if</code>
<code>        /posx posx 1 add def</code>
<code>        posx size eq {/posx 0 def /posy posy 1 add def} if</code>
<code>    } loop</code>
<code></code>
<code>    % Evaluate runlength encoded rows or columns in full symbols</code>
<code>    /evalfulln1n3 {</code>
<code>        /scrle exch def</code>
<code>        % Detect runs of 3 or more like modules</code>
<code>        /scr1 0 scrle { dup 3 ge {4 mul add dup} if pop } forall def</code>
<code>        /scr3 0 def</code>
<code>        % Detect 1:1:1:1:3 ratio next to 3 modules of whitespace</code>
<code>        5 2 scrle length 1 sub {  % Scan odd (dark) runs within bounds</code>
<code>            /j exch def</code>
<code>            scrle j get 3 mod 0 eq {  % Multiple of 3 black modules</code>
<code>                /fact scrle j get 3 idiv def</code>
<code>                scrle j 4 sub 4 getinterval {fact eq} forall and and and {</code>
<code>                    j 5 eq j 2 add scrle length ge or {  % At either extent of run</code>
<code>                        /scr3 scr3 50 add def</code>
<code>                    } {  % Bounded by dark modules</code>
<code>                        scrle j 5 sub get 3 ge scrle j 1 add get 3 ge or {</code>
<code>                            /scr3 scr3 50 add def</code>
<code>                        } if</code>
<code>                    } ifelse</code>
<code>                } if</code>
<code>            } if</code>
<code>        } for</code>
<code>        % Detect 3:1:1:1:1 ratio next to 3 modules of whitespace</code>
<code>        1 2 scrle length 5 sub {  % Scan odd (dark) runs within bounds</code>
<code>            /j exch def</code>
<code>            scrle j get 3 mod 0 eq {  % Multiple of 3 black modules</code>
<code>                /fact scrle j get 3 idiv def</code>
<code>                scrle j 1 add 4 getinterval {fact eq} forall and and and {</code>
<code>                    j 1 eq j 6 add scrle length ge or {  % At either extent of run</code>
<code>                        /scr3 scr3 50 add def</code>
<code>                    } {  % Bounded by dark modules</code>
<code>                        scrle j 1 sub get 3 ge scrle j 5 add get 3 ge or {</code>
<code>                            /scr3 scr3 50 add def</code>
<code>                        } if</code>
<code>                    } ifelse</code>
<code>                } if</code>
<code>            } if</code>
<code>        } for</code>
<code>        scr1 scr3</code>
<code>    } def</code>
<code></code>
<code>    % Evaluation algorithm</code>
<code>    /evalfull {</code>
<code>        /sym exch def</code>
<code></code>
<code>        /n1 0 def /n3 0 def</code>
<code>        /rle size 1 add array def</code>
<code>        /lastpairs size array def</code>
<code>        /thispairs size array def</code>
<code>        /sizeadd1 size 1 add def</code>
<code>        0 1 size 1 sub {</code>
<code>            /i exch def</code>
<code></code>
<code>            % Runlength encode (light, dark, light, ...) and evaluate each column</code>
<code>            mark 0 0</code>
<code>            i size dup dup mul 1 sub {</code>
<code>                sym exch get exch 1 index eq {exch 1 add exch} {1 exch} ifelse</code>
<code>            } for</code>
<code>            pop</code>
<code>            rle 0 counttomark 2 sub getinterval astore</code>
<code>            evalfulln1n3 n3 add /n3 exch def n1 add /n1 exch def</code>
<code>            pop</code>
<code></code>
<code>            % Runlength encode (light, dark, light, ...) and evaluate each row</code>
<code>            /symrow sym i size mul size getinterval def</code>
<code>            mark 0 0</code>
<code>            symrow {</code>
<code>                exch 1 index eq {exch 1 add exch} {1 exch} ifelse</code>
<code>            } forall</code>
<code>            pop</code>
<code>            rle 0 counttomark 2 sub getinterval astore</code>
<code>            evalfulln1n3 n3 add /n3 exch def n1 add /n1 exch def</code>
<code>            pop</code>
<code></code>
<code>        } for</code>
<code></code>
<code>        n1 n3 add</code>
<code>    } def</code>
<code></code>
<code>    % Evaluate the masked symbols to find the most suitable</code>
<code>    /bestscore 999999999 def</code>
<code>    0 1 masks length 1 sub {</code>
<code>        /m exch def</code>
<code>        /masksym size size mul array def</code>
<code>        0 1 size size mul 1 sub {</code>
<code>            /i exch def</code>
<code>            masksym i pixs i get masks m get i get xor put</code>
<code>        } for</code>
<code>        masks length 1 ne {</code>
<code>            masksym evalfull /score exch def</code>
<code>            score bestscore lt {</code>
<code>                /bestsym masksym def</code>
<code>                /bestmaskval m def</code>
<code>                /bestscore score def</code>
<code>            } if</code>
<code>        } {</code>
<code>            /bestsym masksym def</code>
<code>        } ifelse</code>
<code>    } for</code>
<code>    /pixs bestsym def</code>
<code></code>
<code>    % Add the function information</code>
<code>    /funval size 21 sub 2 idiv 20 add 4 mul eclval add 4 mul bestmaskval add def</code>
<code>    [ funval 16#0F00 and -8 bitshift</code>
<code>      funval 16#00F0 and -4 bitshift</code>
<code>      funval 16#000F and ]</code>
<code>    4 16 19 rscodes /funvals exch def</code>
<code>    /funbits [</code>
<code>        funvals {</code>
<code>            4 tobin {48 sub} forall</code>
<code>        } forall</code>
<code>        0 1 0 1 0 1</code>
<code>    ] def</code>
<code>    0 1 functionmap length 1 sub {</code>
<code>        /i exch def</code>
<code>        functionmap i get {</code>
<code>            pixs exch aload pop qmv funbits i get put</code>
<code>        } forall</code>
<code>    } for</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renmatrix</code>
<code>    /pixs pixs</code>
<code>    /pixx size</code>
<code>    /pixy size</code>
<code>    /height size 2 mul 72 div</code>
<code>    /width size 2 mul 72 div</code>
<code>    /borderleft 3.0</code>
<code>    /borderright 3.0</code>
<code>    /bordertop 3.0</code>
<code>    /borderbottom 3.0</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /hanxin dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER hanxin--</code>
<code></code>
<code>% --BEGIN ENCODER dotcode--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix--</code>
<code>% --DESC: DotCode</code>
<code>% --EXAM: This is DotCode</code>
<code>% --EXOP: inkspread=0.16</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp dotcode 0.0 2024010300 242601 271643</code>
<code>%%BeginData:       1090 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/dotcode {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /rows -1 def</code>
<code>    /columns -1 def</code>
<code>    /ratio -1.0 def</code>
<code>    /parse false def</code>
<code>    /parsefnc false def</code>
<code>    /raw false def</code>
<code>    /fast false def</code>
<code>    /mask -1 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    rows -1 ne {</code>
<code>        rows 5 lt {</code>
<code>            /bwipp.dotcodeBadRows (There must be at least 5 rows) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    columns -1 ne {</code>
<code>        columns 5 lt {</code>
<code>            /bwipp.dotcodeBadColumns (There must be at least 5 columns) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    rows -1 ne columns -1 ne and rows columns add 2 mod 1 ne and {</code>
<code>        /bwipp.dotcodeRowsColumnsBadParity (Sum of rows and columns must be odd) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Set the ratio to 3:2 if no size is specified</code>
<code>    ratio -1 eq rows -1 eq and columns -1 eq and {</code>
<code>        /ratio 3 2 div def</code>
<code>    } if</code>
<code>    ratio -1 ne {</code>
<code>        ratio 0 le {</code>
<code>            /bwipp.dotcodeRatio (The ratio must be greater than 0) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    mask -1 ne {</code>
<code>        mask 0 lt mask 3 gt or {</code>
<code>            /bwipp.dotcodeBadMask (Valid mask values are 0 to 3) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    /dotcode //loadctx exec</code>
<code></code>
<code>    % Convert input into bytes accounting for FNC characters</code>
<code>{</code>
<code>    /laa  -1 def  /lab  -2 def  /lac  -3 def  /bin  -4 def</code>
<code>    /sfa  -5 def  /sfb  -6 def  /sb2  -7 def  /sb3  -8 def</code>
<code>    /sb4  -9 def  /sb5 -10 def  /sb6 -11 def  /sfc -12 def</code>
<code>    /sc2 -13 def  /sc3 -14 def  /sc4 -15 def  /sc5 -16 def</code>
<code>    /sc6 -17 def  /sc7 -18 def  /bsa -19 def  /bsb -20 def</code>
<code>    /tma -21 def  /tmb -22 def  /tmc -23 def  /tms -24 def</code>
<code>    /fn1 -25 def  /fn2 -26 def  /fn3 -27 def  /crl -28 def</code>
<code>    /aim -29 def  /m05 -30 def  /m06 -31 def  /m12 -32 def</code>
<code>    /mac -33 def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Parse the input</code>
<code>    /fncvals &lt;&lt;</code>
<code>        /parse parse</code>
<code>        /parsefnc parsefnc</code>
<code>        /eci true</code>
<code>        (FNC1) fn1</code>
<code>        % (FNC2) fn2  %  Use ^ECInnnnnn for ECI; Structured append not supported</code>
<code>        (FNC3) fn3</code>
<code>    &gt;&gt; def</code>
<code>    /msg barcode fncvals //parseinput exec def</code>
<code>    /msglen msg length def</code>
<code></code>
<code>    % Special FNC2 semantics: Expand ECI characters into ^FNC2nnnnnn</code>
<code>    /numecis 0 msg { -1000000 le {1 add} if } forall def</code>
<code>    /msgtmp msg length numecis 6 mul add array def</code>
<code>    /j 0 def</code>
<code>    0 1 msg length 1 sub {</code>
<code>        msg exch get dup -1000000 le {</code>
<code>            neg 10 7 string cvrs 1 6 getinterval {} forall 6 array astore</code>
<code>            msgtmp exch j 1 add exch putinterval</code>
<code>            msgtmp j fn2 put</code>
<code>            /j j 7 add def</code>
<code>        } {</code>
<code>            msgtmp exch j exch put</code>
<code>            /j j 1 add def</code>
<code>        } ifelse</code>
<code>    } for</code>
<code>    /msg msgtmp def</code>
<code>    /msglen msg length def</code>
<code></code>
<code>    % Character maps for each state</code>
<code>{</code>
<code>   /charmaps [</code>
<code>      %  A    B    C         A    B    C         A    B    C</code>
<code>      [  32   32  (00) ]  [ (!)  (!)  (01) ]  [ (")  (")  (02) ]  % 0-2</code>
<code>      [ (#)  (#)  (03) ]  [ ($)  ($)  (04) ]  [ (%)  (%)  (05) ]  % 3-5</code>
<code>      [ (&amp;)  (&amp;)  (06) ]  [ (')  (')  (07) ]  [  40   40  (08) ]  % 6-8</code>
<code>      [  41   41  (09) ]  [ (*)  (*)  (10) ]  [ (+)  (+)  (11) ]  % 9-11</code>
<code>      [ (,)  (,)  (12) ]  [ (-)  (-)  (13) ]  [ (.)  (.)  (14) ]  % 12-14</code>
<code>      [ (/)  (/)  (15) ]  [ (0)  (0)  (16) ]  [ (1)  (1)  (17) ]  % 15-17</code>
<code>      [ (2)  (2)  (18) ]  [ (3)  (3)  (19) ]  [ (4)  (4)  (20) ]  % 18-20</code>
<code>      [ (5)  (5)  (21) ]  [ (6)  (6)  (22) ]  [ (7)  (7)  (23) ]  % 21-23</code>
<code>      [ (8)  (8)  (24) ]  [ (9)  (9)  (25) ]  [ (:)  (:)  (26) ]  % 24-26</code>
<code>      [ (;)  (;)  (27) ]  [ (&lt;)  (&lt;)  (28) ]  [ (=)  (=)  (29) ]  % 27-29</code>
<code>      [ (&gt;)  (&gt;)  (30) ]  [ (?)  (?)  (31) ]  [ (@)  (@)  (32) ]  % 30-32</code>
<code>      [ (A)  (A)  (33) ]  [ (B)  (B)  (34) ]  [ (C)  (C)  (35) ]  % 33-35</code>
<code>      [ (D)  (D)  (36) ]  [ (E)  (E)  (37) ]  [ (F)  (F)  (38) ]  % 36-38</code>
<code>      [ (G)  (G)  (39) ]  [ (H)  (H)  (40) ]  [ (I)  (I)  (41) ]  % 39-41</code>
<code>      [ (J)  (J)  (42) ]  [ (K)  (K)  (43) ]  [ (L)  (L)  (44) ]  % 42-44</code>
<code>      [ (M)  (M)  (45) ]  [ (N)  (N)  (46) ]  [ (O)  (O)  (47) ]  % 45-47</code>
<code>      [ (P)  (P)  (48) ]  [ (Q)  (Q)  (49) ]  [ (R)  (R)  (50) ]  % 48-50</code>
<code>      [ (S)  (S)  (51) ]  [ (T)  (T)  (52) ]  [ (U)  (U)  (53) ]  % 51-53</code>
<code>      [ (V)  (V)  (54) ]  [ (W)  (W)  (55) ]  [ (X)  (X)  (56) ]  % 54-56</code>
<code>      [ (Y)  (Y)  (57) ]  [ (Z)  (Z)  (58) ]  [ ([)  ([)  (59) ]  % 57-59</code>
<code>      [  92   92  (60) ]  [ (])  (])  (61) ]  [ (^)  (^)  (62) ]  % 60-62</code>
<code>      [ (_)  (_)  (63) ]  [   0  (`)  (64) ]  [   1  (a)  (65) ]  % 63-65</code>
<code>      [   2  (b)  (66) ]  [   3  (c)  (67) ]  [   4  (d)  (68) ]  % 66-68</code>
<code>      [   5  (e)  (69) ]  [   6  (f)  (70) ]  [   7  (g)  (71) ]  % 69-71</code>
<code>      [   8  (h)  (72) ]  [   9  (i)  (73) ]  [  10  (j)  (74) ]  % 72-74</code>
<code>      [  11  (k)  (75) ]  [  12  (l)  (76) ]  [  13  (m)  (77) ]  % 75-77</code>
<code>      [  14  (n)  (78) ]  [  15  (o)  (79) ]  [  16  (p)  (80) ]  % 78-80</code>
<code>      [  17  (q)  (81) ]  [  18  (r)  (82) ]  [  19  (s)  (83) ]  % 81-83</code>
<code>      [  20  (t)  (84) ]  [  21  (u)  (85) ]  [  22  (v)  (86) ]  % 84-86</code>
<code>      [  23  (w)  (87) ]  [  24  (x)  (88) ]  [  25  (y)  (89) ]  % 87-89</code>
<code>      [  26  (z)  (90) ]  [  27  ({)  (91) ]  [  28  (|)  (92) ]  % 90-92</code>
<code>      [  29  (})  (93) ]  [  30  (~)  (94) ]  [  31  127  (95) ]  % 93-95</code>
<code>      [ sfb  crl  (96) ]  [ sb2    9  (97) ]  [ sb3   28  (98) ]  % 96-98</code>
<code>      [ sb4   29  (99) ]  [ sb5   30  aim  ]  [ sb6  sfa  laa  ]  % 99-101</code>
<code>      [ lab  laa  sfb  ]  [ sc2  sc2  sb2  ]  [ sc3  sc3  sb3  ]  % 102-104</code>
<code>      [ sc4  sc4  sb4  ]  [ lac  lac  lab  ]  [ fn1  fn1  fn1  ]  % 105-107</code>
<code>      [ fn2  fn2  fn2  ]  [ fn3  fn3  fn3  ]  [ bsa  bsa  bsa  ]  % 108-110</code>
<code>      [ bsb  bsb  bsb  ]  [ bin  bin  bin  ]                      % 111-112</code>
<code>    ] def</code>
<code></code>
<code>    % Invert charmaps to give character to value maps for each state</code>
<code>    /charvals [ 113 dict 117 dict 113 dict ] def</code>
<code>    0 1 charmaps length 1 sub {</code>
<code>        /i exch def</code>
<code>        /encs charmaps i get def</code>
<code>        0 1 2 {</code>
<code>            /j exch def</code>
<code>            encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required</code>
<code>            charvals j get exch i put</code>
<code>        } for</code>
<code>    } for</code>
<code>    /Avals charvals 0 get def</code>
<code>    /Bvals charvals 1 get def</code>
<code>    Bvals m05  97 put</code>
<code>    Bvals m06  98 put</code>
<code>    Bvals m12  99 put</code>
<code>    Bvals mac 100 put</code>
<code>    /Cvals charvals 2 get def</code>
<code>    /BINvals &lt;&lt;</code>
<code>        102 [ sc2 sc3 sc4 sc5 sc6 sc7 tma tmb tmc tms ] {exch 1 add dup} forall pop</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /A 0 def  /B 1 def  /C 2 def  /BIN 3 def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Pre-compute properties of the input at each point</code>
<code>    /nDigits      [ msglen 1 add {0} repeat     ] def</code>
<code>    /SeventeenTen [ msglen 1 add {false} repeat ] def</code>
<code>    /ECI          [ msglen 1 add {false} repeat ] def</code>
<code>    /DatumA       [ msglen 1 add {false} repeat ] def</code>
<code>    /DatumB       [ msglen 1 add {false} repeat ] def</code>
<code>    /DatumC       [ msglen 1 add {false} repeat ] def</code>
<code>    /Binary       [ msglen 8 add {false} repeat ] def</code>
<code>    /AheadC       [ msglen 1 add {0} repeat     ] def</code>
<code>    /TryC         [ msglen 1 add {0} repeat     ] def</code>
<code>    /AheadA       [ msglen 1 add {0} repeat     ] def</code>
<code>    /AheadB       [ msglen 1 add {0} repeat     ] def</code>
<code>    /UntilEndSeg  [ msglen 1 add {0} repeat     ] def</code>
<code>    msglen 1 sub -1 0 {</code>
<code>        /i exch def</code>
<code>        /barchar msg i get def</code>
<code>        barchar 48 ge barchar 57 le and {</code>
<code>            nDigits i nDigits i 1 add get 1 add put</code>
<code>        } if</code>
<code>        Avals barchar known {DatumA i true put} if</code>
<code>        Bvals barchar known {DatumB i true put} if</code>
<code>        /CRLF false def</code>
<code>        barchar 13 eq i msglen 1 sub lt and {</code>
<code>            msg i 1 add get 10 eq {/CRLF true def} if</code>
<code>        } if</code>
<code>        CRLF {DatumB i true put} if</code>
<code>        nDigits i get 2 ge  {DatumC i true put} if</code>
<code>        barchar 0 lt        {DatumC i true put} if  % FNCx</code>
<code>        barchar 128 ge      {Binary i true put} if</code>
<code>        nDigits i get 10 ge {  % 17xxxxxx10</code>
<code>            mark</code>
<code>            msg i 10 getinterval aload pop</code>
<code>            1 {  % common exit</code>
<code>                48 ne {false exit} if</code>
<code>                49 ne {false exit} if</code>
<code>                pop pop pop pop pop pop</code>
<code>                55 ne {false exit} if</code>
<code>                49 ne {false exit} if</code>
<code>                true</code>
<code>            } repeat</code>
<code>            SeventeenTen i 3 -1 roll put</code>
<code>            cleartomark</code>
<code>        } if</code>
<code>        nDigits i 1 add get 6 ge msg i get fn2 eq and {  % ^FNC2xxxxxx</code>
<code>            ECI i true put</code>
<code>        } if</code>
<code>        barchar 0 lt barchar fn3 ne and {  % FNCx, except FNC3</code>
<code>            AheadC i AheadC i 1 add get 1 add put</code>
<code>        } {</code>
<code>            nDigits i get 1 le {</code>
<code>                AheadC i 0 put</code>
<code>            } {</code>
<code>                AheadC i AheadC i 2 add get 1 add put</code>
<code>            } ifelse</code>
<code>        } ifelse</code>
<code>        nDigits i get 0 gt AheadC i get AheadC i 1 add get gt and {</code>
<code>            TryC i AheadC i get put</code>
<code>        } if</code>
<code>        DatumA i get TryC i get 2 lt and barchar fn3 ne and {</code>
<code>            AheadA i AheadA i 1 add get 1 add put</code>
<code>        } if</code>
<code>        DatumB i get TryC i get 2 lt and barchar fn3 ne and {</code>
<code>            AheadB i AheadB i 1 add CRLF {1 add} if get 1 add put</code>
<code>        } if</code>
<code>        barchar fn3 ne {</code>
<code>            UntilEndSeg i UntilEndSeg i 1 add get 1 add put</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    /addtocws {</code>
<code>        dup cws exch j exch putinterval</code>
<code>        /j exch length j add def</code>
<code>    } def</code>
<code></code>
<code>    % Base 259 to one more in base 103</code>
<code>    /base259to103 {</code>
<code>        /in exch def</code>
<code>        /inlen in length def</code>
<code>        /in [ 5 inlen sub {0} repeat in aload pop ] def</code>
<code>        /out 6 array def</code>
<code>        /msbs [ in 0 2 getinterval aload pop ] def</code>
<code>        /mscs [</code>
<code>            msbs aload pop exch 259 mul add</code>
<code>            2 {dup 103 mod exch 103 idiv} repeat</code>
<code>        ] def</code>
<code>        /lsbs [ in 2 3 getinterval aload pop ] def</code>
<code>        /lscs [</code>
<code>            lsbs aload pop exch 259 mul add exch 67081 mul add</code>
<code>            3 {dup 103 mod exch 103 idiv} repeat</code>
<code>        ] def</code>
<code>        lscs 0 get mscs 0 get 42 mul add</code>
<code>        out 5 2 index 103 mod put</code>
<code>        103 idiv lscs 1 get add mscs 0 get 68 mul add mscs 1 get 42 mul add</code>
<code>        out 4 2 index 103 mod put</code>
<code>        103 idiv lscs 2 get add mscs 0 get 92 mul add mscs 1 get 68 mul add mscs 2 get 42 mul add</code>
<code>        out 3 2 index 103 mod put</code>
<code>        103 idiv lscs 3 get add mscs 0 get 15 mul add mscs 1 get 92 mul add mscs 2 get 68 mul add</code>
<code>        out 2 2 index 103 mod put</code>
<code>        103 idiv mscs 1 get 15 mul add mscs 2 get 92 mul add</code>
<code>        out 1 2 index 103 mod put</code>
<code>        103 idiv mscs 2 get 15 mul add</code>
<code>        out 0 3 -1 roll 103 mod put</code>
<code>        out 6 inlen sub 1 sub inlen 1 add getinterval</code>
<code>    } def</code>
<code></code>
<code>    /finaliseBIN {</code>
<code>        bpos 0 ne {</code>
<code>            bvals 0 bpos getinterval base259to103 aload pop</code>
<code>            /bpos 0 def</code>
<code>        } if</code>
<code>    } def</code>
<code></code>
<code>    /addtobin {</code>
<code>        bvals exch bpos exch put</code>
<code>        /bpos bpos 1 add def</code>
<code>        bpos 5 eq { finaliseBIN } if</code>
<code>    } def</code>
<code></code>
<code>    /ECIabc {  % ECI encoding for modes A, B and C</code>
<code>        msg i 1 add 6 getinterval 0 exch {48 sub add 10 mul} forall 10 idiv</code>
<code>        dup 40 ge {</code>
<code>            40 sub</code>
<code>            dup 12769 idiv 40 add exch 12769 mod</code>
<code>            dup   113 idiv        exch   113 mod</code>
<code>        } if</code>
<code>    } def</code>
<code></code>
<code>    /ECIbin {  % ECI encoding for binary mode</code>
<code>        [</code>
<code>            msg i 1 add 6 getinterval 0 exch {48 sub add 10 mul} forall 10 idiv</code>
<code>            dup 65536 ge {</code>
<code>                258 exch dup 65536 idiv exch 65536 mod dup 256 idiv exch 256 mod</code>
<code>            } {</code>
<code>                dup 256 ge {</code>
<code>                    257 exch dup 256 idiv exch 256 mod</code>
<code>                } {</code>
<code>                    256 exch</code>
<code>                } ifelse</code>
<code>            } ifelse</code>
<code>        ] {</code>
<code>            addtobin</code>
<code>        } forall</code>
<code>    } def</code>
<code></code>
<code>    /encC {</code>
<code>        1 {  % Common exit</code>
<code>            i segstart eq {  % Structured data macros</code>
<code>                1 {  % common exit</code>
<code>                    i segend 7 sub gt {0 exit} if</code>
<code>                    msg segstart       get 91 ne {0 exit} if                    % [</code>
<code>                    msg segstart 1 add get 41 ne {0 exit} if                    % )</code>
<code>                    msg segstart 2 add get 62 ne {0 exit} if                    % &gt;</code>
<code>                    msg segstart 3 add get 30 ne {0 exit} if                    % {RS}</code>
<code>                    msg segstart 4 add get dup 48 lt exch 57 gt or {0 exit} if  % digit</code>
<code>                    msg segstart 5 add get dup 48 lt exch 57 gt or {0 exit} if  % digit</code>
<code>                    msg segend   1 sub get  4 ne {0 exit} if                    % End: {EOT}</code>
<code>                    msg segstart 4 add get 48 sub 10 mul msg segstart 5 add get 48 sub add</code>
<code>                    dup dup 05 ne exch dup 06 ne exch 12 ne and and {pop mac exit} if</code>
<code>                    msg segstart 6 add get 29 ne {pop 0 exit} if                % {GS}</code>
<code>                    msg segend   2 sub get 30 ne {pop 0 exit} if                % End: {RS}</code>
<code>                    dup 05 eq {pop m05 exit} if</code>
<code>                        06 eq {    m06 exit} if</code>
<code>                                   m12 exit</code>
<code>                } repeat</code>
<code>                /inmac exch def</code>
<code>                inmac 0 ne {</code>
<code>                    [ Cvals lab get ] addtocws</code>
<code>                    /mode B def</code>
<code>                    [ Bvals inmac get ] addtocws</code>
<code>                    inmac mac eq {</code>
<code>                        [ Bvals msg segstart 4 add get get ] addtocws</code>
<code>                        [ Bvals msg segstart 5 add get get ] addtocws</code>
<code>                        /i i 6 add def</code>
<code>                    } {</code>
<code>                        /i i 7 add def</code>
<code>                    } ifelse</code>
<code>                    exit</code>
<code>                } if</code>
<code>            } if</code>
<code>            % Special treatment of FNC1 in First for Dotcode</code>
<code>            i segstart eq {</code>
<code>                % Encode an FNC1 if two digits start a segment</code>
<code>                nDigits i get 2 ge {</code>
<code>                    [ Cvals fn1 get ] addtocws</code>
<code>                } if</code>
<code>                % Skip an FNC1 if followed by two digits at start of segment</code>
<code>                msg i get fn1 eq nDigits i 1 add get 2 ge and {</code>
<code>                    /i i 1 add def</code>
<code>                } if</code>
<code>            } if</code>
<code>            SeventeenTen i get {</code>
<code>                [  % 17xxxxxx10 macro</code>
<code>                    Cvals aim get</code>
<code>                    msg i 2 add get 48 sub 10 mul msg i 3 add get 48 sub add</code>
<code>                    msg i 4 add get 48 sub 10 mul msg i 5 add get 48 sub add</code>
<code>                    msg i 6 add get 48 sub 10 mul msg i 7 add get 48 sub add</code>
<code>                ] addtocws</code>
<code>                /i i 10 add def</code>
<code>                exit</code>
<code>            } if</code>
<code>            DatumC i get {</code>
<code>                msg i get dup fn1 eq exch dup fn2 eq exch fn3 eq or or {  % FNCx</code>
<code>                    [ Cvals msg i get get ] addtocws</code>
<code>                    ECI i get {  % FNC2 then 6 digits</code>
<code>                        [ ECIabc ] addtocws</code>
<code>                        /i i 7 add def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    msg i get fn3 eq segstart i ne and {  % FNC3</code>
<code>                        /i i 1 add def</code>
<code>                        /inmac 0 def</code>
<code>                        /segstart i def</code>
<code>                        /segend i UntilEndSeg i get add def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    /i i 1 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                [ msg i get 48 sub 10 mul msg i 1 add get 48 sub add ] addtocws</code>
<code>                /i i 2 add def</code>
<code>                exit</code>
<code>            } if</code>
<code>            Binary i get {  % Binary</code>
<code>                nDigits i 1 add get 0 gt {</code>
<code>                    msg i get 160 lt {</code>
<code>                        [ Cvals bsa get Avals msg i get 128 sub get ] addtocws</code>
<code>                    } {</code>
<code>                        [ Cvals bsb get Bvals msg i get 128 sub get ] addtocws</code>
<code>                    } ifelse</code>
<code>                    /i i 1 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                [ Cvals bin get ] addtocws</code>
<code>                /mode BIN def</code>
<code>                exit</code>
<code>            } if</code>
<code>            /m AheadA i get def  /n AheadB i get def</code>
<code>            m n gt {</code>
<code>                [ Cvals laa get ] addtocws</code>
<code>                /mode A def</code>
<code>                exit</code>
<code>            } if</code>
<code>            i segstart eq {</code>
<code>                msg i get dup 9 eq exch dup 28 eq exch dup 29 eq exch 30 eq or or or {</code>
<code>                    [ Cvals laa get ] addtocws</code>
<code>                    /mode A def</code>
<code>                    exit</code>
<code>                } if</code>
<code>            } if</code>
<code>            n 4 gt {</code>
<code>                [ Cvals lab get ] addtocws</code>
<code>                /mode B def</code>
<code>                exit</code>
<code>            } if</code>
<code>            [ Cvals [ sfb sb2 sb3 sb4 ] n 1 sub get get ] addtocws</code>
<code>            n {</code>
<code>                msg i get 13 eq {</code>
<code>                    [ Bvals crl get ] addtocws</code>
<code>                    /i i 2 add def</code>
<code>                } {</code>
<code>                    [ Bvals msg i get get ] addtocws</code>
<code>                    /i i 1 add def</code>
<code>                } ifelse</code>
<code>            } repeat</code>
<code>            exit</code>
<code>        } repeat</code>
<code>    } def  % encC</code>
<code></code>
<code>    /encB {</code>
<code>        1 {  % Common exit</code>
<code>            /n TryC i get def</code>
<code>            n 2 ge {</code>
<code>                n 4 gt {</code>
<code>                    [ Bvals lac get ] addtocws</code>
<code>                    /mode C def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                [ Bvals [ sfc sc2 sc3 sc4 ] n 1 sub get get ] addtocws</code>
<code>                n {</code>
<code>                    msg i get 0 lt {</code>
<code>                        [ Cvals msg i get get ] addtocws</code>
<code>                        /i i 1 add def</code>
<code>                    } {</code>
<code>                        [ msg i get 48 sub 10 mul msg i 1 add get 48 sub add ] addtocws</code>
<code>                        /i i 2 add def</code>
<code>                    } ifelse</code>
<code>                } repeat</code>
<code>                exit</code>
<code>            } if</code>
<code>            DatumB i get {</code>
<code>                msg i get dup fn1 eq exch dup fn2 eq exch fn3 eq or or {  % FNCx</code>
<code>                    [ Bvals msg i get get ] addtocws</code>
<code>                    ECI i get {  % FNC2 then 6 digits</code>
<code>                        [ ECIabc ] addtocws</code>
<code>                        /i i 7 add def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    msg i get fn3 eq i segstart ne and {  % FNC3</code>
<code>                        /i i 1 add def</code>
<code>                        /mode C def</code>
<code>                        /inmac 0 def</code>
<code>                        /segstart i def</code>
<code>                        /segend i UntilEndSeg i get add def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    /i i 1 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                msg i get 13 eq i msglen 1 sub lt and {</code>
<code>                    msg i 1 add get 10 eq {  % CRLF</code>
<code>                        [ Bvals crl get ] addtocws</code>
<code>                        /i i 2 add def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                } if</code>
<code>                [ Bvals msg i get get ] addtocws</code>
<code>                /i i 1 add def</code>
<code>                exit</code>
<code>            } if</code>
<code>            Binary i get {  % Binary</code>
<code>                DatumB i 1 add get {</code>
<code>                    msg i get 160 lt {</code>
<code>                        [ Bvals bsa get Avals msg i get 128 sub get ] addtocws</code>
<code>                    } {</code>
<code>                        [ Bvals bsb get Bvals msg i get 128 sub get ] addtocws</code>
<code>                    } ifelse</code>
<code>                    /i i 1 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                [ Bvals bin get ] addtocws</code>
<code>                /mode BIN def</code>
<code>                exit</code>
<code>            } if</code>
<code>            AheadA i get 1 eq {</code>
<code>                [ Bvals sfa get Avals msg i get get ] addtocws</code>
<code>                /i i 1 add def</code>
<code>                exit</code>
<code>            } if</code>
<code>            [ Bvals laa get ] addtocws</code>
<code>            /mode A def</code>
<code>            exit</code>
<code>        } repeat</code>
<code>    } def</code>
<code></code>
<code>    /encA {</code>
<code>        1 {  % Common exit</code>
<code>            /n TryC i get def</code>
<code>            n 2 ge {</code>
<code>                n 4 gt {</code>
<code>                    [ Avals lac get ] addtocws</code>
<code>                    /mode C def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                [ Avals [ sfc sc2 sc3 sc4 ] n 1 sub get get ] addtocws</code>
<code>                n {</code>
<code>                    msg i get 0 lt {</code>
<code>                        [ Cvals msg i get get ] addtocws</code>
<code>                        /i i 1 add def</code>
<code>                    } {</code>
<code>                        [ msg i get 48 sub 10 mul msg i 1 add get 48 sub add ] addtocws</code>
<code>                        /i i 2 add def</code>
<code>                    } ifelse</code>
<code>                } repeat</code>
<code>                exit</code>
<code>            } if</code>
<code>            DatumA i get {</code>
<code>                msg i get dup fn1 eq exch dup fn2 eq exch fn3 eq or or {  % FNCx</code>
<code>                    [ Avals msg i get get ] addtocws</code>
<code>                    ECI i get {  % FNC2 then 6 digits</code>
<code>                        [ ECIabc ] addtocws</code>
<code>                        /i i 7 add def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    msg i get fn3 eq i segstart ne and {  % FNC3</code>
<code>                        /i i 1 add def</code>
<code>                        /mode C def</code>
<code>                        /inmac 0 def</code>
<code>                        /segstart i def</code>
<code>                        /segend i UntilEndSeg i get add def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    /i i 1 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                [ Avals msg i get get ] addtocws</code>
<code>                /i i 1 add def</code>
<code>                exit</code>
<code>            } if</code>
<code>            Binary i get {  % Binary</code>
<code>                DatumA i 1 add get {</code>
<code>                    msg i get 160 lt {</code>
<code>                        [ Avals bsa get Avals msg i get 128 sub get ] addtocws</code>
<code>                    } {</code>
<code>                        [ Avals bsb get Bvals msg i get 128 sub get ] addtocws</code>
<code>                    } ifelse</code>
<code>                    /i i 1 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                [ Avals bin get ] addtocws</code>
<code>                /mode BIN def</code>
<code>                exit</code>
<code>            } if</code>
<code>            /n AheadB i get def</code>
<code>            n 6 gt {</code>
<code>                [ Avals lab get ] addtocws</code>
<code>                /mode B def</code>
<code>                exit</code>
<code>            } if</code>
<code>            [ Avals [ sfb sb2 sb3 sb4 sb5 sb6 ] n 1 sub get get ] addtocws</code>
<code>            n {</code>
<code>                msg i get 13 eq {</code>
<code>                    [ Bvals crl get ] addtocws</code>
<code>                    /i i 2 add def</code>
<code>                } {</code>
<code>                    [ Bvals msg i get get ] addtocws</code>
<code>                    /i i 1 add def</code>
<code>                } ifelse</code>
<code>            } repeat</code>
<code>            exit</code>
<code>        } repeat</code>
<code>    } def</code>
<code></code>
<code>    /encBIN {</code>
<code>        1 {  % Common exit</code>
<code>            /n TryC i get def</code>
<code>            n 2 ge {</code>
<code>                [ finaliseBIN ] addtocws</code>
<code>                n 7 gt {  % Terminate to C</code>
<code>                    [ BINvals tmc get ] addtocws</code>
<code>                    /mode C def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                [ BINvals [ sc2 sc3 sc4 sc5 sc6 sc7 ] n 2 sub get get ] addtocws</code>
<code>                n {</code>
<code>                    msg i get 0 lt {</code>
<code>                        [ Cvals msg i get get ] addtocws</code>
<code>                        /i i 1 add def</code>
<code>                    } {</code>
<code>                        [ msg i get 48 sub 10 mul msg i 1 add get 48 sub add ] addtocws</code>
<code>                        /i i 2 add def</code>
<code>                    } ifelse</code>
<code>                } repeat</code>
<code>                exit</code>
<code>            } if</code>
<code>            ECI i get Binary i 7 add get and {  % ECI then binary</code>
<code>                [ ECIbin ] addtocws</code>
<code>                /i i 7 add def</code>
<code>                i msglen eq { [ finaliseBIN ] addtocws } if</code>
<code>                exit</code>
<code>            } if</code>
<code>            msg i get 0 ge {  % Not FNCx</code>
<code>                Binary i       get    Binary i 1 add get or</code>
<code>                Binary i 2 add get or Binary i 3 add get or</code>
<code>                ECI i 1 add get       Binary i 8 add get and or {</code>
<code>                    [ msg i get addtobin ] addtocws</code>
<code>                    /i i 1 add def</code>
<code>                    i msglen eq { [ finaliseBIN ] addtocws } if</code>
<code>                    exit</code>
<code>                } if</code>
<code>            } if</code>
<code>            [ finaliseBIN ] addtocws</code>
<code>            i msglen 1 sub ne {  % Not last character</code>
<code>                msg i get fn3 eq i segstart ne and {  % FNC3</code>
<code>                    [ BINvals tms get ] addtocws</code>
<code>                    /i i 1 add def</code>
<code>                    /mode C def</code>
<code>                    /inmac 0 def</code>
<code>                    /segstart i def</code>
<code>                    /segend i UntilEndSeg i get add def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                AheadA i get AheadB i get gt {</code>
<code>                    [ BINvals tma get ] addtocws</code>
<code>                    /mode A def</code>
<code>                } {</code>
<code>                    [ BINvals tmb get ] addtocws</code>
<code>                    /mode B def</code>
<code>                } ifelse</code>
<code>                exit</code>
<code>            } if</code>
<code>            exit</code>
<code>        } repeat</code>
<code>    } def</code>
<code></code>
<code>    /cws msglen 2 mul 1 add array def</code>
<code>    /mode C def</code>
<code>    /bvals 5 array def  /bpos 0 def</code>
<code>    /inmac 0 def  /segstart 0 def  /segend UntilEndSeg 0 get def</code>
<code>    /i 0 def  /j 0 def  {</code>
<code>        i msglen ge {exit} if</code>
<code>        inmac 0 ne {  % Jump over macro trailers</code>
<code>            inmac mac ne i segend 2 sub eq and {  % {RS}{EOT}</code>
<code>                /i i 2 add def</code>
<code>                i msglen ge {exit} if</code>
<code>            } if</code>
<code>            inmac mac eq i segend 1 sub eq and {  % {EOT}</code>
<code>                /i i 1 add def</code>
<code>                i msglen ge {exit} if</code>
<code>            } if</code>
<code>        } if</code>
<code>        [ /encA /encB /encC /encBIN ] mode get load exec</code>
<code>    } loop</code>
<code>    /cws cws 0 j getinterval def</code>
<code></code>
<code>    % Determine the symbol size</code>
<code>    /nd cws length def</code>
<code>    /minarea nd 3 add nd 2 idiv add 9 mul 2 add 2 mul def</code>
<code>    ratio -1 ne {        % Fixed ratio</code>
<code>        /hgt minarea ratio div sqrt def</code>
<code>        /wid minarea ratio mul sqrt def</code>
<code>        /h hgt cvi def  /w wid cvi def</code>
<code>        h w add 2 mod 1 eq {</code>
<code>            h w mul minarea lt {/h h 1 add def  /w w 1 add def} if</code>
<code>        } {</code>
<code>            hgt w mul wid h mul lt {</code>
<code>                /w w 1 add def</code>
<code>                h w mul minarea lt {</code>
<code>                    /w w 1 sub def  /h h 1 add def</code>
<code>                    h w mul minarea lt {/w w 2 add def} if</code>
<code>                } if</code>
<code>            } {</code>
<code>                /h h 1 add def</code>
<code>                h w mul minarea lt {</code>
<code>                    /h h 1 sub def  /w w 1 add def</code>
<code>                    h w mul minarea lt {/h h 2 add def} if</code>
<code>                } if</code>
<code>            } ifelse</code>
<code>        } ifelse</code>
<code>        /rows h def  /columns w def</code>
<code>    } {</code>
<code>        columns -1 eq {  % Fixed height</code>
<code>            /columns minarea rows add 1 sub rows idiv dup rows add 2 mod 0 eq {1 add} if def</code>
<code>        } if</code>
<code>        rows -1 eq {     % Fixed width</code>
<code>            /rows minarea columns add 1 sub columns idiv dup columns add 2 mod 0 eq {1 add} if def</code>
<code>        } if</code>
<code>    } ifelse</code>
<code></code>
<code>    % Extend the codewords with padding</code>
<code>    /ndots rows columns mul 2 idiv def</code>
<code>    {</code>
<code>        nd 1 add dup 2 idiv 3 add add 9 mul 2 add ndots gt {exit} if</code>
<code>        /nd nd 1 add def</code>
<code>    } loop</code>
<code>    /nc nd 2 idiv 3 add def</code>
<code>    /nw nd nc add def</code>
<code>    /rembits ndots nw 9 mul 2 add sub def</code>
<code>    nd cws length gt {</code>
<code>        /cws [</code>
<code>            cws aload pop</code>
<code>            mode BIN eq {109} {106} ifelse</code>
<code>            nd cws length sub 1 sub {106} repeat</code>
<code>        ] def</code>
<code>    } if</code>
<code></code>
<code>    options /debugcws known { /bwipp.debugcws cws //raiseerror exec } if</code>
<code></code>
<code>    % Check that the codewords will fit in the symbol</code>
<code>    nw 9 mul ndots 2 sub gt {</code>
<code>        /bwipp.dotcodeTooLong (Maximum length exceeded) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Create an array containing the character mappings</code>
<code>{</code>
<code>    /encs [</code>
<code>        (101010101) (010101011) (010101101) (010110101) (011010101)</code>
<code>        (101010110) (101011010) (101101010) (110101010) (010101110)</code>
<code>        (010110110) (010111010) (011010110) (011011010) (011101010)</code>
<code>        (100101011) (100101101) (100110101) (101001011) (101001101)</code>
<code>        (101010011) (101011001) (101100101) (101101001) (110010101)</code>
<code>        (110100101) (110101001) (001010111) (001011011) (001011101)</code>
<code>        (001101011) (001101101) (001110101) (010010111) (010011011)</code>
<code>        (010011101) (010100111) (010110011) (010111001) (011001011)</code>
<code>        (011001101) (011010011) (011011001) (011100101) (011101001)</code>
<code>        (100101110) (100110110) (100111010) (101001110) (101011100)</code>
<code>        (101100110) (101101100) (101110010) (101110100) (110010110)</code>
<code>        (110011010) (110100110) (110101100) (110110010) (110110100)</code>
<code>        (111001010) (111010010) (111010100) (001011110) (001101110)</code>
<code>        (001110110) (001111010) (010011110) (010111100) (011001110)</code>
<code>        (011011100) (011100110) (011101100) (011110010) (011110100)</code>
<code>        (100010111) (100011011) (100011101) (100100111) (100110011)</code>
<code>        (100111001) (101000111) (101100011) (101110001) (110001011)</code>
<code>        (110001101) (110010011) (110011001) (110100011) (110110001)</code>
<code>        (111000101) (111001001) (111010001) (000101111) (000110111)</code>
<code>        (000111011) (000111101) (001001111) (001100111) (001110011)</code>
<code>        (001111001) (010001111) (011000111) (011100011) (011110001)</code>
<code>        (100011110) (100111100) (101111000) (110001110) (110011100)</code>
<code>        (110111000) (111000110) (111001100)</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Final six dots arranged at edges</code>
<code>    rows 2 mod 0 eq {</code>
<code>        /sixedges [</code>
<code>            [ columns 1 sub  rows 2 sub ]</code>
<code>            [ 0              rows 2 sub ]</code>
<code>            [ columns 2 sub  rows 1 sub ]</code>
<code>            [ 1              rows 1 sub ]</code>
<code>            [ columns 1 sub  0          ]</code>
<code>            [ 0              0          ]</code>
<code>        ] def</code>
<code>    } {</code>
<code>        /sixedges [</code>
<code>            [ columns 2 sub  0          ]</code>
<code>            [ columns 2 sub  rows 1 sub ]</code>
<code>            [ columns 1 sub  1          ]</code>
<code>            [ columns 1 sub  rows 2 sub ]</code>
<code>            [ 0              0          ]</code>
<code>            [ 0              rows 1 sub ]</code>
<code>        ] def</code>
<code>    } ifelse</code>
<code></code>
<code>    /dmv {columns mul add} def</code>
<code></code>
<code>    % Construct the template</code>
<code>    /outline rows columns mul array def</code>
<code>    0 1 rows 1 sub {</code>
<code>        /y exch def</code>
<code>        0 1 columns 1 sub {</code>
<code>            /x exch def</code>
<code>            outline x y dmv x y add 2 mod 1 sub put</code>
<code>        } for</code>
<code>    } for</code>
<code>    sixedges {</code>
<code>        outline exch aload pop dmv 1 put</code>
<code>    } forall</code>
<code></code>
<code>    /clearcol {</code>
<code>        /x exch def</code>
<code>        true</code>
<code>        x 1 and 2 rows 1 sub {</code>
<code>            x exch dmv sym exch get 1 eq {pop false exit} if</code>
<code>        } for</code>
<code>    } def</code>
<code></code>
<code>    /clearrow {</code>
<code>        /y exch def</code>
<code>        true</code>
<code>        y 1 and 2 columns 1 sub {</code>
<code>            y dmv sym exch get 1 eq {pop false exit} if</code>
<code>        } for</code>
<code>    } def</code>
<code></code>
<code>    % Evaluate the symbol</code>
<code>    /evalsymbol {</code>
<code>        /sym exch def</code>
<code></code>
<code>        % Identify the worst side</code>
<code>        /worst 9999999 def</code>
<code>        [ [ /x 0 ] [ /x 1 ] [ /y 0 ] [ /y 1 ] ] {  % Top Bottom Left Right</code>
<code>            aload pop  /fl exch def  /dir exch def</code>
<code>            /sum 0 def  /first -1 def  /last -1 def</code>
<code>            0 1 dir /x eq {columns} {rows} ifelse 1 sub {</code>
<code>                dir exch def</code>
<code>                sym</code>
<code>                dir load</code>
<code>                dir /x eq {rows} {columns} ifelse 1 sub fl mul</code>
<code>                dir /y eq {exch} if</code>
<code>                dmv get 1 eq {</code>
<code>                    first -1 eq {/first dir load def} if</code>
<code>                    /last dir load def</code>
<code>                    /sum sum 1 add def</code>
<code>                } if</code>
<code>            } for</code>
<code>            sum last add first sub</code>
<code>            dir /x eq {rows} {columns} ifelse mul</code>
<code>            dup worst lt {/worst exch def} {pop} ifelse</code>
<code>        } forall</code>
<code></code>
<code>        /pen 0 def</code>
<code></code>
<code>        % Check for groups of blank columns unless data is encoded vertically</code>
<code>        % in a symbol of sufficient height to overcome up to six consecutive 0s</code>
<code>        % in two neighbouring 5 of 9 dot patterns</code>
<code>        rows 2 mod 1 eq rows 12 le or {</code>
<code>            /sum 0 def  /p 0 def</code>
<code>            1 1 columns 2 sub {</code>
<code>                clearcol {</code>
<code>                    /sum sum 1 add def</code>
<code>                    /p sum 1 eq {rows} {p rows mul} ifelse def</code>
<code>                } {</code>
<code>                    /sum 0 def</code>
<code>                    /pen pen p add def</code>
<code>                    /p 0 def</code>
<code>                } ifelse</code>
<code>            } for</code>
<code>            /pen pen p add def</code>
<code>        } if</code>
<code></code>
<code>        % Check for groups of blank rows unless data is encoded horizontally</code>
<code>        % in a symbol of sufficient width to overcome up to six consecutive 0s</code>
<code>        % in two neighbouring 5 of 9 dot patterns</code>
<code>        rows 2 mod 0 eq columns 12 le or {</code>
<code>            /sum 0 def  /p 0 def</code>
<code>            1 1 rows 2 sub {</code>
<code>                clearrow {</code>
<code>                    /sum sum 1 add def</code>
<code>                    /p sum 1 eq {columns} {p columns mul} ifelse def</code>
<code>                } {</code>
<code>                    /sum 0 def</code>
<code>                    /pen pen p add def</code>
<code>                    /p 0 def</code>
<code>                } ifelse</code>
<code>            } for</code>
<code>            /pen pen p add def</code>
<code>        } if</code>
<code></code>
<code>        % Pad twice on all sides</code>
<code>        /symp [</code>
<code>            columns 4 add 2 mul {0} repeat</code>
<code>            0 columns sym length 1 sub {</code>
<code>                0 exch 0 exch</code>
<code>                sym exch columns getinterval aload pop</code>
<code>                0 0</code>
<code>            } for</code>
<code>            columns 4 add 2 mul {0} repeat</code>
<code>        ] def</code>
<code></code>
<code>        % Count voids and isolated dots</code>
<code>        /columns columns 4 add def</code>
<code>        /rows    rows    4 add def</code>
<code>        /sum 0 def</code>
<code>        2 1 rows 3 sub {</code>
<code>            /y exch def</code>
<code>            y 1 and 2 add 2 columns 3 sub {</code>
<code>                /x exch def</code>
<code>                1 {  % Common exit</code>
<code>                    symp x 1 sub y 1 sub dmv get 1 eq {exit} if</code>
<code>                    symp x 1 add y 1 sub dmv get 1 eq {exit} if</code>
<code>                    symp x 1 sub y 1 add dmv get 1 eq {exit} if</code>
<code>                    symp x 1 add y 1 add dmv get 1 eq {exit} if</code>
<code>                    symp x y dmv get 0 eq {/sum sum 1 add def exit} if</code>
<code>                    symp x 2 sub y       dmv get 1 eq {exit} if</code>
<code>                    symp x       y 2 sub dmv get 1 eq {exit} if</code>
<code>                    symp x 2 add y       dmv get 1 eq {exit} if</code>
<code>                    symp x       y 2 add dmv get 1 eq {exit} if</code>
<code>                    /sum sum 1 add def</code>
<code>                } repeat</code>
<code>            } for</code>
<code>        } for</code>
<code>        /columns columns 4 sub def</code>
<code>        /rows    rows    4 sub def</code>
<code></code>
<code>        worst 0 eq {  % Fixed penalty to disqualify a symbol with an unlit edge</code>
<code>            -99999</code>
<code>        } {</code>
<code>            worst sum sum mul sub pen sub</code>
<code>        } ifelse</code>
<code></code>
<code>    } def</code>
<code></code>
<code>    % Reed Solomon antilog table</code>
<code>{</code>
<code>    /rsalog [ 1 112 { dup 3 mul 113 mod } repeat ] def</code>
<code>} ctxdef</code>
<code>    /step nw 112 idiv 1 add def</code>
<code>    /offset {step mul start add} def</code>
<code></code>
<code>    % Evaluate the symbols in the following order:</code>
<code>    % fast mode: m3 -&gt; m3' -&gt; m2 -&gt; m2' -&gt; m1 -&gt; m1' -&gt; m0 -&gt; m0'</code>
<code>    % dflt mode: (m0 m1 m2 m3) -&gt; (m0' m1' m2' m3')</code>
<code>    % -&gt; : Test if we have met the HxW/2 threshold</code>
<code>    % m' : Symbols with six edge dots forcibly lit</code>
<code>    % () : Best of</code>
<code>    /bestscore -99999999 def</code>
<code>    /masks mask -1 ne {</code>
<code>        [ mask ]</code>
<code>    } {</code>
<code>        fast { [ 2#11 2#10 2#01 2#00 ] } { [ 2#00 2#01 2#10 2#11 ] } ifelse</code>
<code>    } ifelse def</code>
<code>    /litmasks 4 array def</code>
<code>    masks {  % For each mask pattern</code>
<code></code>
<code>        /mask exch def</code>
<code></code>
<code>        % Calculate the error correction codewords for each block</code>
<code>        /rscws [</code>
<code>             mask</code>
<code>             [ 0 3 7 17 ] mask get 0 cws {1 index add 113 mod exch 2 index add exch 3 1 roll} forall pop pop</code>
<code>             nc {0} repeat</code>
<code>        ] def</code>
<code>        0 1 step 1 sub {</code>
<code>            /start exch def</code>
<code>            /ND nd 1 add start sub step add 1 sub step idiv def</code>
<code>            /NW nw 1 add start sub step add 1 sub step idiv def</code>
<code>            /NC NW ND sub def</code>
<code>            /coeffs [ 1 NC {0} repeat ] def</code>
<code>            1 1 NC {</code>
<code>                /i exch def</code>
<code>                NC -1 1 {</code>
<code>                    /j exch def</code>
<code>                    coeffs j coeffs j get 113 add rsalog i get coeffs j 1 sub get mul 113 mod sub 113 mod put</code>
<code>                } for</code>
<code>            } for</code>
<code>            0 1 ND 1 sub {</code>
<code>                /t exch rscws exch offset get rscws ND offset get add 113 mod def</code>
<code>                0 1 NC 2 sub {</code>
<code>                    /j exch def</code>
<code>                    rscws ND j add offset rscws ND j add 1 add offset get 113 add t coeffs j 1 add get mul 113 mod sub 113 mod put</code>
<code>                } for</code>
<code>                rscws ND NC add 1 sub offset 113 t coeffs NC get mul 113 mod sub 113 mod put</code>
<code>            } for</code>
<code>            ND 1 NW 1 sub { dup rscws exch offset 113 rscws 5 -1 roll offset get sub 113 mod put } for</code>
<code>        } for</code>
<code></code>
<code>        % Create the bitstream</code>
<code>        /bits ndots string def</code>
<code>        bits 0 [ (00) (01) (10) (11) ] mask get putinterval</code>
<code>        1 1 nw {</code>
<code>            /i exch def</code>
<code>            bits i 1 sub 9 mul 2 add encs rscws i get get putinterval</code>
<code>        } for</code>
<code>        rembits 0 gt {</code>
<code>            bits nw 9 mul 2 add (11111111111111111) 0 rembits getinterval putinterval</code>
<code>        } if</code>
<code></code>
<code>        % Walk the symbol placing the bitstream</code>
<code>        /pixs outline dup length array copy def</code>
<code>        /posx 0 def</code>
<code>        /posy rows 2 mod 0 eq {0} {rows 1 sub} ifelse def</code>
<code>        bits 0 bits length 6 sub getinterval {</code>
<code>            {  % Move to next vacant position</code>
<code>                pixs posx posy dmv get -1 eq {exit} if</code>
<code>                rows 2 mod 0 eq {</code>
<code>                    /posy posy 1 add def</code>
<code>                    posy rows eq {</code>
<code>                        /posy 0 def</code>
<code>                        /posx posx 1 add def</code>
<code>                    } if</code>
<code>                } {</code>
<code>                    /posx posx 1 add def</code>
<code>                    posx columns eq {</code>
<code>                        /posx 0 def</code>
<code>                        /posy posy 1 sub def</code>
<code>                    } if</code>
<code>                } ifelse</code>
<code>            } loop</code>
<code>            pixs posx posy dmv 3 -1 roll 48 sub put</code>
<code>        } forall</code>
<code>        0 1 5 {  % Last six edge dots</code>
<code>            /i exch def</code>
<code>            pixs sixedges i get aload pop dmv</code>
<code>            bits bits length 6 sub i add get 48 sub put</code>
<code>        } for</code>
<code></code>
<code>        % Evaluate the symbol to find the most suitable mask</code>
<code>        /score pixs evalsymbol def</code>
<code>        score bestscore gt {</code>
<code>            /bestsym pixs def</code>
<code>            /bestscore score def</code>
<code>            fast bestscore rows columns mul 2 idiv gt and {exit} if</code>
<code>        } if</code>
<code></code>
<code>        % Make a copy with lit edges for possible later evaluation</code>
<code>        /litmask pixs dup length array copy def</code>
<code>        0 1 5 {  % Light last six edge dots</code>
<code>            /i exch def</code>
<code>            litmask sixedges i get aload pop dmv</code>
<code>            1 put</code>
<code>        } for</code>
<code>        litmasks mask litmask put</code>
<code></code>
<code>        % In fast mode immediately score the lit symbol</code>
<code>        fast {</code>
<code>            /score litmask evalsymbol def</code>
<code>            score bestscore gt {</code>
<code>                /bestsym litmask def</code>
<code>                /bestscore score def</code>
<code>                bestscore rows columns mul 2 idiv gt {exit} if</code>
<code>            } if</code>
<code>        } if</code>
<code></code>
<code>    } forall</code>
<code>    /pixs bestsym def</code>
<code></code>
<code>    % For default mode, if best mask fails threshold then recalculate with lit corners and pick best</code>
<code>    fast not bestscore rows columns mul 2 idiv le and {</code>
<code>        /bestscore -99999999 def</code>
<code>        masks {</code>
<code>            litmasks exch get /litmask exch def</code>
<code>            /score litmask evalsymbol def</code>
<code>            score bestscore gt {</code>
<code>                /bestsym litmask def</code>
<code>                /bestscore score def</code>
<code>            } if</code>
<code>        } forall</code>
<code>        /pixs bestsym def</code>
<code>    } if</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renmatrix</code>
<code>    /dotty true</code>
<code>    /pixs pixs</code>
<code>    /pixx columns</code>
<code>    /pixy rows</code>
<code>    /height rows 2 mul 72 div</code>
<code>    /width columns 2 mul 72 div</code>
<code>    /borderleft 3.0</code>
<code>    /borderright 3.0</code>
<code>    /bordertop 3.0</code>
<code>    /borderbottom 3.0</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /dotcode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER dotcode--</code>
<code></code>
<code>% --BEGIN ENCODER ultracode--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix--</code>
<code>% --DESC: Ultracode</code>
<code>% --EXAM: Awesome colours!</code>
<code>% --EXOP: eclevel=EC2</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp ultracode 0.0 2024010300 97986 100686</code>
<code>%%BeginData:        357 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/ultracode {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /eclevel (EC2) def     % EC1-EC5, and EC0 for rev 1</code>
<code>    /parse false def</code>
<code>    /parsefnc false def</code>
<code>    /start 257 def         % 8-bit ISO-8859-1, until we write high-level encoders</code>
<code>    /link1 0 def</code>
<code>    /raw false def</code>
<code>    /rev 2 def             % Ultracode specification revision</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    rev dup 1 ne exch 2 ne and {</code>
<code>        /bwipp.ultracodeInvalidRevision (Valid revisions are 1 and 2) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    eclevel length 3 eq dup {</code>
<code>       pop eclevel 0 2 getinterval (EC) dup eq {</code>
<code>           pop eclevel 2 get 48 sub dup rev 2 eq {1} {0} ifelse ge exch 5 le and</code>
<code>       } if</code>
<code>    } if</code>
<code>    not {</code>
<code>        /bwipp.ultracodeInvalidErrorCorrectionLevel (Valid error correction levels are EC1 to EC5, and EC0 for legacy revision 1) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /ultracode //loadctx exec</code>
<code></code>
<code>    raw {</code>
<code></code>
<code>        /dcws barcode length array def</code>
<code>        /i 0 def /j 0 def</code>
<code>        { % loop</code>
<code>            i barcode length eq {exit} if</code>
<code>            /cw barcode i 1 add 3 getinterval cvi def</code>
<code>            dcws j cw put</code>
<code>            /i i 4 add def</code>
<code>            /j j 1 add def</code>
<code>        } loop</code>
<code>        /dcws dcws 0 j getinterval def</code>
<code></code>
<code>    } {</code>
<code></code>
<code>        % Parse the input</code>
<code>        /fn1 -1 def  /fn3 -2 def</code>
<code>        /fncvals &lt;&lt;</code>
<code>            /parse parse</code>
<code>            /parsefnc parsefnc</code>
<code>            (FNC1) fn1</code>
<code>            (FNC3) fn3</code>
<code>        &gt;&gt; def</code>
<code>        /msg barcode fncvals //parseinput exec def</code>
<code>        /msglen msg length def</code>
<code></code>
<code>        /scr [] def     % Empty symbol control region</code>
<code>        /scp [] def     % Empty start sequence parameters</code>
<code>        /dcws [</code>
<code>            scr aload pop</code>
<code>            scp aload pop</code>
<code>            msg {</code>
<code>                dup fn1 eq {pop 268} if</code>
<code>                dup fn3 eq {pop 269} if</code>
<code>            } forall</code>
<code>        ] def</code>
<code></code>
<code>    } ifelse</code>
<code></code>
<code>    options /debugcws known { /bwipp.debugcws dcws //raiseerror exec } if</code>
<code></code>
<code>    /mcc dcws length 3 add def  % Message codewords: start mcc acc [dcws ...]</code>
<code></code>
<code>    /eclval eclevel 2 get 48 sub def</code>
<code>    eclval 0 ne {</code>
<code>        /qcc [0 1 2 4 6 8] eclval get mcc 25 idiv mcc 25 mod 0 ne {1 add} if mul 5 add def</code>
<code>    } {</code>
<code>        /qcc 3 def</code>
<code>    } ifelse</code>
<code>    /acc qcc 3 sub 78 link1 mul add def</code>
<code>    /tcc mcc qcc add def</code>
<code></code>
<code>    % Lookup the most appropriate symbol specification</code>
<code>{</code>
<code>    /metrics [</code>
<code>        % rows  minc  maxc  mcol</code>
<code>        [   2     7    37     5  ]</code>
<code>        [   3    36    84    13  ]</code>
<code>        [   4    85   161    22  ]</code>
<code>        [   5   142   282    29  ]</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    metrics {</code>
<code>        /m exch def</code>
<code>        /rows m 0 get def</code>
<code>        /minc m 1 get def  % Minimum permissible codewords</code>
<code>        /maxc m 2 get def  % Maximum permissible codewords</code>
<code>        /mcol m 3 get def  % Minimum tile columns</code>
<code>        /okay true def</code>
<code>        tcc minc lt tcc maxc gt or {/okay false def} if</code>
<code>        okay {exit} if</code>
<code>    } forall</code>
<code></code>
<code>    okay not {</code>
<code>        /bwipp.ultracodeNoValidSymbol (Maximum length exceeded or invalid content) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Determine required number of columns and pads</code>
<code>    mcol 1 61 {</code>
<code>        /columns exch def</code>
<code>        columns</code>
<code>        columns 15 ge {1 sub} if</code>
<code>        columns 31 ge {1 sub} if</code>
<code>        columns 47 ge {1 sub} if</code>
<code>        rows mul 3 sub tcc sub dup 0 ge {</code>
<code>            /pads exch def</code>
<code>            exit</code>
<code>        } if</code>
<code>        pop</code>
<code>    } for</code>
<code>    /dcc columns mcol sub def</code>
<code></code>
<code>    % Reed-Solomon error correction</code>
<code>    /rsseq [</code>
<code>        start</code>
<code>        mcc</code>
<code>        acc</code>
<code>        dcws aload pop</code>
<code>        qcc {0} repeat</code>
<code>        0  % Working space</code>
<code>    ] def</code>
<code></code>
<code>    % Calculate the log and anti-log tables</code>
<code>{</code>
<code>    /rsalog [ 1 282 {dup 3 mul 283 mod} repeat ] def</code>
<code>    /rslog 283 array def</code>
<code>    1 1 282 {dup rsalog exch get exch rslog 3 1 roll put} for</code>
<code>} ctxdef</code>
<code></code>
<code>    % Function to calculate the product in the field</code>
<code>    /rsprod {</code>
<code>        2 copy 0 ne exch 0 ne and {</code>
<code>            rslog exch get exch rslog exch get add 282 mod rsalog exch get</code>
<code>        } {</code>
<code>            pop pop 0</code>
<code>        } ifelse</code>
<code>    } def</code>
<code></code>
<code>    % Generate the coefficients</code>
<code>    /n mcc def  /k qcc def</code>
<code>    /coeffs [ 1 k {0} repeat ] def</code>
<code>    1 1 k {</code>
<code>        /i exch def</code>
<code>        coeffs i coeffs i 1 sub get put</code>
<code>        i 1 sub -1 1 {</code>
<code>            /j exch def</code>
<code>            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod add 283 mod put</code>
<code>        } for</code>
<code>        coeffs 0 coeffs 0 get rsalog i get rsprod put</code>
<code>    } for</code>
<code>    /coeffs coeffs 0 coeffs length 1 sub getinterval def</code>
<code>    coeffs length 1 sub -2 0 {coeffs exch 2 copy get 283 exch sub put} for</code>
<code></code>
<code>    % Derive the error codewords</code>
<code>    0 1 n 1 sub {</code>
<code>        /t exch rsseq exch get rsseq n get add 283 mod def</code>
<code>        0 1 k 1 sub {</code>
<code>            /j exch def</code>
<code>            rsseq n j add rsseq n j add 1 add get 283 t coeffs k j sub 1 sub get mul 283 mod sub add 283 mod put</code>
<code>        } for</code>
<code>    } for</code>
<code>    n 1 n k add { dup rsseq exch 283 rsseq 5 -1 roll get sub 283 mod put } for</code>
<code>    /ecws rsseq n k getinterval def</code>
<code></code>
<code>    options /debugecc known { /bwipp.debugecc ecws //raiseerror exec } if</code>
<code></code>
<code>{</code>
<code>    /tiles [</code>
<code>        13135  13136  13153  13156  13163  13165  13513  13515  13516  13531  %   0-9</code>
<code>        13535  13536  13561  13563  13565  13613  13615  13616  13631  13635  %  10-19</code>
<code>        13636  13651  13653  13656  15135  15136  15153  15163  15165  15313  %  20-29</code>
<code>        15315  15316  15351  15353  15356  15361  15363  15365  15613  15615  %  30-39</code>
<code>        15616  15631  15635  15636  15651  15653  15656  16135  16136  16153  %  40-49</code>
<code>        16156  16165  16313  16315  16316  16351  16353  16356  16361  16363  %  50-59</code>
<code>        16365  16513  16515  16516  16531  16535  16536  16561  16563  16565  %  60-69</code>
<code>        31315  31316  31351  31356  31361  31365  31513  31515  31516  31531  %  70-79</code>
<code>        31535  31536  31561  31563  31565  31613  31615  31631  31635  31636  %  80-89</code>
<code>        31651  31653  31656  35131  35135  35136  35151  35153  35156  35161  %  90-99</code>
<code>        35163  35165  35315  35316  35351  35356  35361  35365  35613  35615  % 100-109</code>
<code>        35616  35631  35635  35636  35651  35653  35656  36131  36135  36136  % 110-119</code>
<code>        36151  36153  36156  36163  36165  36315  36316  36351  36356  36361  % 120-129</code>
<code>        36365  36513  36515  36516  36531  36535  36536  36561  36563  36565  % 130-139</code>
<code>        51313  51315  51316  51351  51353  51356  51361  51363  51365  51513  % 140-149</code>
<code>        51516  51531  51536  51561  51563  51613  51615  51616  51631  51635  % 150-159</code>
<code>        51636  51651  51653  51656  53131  53135  53136  53151  53153  53156  % 160-169</code>
<code>        53161  53163  53165  53513  53516  53531  53536  53561  53563  53613  % 170-179</code>
<code>        53615  53616  53631  53635  53636  53651  53653  53656  56131  56135  % 180-189</code>
<code>        56136  56151  56153  56156  56161  56163  56165  56313  56315  56316  % 190-199</code>
<code>        56351  56353  56356  56361  56363  56365  56513  56516  56531  56536  % 200-209</code>
<code>        56561  56563  61313  61315  61316  61351  61353  61356  61361  61363  % 210-219</code>
<code>        61365  61513  61515  61516  61531  61535  61536  61561  61563  61565  % 220-229</code>
<code>        61615  61631  61635  61651  61653  63131  63135  63136  63151  63153  % 230-239</code>
<code>        63156  63161  63163  63165  63513  63515  63516  63531  63535  63536  % 240-249</code>
<code>        63561  63563  63565  63613  63615  63631  63635  63651  63653  65131  % 250-259</code>
<code>        65135  65136  65151  65153  65156  65161  65163  65165  65313  65315  % 260-269</code>
<code>        65316  65351  65353  65356  65361  65363  65365  65613  65615  65631  % 270-279</code>
<code>        65635  65651  65653  56565  51515                                     % 280-284</code>
<code>    ] def</code>
<code></code>
<code>    /dccurev1 [</code>
<code>        51363  51563  51653  53153  53163  53513  53563  53613  %  0-7</code>
<code>        53653  56153  56163  56313  56353  56363  56513  56563  %  8-15</code>
<code>        51316  51356  51536  51616  53156  53516  53536  53616  % 16-23</code>
<code>        53636  53656  56136  56156  56316  56356  56516  56536  % 24-31</code>
<code>    ] def</code>
<code>    /dcclrev1 [</code>
<code>        61351  61361  61531  61561  61631  61651  63131  63151  %  0-7</code>
<code>        63161  63531  63561  63631  65131  65161  65351  65631  %  8-15</code>
<code>        31351  31361  31531  31561  31631  31651  35131  35151  % 16-23</code>
<code>        35161  35361  35631  35651  36131  36151  36351  36531  % 24-31</code>
<code>    ] def</code>
<code>    /dccurev2 [</code>
<code>        15316  16316  13516  16516  13616  15616  13136  15136  %  0-7</code>
<code>        16136  13536  16536  13636  13156  16156  15356  13656  %  8-15</code>
<code>        15313  16313  13513  16513  13613  15613  13153  15153  % 16-23</code>
<code>        16153  16353  13653  15653  13163  15163  15363  13563  % 24-31</code>
<code>    ] def</code>
<code>    /dcclrev2 [</code>
<code>        36315  36515  35615  35135  36135  31535  36535  31635  %  0-7</code>
<code>        35635  35165  36165  31365  35365  36365  31565  36565  %  8-15</code>
<code>        61315  65315  63515  61615  65135  61535  63535  61635  % 16-23</code>
<code>        63635  65635  63165  65165  61365  65365  61565  63565  % 24-31</code>
<code>    ] def</code>
<code>} ctxdef</code>
<code></code>
<code>    /dccu rev 1 eq {dccurev1} {dccurev2} ifelse def</code>
<code>    /dccl rev 1 eq {dcclrev1} {dcclrev2} ifelse def</code>
<code></code>
<code>    % Create the bitmap</code>
<code>    /rows rows 6 mul 1 add def</code>
<code>    /columns columns 6 add def</code>
<code>    /pixs [ rows columns mul {-1} repeat ] def</code>
<code>    /qmv {columns mul add} def</code>
<code>    0 1 columns 1 sub {</code>
<code>        /i exch def</code>
<code>        0 6 rows 1 sub {</code>
<code>            /j exch def</code>
<code>            i 5 ge {pixs i j qmv i 2 mod 9 mul put} if</code>
<code>        } for</code>
<code>        pixs i 0 qmv 9 put</code>
<code>        pixs i rows 1 sub qmv 9 put</code>
<code>    } for</code>
<code>    1 1 rows 2 sub {</code>
<code>        /i exch def</code>
<code>        3 16 columns 1 sub {</code>
<code>            /j exch def</code>
<code>            pixs j i qmv 1 i 2 mod sub 9 mul put</code>
<code>        } for</code>
<code>        pixs 0 i qmv 9 put</code>
<code>        pixs 1 i qmv 1 i 2 mod sub 9 mul put</code>
<code>        pixs 2 i qmv 0 put</code>
<code>        pixs 3 i qmv 9 put</code>
<code>        pixs 4 i qmv 0 put</code>
<code>        pixs columns 1 sub i qmv 9 put</code>
<code>    } for</code>
<code></code>
<code>    % DCCU and DCCL tiles</code>
<code>    /i rows 2 idiv 5 sub def</code>
<code>    [</code>
<code>        dccu dcc get 10 5 string cvrs {48 sub} forall</code>
<code>        0</code>
<code>        dccl dcc get 10 5 string cvrs {48 sub} forall</code>
<code>    ] {</code>
<code>        pixs 2 i qmv 3 -1 roll put</code>
<code>        /i i 1 add def</code>
<code>    } forall</code>
<code></code>
<code>    % Data tiles</code>
<code>    /tileseq [</code>
<code>        start</code>
<code>        mcc</code>
<code>        ecws aload pop</code>
<code>        tcc</code>
<code>        283  % SEP</code>
<code>        acc</code>
<code>        dcws aload pop</code>
<code>        pads {284} repeat</code>
<code>        qcc</code>
<code>    ] def</code>
<code></code>
<code>    /x 5 def /y 1 def</code>
<code>    tileseq {</code>
<code>         tiles exch get 10 5 string cvrs {</code>
<code>              pixs x y qmv 3 -1 roll 48 sub put</code>
<code>              /y y 1 add def</code>
<code>         } forall</code>
<code>         y rows 1 sub ne {</code>
<code>              /y y 1 add def      % Jump horizontal timing pattern</code>
<code>         } {</code>
<code>              /x x 1 add def  /y 1 def</code>
<code>              pixs x y qmv get -1 ne {</code>
<code>                  /x x 1 add def  % Jump vertical timing pattern</code>
<code>              } if</code>
<code>         } ifelse</code>
<code>    } forall</code>
<code></code>
<code>{</code>
<code>    /colormap &lt;&lt;</code>
<code>        0 (FFFFFF)  % W</code>
<code>        9 (000000)  % K</code>
<code>        1 (00FFFF)  % C</code>
<code>        3 (FF00FF)  % M</code>
<code>        5 (FFFF00)  % Y</code>
<code>        6 (00FF00)  % G</code>
<code>    &gt;&gt; def</code>
<code>} ctxdef</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renmatrix</code>
<code>    /pixs pixs</code>
<code>    /pixx columns</code>
<code>    /pixy rows</code>
<code>    /height rows 72 div 2 mul</code>
<code>    /width columns 72 div 2 mul</code>
<code>    /colormap colormap</code>
<code>    /borderleft 1.0</code>
<code>    /borderright 1.0</code>
<code>    /bordertop 1.0</code>
<code>    /borderbottom 1.0</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /ultracode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER ultracode--</code>
<code></code>
<code>% --BEGIN ENCODER jabcode--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix--</code>
<code>% --DESC: JAB Code (Beta)</code>
<code>% --EXAM: This is JAB Code</code>
<code>% --EXOP: eclevel=6</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp jabcode 0.0 2024010300 244622 276310</code>
<code>%%BeginData:       1121 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/jabcode {</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /rows -1 def</code>
<code>    /columns -1 def</code>
<code>    /slave false def</code>
<code>    /colors 16 def</code>
<code>    /eclevel 6 def  % 0-10</code>
<code>    /raw false def</code>
<code>    /parse false def</code>
<code>    /parsefnc false def</code>
<code>    /mask -1 def    % 0-7</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /databpm colors ln 2 ln div round cvi def</code>
<code>    /metabpm colors dup 8 gt {pop 8} if ln 2 ln div round cvi def</code>
<code></code>
<code>     % Parse the input</code>
<code>    /fn1 -1 def</code>
<code>    /fncvals &lt;&lt;</code>
<code>        /parse parse</code>
<code>        /parsefnc parsefnc</code>
<code>        (FNC1) fn1</code>
<code>    &gt;&gt; def</code>
<code>    /msg barcode fncvals //parseinput exec def</code>
<code>    /msglen msg length def</code>
<code></code>
<code>    % Wide array support, as needed</code>
<code>%psc     {65536 array} stopped {</code>
<code>%psc         pop</code>
<code>%psc         /arrayw {</code>
<code>%psc             dup 65535 idiv 1 add dup array exch 0 exch 1 sub {2 copy 65535 array put 1 add} repeat</code>
<code>%psc             1 index 4 1 roll 3 -1 roll 65535 mod array put</code>
<code>%psc         } def</code>
<code>%psc         /getw  {exch 1 index 65535 idiv get exch 65535 mod get} def</code>
<code>%psc         /putw  {3 1 roll exch 1 index 65535 idiv get exch 65535 mod 3 -1 roll put} def</code>
<code>%psc         /copyw {exch 0 exch {dup length array copy 3 copy put pop 1 add} forall pop} def</code>
<code>%psc     } {</code>
<code>%psc         pop</code>
<code>%psc         /arrayw {array} def</code>
<code>%psc         /getw   {get}   def</code>
<code>%psc         /putw   {put}   def</code>
<code>%psc         /copyw  {copy}  def</code>
<code>%psc     } ifelse</code>
<code></code>
<code>    /addtobits {</code>
<code>        dup bits j 3 -1 roll putinterval</code>
<code>        length j add /j exch def</code>
<code>    } def</code>
<code></code>
<code>    /tofixedbits {  % Zero padded base 2 string</code>
<code>        (0000000000000) 13 string copy dup 4 -1 roll 2 13 string cvrs</code>
<code>        dup length 4 index exch sub exch putinterval</code>
<code>        0 3 -1 roll getinterval</code>
<code>    } def</code>
<code></code>
<code>    % Encode the data using byte mode encoding and terminate with EOM</code>
<code>    /bits 7 msglen 15 le {4} {17} ifelse add msglen 8 mul add 12 add string def</code>
<code>    /j 0 def</code>
<code>    31 5 tofixedbits addtobits  % MS</code>
<code>    (00) addtobits              % S/B</code>
<code>    msglen 15 le {</code>
<code>        msglen 4 tofixedbits addtobits</code>
<code>    } {</code>
<code>        (0000) addtobits</code>
<code>        msglen 16 sub 13 tofixedbits addtobits</code>
<code>    } ifelse</code>
<code>    0 1 msglen 1 sub {</code>
<code>        msg exch get 8 tofixedbits addtobits</code>
<code>    } for</code>
<code>    28 5 tofixedbits addtobits  % L/L</code>
<code>    31 5 tofixedbits addtobits  % MS</code>
<code>    (11) addtobits              % EOM</code>
<code></code>
<code>    % TODO Cascade</code>
<code>    /diffside 21 def</code>
<code>    /sameshape false def</code>
<code>    /sameecc false def</code>
<code>    /hasslaves false def</code>
<code></code>
<code>    % Determine the metrics for a symbol of a given size</code>
<code>    /metrics {</code>
<code>        /mc exch def  /mr exch def</code>
<code>        mc mr mul                                      % All modules</code>
<code>        mc 25 sub 16 idiv 2 add mr 25 sub 16 idiv 2 add</code>
<code>        mul 4 sub 7 mul                                % Alignment modules</code>
<code>        64 colors 2 copy gt {exch} if pop 2 mul        % Palette modules</code>
<code>        slave {7} {17} ifelse 4 mul                    % Finder modules</code>
<code></code>
<code>        % Metadata bits and modules</code>
<code>        slave not {  % Master</code>
<code>            /metass mr mc eq {0} {1} ifelse def</code>
<code>            mr mc 2 copy lt {exch} if pop</code>
<code>            21 sub 16 idiv [ 0 1 2 2 3 3 3 3 ] exch get  /metavf exch def</code>
<code>            /metavlen metass 0 eq {[2 2 3 4]} {[4 6 8 10]} ifelse metavf get def</code>
<code>            /metaelen metavf 2 mul 10 add def</code>
<code>            7                                          % II:  SS VF MSK SF</code>
<code>            metavlen add metaelen add                  % III: V E</code>
<code>            hasslaves {4 add} if                       % III: S</code>
<code>            2 mul                                      % LDPC</code>
<code>            metabpm div ceiling cvi</code>
<code>            dup metabpm mul 6 add /nummetabits exch def</code>
<code>            6 add                                      % I:   Nc into 6 modules</code>
<code>        } {  % Slave</code>
<code>            3                                          % I:   SS SE SF</code>
<code>            sameshape not {5 add} if                   % II:  V</code>
<code>            hasslaves     {3 add} if                   % II:  S</code>
<code>            sameecc not {</code>
<code>                mr mc 2 copy lt {exch} if pop</code>
<code>                21 sub 16 idiv [ 10 12 14 14 16 16 16 16 ] exch get</code>
<code>                add                                    % III: E</code>
<code>            } if</code>
<code>            2 mul                                      % LDPC</code>
<code>            metabpm div ceiling cvi</code>
<code>            dup metabpm mul /nummetabits exch def</code>
<code>        } ifelse</code>
<code></code>
<code>        dup              /nummetamodules exch def</code>
<code>        add add add sub  /numdatamodules exch def</code>
<code>        /numdatabits numdatamodules databpm mul def</code>
<code>    } def</code>
<code></code>
<code>    % Select a symbol size sufficient to carry the message</code>
<code>    /coderate [ 0.67 0.63 0.57 0.55 0.50 0.43 0.34 0.25 0.20 0.17 0.14 ] eclevel get def</code>
<code>    /grosslen bits length coderate div ceiling cvi def</code>
<code>    /snapsize {ceiling cvi 18 sub dup 0 lt {pop 0} if 4 idiv 4 mul 21 add} def</code>
<code></code>
<code>    rows -1 eq columns -1 eq and {        % Square if neither rows or columns fixed</code>
<code>        /size grosslen sqrt snapsize def</code>
<code>        {</code>
<code>            size size metrics</code>
<code>            grosslen numdatabits le {exit} if</code>
<code>            /size size 4 add def</code>
<code>        } loop</code>
<code>        /rows size def</code>
<code>        /columns size def</code>
<code>    } {</code>
<code>        columns -1 eq rows -1 ne and {     % Fixed height</code>
<code>            /columns grosslen rows div snapsize def</code>
<code>            {</code>
<code>                rows columns metrics</code>
<code>                grosslen numdatabits le {exit} if</code>
<code>                /columns columns 4 add def</code>
<code>            } loop</code>
<code>        } if</code>
<code>        rows -1 eq columns -1 ne and {     % Fixed width</code>
<code>            /rows grosslen columns div snapsize def</code>
<code>            {</code>
<code>                rows columns metrics</code>
<code>                grosslen numdatabits le {exit} if</code>
<code>                /rows rows 4 add def</code>
<code>            } loop</code>
<code>        } if</code>
<code>        rows -1 ne columns -1 ne and {     % Fixed height and width</code>
<code>            rows columns metrics</code>
<code>        } if</code>
<code>    } ifelse</code>
<code>    /C numdatabits def</code>
<code>    /cols columns def</code>
<code></code>
<code>    % TODO Reject all invalid sizes</code>
<code>    rows 145 gt cols 145 gt or {</code>
<code>        /bwipp.jabcodeNoValidSymbol (Maximum length exceeded or invalid content) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Pick ECC params to maximally fill symbol</code>
<code>    /min C def</code>
<code>    3 1 8 {</code>
<code>        /i exch def</code>
<code>        i 1 add 1 9 {</code>
<code>            /j exch def</code>
<code>            /dist C j idiv j mul C j idiv i mul sub bits length sub def</code>
<code>            dist min lt dist 0 ge and {</code>
<code>                /datawc i def</code>
<code>                /datawr j def</code>
<code>                /min dist def</code>
<code>            } if</code>
<code>        } for</code>
<code>    } for</code>
<code></code>
<code>    % Extend the encoded data to fill the required data length</code>
<code>    /tmpbits C datawr idiv datawr mul C datawr idiv datawc mul sub string def</code>
<code>    tmpbits 0 bits putinterval</code>
<code>    bits length 1 tmpbits length 1 sub {</code>
<code>        dup 1 sub tmpbits exch get dup 2 mod 0 eq {1 add} {1 sub} ifelse</code>
<code>        tmpbits 3 1 roll put</code>
<code>    } for</code>
<code>    /bits tmpbits def</code>
<code></code>
<code>    % Avoid 15-bit overflow when multiplying the digits by stealing from the second digit</code>
<code>    % m = 6364136223846793005 = 0x 5851 f42d 4c95 7f2d</code>
<code>    /m0 16#5851 16#1 add def  /m1 16#f42d 16#10000 sub def  /m2 16#4c95 def  /m3 16#7f2d def</code>
<code></code>
<code>    /lcg64_temper {</code>
<code></code>
<code>        % Multiply seed by 6364136223846793005 then add 1</code>
<code></code>
<code>        /p00 m0 s0 mul def  /p01 m0 s1 mul def  /p02 m0 s2 mul def  /p03 m0 s3 mul def</code>
<code>        /p10 m1 s0 mul def  /p11 m1 s1 mul def  /p12 m1 s2 mul def  /p13 m1 s3 mul def</code>
<code>        /p20 m2 s0 mul def  /p21 m2 s1 mul def  /p22 m2 s2 mul def  /p23 m2 s3 mul def</code>
<code>        /p30 m3 s0 mul def  /p31 m3 s1 mul def  /p32 m3 s2 mul def  /p33 m3 s3 mul def</code>
<code></code>
<code>        /s3 p33 16#10000 mod                     1 add def  % 1 added here</code>
<code>        /s2 p32 16#10000 mod p33 16#10000 idiv add</code>
<code>            p23 16#10000 mod                       add def</code>
<code>        /s1 p31 16#10000 mod p32 16#10000 idiv add</code>
<code>            p22 16#10000 mod p23 16#10000 idiv add add</code>
<code>            p13 16#10000 mod                       add def</code>
<code>        /s0 p30 16#10000 mod p31 16#10000 idiv add</code>
<code>            p21 16#10000 mod p22 16#10000 idiv add add</code>
<code>            p12 16#10000 mod p13 16#10000 idiv add add</code>
<code>            p03 16#10000 mod                       add def</code>
<code></code>
<code>        % Simplify carry by making each digit positive by borrowing from more significant digit</code>
<code>        /s3 s3 16#10000 add def</code>
<code>        /s2 s2 16#ffff  add def</code>
<code>        /s1 s1 16#ffff  add def</code>
<code>        /s0 s0 16#ffff  add def</code>
<code></code>
<code>        % Carry</code>
<code>        /s2 s3 16#10000 idiv s2 add def  /s3 s3 16#10000 mod def</code>
<code>        /s1 s2 16#10000 idiv s1 add def  /s2 s2 16#10000 mod def</code>
<code>        /s0 s1 16#10000 idiv s0 add def  /s1 s1 16#10000 mod def</code>
<code>                                         /s0 s0 16#10000 mod def</code>
<code></code>
<code>        % Temper most significant 32 bits</code>
<code>        s0 16#8000 sub 16#10000 mul s1 add 16#80000000 xor</code>
<code>        16#ffffffff and</code>
<code>        dup -11 bitshift xor</code>
<code>        dup   7 bitshift 16#62d3a980 neg and xor  % 0x9D2C5680 - 0x100000000</code>
<code>        dup  15 bitshift 16#103a0000 neg and xor  % 0xEFC60000 - 0x100000000</code>
<code>        16#ffffffff and</code>
<code>        dup -18 bitshift xor</code>
<code></code>
<code>    } def</code>
<code></code>
<code>    /createMatrixA {</code>
<code></code>
<code>        /nb_pcb wr 4 lt {Pg_sub_block 2 idiv} {Pg_sub_block wr idiv wc mul} ifelse def</code>
<code>        /offset Pg_sub_block 32 div ceiling cvi def</code>
<code>        /effwidth offset 32 mul def</code>
<code>        /matrixA offset nb_pcb mul arrayw def</code>
<code>        0 1 offset nb_pcb mul 1 sub {matrixA exch 0 putw} for</code>
<code>        /permutation Pg_sub_block array def</code>
<code>        0 1 Pg_sub_block 1 sub {permutation exch dup put} for</code>
<code></code>
<code>        0 1 Pg_sub_block wr idiv 1 sub {</code>
<code>            /i exch def</code>
<code>            0 1 wr 1 sub {</code>
<code>                /j exch def</code>
<code>                matrixA i effwidth wr add mul j add 32 idiv</code>
<code>                2 copy getw 1 31 i effwidth wr add mul j add 32 mod sub bitshift or putw</code>
<code>            } for</code>
<code>        } for</code>
<code></code>
<code>        % Pseudorandom permutation</code>
<code>        /s0 16#0000 def  /s1 16#0000 def  /s2 16#000B def  /s3 16#FC39 def  % s=785465</code>
<code>        1 1 wc 1 sub {</code>
<code>            /i exch def</code>
<code>            /off_index Pg_sub_block wr idiv i mul def</code>
<code>            0 1 Pg_sub_block 1 sub {</code>
<code>                /j exch def</code>
<code>                lcg64_temper</code>
<code>                dup 0 lt {16#80000000 xor 2147483648.0 add} if</code>
<code>                4294967296.0 div Pg_sub_block j sub mul cvi  % (float)UINT32_MAX = 65536.0 * 65536</code>
<code>                /pos exch def</code>
<code>                0 1 Pg_sub_block wr idiv 1 sub {</code>
<code>                    /k exch def</code>
<code>                    matrixA off_index k add offset mul j 32 idiv add</code>
<code>                    2 copy getw</code>
<code>                        matrixA permutation pos get 32 idiv k offset mul add getw</code>
<code>                        31      permutation pos get 32 mod  sub neg bitshift 1 and</code>
<code>                        31 j                        32 mod  sub bitshift</code>
<code>                    or putw</code>
<code>                } for</code>
<code>                permutation pos permutation Pg_sub_block 1 sub j sub 2 copy get permutation pos get</code>
<code>                exch 4 1 roll   % p b p a p[a] p[b] -&gt; p b p[a] p a p[b]</code>
<code>                put put</code>
<code>            } for</code>
<code>        } for</code>
<code></code>
<code>    } def</code>
<code></code>
<code>    /createMetadataMatrixA {</code>
<code></code>
<code>        /nb_pcb Pg_sub_block 2 idiv def</code>
<code>        /offset Pg_sub_block 32 div ceiling cvi def</code>
<code>        /matrixA offset nb_pcb mul arrayw def</code>
<code>        0 1 offset nb_pcb mul 1 sub {matrixA exch 0 putw} for</code>
<code>        /permutation Pg_sub_block array def</code>
<code>        0 1 Pg_sub_block 1 sub {permutation exch dup put} for</code>
<code></code>
<code>        % Pseudorandom permutation</code>
<code>        /s0 16#0000 def  /s1 16#0000 def  /s2 16#0000 def  /s3 16#9691 def  % s=38545</code>
<code>        /nb_once nb_pcb wc div Pg_sub_block mul 3 add cvi nb_pcb idiv def</code>
<code>        0 1 nb_pcb 1 sub {</code>
<code>            /i exch def</code>
<code>            0 1 nb_once 1 sub {</code>
<code>                /j exch def</code>
<code>                lcg64_temper</code>
<code>                dup 0 lt {16#80000000 xor 2147483648.0 add} if</code>
<code>                4294967296.0 div Pg_sub_block j sub mul cvi  % (float)UINT32_MAX = 65536.0 * 65536</code>
<code>                /pos exch def</code>
<code>                matrixA i offset mul permutation pos get 32 idiv add</code>
<code>                2 copy getw 1 31 permutation pos get 32 mod sub bitshift or putw</code>
<code>                permutation pos permutation Pg_sub_block 1 sub j sub 2 copy get permutation pos get</code>
<code>                exch 4 1 roll   % p b p a p[a] p[b] -&gt; p b p[a] p a p[b]</code>
<code>                put put</code>
<code>            } for</code>
<code>        } for</code>
<code></code>
<code>    } def</code>
<code></code>
<code>    /GaussJordan {</code>
<code></code>
<code>        /nb_pcb wr 4 lt {Pg_sub_block 2 idiv} {Pg_sub_block wr idiv wc mul} ifelse def</code>
<code>        /offset Pg_sub_block 32 div ceiling cvi def</code>
<code>        /matrixH matrixA dup length array copyw def</code>
<code>        /column_arrangement [ Pg_sub_block       {0}     repeat ] def</code>
<code>        /processed_column   [ Pg_sub_block       {false} repeat ] def</code>
<code>        /zero_lines_nb      [ nb_pcb             {0}     repeat ] def</code>
<code>        /swap_col           [ Pg_sub_block 2 mul {0}     repeat ] def</code>
<code>        /zero_lines 0 def</code>
<code></code>
<code>        /loop0 0 def</code>
<code>        0 1 nb_pcb 1 sub {</code>
<code>            /i exch def</code>
<code>            /pivot_column Pg_sub_block 1 add def</code>
<code>            0 1 Pg_sub_block 1 sub {</code>
<code>                /j exch def</code>
<code>                matrixH offset 32 mul i mul j add 32 idiv getw</code>
<code>                31 offset 32 mul i mul j add 32 mod sub neg bitshift 1 and 1 eq {</code>
<code>                    /pivot_column j def</code>
<code>                    exit</code>
<code>                } if</code>
<code>            } for</code>
<code>            pivot_column Pg_sub_block lt {</code>
<code>                processed_column   pivot_column true put</code>
<code>                column_arrangement pivot_column i put</code>
<code>                pivot_column nb_pcb ge {</code>
<code>                    swap_col loop0 2 mul pivot_column put</code>
<code>                    /loop0 loop0 1 add def</code>
<code>                } if</code>
<code>                /off_index  pivot_column 32 idiv def</code>
<code>                /off_index1 pivot_column 32 mod def</code>
<code>                0 1 nb_pcb 1 sub {</code>
<code>                    /j exch def</code>
<code>                    i j ne {</code>
<code>                        matrixH off_index j offset mul add getw</code>
<code>                        31 off_index1 sub neg bitshift 1 and 1 eq {</code>
<code>                            0 1 offset 1 sub {</code>
<code>                                /k exch def</code>
<code>                                matrixH offset j mul k add</code>
<code>                                2 copy getw matrixH offset i mul k add getw xor putw</code>
<code>                            } for</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                } for</code>
<code>            } {</code>
<code>                zero_lines_nb zero_lines i put</code>
<code>                /zero_lines zero_lines 1 add def</code>
<code>            } ifelse</code>
<code>        } for</code>
<code></code>
<code>        /matrix_rank nb_pcb zero_lines sub def</code>
<code>        /loop2 0 def</code>
<code>        matrix_rank 1 nb_pcb 1 sub {</code>
<code>            /i exch def</code>
<code>            column_arrangement i get 0 gt {</code>
<code>                0 1 nb_pcb 1 sub {</code>
<code>                    /j exch def</code>
<code>                    processed_column j get not {</code>
<code>                        column_arrangement j column_arrangement i get put</code>
<code>                        column_arrangement i 0 put</code>
<code>                        processed_column   j true put</code>
<code>                        processed_column   i false put</code>
<code>                        swap_col loop0 2 mul       i put</code>
<code>                        swap_col loop0 2 mul 1 add j put</code>
<code>                        column_arrangement i j put</code>
<code>                        /loop0 loop0 1 add def</code>
<code>                        /loop2 loop2 1 add def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                } for</code>
<code>            } if</code>
<code>        } for</code>
<code></code>
<code>        /loop1 0 def</code>
<code>        0 1 nb_pcb 1 sub {</code>
<code>            /kl exch def</code>
<code>            processed_column kl get not loop1 loop0 loop2 sub lt and {</code>
<code>                column_arrangement kl column_arrangement swap_col loop1 2 mul get get put</code>
<code>                processed_column kl true put</code>
<code>                swap_col loop1 2 mul 1 add kl put</code>
<code>                /loop1 loop1 1 add def</code>
<code>            } if</code>
<code>        } for</code>
<code></code>
<code>        /loop1 0 def</code>
<code>        0 1 nb_pcb 1 sub {</code>
<code>            /kl exch def</code>
<code>            processed_column kl get not {</code>
<code>                column_arrangement kl zero_lines_nb loop1 get put</code>
<code>                /loop1 loop1 1 add def</code>
<code>            } if</code>
<code>        } for</code>
<code></code>
<code>        0 1 nb_pcb 1 sub {</code>
<code>            /i exch def</code>
<code>            0 1 offset 1 sub {</code>
<code>                /j exch def</code>
<code>                matrixH column_arrangement i get offset mul j add getw</code>
<code>                matrixA exch i offset mul j add exch putw</code>
<code>            } for</code>
<code>        } for</code>
<code></code>
<code>        /tmp 0 def</code>
<code>        0 1 loop0 1 sub {</code>
<code>            /i exch def</code>
<code>            0 1 nb_pcb 1 sub {</code>
<code>                /j exch def</code>
<code>                matrixA swap_col i 2 mul get 32 idiv j offset mul add getw</code>
<code>                31 swap_col i 2 mul get 32 mod sub neg bitshift 1 and neg tmp xor 1 and</code>
<code>                tmp xor /tmp exch def</code>
<code>                matrixA     swap_col i 2 mul       get 32 idiv j offset mul add</code>
<code>                2 copy getw</code>
<code>                    matrixA swap_col i 2 mul 1 add get 32 idiv j offset mul add getw</code>
<code>                    31      swap_col i 2 mul 1 add get 32 mod  sub neg bitshift 1 and neg</code>
<code>                    matrixA swap_col i 2 mul       get 32 idiv j offset mul add getw xor</code>
<code>                    1 31    swap_col i 2 mul       get 32 mod  sub     bitshift and</code>
<code>                xor putw</code>
<code>                matrixA swap_col i 2 mul 1 add get 32 idiv j offset mul add</code>
<code>                2 copy getw</code>
<code>                    tmp 1 and neg</code>
<code>                    matrixA swap_col i 2 mul 1 add get 32 idiv j offset mul add getw xor</code>
<code>                    1 31    swap_col i 2 mul 1 add get 32 mod  sub     bitshift and</code>
<code>                xor putw</code>
<code>            } for</code>
<code>        } for</code>
<code></code>
<code>    } def</code>
<code></code>
<code>    /createGeneratorMatrix {</code>
<code></code>
<code>        /pn Pg_sub_block matrix_rank sub def</code>
<code>        /offset pn 32 div ceiling cvi def</code>
<code>        /effwidth offset 32 mul def</code>
<code>        /offset_cap Pg_sub_block 32 div ceiling cvi def</code>
<code>        /G offset Pg_sub_block mul arrayw def</code>
<code>        0 1 offset Pg_sub_block mul 1 sub {</code>
<code>            G exch 0 putw</code>
<code>        } for</code>
<code>        0 1 pn 1 sub {</code>
<code>            /i exch def</code>
<code>            G Pg_sub_block pn sub i add offset mul i 32 idiv add</code>
<code>            2 copy getw 1 31 i 32 mod sub bitshift or putw</code>
<code>        } for</code>
<code>        /matrix_index Pg_sub_block pn sub def</code>
<code>        /loop0 0 def</code>
<code>        0 1 Pg_sub_block pn sub effwidth mul 1 sub {</code>
<code>            /i exch def</code>
<code>            matrix_index Pg_sub_block ge {</code>
<code>                /loop0 loop0 1 add def</code>
<code>                /matrix_index Pg_sub_block pn sub def</code>
<code>            } if</code>
<code>            i effwidth mod pn lt {</code>
<code>                G i 32 idiv</code>
<code>                2 copy getw</code>
<code>                    matrixA matrix_index 32 idiv offset_cap loop0 mul add getw</code>
<code>                    31      matrix_index 32 mod sub neg bitshift 1 and neg</code>
<code>                    G       i            32 idiv getw xor</code>
<code>                    1 31    i            32 mod sub     bitshift and</code>
<code>                xor putw</code>
<code>                /matrix_index matrix_index 1 add def</code>
<code>            } if</code>
<code>        } for</code>
<code></code>
<code>    } def</code>
<code></code>
<code>    /ldpc {</code>
<code></code>
<code>        /wr exch def</code>
<code>        /wc exch def</code>
<code>        [ exch {48 sub} forall ] /data exch def</code>
<code></code>
<code>        /Pn data length def</code>
<code>        wr -1 ne {  % Message data</code>
<code>            /Pg Pn wr mul wr wc sub div ceiling wr div ceiling wr mul cvi def</code>
<code>            /nb_sub_blocks Pg 2700 idiv 1 add def</code>
<code>            /Pg_sub_block  Pg nb_sub_blocks idiv wr idiv wr mul def</code>
<code>            /Pn_sub_block  Pg_sub_block wr wc sub mul wr idiv def</code>
<code>            /nb_sub_blocks Pg Pg_sub_block idiv def</code>
<code>            /encoding_iterations Pg Pg_sub_block idiv Pn_sub_block nb_sub_blocks mul Pn lt {1 sub} if def</code>
<code>            createMatrixA</code>
<code>        } {         % Metadata</code>
<code>            /Pg Pn 2 mul def</code>
<code>            /nb_sub_blocks 1 def</code>
<code>            /Pg_sub_block  Pg def</code>
<code>            /Pn_sub_block  Pn def</code>
<code>            /encoding_iterations 1 def</code>
<code>            createMetadataMatrixA</code>
<code>        } ifelse</code>
<code>        GaussJordan</code>
<code>        createGeneratorMatrix</code>
<code></code>
<code>        /ecc_encoded_data Pg array def</code>
<code></code>
<code>        /offset Pg_sub_block matrix_rank sub 32 div ceiling cvi def</code>
<code>        0 1 encoding_iterations 1 sub {</code>
<code>            /iter exch def</code>
<code>            0 1 Pg_sub_block 1 sub {</code>
<code>                /i exch def</code>
<code>                /temp 0 def</code>
<code>                /loop0 0 def</code>
<code>                /offset_index offset i mul def</code>
<code>                iter Pn_sub_block mul 1 iter 1 add Pn_sub_block mul 1 sub {</code>
<code>                    data exch get</code>
<code>                    G offset_index loop0 32 idiv add getw 31 loop0 32 mod sub neg bitshift 1 and and</code>
<code>                    /temp exch temp xor def</code>
<code>                    /loop0 loop0 1 add def</code>
<code>                } for</code>
<code>                ecc_encoded_data i iter Pg_sub_block mul add temp put</code>
<code>            } for</code>
<code>        } for</code>
<code></code>
<code>        encoding_iterations nb_sub_blocks ne {</code>
<code>            /start      encoding_iterations Pn_sub_block mul def</code>
<code>            /last_index encoding_iterations Pg_sub_block mul def</code>
<code>            /Pg_sub_block Pg encoding_iterations Pg_sub_block mul sub def</code>
<code>            /Pn_sub_block Pg_sub_block wr wc sub mul wr idiv def</code>
<code>            createMatrixA</code>
<code>            GaussJordan</code>
<code>            createGeneratorMatrix</code>
<code>            /offset Pg_sub_block matrix_rank sub 32 div ceiling cvi def</code>
<code>            0 1 Pg_sub_block 1 sub {</code>
<code>                /i exch def</code>
<code>                /temp 0 def</code>
<code>                /loop0 0 def</code>
<code>                /offset_index offset i mul def</code>
<code>                start 1 Pn 1 sub {</code>
<code>                    data exch get</code>
<code>                    G offset_index loop0 32 idiv add getw 31 loop0 32 mod sub neg bitshift 1 and and</code>
<code>                    /temp exch temp xor def</code>
<code>                    /loop0 loop0 1 add def</code>
<code>                } for</code>
<code>                ecc_encoded_data i last_index add temp put</code>
<code>            } for</code>
<code>        } if</code>
<code></code>
<code>        /out Pg string def</code>
<code>        0 1 Pg 1 sub {</code>
<code>            dup ecc_encoded_data exch get</code>
<code>            out 3 1 roll 48 add put</code>
<code>        } for</code>
<code>        out</code>
<code></code>
<code>    } def</code>
<code></code>
<code>    % Replace data bitstream with LDPC error correction stream</code>
<code>    /bits bits datawc datawr ldpc def</code>
<code></code>
<code>    % Interleave via pseudorandom permutation</code>
<code>    /s0 16#0000 def  /s1 16#0000 def  /s2 16#0003 def  /s3 16#75C7 def  % s=226759</code>
<code>    bits length 1 sub -1 1 {</code>
<code>        /l exch def</code>
<code>        lcg64_temper</code>
<code>        dup 0 lt {16#80000000 xor 2147483648.0 add} if</code>
<code>        4294967296.0 div l 1 add mul cvi  % (float)UINT32_MAX = 65536.0 * 65536</code>
<code>        /r exch def</code>
<code>        bits l get bits r get</code>
<code>        bits exch l exch put</code>
<code>        bits exch r exch put</code>
<code>    } for</code>
<code></code>
<code>    % Append padding bits to the interleaved, ECC encoded data up to capacity</code>
<code>    /tmpbits C string def</code>
<code>    tmpbits 0 bits putinterval</code>
<code>    /j bits length def</code>
<code>    C j sub 1 add 2 idiv {</code>
<code>        tmpbits j 48 put</code>
<code>        j 1 add C lt {tmpbits j 1 add 49 put} if</code>
<code>        /j j 2 add def</code>
<code>    } repeat</code>
<code>    /bits tmpbits def</code>
<code></code>
<code>    % Define the color palette</code>
<code>    colors 4 eq {</code>
<code>        /bi 0 def  /gi 1 def  /mi 2 def  /yi 3 def</code>
<code>        /ki 4 def  /wi 5 def  % Extended</code>
<code>        /palette &lt;&lt;</code>
<code>            bi (0000FF)  gi (00FF00)  mi (FF00FF)  yi (FFFF00)</code>
<code>            ki (000000)  wi (FFFFFF)</code>
<code>        &gt;&gt; def</code>
<code>        /metacolorindex [bi gi mi yi] def</code>
<code>        /palettelayout  [bi gi mi yi] def</code>
<code>    } {</code>
<code>        /rgbres &lt;&lt;</code>
<code>              % r g b   Graduations</code>
<code>           8  [ 2 2 2 ]</code>
<code>          16  [ 4 2 2 ]</code>
<code>          32  [ 4 4 2 ]</code>
<code>          64  [ 4 4 4 ]</code>
<code>         128  [ 8 4 4 ]</code>
<code>         256  [ 8 8 4 ]</code>
<code>        &gt;&gt; colors get def</code>
<code></code>
<code>        /rvals rgbres 0 get [ exch 1 sub dup 0 exch 1 exch {255 2 index div mul round cvi exch} for pop ] def</code>
<code>        /gvals rgbres 1 get [ exch 1 sub dup 0 exch 1 exch {255 2 index div mul round cvi exch} for pop ] def</code>
<code>        /bvals rgbres 2 get [ exch 1 sub dup 0 exch 1 exch {255 2 index div mul round cvi exch} for pop ] def</code>
<code></code>
<code>        /palette colors dict def</code>
<code>        /palettelayout 64 colors 2 copy gt {exch} if pop array def</code>
<code>        /i 0 def  /j 8 def</code>
<code>        rvals {</code>
<code>            /r exch def</code>
<code>            gvals {</code>
<code>                /g exch def</code>
<code>                bvals {</code>
<code>                    /b exch def</code>
<code>                    r 16 bitshift g 8 bitshift or b or</code>
<code>                    (000000) 6 string copy dup 3 -1 roll 16 6 string cvrs dup length 6 exch sub exch putinterval</code>
<code>                    false</code>
<code>                    1 index (000000) eq {/ki i def  pop true} if</code>
<code>                    1 index (0000FF) eq {/bi i def  pop true} if</code>
<code>                    1 index (00FF00) eq {/gi i def  pop true} if</code>
<code>                    1 index (00FFFF) eq {/ci i def  pop true} if</code>
<code>                    1 index (FF0000) eq {/ri i def  pop true} if</code>
<code>                    1 index (FF00FF) eq {/mi i def  pop true} if</code>
<code>                    1 index (FFFF00) eq {/yi i def  pop true} if</code>
<code>                    1 index (FFFFFF) eq {/wi i def  pop true} if</code>
<code>                    not {</code>
<code>                        colors 64 le</code>
<code>                        colors 128 eq</code>
<code>                            r 0 eq r 73 eq or r 182 eq or r 255 eq or and</code>
<code>                        colors 256 eq</code>
<code>                            r 0 eq r 73 eq or r 182 eq or r 255 eq or and</code>
<code>                            g 0 eq g 73 eq or g 182 eq or g 255 eq or and</code>
<code>                        or or {  % RGB space is sampled into 64 slots</code>
<code>                            palettelayout j i put</code>
<code>                            /j j 1 add def</code>
<code>                        } if</code>
<code>                    } if</code>
<code>                    palette exch i exch put</code>
<code>                    /i i 1 add def</code>
<code>                } forall</code>
<code>            } forall</code>
<code>        } forall</code>
<code>        palettelayout 0 [ki bi gi ci ri mi yi wi] putinterval</code>
<code>        /metacolorindex [ki bi gi ci ri mi yi wi] def</code>
<code>    } ifelse</code>
<code></code>
<code>    % Create the pixel map</code>
<code>    /pixs [rows cols mul {-1} repeat] def</code>
<code>    /jmv {cols mul add} def</code>
<code></code>
<code>    % Finder patterns</code>
<code>    slave not {  % Master alignment pattern</code>
<code>        /fpat [</code>
<code>            [ 1 1 1 0 0 ]</code>
<code>            [ 1 2 2 0 0 ]</code>
<code>            [ 1 2 1 2 1 ]</code>
<code>            [ 0 0 2 2 1 ]</code>
<code>            [ 0 0 1 1 1 ]</code>
<code>        ] def</code>
<code>        /fmap [</code>
<code>            [ -1 bi yi ]  % UL</code>
<code>            [ -1 yi bi ]  % LL</code>
<code>            [ -1 gi mi ]  % UR</code>
<code>            [ -1 mi gi ]  % LR</code>
<code>        ] def</code>
<code>    } {  % Slave alignment pattern</code>
<code>        /fpat [</code>
<code>            [ 0 0 0 0 0 ]</code>
<code>            [ 0 2 2 0 0 ]</code>
<code>            [ 0 2 1 2 0 ]</code>
<code>            [ 0 0 2 2 0 ]</code>
<code>            [ 0 0 0 0 0 ]</code>
<code>        ] def</code>
<code>        /fmap [</code>
<code>            [ -1 ki wi ]  % UL</code>
<code>            [ -1 ki wi ]  % LL</code>
<code>            [ -1 ki wi ]  % UR</code>
<code>            [ -1 ki wi ]  % LR</code>
<code>        ] def</code>
<code>    } ifelse</code>
<code>    0 1 4 {</code>
<code>      /y exch def</code>
<code>      0 1 4 {</code>
<code>        /x exch def</code>
<code>        /fpb fpat y get x get def</code>
<code>        pixs x 1 add y 1 add                     jmv fmap 0 get fpb get put</code>
<code>        pixs x 1 add           rows y sub 2 sub  jmv fmap 1 get fpb get put</code>
<code>        pixs x cols add 6 sub  y 1 add           jmv fmap 2 get fpb get put</code>
<code>        pixs x cols add 6 sub  rows y sub 2 sub  jmv fmap 3 get fpb get put</code>
<code>      } for</code>
<code>    } for</code>
<code></code>
<code>    % Alignment patterns</code>
<code>    /algnpat0 [</code>
<code>        [ ki ki -1 ]</code>
<code>        [ ki wi ki ]</code>
<code>        [ -1 ki ki ]</code>
<code>    ] def</code>
<code>    /algnpat1 [</code>
<code>        [ -1 ki ki ]</code>
<code>        [ ki wi ki ]</code>
<code>        [ ki ki -1 ]</code>
<code>    ] def</code>
<code>    /num cols 16 div round cvi 1 sub def</code>
<code>    /algnrpos [ 3 17 ] def</code>
<code>    num 0 gt {</code>
<code>        /algnrpos [ 0 1 num {cols 7 sub num div mul cvi 3 add} for ] def</code>
<code>    } if</code>
<code>    /num rows 16 div round cvi 1 sub def</code>
<code>    /algncpos [ 3 17 ] def</code>
<code>    num 0 gt {</code>
<code>        /algncpos [ 0 1 num {rows 7 sub num div mul cvi 3 add} for ] def</code>
<code>    } if</code>
<code>    /putalgnpat {</code>
<code>        /pp exch def</code>
<code>        /py exch def</code>
<code>        /px exch def</code>
<code>        0 1 2 {</code>
<code>            /pb exch def</code>
<code>            0 1 2 {</code>
<code>                /pa exch def</code>
<code>                pixs px pa add py pb add jmv pp pb get pa get put</code>
<code>            } for</code>
<code>        } for</code>
<code>    } def</code>
<code>    0 1 algncpos length 1 sub {</code>
<code>        /j exch def</code>
<code>        /y algncpos j get def</code>
<code>        0 1 algnrpos length 1 sub {</code>
<code>            /i exch def</code>
<code>            /x algnrpos i get def</code>
<code>            pixs x y jmv get -1 eq {</code>
<code>                x 1 sub y 1 sub i j add 2 mod 0 eq {algnpat0} {algnpat1} ifelse putalgnpat</code>
<code>            } if</code>
<code>        } for</code>
<code>    } for</code>
<code></code>
<code>    slave not {</code>
<code></code>
<code>        [  % Expanded to [ x y ] [ x -y ] [ -x -y ] [ x -y ]</code>
<code>            % Metadata and palette</code>
<code>            [ 6 1 ] [ 6 2 ] [ 6 3 ] [ 6 4 ] [ 6 5 ] [ 6 6 ] [ 5 6 ] [ 4 6 ] [ 3 6 ] [ 2 6 ]  %  0-39</code>
<code>            [ 1 6 ] [ 7 1 ] [ 7 2 ] [ 7 3 ] [ 7 4 ] [ 7 5 ] [ 7 6 ] [ 7 7 ] [ 6 7 ] [ 5 7 ]  % 40-79</code>
<code>            % Palette only</code>
<code>            [  4  7 ] [  3  7 ] [  2  7 ] [  1  7 ] [  8  1 ] [  8  2 ] [  8  3 ] [  8  4 ]  % 16-31</code>
<code>            [  8  5 ] [  8  6 ] [  8  7 ] [  8  8 ] [  7  8 ] [  6  8 ] [  5  8 ] [  4  8 ]  % 32-47</code>
<code>            [  3  8 ] [  2  8 ] [  1  8 ] [  9  1 ] [  9  2 ] [  9  3 ] [  9  4 ] [  9  5 ]  % 48-63</code>
<code>        ] {</code>
<code>            aload pop /y exch def /x exch def</code>
<code>            [ x y ] [ x neg y ] [ x neg y neg ] [ x y neg ]</code>
<code>        } forall</code>
<code>        176 array astore /metadatamap exch def</code>
<code></code>
<code>        /palettemap1 [</code>
<code>            [  4  1 ] [  4  2 ] [  5  1 ] [  5  2 ] [  2  4 ] [  2  5 ] [  1  4 ] [  1  5 ]  %  0-7</code>
<code>            [ -2  1 ] [ -2  2 ] [ -1  1 ] [ -1  2 ] [ -4  4 ] [ -4  5 ] [ -5  4 ] [ -5  5 ]  %  8-15</code>
<code>        ] def</code>
<code></code>
<code>        /palettemap2 [</code>
<code>            [ -4 -5 ] [ -4 -4 ] [ -5 -5 ] [ -5 -4 ] [ -2 -2 ] [ -2 -1 ] [ -1 -2 ] [ -1 -1 ]  %  0-7</code>
<code>            [  2 -5 ] [  2 -4 ] [  1 -5 ] [  1 -4 ] [  4 -2 ] [  4 -1 ] [  5 -2 ] [  5 -1 ]  %  8-15</code>
<code>        ] def</code>
<code></code>
<code>    } {  % Slave</code>
<code></code>
<code>        % TODO Cascade</code>
<code></code>
<code>        /metadatamap [</code>
<code>            1 1 19 {</code>
<code>                /i exch def</code>
<code>                [ 0 i ] [ 1 i ]</code>
<code>            } for</code>
<code>            5 1 12 {</code>
<code>                /i exch def</code>
<code>                [ 2 i ] [ 3 i ]</code>
<code>            } for</code>
<code>        ] def</code>
<code></code>
<code>        /palettemap1 [</code>
<code>             5  1 12 { [ exch 4 exch ] } for</code>
<code>            12 -1  5 { [ exch 5 exch ] } for</code>
<code>             5  1 12 { [ exch 6 exch ] } for</code>
<code>            12 -1  5 { [ exch 7 exch ] } for</code>
<code>        ] def</code>
<code></code>
<code>        /palettemap2 [</code>
<code>            palettemap1 {[ exch aload pop neg exch neg exch]} forall</code>
<code>        ] def</code>
<code></code>
<code>    } ifelse</code>
<code></code>
<code>    % Normalise wrapping</code>
<code>    metadatamap {</code>
<code>        dup 0 get dup 0 lt {cols add 1 sub 1 index 0 3 -1 roll put} {pop} ifelse</code>
<code>        dup 1 get dup 0 lt {rows add 1 sub 1 index 1 3 -1 roll put} {pop} ifelse</code>
<code>        pop</code>
<code>    } forall</code>
<code>    palettemap1 {</code>
<code>        dup 0 get dup 0 lt {cols add 1 sub 1 index 0 3 -1 roll put} {pop} ifelse</code>
<code>        dup 1 get dup 0 lt {rows add 1 sub 1 index 1 3 -1 roll put} {pop} ifelse</code>
<code>        pop</code>
<code>    } forall</code>
<code>    palettemap2 {</code>
<code>        dup 0 get dup 0 lt {cols add 1 sub 1 index 0 3 -1 roll put} {pop} ifelse</code>
<code>        dup 1 get dup 0 lt {rows add 1 sub 1 index 1 3 -1 roll put} {pop} ifelse</code>
<code>        pop</code>
<code>    } forall</code>
<code></code>
<code>    % Reserve the metadata modules to be placed once mask is determined</code>
<code>    0 1 nummetamodules 1 sub {</code>
<code>        pixs exch metadatamap exch get aload pop jmv 0 put</code>
<code>    } for</code>
<code></code>
<code>    % Place the color palette</code>
<code>    slave not {</code>
<code>        % Up to first 16 colors into finder slots</code>
<code>        0 1 16 colors 2 copy gt {exch} if pop 1 sub {</code>
<code>            /i exch def</code>
<code>            palettelayout i get dup</code>
<code>            pixs exch palettemap1 i get aload pop jmv exch put</code>
<code>            pixs exch palettemap2 i get aload pop jmv exch put</code>
<code>        } for</code>
<code>        /i 16 def</code>
<code>    } {</code>
<code>        /i 0 def</code>
<code>    } ifelse</code>
<code></code>
<code>    % Continue palette placement after end of metadata modules</code>
<code>    /j nummetamodules def</code>
<code>    i 2 palettelayout length 1 sub {</code>
<code>        /i exch def</code>
<code>        palettelayout i get dup</code>
<code>        pixs exch metadatamap j       get aload pop jmv exch put</code>
<code>        pixs exch metadatamap j 2 add get aload pop jmv exch put</code>
<code>        palettelayout i 1 add get dup</code>
<code>        pixs exch metadatamap j 1 add get aload pop jmv exch put</code>
<code>        pixs exch metadatamap j 3 add get aload pop jmv exch put</code>
<code>        /j j 4 add def</code>
<code>    } for</code>
<code></code>
<code>    % Calculate the mask patterns applied to data modules</code>
<code>    /maskfuncs [</code>
<code>        {add colors mod} bind</code>
<code>        {pop colors mod} bind</code>
<code>        {exch pop colors mod} bind</code>
<code>        {3 idiv exch 2 idiv add colors mod} bind</code>
<code>        {2 idiv exch 3 idiv add colors mod} bind</code>
<code>        {add dup 2 idiv exch 3 idiv add colors mod} bind</code>
<code>        {2 copy exch dup mul mul 7 mod 3 1 roll exch dup mul add 2 mul 19 mod add colors mod} bind</code>
<code>        {2 copy dup mul mul 5 mod 3 1 roll dup mul exch 2 mul add 13 mod add colors mod} bind</code>
<code>    ] def</code>
<code>    mask -1 ne {  % User specifies a mask</code>
<code>        /maskfuncs [maskfuncs mask get] def</code>
<code>        /bestmaskval mask def</code>
<code>    } if</code>
<code>    /masks maskfuncs length array def</code>
<code>    0 1 masks length 1 sub {</code>
<code>        /m exch def</code>
<code>        /mask rows cols mul array def</code>
<code>        0 1 rows 1 sub {</code>
<code>            /j exch def</code>
<code>            0 1 cols 1 sub {</code>
<code>                /i exch def</code>
<code>                pixs i j jmv get -1 eq {i j maskfuncs m get exec} {0} ifelse</code>
<code>                mask i j jmv 3 -1 roll put</code>
<code>            } for</code>
<code>        } for</code>
<code>        masks m mask put</code>
<code>    } for</code>
<code></code>
<code>    % Walk the symbol placing the data bitstream</code>
<code>    /posx 0 def  /posy 0 def</code>
<code>    /i 0 def</code>
<code>    { % loop</code>
<code>        posx cols eq {exit} if</code>
<code>        pixs posx posy jmv get -1 eq {</code>
<code>            bits i databpm getinterval 0 exch {48 sub add 2 mul} forall 2 idiv</code>
<code>            pixs posx posy jmv 3 -1 roll put</code>
<code>            /i i databpm add def</code>
<code>        } if</code>
<code>        /posy posy 1 add def</code>
<code>        posy rows eq {/posy 0 def /posx posx 1 add def} if</code>
<code>    } loop</code>
<code></code>
<code>    % Evaluate runlength encoded rows or columns in full symbols</code>
<code>    /evalrle {</code>
<code>        /scrle exch def</code>
<code>        /scr1 0 def  /scr3 0 def</code>
<code>        0 2 scrle length 2 sub {</code>
<code>            /j exch def</code>
<code>            scrle j 1 add get -1 ne {  % Skip over voids</code>
<code>                % Detect runs of 5 or more like modules, except in voids</code>
<code>                scrle j get dup 5 ge {2 sub /scr1 exch scr1 add def} {pop} ifelse</code>
<code>                % Detect finder pattern</code>
<code>                j 4 ge j scrle length 5 sub le and {</code>
<code>                    scrle j 4 sub 10 getinterval                     % n1 c1 ... n5 c5</code>
<code>                    dup {1 eq} forall pop 4 {exch pop and} repeat {  % n{1-5}=1</code>
<code>                        mark exch aload pop</code>
<code>                        8 index dup 6 index eq exch 2 index eq and   % c1=c3=c5</code>
<code>                        7 index 4 index eq and {                     % c2=c4</code>
<code>                            2 index  /c4 exch def  /c5 exch def</code>
<code>                            c4 bi eq c5 yi eq and  c4 yi eq c5 bi eq and</code>
<code>                            c4 gi eq c5 mi eq and  c4 mi eq c5 gi eq and</code>
<code>                            or or or {/scr3 scr3 100 add def} if</code>
<code>                        } if</code>
<code>                        cleartomark</code>
<code>                    } {pop} ifelse</code>
<code>                } if</code>
<code>            } if</code>
<code>        } for</code>
<code>        scr1 scr3</code>
<code>    } def</code>
<code></code>
<code>    /evalmask {</code>
<code>        /sym exch def</code>
<code></code>
<code>        /n1 0 def /n2 0 def /n3 0 def</code>
<code>        /rle rows cols 2 copy lt {exch} if pop 2 mul 2 add array def</code>
<code>        /lastpairs cols array def</code>
<code>        /thispairs cols array def</code>
<code></code>
<code>        % Runlength encode and evaluate each column</code>
<code>        0 1 cols 1 sub {</code>
<code>            /i exch def</code>
<code>            mark 0 -1</code>
<code>            i cols rows cols mul 1 sub {</code>
<code>                sym exch get 2 copy eq {pop exch 1 add exch} {1 exch} ifelse</code>
<code>            } for</code>
<code>            rle 0 counttomark 2 sub getinterval astore</code>
<code>            evalrle n3 add /n3 exch def n1 add /n1 exch def</code>
<code>            pop</code>
<code>        } for</code>
<code></code>
<code>        0 1 rows 1 sub {</code>
<code>            /i exch def</code>
<code></code>
<code>            % Runlength encode and evaluate each row</code>
<code>            /symrow sym i cols mul cols getinterval def</code>
<code>            mark 0 -1</code>
<code>            symrow {</code>
<code>                2 copy eq {pop exch 1 add exch} {1 exch} ifelse</code>
<code>            } forall</code>
<code>            rle 0 counttomark 2 sub getinterval astore</code>
<code>            evalrle n3 add /n3 exch def n1 add /n1 exch def</code>
<code>            pop</code>
<code></code>
<code>            % Count and score same coloured blocks</code>
<code>            /lastpairs thispairs /thispairs lastpairs def def</code>
<code>            -1 symrow {exch 2 copy ne {pop -1 exch} if} forall</code>
<code>            pop</code>
<code>            thispairs astore pop</code>
<code>            i 0 gt {</code>
<code>                mark</code>
<code>                lastpairs aload pop thispairs aload pop</code>
<code>                n2 cols { exch dup -1 ne { cols 1 add index eq {3 add} if } {pop} ifelse } repeat</code>
<code>                /n2 exch def</code>
<code>                cleartomark</code>
<code>            } if</code>
<code>        } for</code>
<code></code>
<code>        n1 n2 add n3 add</code>
<code>    } def</code>
<code></code>
<code>    % Evaluate the masked symbols to find the most suitable</code>
<code>    /bestscore 999999999 def</code>
<code>    0 1 masks length 1 sub {</code>
<code>        /m exch def</code>
<code>        /masksym rows cols mul array def</code>
<code>        0 1 rows cols mul 1 sub {</code>
<code>            /i exch def</code>
<code>            masksym i pixs i get masks m get i get xor put</code>
<code>        } for</code>
<code>        masks length 1 ne {</code>
<code>            masksym evalmask /score exch def</code>
<code>            score bestscore lt {</code>
<code>                /bestsym masksym def</code>
<code>                /bestmaskval m def</code>
<code>                /bestscore score def</code>
<code>            } if</code>
<code>        } {</code>
<code>            /bestsym masksym def</code>
<code>        } ifelse</code>
<code>    } for</code>
<code>    /pixs bestsym def</code>
<code>    /metamask bestmaskval def</code>
<code></code>
<code>    % Derive the metadata bitstream</code>
<code>    /addtometapart {</code>
<code>        dup metapart p 3 -1 roll putinterval</code>
<code>        length p add /p exch def</code>
<code>    } def</code>
<code></code>
<code>    /addtometabits {</code>
<code>        dup metabits q 3 -1 roll putinterval</code>
<code>        length q add /q exch def</code>
<code>    } def</code>
<code></code>
<code>    /metapart 40 string def</code>
<code>    /metabits nummetabits string def</code>
<code>    /p 0 def  /q 0 def</code>
<code>    slave not {</code>
<code></code>
<code>        % Part I</code>
<code>        colors ln 2 ln div round cvi 1 sub</code>
<code>        3 tofixedbits addtometapart                                 % Nc</code>
<code>        metapart 0 p getinterval 2 -1 ldpc addtometabits  /p 0 def</code>
<code></code>
<code>        % Part II</code>
<code>        metass   1 tofixedbits addtometapart                        % SS</code>
<code>        metavf   2 tofixedbits addtometapart                        % VF</code>
<code>        metamask 3 tofixedbits addtometapart                        % MSK</code>
<code>        hasslaves {(1)} {(0)} ifelse addtometapart                  % SF</code>
<code>        metapart 0 p getinterval 2 -1 ldpc addtometabits  /p 0 def</code>
<code></code>
<code>        % Part III</code>
<code>        metass 0 eq {  % Square</code>
<code>            cols 17 sub 4 idiv [ 0 4 8 16 ] metavf get sub 1 sub</code>
<code>            metavlen tofixedbits addtometapart                      % V</code>
<code>        } {  % Rectangular</code>
<code>            cols 17 sub 4 idiv 1 sub</code>
<code>            metavlen 2 idiv tofixedbits addtometapart               % V1</code>
<code>            rows 17 sub 4 idiv 1 sub</code>
<code>            metavlen 2 idiv tofixedbits addtometapart               % V2</code>
<code>        } ifelse</code>
<code>        datawc 3 sub metaelen 2 idiv tofixedbits addtometapart      % E1</code>
<code>        datawr 4 sub metaelen 2 idiv tofixedbits addtometapart      % E2</code>
<code>        hasslaves {  % TODO Cascading</code>
<code>            0 4 tofixedbits addtometapart                           % S</code>
<code>        } if</code>
<code>        metapart 0 p getinterval 2 -1 ldpc addtometabits  /p 0 def</code>
<code></code>
<code>    } {  % slave</code>
<code></code>
<code>        % Part I</code>
<code>        sameshape {0} {1} ifelse 1 tofixedbits addtometapart        % SS</code>
<code>        sameecc   {0} {1} ifelse 1 tofixedbits addtometapart        % SE</code>
<code>        hasslaves {1} {0} ifelse 1 tofixedbits addtometapart        % SF</code>
<code>        metapart 0 p getinterval 2 -1 ldpc addtometabits  /p 0 def</code>
<code></code>
<code>        % Part II</code>
<code>        sameshape not {</code>
<code>            diffside 17 sub 4 idiv 1 sub</code>
<code>            5 tofixedbits addtometapart                             % V</code>
<code>        } if</code>
<code>        hasslaves {  % TODO Cascading</code>
<code>            0 3 tofixedbits addtometapart                           % S</code>
<code>        } if</code>
<code>        metapart 0 p getinterval 2 -1 ldpc addtometabits  /p 0 def</code>
<code></code>
<code>        % Part III</code>
<code>        sameecc not {</code>
<code>            datawc 3 sub metaelen 2 idiv tofixedbits addtometapart  % E1</code>
<code>            datawr 4 sub metaelen 2 idiv tofixedbits addtometapart  % E2</code>
<code>        } if</code>
<code>        metapart 0 p getinterval 2 -1 ldpc addtometabits  /p 0 def</code>
<code></code>
<code>    } ifelse</code>
<code>    q 1 nummetabits 1 sub {  % Pad with 0s</code>
<code>        metabits exch 48 put</code>
<code>    } for</code>
<code></code>
<code>    % Place the metadata</code>
<code>    /i 0 def  /j 0 def</code>
<code>    slave not {  % Two-color encoding of Part I (Nc) in master symbols</code>
<code>        metabits i 6 getinterval {</code>
<code>            colors 4 eq {[bi yi]} {[ki wi]} ifelse exch 48 sub get</code>
<code>            pixs metadatamap j get aload pop jmv 3 -1 roll put</code>
<code>            /j j 1 add def</code>
<code>        } forall</code>
<code>        /i i 6 add def</code>
<code>    } if</code>
<code>    nummetabits i sub metabpm idiv {</code>
<code>        metabits i metabpm getinterval 0 exch {48 sub add 2 mul} forall 2 idiv</code>
<code>        metacolorindex exch get</code>
<code>        pixs metadatamap j get aload pop jmv 3 -1 roll put</code>
<code>        /i i metabpm add def</code>
<code>        /j j 1 add def</code>
<code>    } repeat</code>
<code></code>
<code>    &lt;&lt;</code>
<code>    /ren //renmatrix</code>
<code>    /pixs pixs</code>
<code>    /pixx cols</code>
<code>    /pixy rows</code>
<code>    /colormap palette</code>
<code>    /height rows 2 mul 72 div</code>
<code>    /width  cols 2 mul 72 div</code>
<code>    /borderleft 0.0</code>
<code>    /borderright 0.0</code>
<code>    /bordertop 0.0</code>
<code>    /borderbottom 0.0</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /jabcode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER jabcode--</code>
<code></code>
<code>% --BEGIN ENCODER gs1-cc--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renmatrix micropdf417 pdf417--</code>
<code>% --DESC: GS1 Composite 2D Component</code>
<code>% --EXAM: (01)09521234543213(3103)000123</code>
<code>% --EXOP: ccversion=b cccolumns=4</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp gs1-cc 0.0 2024010300 226028 208827</code>
<code>%%BeginData:        654 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /pdf417 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /micropdf417 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/gs1-cc {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs false def</code>
<code>    /dontdraw false def</code>
<code>    /ccversion (a) def</code>
<code>    /cccolumns -1 def</code>
<code>    /lintype () def</code>
<code>    /linwidth -1 def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    /gs1-cc //loadctx exec</code>
<code></code>
<code>    ccversion (a) ne ccversion (b) ne and ccversion (c) ne and {</code>
<code>        /bwipp.gs1ccBadCCversion (ccversion must be a, b or c) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    cccolumns 30 gt {</code>
<code>        /bwipp.gs1ccColumnsTooBig (The maximum number of composite component columns is 30) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>{</code>
<code>    /lintypecccolumns &lt;&lt;</code>
<code>        /ean13                  4</code>
<code>        /upca                   4</code>
<code>        /ean8                   3</code>
<code>        /upce                   2</code>
<code>        /gs1-128                4</code>
<code>        /databaromni            4</code>
<code>        /databarstacked         2</code>
<code>        /databarstackedomni     2</code>
<code>        /databartruncated       4</code>
<code>        /databarlimited         3</code>
<code>        /databarexpanded        4</code>
<code>        /databarexpandedstacked 4</code>
<code>    &gt;&gt; def</code>
<code>} ctxdef</code>
<code></code>
<code>    lintype () ne {</code>
<code>        lintypecccolumns lintype known not {</code>
<code>            /bwipp.gs1ccBadLinType (The lintype is not recognised) //raiseerror exec</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    % Select columns based on linear type</code>
<code>    cccolumns -1 eq {</code>
<code>        lintype (gs1-128) eq ccversion (c) eq and {</code>
<code>            linwidth 0 lt {</code>
<code>                /bwipp.gs1ccMissingLinWidth (linwidth must be set for a GS1-128 with a CC-C composite component) //raiseerror exec</code>
<code>            } if</code>
<code>            linwidth 68 lt {</code>
<code>                /bwipp.gs1ccMinimumLinWidth (Minimum linwidth for a GS1-128 with a CC-C composite component is 68) //raiseerror exec</code>
<code>            } if</code>
<code>            linwidth 68 eq { 1 } { linwidth 52 sub 17 idiv } ifelse  % Ensure cccolumns != 0 if minimum linwidth</code>
<code>        } {</code>
<code>            lintype () ne { lintypecccolumns lintype get } {2} ifelse</code>
<code>        } ifelse</code>
<code>        /cccolumns exch def</code>
<code>    } if</code>
<code></code>
<code>    barcode /ai //gs1process exec</code>
<code>    /fncs exch def</code>
<code>    /vals exch def</code>
<code>    /ais exch def</code>
<code></code>
<code>    % Method selection</code>
<code>    /isupper {dup 65 ge exch 90 le and} def  % A-Z</code>
<code>    /isnum0  {dup 48 ge exch 57 le and} def  % 0-9</code>
<code>    /isnum1  {dup 49 ge exch 57 le and} def  % 1-9</code>
<code>    {  % common exit</code>
<code></code>
<code>        % (10/11/17)...</code>
<code>        ais length 1 ge {</code>
<code>            ais 0 get (10) eq ais 0 get (11) eq or ais 0 get (17) eq or {</code>
<code>                -1 (10) exit</code>
<code>            } if</code>
<code>        } if</code>
<code></code>
<code>        % (90){0-3 digits not starting 0}{upper alpha}...</code>
<code>        ais length 1 ge {</code>
<code>            ais 0 get (90) eq {</code>
<code>                /v vals 0 get def</code>
<code>                v length 1 ge {</code>
<code>                   v 0 get isupper {</code>
<code>                       0 (11) exit</code>
<code>                   } if</code>
<code>                } if</code>
<code>                v length 2 ge {</code>
<code>                   v 0 get isnum1</code>
<code>                   v 1 get isupper and {</code>
<code>                       1 (11) exit</code>
<code>                   } if</code>
<code>                } if</code>
<code>                v length 3 ge {</code>
<code>                    v 0 get isnum1</code>
<code>                    v 1 get isnum0 and</code>
<code>                    v 2 get isupper and {</code>
<code>                        2 (11) exit</code>
<code>                    } if</code>
<code>                } if</code>
<code>                v length 4 ge {</code>
<code>                    v 0 get isnum1</code>
<code>                    v 1 get isnum0 and</code>
<code>                    v 2 get isnum0 and</code>
<code>                    v 3 get isupper and {</code>
<code>                        3 (11) exit</code>
<code>                    } if</code>
<code>                } if</code>
<code>            } if</code>
<code>        } if</code>
<code></code>
<code>        % Freeform</code>
<code>        -1 (0) exit</code>
<code></code>
<code>    } loop</code>
<code>    /method exch def</code>
<code>    /npre exch def</code>
<code></code>
<code>    /tobin {</code>
<code>        string dup length 1 sub 0 exch 1 exch {1 index exch 48 put} for</code>
<code>        dup 3 -1 roll 2 2 index length string cvrs dup length 2 index length exch sub exch putinterval</code>
<code>    } def</code>
<code></code>
<code>{</code>
<code></code>
<code>    /fnc1 -1 def /lnumeric -2 def /lalphanumeric -3 def /liso646 -4 def</code>
<code></code>
<code>    /alpha &lt;&lt;</code>
<code>        65 1 90 {dup 65 sub 5 tobin} for</code>
<code>        48 1 57 {dup 4 add 6 tobin} for</code>
<code>        fnc1 (11111)</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /numeric &lt;&lt;</code>
<code>        0 1 119 {</code>
<code>            dup (00) 2 string copy dup 3 -1 roll 11 2 string cvrs</code>
<code>            dup length 2 exch sub exch putinterval</code>
<code>            dup 0 get 65 eq {dup 0 94 put} if</code>
<code>            dup 1 get 65 eq {dup 1 94 put} if</code>
<code>            exch 8 add</code>
<code>            (0000000) 7 string copy dup 3 -1 roll 2 7 string cvrs</code>
<code>            dup length 7 exch sub exch putinterval</code>
<code>        } for</code>
<code>        lalphanumeric (0000)</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /alphanumeric &lt;&lt;</code>
<code>        48 1 57 {dup 43 sub 5 tobin} for</code>
<code>        fnc1 (01111)</code>
<code>        65 1 90 {dup 33 sub 6 tobin} for</code>
<code>        42 (111010)</code>
<code>        44 1 47 {dup 15 add 6 tobin} for</code>
<code>        lnumeric (000)</code>
<code>        liso646 (00100)</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>    /iso646 &lt;&lt;</code>
<code>        48 1 57 {dup 43 sub 5 tobin} for</code>
<code>        fnc1 (01111)</code>
<code>        65 1 90 {dup 1 sub 7 tobin} for</code>
<code>        97 1 122 {dup 7 sub 7 tobin} for</code>
<code>        33 (11101000)</code>
<code>        34 (11101001)</code>
<code>        37 1 47 {dup 197 add 8 tobin} for</code>
<code>        58 1 63 {dup 187 add 8 tobin} for</code>
<code>        95 (11111011)</code>
<code>        32 (11111100)</code>
<code>        lnumeric (000)</code>
<code>        lalphanumeric (00100)</code>
<code>    &gt;&gt; def</code>
<code></code>
<code>} ctxdef</code>
<code></code>
<code>    method (10) eq {  % TODO: fixme</code>
<code>        ais 0 get (11) eq ais 0 get (17) eq or {</code>
<code>            vals 0 get</code>
<code>            dup 0 2 getinterval cvi 384 mul exch</code>
<code>            dup 2 2 getinterval cvi 1 sub 32 mul exch</code>
<code>            4 2 getinterval cvi add add</code>
<code>            (0000000000000000) 16 string copy dup 3 -1 roll 2 16 string cvrs</code>
<code>            dup length 16 exch sub exch putinterval</code>
<code>            [ 1 0</code>
<code>              4 -1 roll {48 sub} forall</code>
<code>              ais 0 get (11) eq {0} {1} ifelse</code>
<code>            ] /cdf exch def</code>
<code>            /ais  ais  1 ais  length 1 sub getinterval def</code>
<code>            /vals vals 1 vals length 1 sub getinterval def</code>
<code>            /fncs fncs 1 fncs length 1 sub getinterval def</code>
<code>        } {</code>
<code>            /cdf [ 1 0  1 1 ] def</code>
<code>        } ifelse</code>
<code>        ais length 0 ne {</code>
<code>            ais 0 get (10) eq {</code>
<code>                /gpf [ vals 0 get {} forall ] def</code>
<code>                ais length 1 gt {/gpf [ gpf aload pop fnc1 ] def} if  % TODO: check</code>
<code>                /ais  ais  1 ais  length 1 sub getinterval def</code>
<code>                /vals vals 1 vals length 1 sub getinterval def</code>
<code>                /fncs fncs 1 fncs length 1 sub getinterval def</code>
<code>            } {</code>
<code>                /gpf [fnc1] def  % TODO: check</code>
<code>            } ifelse</code>
<code>        } {</code>
<code>            /cdf [ cdf aload pop 0 0 0 0 0 1 1 1 1 ] def</code>
<code>            /gpf [] def</code>
<code>        } ifelse</code>
<code>        /mode (numeric) def</code>
<code>    } if</code>
<code></code>
<code>    method (11) eq {</code>
<code>        /cdf [ 1 1 ] def</code>
<code>        /ai90 vals 0 get def</code>
<code>        npre 1 add ai90 length ne {</code>
<code>            ai90 npre 1 add ai90 length npre sub 1 sub getinterval</code>
<code>        } {</code>
<code>            ()</code>
<code>        } ifelse</code>
<code>        /ai90rem exch def</code>
<code>        /nalpha 0 ai90rem {dup 65 ge exch 90 le and {1 add} if} forall def</code>
<code>        /nnums  0 ai90rem {dup 48 ge exch 57 le and {1 add} if} forall def</code>
<code>        /mode nalpha nnums gt {(alpha)} { nalpha 0 eq {(numeric)} {(alphanumeric)} ifelse } ifelse def</code>
<code>        nalpha nnums add ai90rem length ne {/mode (alphanumeric) def} if</code>
<code>        /cdf [</code>
<code>            cdf aload pop</code>
<code>            mode (alphanumeric) eq {0} if</code>
<code>            mode (numeric) eq {1 0} if</code>
<code>            mode (alpha) eq {1 1} if</code>
<code>        ] def</code>
<code>        /ais1  ais  length 1 gt {ais  1 get} {-1} ifelse def</code>
<code>        /vals1 vals length 1 gt {vals 1 get} {-1} ifelse def</code>
<code>        ais1 (21) eq ais1 (8004) eq or {</code>
<code>            /cdf [ cdf aload pop ais1 (21) eq {1 0} {1 1} ifelse ] def</code>
<code>        } {</code>
<code>            /cdf [ cdf aload pop 0 ] def</code>
<code>        } ifelse</code>
<code>        /nval npre 0 ne {ai90 0 npre getinterval cvi} {0} ifelse def</code>
<code>        (BDHIJKLNPQRSTVXZ) ai90 npre 1 getinterval search {</code>
<code>            length exch pop exch pop</code>
<code>            /aval exch def</code>
<code>        } {</code>
<code>            pop /aval -1 def</code>
<code>        } ifelse</code>
<code>        nval 31 lt aval -1 ne and {</code>
<code>            (00000) 5 string copy dup nval 2 5 string cvrs</code>
<code>            dup length 5 exch sub exch putinterval</code>
<code>            [ exch {48 sub} forall ] /nbits exch def</code>
<code>            (0000) 4 string copy dup aval 2 4 string cvrs</code>
<code>            dup length 4 exch sub exch putinterval</code>
<code>            [ exch {48 sub} forall ] /abits exch def</code>
<code>            /cdf [</code>
<code>                cdf aload pop</code>
<code>                nbits aload pop</code>
<code>                abits aload pop</code>
<code>            ] def</code>
<code>        } {</code>
<code>            (0000000000) 10 string copy dup nval 2 10 string cvrs</code>
<code>            dup length 10 exch sub exch putinterval</code>
<code>            [ exch {48 sub} forall ] /nbits exch def</code>
<code>            (00000) 5 string copy dup ai90 npre get 65 sub 2 5 string cvrs</code>
<code>            dup length 5 exch sub exch putinterval</code>
<code>            [ exch {48 sub} forall ] /abits exch def</code>
<code>            /cdf [</code>
<code>                cdf aload pop</code>
<code>                1 1 1 1 1</code>
<code>                nbits aload pop</code>
<code>                abits aload pop</code>
<code>            ] def</code>
<code>        } ifelse</code>
<code>        mode (alpha) ne {</code>
<code>            /gpf [ ai90rem {} forall ais length 1 gt {fnc1} if ] def</code>
<code>        } {</code>
<code>            /in [ ai90rem {} forall ais length 1 gt {fnc1} if ] def</code>
<code>            /out in length 6 mul array def</code>
<code>            /j 0 def</code>
<code>            0 1 in length 1 sub {</code>
<code>                in exch get alpha exch get</code>
<code>                dup [ exch {48 sub} forall ] out exch j exch putinterval</code>
<code>                length j add /j exch def</code>
<code>            } for</code>
<code>            /cdf [</code>
<code>                cdf aload pop</code>
<code>                out 0 j getinterval aload pop</code>
<code>            ] def</code>
<code>            /gpf [] def</code>
<code>            ais length 1 gt {/mode (numeric) def} if</code>
<code>        } ifelse</code>
<code>        /ais  ais  1 ais  length 1 sub getinterval def</code>
<code>        /vals vals 1 vals length 1 sub getinterval def</code>
<code>        /fncs fncs 1 fncs length 1 sub getinterval def</code>
<code>        ais length 0 ne {</code>
<code>            ais1 (21) eq ais1 (8004) eq or {</code>
<code>                /gpf [</code>
<code>                    gpf aload pop</code>
<code>                    vals1 {} forall</code>
<code>                ] def</code>
<code>                /ais  ais  1 ais  length 1 sub getinterval def</code>
<code>                /vals vals 1 vals length 1 sub getinterval def</code>
<code>                /fncs fncs 1 fncs length 1 sub getinterval def</code>
<code>                ais length 0 ne {/gpf [gpf aload pop fnc1] def} if</code>
<code>            } if</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    method (0) eq {</code>
<code>        /cdf [ 0 ] def</code>
<code>        /gpf [] def</code>
<code>        /mode (numeric) def</code>
<code>    } if</code>
<code></code>
<code>    % Append the remaining AI data</code>
<code>    0 1 ais length 1 sub {</code>
<code>        /i exch def</code>
<code>        /ai ais i get def</code>
<code>        /val vals i get def</code>
<code>        gpf length ai length add val length add array</code>
<code>        dup 0 gpf putinterval</code>
<code>        dup gpf length ai [ exch {} forall ] putinterval</code>
<code>        dup gpf length ai length add val [ exch {} forall ] putinterval</code>
<code>        /gpf exch def</code>
<code>        i ais length 1 sub ne fncs i get and {  % Append FNC1</code>
<code>            gpf length 1 add array</code>
<code>            dup 0 gpf putinterval</code>
<code>            dup gpf length fnc1 put</code>
<code>            /gpf exch def</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    % Calculate the number of bits remaining to the next valid symbol size</code>
<code>{</code>
<code>    /bitcapsmaps &lt;&lt;</code>
<code>        /a [</code>
<code>            [167 138 118 108 88 78 59]</code>
<code>            [167 138 118  98 78]</code>
<code>            [197 167 138 108 78]</code>
<code>        ]</code>
<code>        /b [</code>
<code>            [ 336  296 256 208 160 104  56]</code>
<code>            [ 768  648 536 416 304 208 152 112  72 32]</code>
<code>            [1184 1016 840 672 496 352 264 208 152 96 56]</code>
<code>        ]</code>
<code>    &gt;&gt; def</code>
<code>} ctxdef</code>
<code></code>
<code>    /rembits {</code>
<code>        /used exch def</code>
<code>        ccversion (c) ne {  % cc-a or cc-b</code>
<code>            /bitcaps bitcapsmaps ccversion get cccolumns 2 sub get def</code>
<code>            -1 bitcaps {dup used ge {exch} if pop} forall</code>
<code>            dup -1 ne {used sub} if</code>
<code>        } {</code>
<code>            &lt;&lt; /c -1 &gt;&gt; ccversion get pop  % Assert cc-c</code>
<code>            /m used 8 div ceiling cvi dup 6 idiv 5 mul exch 6 mod add def</code>
<code>            m   40 le               {8 } if</code>
<code>            m   41 ge m  160 le and {16} if</code>
<code>            m  161 ge m  320 le and {32} if</code>
<code>            m  321 ge m  833 le and {64} if  % 833 = 900 - 3 - 64, where 900 = 30 rows x 30 cols limit</code>
<code>            m  834 ge               {32} if  % Reduce to meet advertised "up to 2361 digits" (allows max 2372) within 900 limit</code>
<code>            /eccws exch def</code>
<code>            /m m eccws add 3 add def</code>
<code>            cccolumns 30 gt { /cccolumns 30 def } if</code>
<code>            {  % Loop until rows &lt;= 30 or columns &gt;= 30 (GS1 General Specifications 5.11.2.3)</code>
<code>                m cccolumns div ceiling cvi 30 le cccolumns 30 ge or {exit} if</code>
<code>                /cccolumns cccolumns 1 add def</code>
<code>            } loop</code>
<code>            /r m cccolumns div ceiling cvi def</code>
<code>            r 3 lt { /r 3 def } if  % GS1 General Specifications 5.11.2.3 "3 to 30 rows"</code>
<code>            /tgt cccolumns r mul eccws sub 3 sub dup 5 idiv 6 mul exch 5 mod add 8 mul def</code>
<code>            used 8304 le {tgt used sub} {-1} ifelse</code>
<code>        } ifelse</code>
<code>        dup -1 eq {  % Upgrade CC-A to CC-B or CC-B to CC-C to fit</code>
<code>            pop</code>
<code>            ccversion (a) eq {</code>
<code>                /ccversion (b) def</code>
<code>            } {</code>
<code>                ccversion (b) eq lintype (gs1-128) eq and {</code>
<code>                    /ccversion (c) def</code>
<code>                    /cccolumns linwidth 52 sub 17 idiv def</code>
<code>                } {</code>
<code>                    /ccversion -1 def</code>
<code>                } ifelse</code>
<code>            } ifelse</code>
<code>            used rembits</code>
<code>        } if</code>
<code>    } def</code>
<code></code>
<code>    /encode {</code>
<code>        dup /raw ne {exch get} {pop} ifelse</code>
<code>        [ exch {48 sub} forall ]</code>
<code>        dup length exch</code>
<code>        gpfenc exch j exch putinterval</code>
<code>        /j exch j add def</code>
<code>    } def</code>
<code></code>
<code>    % Pre-compute alphanumeric and numeric runlengths and position of next ISO646-only characters</code>
<code>    /numericruns [ gpf length {0} repeat 0 -1 ] def</code>
<code>    /alphanumericruns [ gpf length {0} repeat 0 ] def</code>
<code>    /nextiso646only [ gpf length {0} repeat 9999 ] def</code>
<code>    gpf length 1 sub -1 0 {</code>
<code>        /i exch def</code>
<code>        gpf i get</code>
<code>        (00) 2 string copy</code>
<code>        dup 0 gpf i get dup fnc1 eq {pop 94} if put</code>
<code>        i gpf length 1 sub lt {dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put} if</code>
<code>        numeric exch known {</code>
<code>            numericruns i numericruns i 2 add get 2 add put</code>
<code>        } {</code>
<code>            numericruns i 0 put</code>
<code>        } ifelse</code>
<code>        dup alphanumeric exch known {</code>
<code>            alphanumericruns i alphanumericruns i 1 add get 1 add put</code>
<code>        } {</code>
<code>            alphanumericruns i 0 put</code>
<code>        } ifelse</code>
<code>        dup iso646 exch known exch alphanumeric exch known not and {</code>
<code>            nextiso646only i 0 put</code>
<code>        } {</code>
<code>            nextiso646only i nextiso646only i 1 add get 1 add put</code>
<code>        } ifelse</code>
<code>    } for</code>
<code></code>
<code>    % Encode the general purpose field</code>
<code>    /gpfenc 8304 array def  % 8304 = (865 / 5) * 6 * 8, where 865 = 900 - 3 - 32</code>
<code>    /i 0 def /j 0 def</code>
<code>    {  % loop</code>
<code>        i gpf length eq {exit} if</code>
<code>        {  % not a loop but common exit point</code>
<code></code>
<code>            mode (numeric) eq {</code>
<code>                i gpf length 2 sub le {</code>
<code>                    2 string</code>
<code>                    dup 0 gpf i get dup fnc1 eq {pop 94} if put</code>
<code>                    dup 1 gpf i 1 add get dup fnc1 eq {pop 94} if put</code>
<code>                    dup numeric exch known {</code>
<code>                        numeric encode</code>
<code>                        /i i 2 add def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    pop</code>
<code>                    lalphanumeric numeric encode</code>
<code>                    /mode (alphanumeric) def</code>
<code>                    exit</code>
<code>                } {</code>
<code>                    gpf i get dup 48 lt exch 57 gt or {</code>
<code>                        lalphanumeric numeric encode</code>
<code>                        /mode (alphanumeric) def</code>
<code>                        exit</code>
<code>                    } if</code>
<code>                    /rem cdf length j add rembits def</code>
<code>                    rem 4 ge rem 6 le and {  % C1 + 1 into 4 to 6 bits</code>
<code>                        (000000) 6 string copy 0 rem getinterval</code>
<code>                        dup gpf i get 47 sub 2 4 string cvrs</code>
<code>                        dup length 4 exch sub exch putinterval /raw encode</code>
<code>                        /i i 1 add def</code>
<code>                        exit</code>
<code>                    } {  % C1.FNC1</code>
<code>                        2 string dup 0 gpf i get put dup 1 94 put numeric encode</code>
<code>                        /i i 1 add def</code>
<code>                        exit</code>
<code>                    } ifelse</code>
<code>                } ifelse</code>
<code>            } if</code>
<code></code>
<code>            mode (alphanumeric) eq {</code>
<code>                gpf i get fnc1 eq {</code>
<code>                    fnc1 alphanumeric encode</code>
<code>                    /mode (numeric) def</code>
<code>                    /i i 1 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                gpf i get dup iso646 exch known exch alphanumeric exch known not and {</code>
<code>                     liso646 alphanumeric encode</code>
<code>                     /mode (iso646) def</code>
<code>                     exit</code>
<code>                } if</code>
<code>                numericruns i get 6 ge {</code>
<code>                    lnumeric alphanumeric encode</code>
<code>                    /mode (numeric) def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                numericruns i get dup 4 ge exch i add gpf length eq and {</code>
<code>                    lnumeric alphanumeric encode</code>
<code>                    /mode (numeric) def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                gpf i get alphanumeric encode</code>
<code>                /i i 1 add def</code>
<code>                exit</code>
<code>            } if</code>
<code></code>
<code>            mode (iso646) eq {</code>
<code>                gpf i get fnc1 eq {</code>
<code>                    fnc1 iso646 encode</code>
<code>                    /mode (numeric) def</code>
<code>                    /i i 1 add def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                numericruns i get 4 ge nextiso646only i get 10 ge and {</code>
<code>                    lnumeric iso646 encode</code>
<code>                    /mode (numeric) def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                alphanumericruns i get 5 ge nextiso646only i get 10 ge and {</code>
<code>                    lalphanumeric iso646 encode</code>
<code>                    /mode (alphanumeric) def</code>
<code>                    exit</code>
<code>                } if</code>
<code>                gpf i get iso646 encode</code>
<code>                /i i 1 add def</code>
<code>                exit</code>
<code>            } if</code>
<code></code>
<code>        } loop</code>
<code>    } loop</code>
<code>    /gpf gpfenc 0 j getinterval def</code>
<code></code>
<code>    % Create pad</code>
<code>    /pad cdf length gpf length add rembits array def</code>
<code>    pad length 0 gt {</code>
<code>        0 5 pad length 1 sub {  % Fill with 00100</code>
<code>            /i exch def</code>
<code>            pad i [ 0 0 1 0 0 ] 0 pad length i sub 5 2 copy gt {exch} if pop getinterval putinterval</code>
<code>        } for</code>
<code>        mode (numeric) eq {  % Prefix shift from numeric to ASCII</code>
<code>            /pad [ 0 0 0 0 pad aload pop ] 0 pad length getinterval def</code>
<code>        } if</code>
<code>        mode (alpha) eq {  % Prefix FNC1 + shift from numeric to ASCII</code>
<code>            /pad [ 1 1 1 1 1 0 0 0 0 pad aload pop ] 0 pad length getinterval def</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    % Concatenate fields</code>
<code>    /bits [</code>
<code>        cdf aload pop</code>
<code>        gpf aload pop</code>
<code>        pad aload pop</code>
<code>    ] def</code>
<code></code>
<code>{</code>
<code>    /pwr928 [</code>
<code>        [ 0 0 0 0 0 0 1 ]</code>
<code>        68 {7 array} repeat</code>
<code>    ] def</code>
<code>    1 1 68 {</code>
<code>        /j exch def</code>
<code>        /v 0 def</code>
<code>        6 -1 1 {</code>
<code>            /i exch def</code>
<code>            /v pwr928 j 1 sub get i get 2 mul v 928 idiv add def</code>
<code>            pwr928 j get i v 928 mod put</code>
<code>        } for</code>
<code>        pwr928 j get 0 pwr928 j 1 sub get 0 get 2 mul v 928 idiv add put</code>
<code>    } for</code>
<code>} ctxdef</code>
<code></code>
<code>    ccversion (a) eq {</code>
<code>        /cws [ 28 {0} repeat ] def</code>
<code>        /b 0 def /c 0 def</code>
<code>        {  % loop</code>
<code>            b bits length eq {exit} if</code>
<code>            /bs bits b 69 bits length b sub 2 copy gt {exch} if pop getinterval def</code>
<code>            /bsl bs length def</code>
<code>            /cs cws c bsl 10 idiv 1 add getinterval def</code>
<code>            /csl cs length def</code>
<code>            0 1 bsl 1 sub {</code>
<code>                /i exch def</code>
<code>                0 1 csl 1 sub {</code>
<code>                    /j exch def</code>
<code>                    cs j 2 copy get</code>
<code>                    pwr928 i get j 7 add csl sub get</code>
<code>                    bs bsl i sub 1 sub get</code>
<code>                    mul add put</code>
<code>                } for</code>
<code>            } for</code>
<code>            csl 1 sub -1 1 {</code>
<code>                /i exch def</code>
<code>                cs i 1 sub 2 copy get cs i get 928 idiv add put</code>
<code>                cs i 2 copy get 928 mod put</code>
<code>            } for</code>
<code>            /b b bsl add def</code>
<code>            /c c csl add def</code>
<code>        } loop</code>
<code>        /cws cws 0 c getinterval def</code>
<code>        /barcode cws length 4 mul string def</code>
<code>        0 1 cws length 1 sub {</code>
<code>            /i exch def</code>
<code>            (^000) 4 string copy dup cws i get 10 4 string cvrs</code>
<code>            dup length 4 exch sub exch putinterval</code>
<code>            barcode i 4 mul 3 -1 roll putinterval</code>
<code>        } for</code>
<code>        options (parse) undef</code>
<code>        options (dontdraw) true put</code>
<code>        options (cca) true put</code>
<code>        options (columns) cccolumns put</code>
<code>        /args barcode options //micropdf417 exec def</code>
<code>    } if</code>
<code></code>
<code>    ccversion (b) eq {</code>
<code>        /barcode bits length 8 idiv string def</code>
<code>        0 1 barcode length 1 sub {</code>
<code>            /i exch def</code>
<code>            bits i 8 mul 8 getinterval 0 exch {add 2 mul} forall 2 idiv</code>
<code>            barcode exch i exch put</code>
<code>        } for</code>
<code>        options (parse) undef</code>
<code>        options (dontdraw) true put</code>
<code>        options (ccb) true put</code>
<code>        options (columns) cccolumns put</code>
<code>        /args barcode options //micropdf417 exec def</code>
<code>    } if</code>
<code></code>
<code>    ccversion (c) eq {</code>
<code>        /barcode bits length 8 idiv string def</code>
<code>        0 1 barcode length 1 sub {</code>
<code>            /i exch def</code>
<code>            bits i 8 mul 8 getinterval 0 exch {add 2 mul} forall 2 idiv</code>
<code>            barcode exch i exch put</code>
<code>        } for</code>
<code>        options (parse) undef</code>
<code>        options (dontdraw) true put</code>
<code>        options (ccc) true put</code>
<code>        options (columns) cccolumns put</code>
<code>        options (eclevel) eccws ln 2 ln div cvi 1 sub put</code>
<code>        /args barcode options //pdf417 exec def</code>
<code>    } if</code>
<code></code>
<code>    args</code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /gs1-cc dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER gs1-cc--</code>
<code></code>
<code>% --BEGIN ENCODER ean13composite--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renlinear renmatrix ean5 ean2 ean13 micropdf417 pdf417 gs1-cc--</code>
<code>% --DESC: EAN-13 Composite</code>
<code>% --EXAM: 9520123456788|(99)1234-abcd</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp ean13composite 0.0 2024010300 108907 108706</code>
<code>%%BeginData:        149 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /ean13 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/ean13composite {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /usematrix false def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs true def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    dontdraw { /usematrix true def } if</code>
<code></code>
<code>    % Split the linear and composite parts</code>
<code>    barcode (|) search {</code>
<code>        /linear exch def</code>
<code>        pop</code>
<code>        /comp exch def</code>
<code>    } {</code>
<code>        pop /bwipp.missingCompositeComponent (A Composite Component must be provided following a pipe character) //raiseerror exec</code>
<code>    } ifelse</code>
<code></code>
<code>    options (lintype) (ean13) put</code>
<code>    options (inkspreadv) 0.0 put</code>
<code>    options (dontdraw) true put</code>
<code>    options (dontlint) true put</code>
<code></code>
<code>    % Lint with a fake AI (01)</code>
<code>    comp length 18 add string</code>
<code>    dup 0 ((01)00000000000000) putinterval</code>
<code>    dup 18 comp putinterval</code>
<code>    /ai //gs1process exec pop pop pop</code>
<code></code>
<code>    % Plot the linear part</code>
<code>    linear options //ean13 exec</code>
<code>    usematrix not {</code>
<code>        gsave</code>
<code></code>
<code>        //renlinear exec</code>
<code></code>
<code>        % Plot the separator</code>
<code>        -1 72 rmoveto &lt;&lt;</code>
<code>            /ren //renmatrix</code>
<code>            /pixs [</code>
<code>                0 1  93 {0} repeat  1 0</code>
<code>                1 0  93 {0} repeat  0 1</code>
<code>                0 1  93 {0} repeat  1 0</code>
<code>            ]</code>
<code>            /pixx 97</code>
<code>            /pixy 3</code>
<code>            /height 6 72 div</code>
<code>            /width 97 72 div</code>
<code>            /opt options</code>
<code>        &gt;&gt; //renmatrix exec</code>
<code></code>
<code>        % Plot the 2D part</code>
<code>        -2 6 rmoveto comp options //gs1-cc exec //renmatrix exec</code>
<code></code>
<code>        grestore</code>
<code>    } {</code>
<code>        /linsym exch def</code>
<code>        /sbs linsym /sbs get def</code>
<code>        /bhs linsym /bhs get def</code>
<code>        /bbs linsym /bbs get def</code>
<code>        /linwidth 0 sbs {cvi add} forall def</code>
<code></code>
<code>        /compsym comp options //gs1-cc exec def</code>
<code>        /ccpixs compsym /pixs get def</code>
<code>        /ccpixx compsym /pixx get def</code>
<code></code>
<code>        /linpad [ ccpixx 97 sub {0} repeat ] def</code>
<code></code>
<code>        /diff linwidth linpad length add 1 add ccpixx sub def  % An add-on can make linear wider than composite</code>
<code>        diff 0 gt {  % Left align composite</code>
<code>            /ccrpad [ diff {0} repeat ] def</code>
<code>            /pixx ccpixx diff add def</code>
<code>        } {</code>
<code>            /ccrpad 0 array def</code>
<code>            /pixx ccpixx def</code>
<code>        } ifelse</code>
<code></code>
<code>        /pixs [</code>
<code>            0 ccpixx ccpixs length 1 sub {</code>
<code>                /i exch def</code>
<code>                ccpixs i ccpixx getinterval aload pop ccrpad aload pop</code>
<code>            } for</code>
<code>            2 { linpad aload pop 0 1  93 {0} repeat  1 0 ccrpad aload pop } repeat</code>
<code>            2 { linpad aload pop 1 0  93 {0} repeat  0 1 ccrpad aload pop } repeat</code>
<code>            2 { linpad aload pop 0 1  93 {0} repeat  1 0 ccrpad aload pop } repeat</code>
<code>            71 -1 0 {</code>
<code>                /y exch def</code>
<code>                linpad aload pop</code>
<code>                0</code>
<code>                0 1 sbs length 1 sub {</code>
<code>                    /i exch def</code>
<code>                    i 2 mod 0 eq {</code>
<code>                        % Don't print when bbs &gt; y || (bbs + bhs) &lt; y (i.e. add-on or includetext offsets)</code>
<code>                        bbs i 2 idiv get 72 mul dup y gt exch bhs i 2 idiv get 72 mul add y lt or {</code>
<code>                            sbs i get cvi {0} repeat</code>
<code>                        } {</code>
<code>                            sbs i get cvi {1} repeat</code>
<code>                        } ifelse</code>
<code>                    } {</code>
<code>                        sbs i get cvi {0} repeat</code>
<code>                    } ifelse</code>
<code>                } for</code>
<code>                diff 0 lt {0} if  % Allow for middle separator overhang on RHS if no add-on</code>
<code>            } for</code>
<code>        ] def</code>
<code></code>
<code>        /pixy pixs length pixx idiv def</code>
<code>        &lt;&lt;</code>
<code>        /ren //renmatrix</code>
<code>        /pixs pixs</code>
<code>        /pixx pixx</code>
<code>        /pixy pixy</code>
<code>        /height pixy 72 div</code>
<code>        /width pixx 72 div</code>
<code>        /opt options</code>
<code>        &gt;&gt;</code>
<code></code>
<code>        dontdraw not {</code>
<code>            gsave</code>
<code>            //renmatrix exec</code>
<code>            grestore</code>
<code>        } if</code>
<code>    } ifelse</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /ean13composite dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER ean13composite--</code>
<code></code>
<code>% --BEGIN ENCODER ean8composite--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renlinear renmatrix ean5 ean2 ean8 micropdf417 pdf417 gs1-cc--</code>
<code>% --DESC: EAN-8 Composite</code>
<code>% --EXAM: 95200002|(21)A12345678</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp ean8composite 0.0 2024010300 105816 112504</code>
<code>%%BeginData:        152 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /ean8 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/ean8composite {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /usematrix false def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs true def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    dontdraw { /usematrix true def } if</code>
<code></code>
<code>    % Split the linear and composite parts</code>
<code>    barcode (|) search {</code>
<code>        /linear exch def</code>
<code>        pop</code>
<code>        /comp exch def</code>
<code>    } {</code>
<code>        pop /bwipp.missingCompositeComponent (A Composite Component must be provided following a pipe character) //raiseerror exec</code>
<code>    } ifelse</code>
<code></code>
<code>    % Get the result of encoding with ean8 and gs1-cc</code>
<code>    options (lintype) (ean8) put</code>
<code>    options (inkspreadv) 0.0 put</code>
<code>    options (dontdraw) true put</code>
<code>    options (dontlint) true put</code>
<code></code>
<code>    % Lint with a fake AI (01)</code>
<code>    comp length 18 add string</code>
<code>    dup 0 ((01)00000000000000) putinterval</code>
<code>    dup 18 comp putinterval</code>
<code>    /ai //gs1process exec pop pop pop</code>
<code></code>
<code>    % Plot the linear part</code>
<code>    linear options //ean8 exec</code>
<code>    usematrix not {</code>
<code>        gsave</code>
<code></code>
<code>        //renlinear exec</code>
<code></code>
<code>        % Plot the separator</code>
<code>        -1 72 rmoveto &lt;&lt;</code>
<code>            /ren //renmatrix</code>
<code>            /pixs [</code>
<code>                0 1  65 {0} repeat  1 0</code>
<code>                1 0  65 {0} repeat  0 1</code>
<code>                0 1  65 {0} repeat  1 0</code>
<code>            ]</code>
<code>            /pixx 69</code>
<code>            /pixy 3</code>
<code>            /height 6 72 div</code>
<code>            /width 69 72 div</code>
<code>            /opt options</code>
<code>        &gt;&gt; //renmatrix exec</code>
<code></code>
<code>        % Plot the 2D part</code>
<code>        comp options //gs1-cc exec</code>
<code>        dup (pixx) get 69 exch sub 6 rmoveto</code>
<code>        //renmatrix exec</code>
<code></code>
<code>        grestore</code>
<code>    } {</code>
<code>        /linsym exch def</code>
<code>        /sbs linsym /sbs get def</code>
<code>        /bhs linsym /bhs get def</code>
<code>        /bbs linsym /bbs get def</code>
<code>        /linwidth 0 sbs {cvi add} forall def</code>
<code></code>
<code>        /compsym comp options //gs1-cc exec def</code>
<code>        /ccpixs compsym /pixs get def</code>
<code>        /ccpixx compsym /pixx get def</code>
<code></code>
<code>        /linpad [ ccpixx 69 sub {0} repeat ] def</code>
<code></code>
<code>        /diff linwidth linpad length add 1 add ccpixx sub def  % An add-on can make linear wider than composite</code>
<code>        diff 0 gt {  % Left align composite</code>
<code>            /ccrpad [ diff {0} repeat ] def</code>
<code>            /pixx ccpixx diff add def</code>
<code>        } {</code>
<code>            /ccrpad 0 array def</code>
<code>            /pixx ccpixx def</code>
<code>        } ifelse</code>
<code></code>
<code>        /pixs [</code>
<code>            0 ccpixx ccpixs length 1 sub {</code>
<code>                /i exch def</code>
<code>                ccpixs i ccpixx getinterval aload pop ccrpad aload pop</code>
<code>            } for</code>
<code>            2 { linpad aload pop 0 1  65 {0} repeat  1 0 ccrpad aload pop } repeat</code>
<code>            2 { linpad aload pop 1 0  65 {0} repeat  0 1 ccrpad aload pop } repeat</code>
<code>            2 { linpad aload pop 0 1  65 {0} repeat  1 0 ccrpad aload pop } repeat</code>
<code>            71 -1 0 {</code>
<code>                /y exch def</code>
<code>                linpad aload pop</code>
<code>                0</code>
<code>                0 1 sbs length 1 sub {</code>
<code>                    /i exch def</code>
<code>                    i 2 mod 0 eq {</code>
<code>                        % Don't print when bbs &gt; y || (bbs + bhs) &lt; y (i.e. add-on or includetext offsets)</code>
<code>                        bbs i 2 idiv get 72 mul dup y gt exch bhs i 2 idiv get 72 mul add y lt or {</code>
<code>                            sbs i get cvi {0} repeat</code>
<code>                        } {</code>
<code>                            sbs i get cvi {1} repeat</code>
<code>                        } ifelse</code>
<code>                    } {</code>
<code>                        sbs i get cvi {0} repeat</code>
<code>                    } ifelse</code>
<code>                } for</code>
<code>                diff 0 lt {0} if  % Allow for middle separator overhang on RHS if no add-on</code>
<code>            } for</code>
<code>        ] def</code>
<code></code>
<code>        /pixy pixs length pixx idiv def</code>
<code>        &lt;&lt;</code>
<code>        /ren //renmatrix</code>
<code>        /pixs pixs</code>
<code>        /pixx pixx</code>
<code>        /pixy pixy</code>
<code>        /height pixy 72 div</code>
<code>        /width pixx 72 div</code>
<code>        /opt options</code>
<code>        &gt;&gt;</code>
<code></code>
<code>        dontdraw not {</code>
<code>            gsave</code>
<code>            //renmatrix exec</code>
<code>            grestore</code>
<code>        } if</code>
<code>    } ifelse</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /ean8composite dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER ean8composite--</code>
<code></code>
<code>% --BEGIN ENCODER upcacomposite--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renlinear renmatrix ean5 ean2 upca micropdf417 pdf417 gs1-cc--</code>
<code>% --DESC: UPC-A Composite</code>
<code>% --EXAM: 012345000058|(99)1234-abcd</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp upcacomposite 0.0 2024010300 108925 108701</code>
<code>%%BeginData:        149 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /upca dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/upcacomposite {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /usematrix false def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs true def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    dontdraw { /usematrix true def } if</code>
<code></code>
<code>    % Split the linear and composite parts</code>
<code>    barcode (|) search {</code>
<code>        /linear exch def</code>
<code>        pop</code>
<code>        /comp exch def</code>
<code>    } {</code>
<code>        pop /bwipp.missingCompositeComponent (A Composite Component must be provided following a pipe character) //raiseerror exec</code>
<code>    } ifelse</code>
<code></code>
<code>    options (lintype) (ean13) put</code>
<code>    options (inkspreadv) 0.0 put</code>
<code>    options (dontdraw) true put</code>
<code>    options (dontlint) true put</code>
<code></code>
<code>    % Lint with a fake AI (01)</code>
<code>    comp length 18 add string</code>
<code>    dup 0 ((01)00000000000000) putinterval</code>
<code>    dup 18 comp putinterval</code>
<code>    /ai //gs1process exec pop pop pop</code>
<code></code>
<code>    % Plot the linear part</code>
<code>    linear options //upca exec</code>
<code>    usematrix not {</code>
<code>        gsave</code>
<code></code>
<code>        //renlinear exec</code>
<code></code>
<code>        % Plot the separator</code>
<code>        -1 72 rmoveto &lt;&lt;</code>
<code>            /ren //renmatrix</code>
<code>            /pixs [</code>
<code>                0 1  93 {0} repeat  1 0</code>
<code>                1 0  93 {0} repeat  0 1</code>
<code>                0 1  93 {0} repeat  1 0</code>
<code>            ]</code>
<code>            /pixx 97</code>
<code>            /pixy 3</code>
<code>            /height 6 72 div</code>
<code>            /width 97 72 div</code>
<code>            /opt options</code>
<code>        &gt;&gt; //renmatrix exec</code>
<code></code>
<code>        % Plot the 2D part</code>
<code>        -2 6 rmoveto comp options //gs1-cc exec //renmatrix exec</code>
<code></code>
<code>        grestore</code>
<code>    } {</code>
<code>        /linsym exch def</code>
<code>        /sbs linsym /sbs get def</code>
<code>        /bhs linsym /bhs get def</code>
<code>        /bbs linsym /bbs get def</code>
<code>        /linwidth 0 sbs {cvi add} forall def</code>
<code></code>
<code>        /compsym comp options //gs1-cc exec def</code>
<code>        /ccpixs compsym /pixs get def</code>
<code>        /ccpixx compsym /pixx get def</code>
<code></code>
<code>        /linpad [ ccpixx 97 sub {0} repeat ] def</code>
<code></code>
<code>        /diff linwidth linpad length add 1 add ccpixx sub def  % An add-on can make linear wider than composite</code>
<code>        diff 0 gt {  % Left align composite</code>
<code>            /ccrpad [ diff {0} repeat ] def</code>
<code>            /pixx ccpixx diff add def</code>
<code>        } {</code>
<code>            /ccrpad 0 array def</code>
<code>            /pixx ccpixx def</code>
<code>        } ifelse</code>
<code></code>
<code>        /pixs [</code>
<code>            0 ccpixx ccpixs length 1 sub {</code>
<code>                /i exch def</code>
<code>                ccpixs i ccpixx getinterval aload pop ccrpad aload pop</code>
<code>            } for</code>
<code>            2 { linpad aload pop 0 1  93 {0} repeat  1 0 ccrpad aload pop } repeat</code>
<code>            2 { linpad aload pop 1 0  93 {0} repeat  0 1 ccrpad aload pop } repeat</code>
<code>            2 { linpad aload pop 0 1  93 {0} repeat  1 0 ccrpad aload pop } repeat</code>
<code>            71 -1 0 {</code>
<code>                /y exch def</code>
<code>                linpad aload pop</code>
<code>                0</code>
<code>                0 1 sbs length 1 sub {</code>
<code>                    /i exch def</code>
<code>                    i 2 mod 0 eq {</code>
<code>                        % Don't print when bbs &gt; y || (bbs + bhs) &lt; y (i.e. add-on or includetext offsets)</code>
<code>                        bbs i 2 idiv get 72 mul dup y gt exch bhs i 2 idiv get 72 mul add y lt or {</code>
<code>                            sbs i get cvi {0} repeat</code>
<code>                        } {</code>
<code>                            sbs i get cvi {1} repeat</code>
<code>                        } ifelse</code>
<code>                    } {</code>
<code>                        sbs i get cvi {0} repeat</code>
<code>                    } ifelse</code>
<code>                } for</code>
<code>                diff 0 lt {0} if  % Allow for middle separator overhang on RHS if no add-on</code>
<code>            } for</code>
<code>        ] def</code>
<code></code>
<code>        /pixy pixs length pixx idiv def</code>
<code>        &lt;&lt;</code>
<code>        /ren //renmatrix</code>
<code>        /pixs pixs</code>
<code>        /pixx pixx</code>
<code>        /pixy pixy</code>
<code>        /height pixy 72 div</code>
<code>        /width pixx 72 div</code>
<code>        /opt options</code>
<code>        &gt;&gt;</code>
<code></code>
<code>        dontdraw not {</code>
<code>            gsave</code>
<code>            //renmatrix exec</code>
<code>            grestore</code>
<code>        } if</code>
<code>    } ifelse</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /upcacomposite dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER upcacomposite--</code>
<code></code>
<code>% --BEGIN ENCODER upcecomposite--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renlinear renmatrix ean5 ean2 upce micropdf417 pdf417 gs1-cc--</code>
<code>% --DESC: UPC-E Composite</code>
<code>% --EXAM: 01234558|(15)021231</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp upcecomposite 0.0 2024010300 105468 112132</code>
<code>%%BeginData:        149 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /upce dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/upcecomposite {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /usematrix false def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs true def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    dontdraw { /usematrix true def } if</code>
<code></code>
<code>    % Split the linear and composite parts</code>
<code>    barcode (|) search {</code>
<code>        /linear exch def</code>
<code>        pop</code>
<code>        /comp exch def</code>
<code>    } {</code>
<code>        pop /bwipp.missingCompositeComponent (A Composite Component must be provided following a pipe character) //raiseerror exec</code>
<code>    } ifelse</code>
<code></code>
<code>    options (lintype) (upce) put</code>
<code>    options (inkspreadv) 0.0 put</code>
<code>    options (dontdraw) true put</code>
<code>    options (dontlint) true put</code>
<code></code>
<code>    % Lint with a fake AI (01)</code>
<code>    comp length 18 add string</code>
<code>    dup 0 ((01)00000000000000) putinterval</code>
<code>    dup 18 comp putinterval</code>
<code>    /ai //gs1process exec pop pop pop</code>
<code></code>
<code>    % Plot the linear part</code>
<code>    linear options //upce exec</code>
<code>    usematrix not {</code>
<code>        gsave</code>
<code></code>
<code>        //renlinear exec</code>
<code></code>
<code>        % Plot the separator</code>
<code>        -1 72 rmoveto &lt;&lt;</code>
<code>            /ren //renmatrix</code>
<code>            /pixs [</code>
<code>                0 1  49 {0} repeat  1 0</code>
<code>                1 0  49 {0} repeat  0 1</code>
<code>                0 1  49 {0} repeat  1 0</code>
<code>            ]</code>
<code>            /pixx 53</code>
<code>            /pixy 3</code>
<code>            /height 6 72 div</code>
<code>            /width 53 72 div</code>
<code>            /opt options</code>
<code>        &gt;&gt; //renmatrix exec</code>
<code></code>
<code>        % Plot the 2D part</code>
<code>        -2 6 rmoveto comp options //gs1-cc exec //renmatrix exec</code>
<code></code>
<code>        grestore</code>
<code>    } {</code>
<code>        /linsym exch def</code>
<code>        /sbs linsym /sbs get def</code>
<code>        /bhs linsym /bhs get def</code>
<code>        /bbs linsym /bbs get def</code>
<code>        /linwidth 0 sbs {cvi add} forall def</code>
<code></code>
<code>        /compsym comp options //gs1-cc exec def</code>
<code>        /ccpixs compsym /pixs get def</code>
<code>        /ccpixx compsym /pixx get def</code>
<code></code>
<code>        /linpad [ ccpixx 53 sub {0} repeat ] def</code>
<code></code>
<code>        /diff linwidth linpad length add 1 add ccpixx sub def  % An add-on can make linear wider than composite</code>
<code>        diff 0 gt {  % Left align composite</code>
<code>            /ccrpad [ diff {0} repeat ] def</code>
<code>            /pixx ccpixx diff add def</code>
<code>        } {</code>
<code>            /ccrpad 0 array def</code>
<code>            /pixx ccpixx def</code>
<code>        } ifelse</code>
<code></code>
<code>        /pixs [</code>
<code>            0 ccpixx ccpixs length 1 sub {</code>
<code>                /i exch def</code>
<code>                ccpixs i ccpixx getinterval aload pop ccrpad aload pop</code>
<code>            } for</code>
<code>            2 { linpad aload pop 0 1  49 {0} repeat  1 0 ccrpad aload pop } repeat</code>
<code>            2 { linpad aload pop 1 0  49 {0} repeat  0 1 ccrpad aload pop } repeat</code>
<code>            2 { linpad aload pop 0 1  49 {0} repeat  1 0 ccrpad aload pop } repeat</code>
<code>            71 -1 0 {</code>
<code>                /y exch def</code>
<code>                linpad aload pop</code>
<code>                0</code>
<code>                0 1 sbs length 1 sub {</code>
<code>                    /i exch def</code>
<code>                    i 2 mod 0 eq {</code>
<code>                        % Don't print when bbs &gt; y || (bbs + bhs) &lt; y (i.e. add-on or includetext offsets)</code>
<code>                        bbs i 2 idiv get 72 mul dup y gt exch bhs i 2 idiv get 72 mul add y lt or {</code>
<code>                            sbs i get cvi {0} repeat</code>
<code>                        } {</code>
<code>                            sbs i get cvi {1} repeat</code>
<code>                        } ifelse</code>
<code>                    } {</code>
<code>                        sbs i get cvi {0} repeat</code>
<code>                    } ifelse</code>
<code>                } for</code>
<code>                diff 0 lt {0} if  % Allow for middle separator overhang on RHS if no add-on</code>
<code>            } for</code>
<code>        ] def</code>
<code></code>
<code>        /pixy pixs length pixx idiv def</code>
<code>        &lt;&lt;</code>
<code>        /ren //renmatrix</code>
<code>        /pixs pixs</code>
<code>        /pixx pixx</code>
<code>        /pixy pixy</code>
<code>        /height pixy 72 div</code>
<code>        /width pixx 72 div</code>
<code>        /opt options</code>
<code>        &gt;&gt;</code>
<code></code>
<code>        dontdraw not {</code>
<code>            gsave</code>
<code>            //renmatrix exec</code>
<code>            grestore</code>
<code>        } if</code>
<code>    } ifelse</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /upcecomposite dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER upcecomposite--</code>
<code></code>
<code>% --BEGIN ENCODER databaromnicomposite--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renlinear renmatrix databaromni micropdf417 pdf417 gs1-cc--</code>
<code>% --DESC: GS1 DataBar Omnidirectional Composite</code>
<code>% --EXAM: (01)09521234543213|(11)990102</code>
<code>% --EXOP:</code>
<code>% --RNDR: renlinear renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp databaromnicomposite 0.0 2024010300 104489 97399</code>
<code>%%BeginData:        146 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /databaromni dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/databaromnicomposite {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /usematrix false def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs true def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    dontdraw { /usematrix true def } if</code>
<code></code>
<code>    % Split the linear and composite parts</code>
<code>    barcode (|) search {</code>
<code>        /linear exch def</code>
<code>        pop</code>
<code>        /comp exch def</code>
<code>    } {</code>
<code>        pop /bwipp.missingCompositeComponent (A Composite Component must be provided following a pipe character) //raiseerror exec</code>
<code>    } ifelse</code>
<code></code>
<code>    usematrix not { gsave } if</code>
<code></code>
<code>    options (lintype) (databaromni) put</code>
<code>    options (linkage) true put</code>
<code>    options (inkspreadv) 0.0 put</code>
<code>    options (dontdraw) true put</code>
<code>    options (dontlint) true put</code>
<code></code>
<code>    % Lint the combined AI element strings</code>
<code>    linear length comp length add string</code>
<code>    dup 0 linear putinterval</code>
<code>    dup linear length comp putinterval</code>
<code>    /ai //gs1process exec pop pop pop</code>
<code></code>
<code>    % Plot the linear part</code>
<code>    linear options //databaromni exec</code>
<code>    dup (sbs) get /linsbs exch def</code>
<code>    dup (bhs) get 0 get 72 mul /linheight exch def</code>
<code>    usematrix not { //renlinear exec } { pop } ifelse</code>
<code></code>
<code>    % Plot the separator</code>
<code>    /sepfinder {</code>
<code>        /fp exch def</code>
<code>        fp 1 fp 12 add {</code>
<code>            /i exch def</code>
<code>            bot i get 0 eq {</code>
<code>                bot i 1 sub get 1 eq {</code>
<code>                    1</code>
<code>                } {</code>
<code>                    sep i 1 sub get 0 eq {1} {0} ifelse</code>
<code>                } ifelse</code>
<code>            } {</code>
<code>                0</code>
<code>            } ifelse</code>
<code>            sep exch i exch put</code>
<code>        } for</code>
<code>        /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def</code>
<code>        true 0 1 12 {dup bot exch fp add get exch f3 exch get eq and} for {</code>
<code>            % Right shifted module for value 3 finder</code>
<code>            sep fp [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval</code>
<code>        } if</code>
<code>    } def</code>
<code>    mark</code>
<code>    0 linsbs {1 index 1 eq {{0}} {{1}} ifelse repeat} forall</code>
<code>    counttomark 1 sub array astore /bot exch def pop pop</code>
<code>    /sep [ bot {1 exch sub} forall ] def</code>
<code>    sep 0 [0 0 0] putinterval</code>
<code>    sep sep length 4 sub [0 0 0 0] putinterval</code>
<code>    18 sepfinder 64 sepfinder</code>
<code>    usematrix not {</code>
<code>        0 linheight rmoveto &lt;&lt;</code>
<code>            /ren //renmatrix</code>
<code>            /pixs sep</code>
<code>            /pixx sep length</code>
<code>            /pixy 1</code>
<code>            /height 1 72 div</code>
<code>            /width sep length 72 div</code>
<code>            /opt options</code>
<code>        &gt;&gt; //renmatrix exec</code>
<code></code>
<code>        % Plot the 2D part</code>
<code>        -5 1 rmoveto comp options //gs1-cc exec //renmatrix exec</code>
<code></code>
<code>        grestore</code>
<code>    } {</code>
<code>        /compsym comp options //gs1-cc exec def</code>
<code>        /ccpixs compsym /pixs get def</code>
<code>        /ccpixx compsym /pixx get def</code>
<code></code>
<code>        /linpixs [ 0  % Begin with left guard space</code>
<code>            linsbs { cvi 1 index 0 eq {{1}} {{0}} ifelse repeat } forall  % Alternates i 1/0's</code>
<code>        ] def</code>
<code>        /sep [ 0 sep aload pop ] def  % Offset by 1</code>
<code></code>
<code>        /linheight linheight cvi def</code>
<code>        % ccpixx is 99 for both 4-col CC-A and 4-col CC-B; linpixs length is 96</code>
<code>        /pixs [</code>
<code>            0 ccpixx ccpixs length 1 sub {  % Right pad composite with 1 space</code>
<code>                /i exch def</code>
<code>                ccpixs i ccpixx getinterval aload pop 0</code>
<code>            } for</code>
<code>            0 0 0 0 sep aload pop linheight { 0 0 0 0 linpixs aload pop } repeat  % Left pad with 4 spaces</code>
<code>        ] def</code>
<code>        /pixx ccpixx 1 add def  % 100</code>
<code></code>
<code>        /pixy pixs length pixx idiv def</code>
<code>        &lt;&lt;</code>
<code>        /ren //renmatrix</code>
<code>        /pixs pixs</code>
<code>        /pixx pixx</code>
<code>        /pixy pixy</code>
<code>        /height pixy 72 div</code>
<code>        /width pixx 72 div</code>
<code>        /opt options</code>
<code>        &gt;&gt;</code>
<code></code>
<code>        dontdraw not {</code>
<code>            gsave</code>
<code>            //renmatrix exec</code>
<code>            grestore</code>
<code>        } if</code>
<code>    } ifelse</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /databaromnicomposite dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER databaromnicomposite--</code>
<code></code>
<code>% --BEGIN ENCODER databarstackedcomposite--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renlinear renmatrix databaromni databarstacked micropdf417 pdf417 gs1-cc--</code>
<code>% --DESC: GS1 DataBar Stacked Composite</code>
<code>% --EXAM: (01)09521234543213|(17)010200</code>
<code>% --EXOP:</code>
<code>% --RNDR: renlinear renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp databarstackedcomposite 0.0 2024010300 102773 105478</code>
<code>%%BeginData:        141 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /databarstacked dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/databarstackedcomposite {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /usematrix false def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs true def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    dontdraw { /usematrix true def } if</code>
<code></code>
<code>    % Split the linear and composite parts</code>
<code>    barcode (|) search {</code>
<code>        /linear exch def</code>
<code>        pop</code>
<code>        /comp exch def</code>
<code>    } {</code>
<code>        pop /bwipp.missingCompositeComponent (A Composite Component must be provided following a pipe character) //raiseerror exec</code>
<code>    } ifelse</code>
<code></code>
<code>    usematrix not { gsave } if</code>
<code></code>
<code>    options (lintype) (databarstacked) put</code>
<code>    options (linkage) true put</code>
<code>    options (inkspreadv) 0.0 put</code>
<code>    options (dontdraw) true put</code>
<code>    options (dontlint) true put</code>
<code></code>
<code>    % Lint the combined AI element strings</code>
<code>    linear length comp length add string</code>
<code>    dup 0 linear putinterval</code>
<code>    dup linear length comp putinterval</code>
<code>    /ai //gs1process exec pop pop pop</code>
<code></code>
<code>    % Plot the linear part</code>
<code>    linear options //databarstacked exec</code>
<code>    dup (pixs) get 0 2 index (pixx) get getinterval /bot exch def</code>
<code>    dup (pixy) get /linheight exch def</code>
<code>    usematrix not { //renmatrix exec } { /pixs get /linpixs exch def } ifelse</code>
<code></code>
<code>    % Plot the separator</code>
<code>    /sepfinder {</code>
<code>        /fp exch def</code>
<code>        fp 1 fp 12 add {</code>
<code>            /i exch def</code>
<code>            bot i get 0 eq {</code>
<code>                bot i 1 sub get 1 eq {</code>
<code>                    1</code>
<code>                } {</code>
<code>                    sep i 1 sub get 0 eq {1} {0} ifelse</code>
<code>                } ifelse</code>
<code>            } {</code>
<code>                0</code>
<code>            } ifelse</code>
<code>            sep exch i exch put</code>
<code>        } for</code>
<code>        /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def</code>
<code>        true 0 1 12 {dup bot exch fp add get exch f3 exch get eq and} for {</code>
<code>            % Right shifted module for value 3 finder</code>
<code>            sep fp [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval</code>
<code>        } if</code>
<code>    } def</code>
<code>    /sep [ bot {1 exch sub} forall ] def</code>
<code>    sep 0 [ 0 0 0 0 ] putinterval</code>
<code>    sep sep length 4 sub [ 0 0 0 0 ] putinterval</code>
<code>    18 sepfinder</code>
<code>    usematrix not {</code>
<code>        0 linheight rmoveto &lt;&lt;</code>
<code>            /ren //renmatrix</code>
<code>            /pixs sep</code>
<code>            /pixx sep length</code>
<code>            /pixy 1</code>
<code>            /height 1 72 div</code>
<code>            /width sep length 72 div</code>
<code>            /opt options</code>
<code>        &gt;&gt; //renmatrix exec</code>
<code></code>
<code>        % Plot the 2D part</code>
<code>        1 1 rmoveto comp options //gs1-cc exec //renmatrix exec</code>
<code></code>
<code>        grestore</code>
<code>    } {</code>
<code>        /compsym comp options //gs1-cc exec def</code>
<code>        /ccpixs compsym /pixs get def</code>
<code>        /ccpixx compsym /pixx get def</code>
<code></code>
<code>        /linwidth sep length def  % 50</code>
<code>        % ccpixx is 55 for both 2-col CC-A and 2-col CC-B</code>
<code>        /pixs [</code>
<code>            0 ccpixx ccpixs length 1 sub {  % Left pad composite with 1 space</code>
<code>                /i exch def</code>
<code>                0 ccpixs i ccpixx getinterval aload pop</code>
<code>            } for</code>
<code>            sep aload pop 0 0 0 0 0 0</code>
<code>            0 linwidth linpixs length 1 sub {  % Right pad linear with 6 spaces</code>
<code>                /i exch def</code>
<code>                linpixs i linwidth getinterval aload pop 0 0 0 0 0 0</code>
<code>            } for</code>
<code>        ] def</code>
<code>        /pixx ccpixx 1 add def  % 56</code>
<code></code>
<code>        /pixy pixs length pixx idiv def</code>
<code>        &lt;&lt;</code>
<code>        /ren //renmatrix</code>
<code>        /pixs pixs</code>
<code>        /pixx pixx</code>
<code>        /pixy pixy</code>
<code>        /height pixy 72 div</code>
<code>        /width pixx 72 div</code>
<code>        /opt options</code>
<code>        &gt;&gt;</code>
<code></code>
<code>        dontdraw not {</code>
<code>            gsave</code>
<code>            //renmatrix exec</code>
<code>            grestore</code>
<code>        } if</code>
<code>    } ifelse</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /databarstackedcomposite dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER databarstackedcomposite--</code>
<code></code>
<code>% --BEGIN ENCODER databarstackedomnicomposite--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renlinear renmatrix databaromni databarstackedomni micropdf417 pdf417 gs1-cc--</code>
<code>% --DESC: GS1 DataBar Stacked Omnidirectional Composite</code>
<code>% --EXAM: (01)03612345678904|(11)990102</code>
<code>% --EXOP:</code>
<code>% --RNDR: renlinear renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp databarstackedomnicomposite 0.0 2024010300 102801 105502</code>
<code>%%BeginData:        141 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /databarstackedomni dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/databarstackedomnicomposite {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /usematrix false def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs true def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    dontdraw { /usematrix true def } if</code>
<code></code>
<code>    % Split the linear and composite parts</code>
<code>    barcode (|) search {</code>
<code>        /linear exch def</code>
<code>        pop</code>
<code>        /comp exch def</code>
<code>    } {</code>
<code>        pop /bwipp.missingCompositeComponent (A Composite Component must be provided following a pipe character) //raiseerror exec</code>
<code>    } ifelse</code>
<code></code>
<code>    usematrix not { gsave } if</code>
<code></code>
<code>    options (lintype) (databarstackedomni) put</code>
<code>    options (linkage) true put</code>
<code>    options (inkspreadv) 0.0 put</code>
<code>    options (dontdraw) true put</code>
<code>    options (dontlint) true put</code>
<code></code>
<code>    % Lint the combined AI element strings</code>
<code>    linear length comp length add string</code>
<code>    dup 0 linear putinterval</code>
<code>    dup linear length comp putinterval</code>
<code>    /ai //gs1process exec pop pop pop</code>
<code></code>
<code>    % Plot the linear part</code>
<code>    linear options //databarstackedomni exec</code>
<code>    dup (pixs) get 0 2 index (pixx) get getinterval /bot exch def</code>
<code>    dup (pixy) get /linheight exch def</code>
<code>    usematrix not { //renmatrix exec } { /pixs get /linpixs exch def } ifelse</code>
<code></code>
<code>    % Plot the separator</code>
<code>    /sepfinder {</code>
<code>        /fp exch def</code>
<code>        fp 1 fp 12 add {</code>
<code>            /i exch def</code>
<code>            bot i get 0 eq {</code>
<code>                bot i 1 sub get 1 eq {</code>
<code>                    1</code>
<code>                } {</code>
<code>                    sep i 1 sub get 0 eq {1} {0} ifelse</code>
<code>                } ifelse</code>
<code>            } {</code>
<code>                0</code>
<code>            } ifelse</code>
<code>            sep exch i exch put</code>
<code>        } for</code>
<code>        /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def</code>
<code>        true 0 1 12 {dup bot exch fp add get exch f3 exch get eq and} for {</code>
<code>            % Right shifted module for value 3 finder</code>
<code>            sep fp [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval</code>
<code>        } if</code>
<code>    } def</code>
<code>    /sep [ bot {1 exch sub} forall ] def</code>
<code>    sep 0 [ 0 0 0 0 ] putinterval</code>
<code>    sep sep length 4 sub [ 0 0 0 0 ] putinterval</code>
<code>    18 sepfinder</code>
<code>    usematrix not {</code>
<code>        0 linheight rmoveto &lt;&lt;</code>
<code>            /ren //renmatrix</code>
<code>            /pixs sep</code>
<code>            /pixx sep length</code>
<code>            /pixy 1</code>
<code>            /height 1 72 div</code>
<code>            /width sep length 72 div</code>
<code>            /opt options</code>
<code>        &gt;&gt; //renmatrix exec</code>
<code></code>
<code>        % Plot the 2D part</code>
<code>        1 1 rmoveto comp options //gs1-cc exec //renmatrix exec</code>
<code></code>
<code>        grestore</code>
<code>    } {</code>
<code>        /compsym comp options //gs1-cc exec def</code>
<code>        /ccpixs compsym /pixs get def</code>
<code>        /ccpixx compsym /pixx get def</code>
<code></code>
<code>        /linwidth sep length def  % 50</code>
<code>        % ccpixx is 55 for both 2-col CC-A and 2-col CC-B</code>
<code>        /pixs [</code>
<code>            0 ccpixx ccpixs length 1 sub {  % Left pad composite with 1 space</code>
<code>                /i exch def</code>
<code>                0 ccpixs i ccpixx getinterval aload pop</code>
<code>            } for</code>
<code>            sep aload pop 0 0 0 0 0 0</code>
<code>            0 linwidth linpixs length 1 sub {  % Right pad linear with 6 spaces</code>
<code>                /i exch def</code>
<code>                linpixs i linwidth getinterval aload pop 0 0 0 0 0 0</code>
<code>            } for</code>
<code>        ] def</code>
<code>        /pixx ccpixx 1 add def  % 56</code>
<code></code>
<code>        /pixy pixs length pixx idiv def</code>
<code>        &lt;&lt;</code>
<code>        /ren //renmatrix</code>
<code>        /pixs pixs</code>
<code>        /pixx pixx</code>
<code>        /pixy pixy</code>
<code>        /height pixy 72 div</code>
<code>        /width pixx 72 div</code>
<code>        /opt options</code>
<code>        &gt;&gt;</code>
<code></code>
<code>        dontdraw not {</code>
<code>            gsave</code>
<code>            //renmatrix exec</code>
<code>            grestore</code>
<code>        } if</code>
<code>    } ifelse</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /databarstackedomnicomposite dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER databarstackedomnicomposite--</code>
<code></code>
<code>% --BEGIN ENCODER databartruncatedcomposite--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renlinear renmatrix databaromni databartruncated micropdf417 pdf417 gs1-cc--</code>
<code>% --DESC: GS1 DataBar Truncated Composite</code>
<code>% --EXAM: (01)09521234543213|(11)990102</code>
<code>% --EXOP:</code>
<code>% --RNDR: renlinear renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp databartruncatedcomposite 0.0 2024010300 104563 107276</code>
<code>%%BeginData:        146 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /databartruncated dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/databartruncatedcomposite {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /usematrix false def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs true def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    dontdraw { /usematrix true def } if</code>
<code></code>
<code>    % Split the linear and composite parts</code>
<code>    barcode (|) search {</code>
<code>        /linear exch def</code>
<code>        pop</code>
<code>        /comp exch def</code>
<code>    } {</code>
<code>        pop /bwipp.missingCompositeComponent (A Composite Component must be provided following a pipe character) //raiseerror exec</code>
<code>    } ifelse</code>
<code></code>
<code>    usematrix not { gsave } if</code>
<code></code>
<code>    options (lintype) (databartruncated) put</code>
<code>    options (linkage) true put</code>
<code>    options (inkspreadv) 0.0 put</code>
<code>    options (dontdraw) true put</code>
<code>    options (dontlint) true put</code>
<code></code>
<code>    % Lint the combined AI element strings</code>
<code>    linear length comp length add string</code>
<code>    dup 0 linear putinterval</code>
<code>    dup linear length comp putinterval</code>
<code>    /ai //gs1process exec pop pop pop</code>
<code></code>
<code>    % Plot the linear part</code>
<code>    linear options //databartruncated exec</code>
<code>    dup (sbs) get /linsbs exch def</code>
<code>    dup (bhs) get 0 get 72 mul /linheight exch def</code>
<code>    usematrix not { //renlinear exec } { pop } ifelse</code>
<code></code>
<code>    % Plot the separator</code>
<code>    /sepfinder {</code>
<code>        /fp exch def</code>
<code>        fp 1 fp 12 add {</code>
<code>            /i exch def</code>
<code>            bot i get 0 eq {</code>
<code>                bot i 1 sub get 1 eq {</code>
<code>                    1</code>
<code>                } {</code>
<code>                    sep i 1 sub get 0 eq {1} {0} ifelse</code>
<code>                } ifelse</code>
<code>            } {</code>
<code>                0</code>
<code>            } ifelse</code>
<code>            sep exch i exch put</code>
<code>        } for</code>
<code>        /f3 [1 1 1 1 1 1 1 1 1 0 1 1 1] def</code>
<code>        true 0 1 12 {dup bot exch fp add get exch f3 exch get eq and} for {</code>
<code>            % Right shifted module for value 3 finder</code>
<code>            sep fp [ 0 0 0 0 0 0 0 0 0 0 1 0 0 ] putinterval</code>
<code>        } if</code>
<code>    } def</code>
<code>    mark</code>
<code>    0 linsbs {1 index 1 eq {{0}} {{1}} ifelse repeat} forall</code>
<code>    counttomark 1 sub array astore /bot exch def pop pop</code>
<code>    /sep [ bot {1 exch sub} forall ] def</code>
<code>    sep 0 [0 0 0] putinterval</code>
<code>    sep sep length 4 sub [0 0 0 0] putinterval</code>
<code>    18 sepfinder 64 sepfinder</code>
<code>    usematrix not {</code>
<code>        0 linheight rmoveto &lt;&lt;</code>
<code>            /ren //renmatrix</code>
<code>            /pixs sep</code>
<code>            /pixx sep length</code>
<code>            /pixy 1</code>
<code>            /height 1 72 div</code>
<code>            /width sep length 72 div</code>
<code>            /opt options</code>
<code>        &gt;&gt; //renmatrix exec</code>
<code></code>
<code>        % Plot the 2D part</code>
<code>        -5 1 rmoveto comp options //gs1-cc exec //renmatrix exec</code>
<code></code>
<code>        grestore</code>
<code>    } {</code>
<code>        /compsym comp options //gs1-cc exec def</code>
<code>        /ccpixs compsym /pixs get def</code>
<code>        /ccpixx compsym /pixx get def</code>
<code></code>
<code>        /linpixs [ 0  % Begin with left guard space</code>
<code>            linsbs { cvi 1 index 0 eq {{1}} {{0}} ifelse repeat } forall  % Alternates i 1/0's</code>
<code>        ] def</code>
<code>        /sep [ 0 sep aload pop ] def  % Offset by 1</code>
<code></code>
<code>        /linheight linheight cvi def</code>
<code>        % ccpixx is 99 for both 4-col CC-A and 4-col CC-B; linpixs length is 96</code>
<code>        /pixs [</code>
<code>            0 ccpixx ccpixs length 1 sub {  % Right pad composite with 1 space</code>
<code>                /i exch def</code>
<code>                ccpixs i ccpixx getinterval aload pop 0</code>
<code>            } for</code>
<code>            0 0 0 0 sep aload pop linheight { 0 0 0 0 linpixs aload pop } repeat  % Left pad with 4 spaces</code>
<code>        ] def</code>
<code>        /pixx ccpixx 1 add def  % 100</code>
<code></code>
<code>        /pixy pixs length pixx idiv def</code>
<code>        &lt;&lt;</code>
<code>        /ren //renmatrix</code>
<code>        /pixs pixs</code>
<code>        /pixx pixx</code>
<code>        /pixy pixy</code>
<code>        /height pixy 72 div</code>
<code>        /width pixx 72 div</code>
<code>        /opt options</code>
<code>        &gt;&gt;</code>
<code></code>
<code>        dontdraw not {</code>
<code>            gsave</code>
<code>            //renmatrix exec</code>
<code>            grestore</code>
<code>        } if</code>
<code>    } ifelse</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /databartruncatedcomposite dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER databartruncatedcomposite--</code>
<code></code>
<code>% --BEGIN ENCODER databarlimitedcomposite--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renlinear renmatrix databarlimited micropdf417 pdf417 gs1-cc--</code>
<code>% --DESC: GS1 DataBar Limited Composite</code>
<code>% --EXAM: (01)09521234543213|(21)abcdefghijklmnopqrst</code>
<code>% --EXOP:</code>
<code>% --RNDR: renlinear renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp databarlimitedcomposite 0.0 2024010300 95882 102533</code>
<code>%%BeginData:        137 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /databarlimited dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/databarlimitedcomposite {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /usematrix false def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs true def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    dontdraw { /usematrix true def } if</code>
<code></code>
<code>    % Split the linear and composite parts</code>
<code>    barcode (|) search {</code>
<code>        /linear exch def</code>
<code>        pop</code>
<code>        /comp exch def</code>
<code>    } {</code>
<code>        pop /bwipp.missingCompositeComponent (A Composite Component must be provided following a pipe character) //raiseerror exec</code>
<code>    } ifelse</code>
<code></code>
<code>    usematrix not { gsave } if</code>
<code></code>
<code>    options (lintype) (databarlimited) put</code>
<code>    options (linkage) true put</code>
<code>    options (inkspreadv) 0.0 put</code>
<code>    options (dontdraw) true put</code>
<code>    options (dontlint) true put</code>
<code></code>
<code>    % Lint the combined AI element strings</code>
<code>    linear length comp length add string</code>
<code>    dup 0 linear putinterval</code>
<code>    dup linear length comp putinterval</code>
<code>    /ai //gs1process exec pop pop pop</code>
<code></code>
<code>    % Plot the linear part</code>
<code>    linear options //databarlimited exec</code>
<code>    dup (sbs) get /linsbs exch def</code>
<code>    dup (bhs) get 0 get 72 mul /linheight exch def</code>
<code>    usematrix not { //renlinear exec } { pop } ifelse</code>
<code></code>
<code>    % Plot the separator</code>
<code>    mark</code>
<code>    1 linsbs {1 index 0 eq {{1}} {{0}} ifelse repeat} forall</code>
<code>    counttomark 1 sub array astore /sep exch def pop pop</code>
<code>    sep 0 [0 0 0] putinterval</code>
<code>    sep sep length 9 sub [0 0 0 0 0 0 0 0 0] putinterval % 4 + 5 right guard spaces</code>
<code></code>
<code>    usematrix not {</code>
<code>        0 linheight rmoveto &lt;&lt;</code>
<code>            /ren //renmatrix</code>
<code>            /pixs sep</code>
<code>            /pixx sep length</code>
<code>            /pixy 1</code>
<code>            /height 1 72 div</code>
<code>            /width sep length 72 div</code>
<code>            /opt options</code>
<code>        &gt;&gt; //renmatrix exec</code>
<code></code>
<code>        % Plot the 2D part</code>
<code>        comp options //gs1-cc exec</code>
<code>        dup (pixx) get 72 exch sub 1 rmoveto</code>
<code>        //renmatrix exec</code>
<code></code>
<code>        grestore</code>
<code>    } {</code>
<code>        /compsym comp options //gs1-cc exec def</code>
<code>        /ccpixs compsym /pixs get def</code>
<code>        /ccpixx compsym /pixx get def</code>
<code></code>
<code>        /linpixs [ 0  % Begin with left guard space</code>
<code>            linsbs { cvi 1 index 0 eq {{1}} {{0}} ifelse repeat } forall  % Alternates i 1/0's</code>
<code>        ] def</code>
<code>        /sep [ 0 sep aload pop ] def  % Offset by 1</code>
<code></code>
<code>        /linheight linheight cvi def</code>
<code>        % ccpixx is 72 for CC-A and 82 for CC-B; linpixs length is 79</code>
<code>        ccpixx 72 eq {  % 3-col CC-A</code>
<code>            /pixs [</code>
<code>                0 ccpixx ccpixs length 1 sub {  % Left pad composite with 1 space &amp; right pad with 1 space + 5 right guard spaces</code>
<code>                    /i exch def</code>
<code>                    0 ccpixs i ccpixx getinterval aload pop 0 0 0 0 0 0</code>
<code>                } for</code>
<code>                sep aload pop linheight { linpixs aload pop } repeat</code>
<code>            ] def</code>
<code>            /pixx linpixs length def  % 79</code>
<code>        } {  % 3-col CC-B</code>
<code>            /pixs [</code>
<code>                0 ccpixx ccpixs length 1 sub {  % Right pad composite with 1 space + 5 right guard spaces</code>
<code>                    /i exch def</code>
<code>                    ccpixs i ccpixx getinterval aload pop 0 0 0 0 0 0</code>
<code>                } for</code>
<code>                0 0 0 0 0 0 0 0 0 sep aload pop linheight { 0 0 0 0 0 0 0 0 0 linpixs aload pop } repeat  % Left pad with 9 spaces</code>
<code>            ] def</code>
<code>            /pixx ccpixx 6 add def  % 88</code>
<code>        } ifelse</code>
<code></code>
<code>        /pixy pixs length pixx idiv def</code>
<code>        &lt;&lt;</code>
<code>        /ren //renmatrix</code>
<code>        /pixs pixs</code>
<code>        /pixx pixx</code>
<code>        /pixy pixy</code>
<code>        /height pixy 72 div</code>
<code>        /width pixx 72 div</code>
<code>        /opt options</code>
<code>        &gt;&gt;</code>
<code></code>
<code>        dontdraw not {</code>
<code>            gsave</code>
<code>            //renmatrix exec</code>
<code>            grestore</code>
<code>        } if</code>
<code>    } ifelse</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /databarlimitedcomposite dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER databarlimitedcomposite--</code>
<code></code>
<code>% --BEGIN ENCODER databarexpandedcomposite--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renlinear renmatrix databarexpanded micropdf417 pdf417 gs1-cc--</code>
<code>% --DESC: GS1 DataBar Expanded Composite</code>
<code>% --EXAM: (01)09521234543213(3103)001234|(91)1A2B3C4D5E</code>
<code>% --EXOP:</code>
<code>% --RNDR: renlinear renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp databarexpandedcomposite 0.0 2024010300 104906 101207</code>
<code>%%BeginData:        146 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /databarexpanded dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/databarexpandedcomposite {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /usematrix false def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs true def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    dontdraw { /usematrix true def } if</code>
<code></code>
<code>    % Split the linear and composite parts</code>
<code>    barcode (|) search {</code>
<code>        /linear exch def</code>
<code>        pop</code>
<code>        /comp exch def</code>
<code>    } {</code>
<code>        pop /bwipp.missingCompositeComponent (A Composite Component must be provided following a pipe character) //raiseerror exec</code>
<code>    } ifelse</code>
<code></code>
<code>    usematrix not { gsave } if</code>
<code></code>
<code>    options (lintype) (databarexpanded) put</code>
<code>    options (linkage) true put</code>
<code>    options (inkspreadv) 0.0 put</code>
<code>    options (dontdraw) true put</code>
<code>    options (dontlint) true put</code>
<code></code>
<code>    % Lint the combined AI element strings</code>
<code>    linear length comp length add string</code>
<code>    dup 0 linear putinterval</code>
<code>    dup linear length comp putinterval</code>
<code>    /ai //gs1process exec pop pop pop</code>
<code></code>
<code>    % Plot the linear part</code>
<code>    linear options //databarexpanded exec</code>
<code>    dup (sbs) get /linsbs exch def</code>
<code>    dup (bhs) get 0 get 72 mul /linheight exch def</code>
<code>    usematrix not { //renlinear exec } { pop } ifelse</code>
<code></code>
<code>    % Plot the separator</code>
<code>    /sepfinder {</code>
<code>        /fp exch def</code>
<code>        fp 1 fp 12 add {</code>
<code>            /i exch def</code>
<code>            bot i get 0 eq {</code>
<code>                bot i 1 sub get 1 eq {</code>
<code>                    1</code>
<code>                } {</code>
<code>                    sep i 1 sub get 0 eq {1} {0} ifelse</code>
<code>                } ifelse</code>
<code>            } {</code>
<code>                0</code>
<code>            } ifelse</code>
<code>            sep exch i exch put</code>
<code>        } for</code>
<code>    } def</code>
<code>    mark</code>
<code>    0 linsbs {1 index 1 eq {{0}} {{1}} ifelse repeat} forall</code>
<code>    counttomark 1 sub array astore /bot exch def pop pop</code>
<code>    /sep [ bot {1 exch sub} forall ] def</code>
<code>    sep 0 [0 0 0] putinterval</code>
<code>    sep sep length 4 sub [0 0 0 0] putinterval</code>
<code>    [  % Finder pattern module positions</code>
<code>        18 98 bot length 13 sub {} for</code>
<code>        69 98 bot length 13 sub {} for</code>
<code>    ] {sepfinder} forall</code>
<code></code>
<code>    usematrix not {</code>
<code>        0 linheight rmoveto &lt;&lt;</code>
<code>            /ren //renmatrix</code>
<code>            /pixs sep</code>
<code>            /pixx sep length</code>
<code>            /pixy 1</code>
<code>            /height 1 72 div</code>
<code>            /width sep length 72 div</code>
<code>            /opt options</code>
<code>        &gt;&gt; //renmatrix exec</code>
<code></code>
<code>        % Plot the 2D part</code>
<code>        1 1 rmoveto comp options //gs1-cc exec //renmatrix exec</code>
<code></code>
<code>        grestore</code>
<code>    } {</code>
<code>        /compsym comp options //gs1-cc exec def</code>
<code>        /ccpixs compsym /pixs get def</code>
<code>        /ccpixx compsym /pixx get def</code>
<code></code>
<code>        /linpixs [ 0  % Begin with left guard space</code>
<code>            linsbs { cvi 1 index 0 eq {{1}} {{0}} ifelse repeat } forall  % Alternates i 1/0's</code>
<code>        ] def</code>
<code>        /sep [ 0 sep aload pop ] def  % Offset by 1</code>
<code></code>
<code>        /linheight linheight cvi def</code>
<code>        /diff linpixs length ccpixx sub def  % Minimum linpixs length is 102, ccpixx is 99</code>
<code>        /ccrpad [ diff 2 sub {0} repeat ] def</code>
<code>        /pixs [</code>
<code>            0 ccpixx ccpixs length 1 sub {</code>
<code>                /i exch def</code>
<code>                0 0 ccpixs i ccpixx getinterval aload pop ccrpad aload pop</code>
<code>            } for</code>
<code>            sep aload pop linheight { linpixs aload pop } repeat</code>
<code>        ] def</code>
<code></code>
<code>        /pixx linpixs length def</code>
<code>        /pixy pixs length pixx idiv def</code>
<code>        &lt;&lt;</code>
<code>        /ren //renmatrix</code>
<code>        /pixs pixs</code>
<code>        /pixx pixx</code>
<code>        /pixy pixy</code>
<code>        /height pixy 72 div</code>
<code>        /width pixx 72 div</code>
<code>        /opt options</code>
<code>        &gt;&gt;</code>
<code></code>
<code>        dontdraw not {</code>
<code>            gsave</code>
<code>            //renmatrix exec</code>
<code>            grestore</code>
<code>        } if</code>
<code>    } ifelse</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /databarexpandedcomposite dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER databarexpandedcomposite--</code>
<code></code>
<code>% --BEGIN ENCODER databarexpandedstackedcomposite--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renlinear renmatrix databarexpanded databarexpandedstacked micropdf417 pdf417 gs1-cc--</code>
<code>% --DESC: GS1 DataBar Expanded Stacked Composite</code>
<code>% --EXAM: (01)09521234543213(10)ABCDEF|(21)12345678</code>
<code>% --EXOP: segments=4</code>
<code>% --RNDR: renmatrix renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp databarexpandedstackedcomposite 0.0 2024010300 103484 102606</code>
<code>%%BeginData:        136 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /databarexpandedstacked dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/databarexpandedstackedcomposite {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /usematrix false def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs true def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    dontdraw { /usematrix true def } if</code>
<code></code>
<code>    % Split the linear and composite parts</code>
<code>    barcode (|) search {</code>
<code>        /linear exch def</code>
<code>        pop</code>
<code>        /comp exch def</code>
<code>    } {</code>
<code>        pop /bwipp.missingCompositeComponent (A Composite Component must be provided following a pipe character) //raiseerror exec</code>
<code>    } ifelse</code>
<code></code>
<code>    usematrix not { gsave } if</code>
<code></code>
<code>    options (lintype) (databarexpandedstacked) put</code>
<code>    options (linkage) true put</code>
<code>    options (inkspreadv) 0.0 put</code>
<code>    options (dontdraw) true put</code>
<code>    options (dontlint) true put</code>
<code></code>
<code>    % Lint the combined AI element strings</code>
<code>    linear length comp length add string</code>
<code>    dup 0 linear putinterval</code>
<code>    dup linear length comp putinterval</code>
<code>    /ai //gs1process exec pop pop pop</code>
<code></code>
<code>    % Plot the linear part</code>
<code>    linear options //databarexpandedstacked exec</code>
<code>    dup (pixs) get 0 2 index (pixx) get getinterval /bot exch def</code>
<code>    dup (pixy) get /linheight exch def</code>
<code>    usematrix not { //renmatrix exec } { /pixs get /linpixs exch def } ifelse</code>
<code></code>
<code>    % Plot the separator</code>
<code>    /sepfinder {</code>
<code>        /fp exch def</code>
<code>        fp 1 fp 12 add {</code>
<code>            /i exch def</code>
<code>            bot i get 0 eq {</code>
<code>                bot i 1 sub get 1 eq {</code>
<code>                    1</code>
<code>                } {</code>
<code>                    sep i 1 sub get 0 eq {1} {0} ifelse</code>
<code>                } ifelse</code>
<code>            } {</code>
<code>                0</code>
<code>            } ifelse</code>
<code>            sep exch i exch put</code>
<code>        } for</code>
<code>    } def</code>
<code>    /sep [ bot {1 exch sub} forall ] def</code>
<code>    sep 0 [ 0 0 0 0 ] putinterval</code>
<code>    sep sep length 4 sub [ 0 0 0 0 ] putinterval</code>
<code>    [  % Finder pattern module positions</code>
<code>        19 98 bot length 13 sub {} for</code>
<code>        70 98 bot length 13 sub {} for</code>
<code>    ] {sepfinder} forall</code>
<code>    usematrix not {</code>
<code>        0 linheight rmoveto &lt;&lt;</code>
<code>            /ren //renmatrix</code>
<code>            /pixs sep</code>
<code>            /pixx sep length</code>
<code>            /pixy 1</code>
<code>            /height 1 72 div</code>
<code>            /width sep length 72 div</code>
<code>            /opt options</code>
<code>        &gt;&gt; //renmatrix exec</code>
<code></code>
<code>        % Plot the 2D part</code>
<code>        bot 0 get 0 eq {2} {0} ifelse 1 rmoveto</code>
<code>        comp options //gs1-cc exec //renmatrix exec</code>
<code></code>
<code>        grestore</code>
<code>    } {</code>
<code>        /compsym comp options //gs1-cc exec def</code>
<code>        /ccpixs compsym /pixs get def</code>
<code>        /ccpixx compsym /pixx get def</code>
<code></code>
<code>        /pixx sep length def</code>
<code>        /cclpad [ pixx ccpixx sub 1 add 2 idiv {0} repeat ] def  % Add 1 to allow for odd difference</code>
<code>        /ccrpad [ pixx ccpixx sub 2 idiv {0} repeat ] def</code>
<code>        /pixs [</code>
<code>            0 ccpixx ccpixs length 1 sub {  % Centre align composite</code>
<code>                /i exch def</code>
<code>                cclpad aload pop ccpixs i ccpixx getinterval aload pop ccrpad aload pop</code>
<code>            } for</code>
<code>            sep aload pop linpixs aload pop</code>
<code>        ] def</code>
<code></code>
<code>        /pixy pixs length pixx idiv def</code>
<code>        &lt;&lt;</code>
<code>        /ren //renmatrix</code>
<code>        /pixs pixs</code>
<code>        /pixx pixx</code>
<code>        /pixy pixy</code>
<code>        /height pixy 72 div</code>
<code>        /width pixx 72 div</code>
<code>        /opt options</code>
<code>        &gt;&gt;</code>
<code></code>
<code>        dontdraw not {</code>
<code>            gsave</code>
<code>            //renmatrix exec</code>
<code>            grestore</code>
<code>        } if</code>
<code>    } ifelse</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /databarexpandedstackedcomposite dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER databarexpandedstackedcomposite--</code>
<code></code>
<code>% --BEGIN ENCODER gs1-128composite--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renlinear renmatrix code128 gs1-128 micropdf417 pdf417 gs1-cc--</code>
<code>% --DESC: GS1-128 Composite</code>
<code>% --EXAM: (00)095287654321012346|(02)09521234543213(37)24(10)1234567ABCDEFG</code>
<code>% --EXOP: ccversion=c</code>
<code>% --RNDR: renlinear renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp gs1-128composite 0.0 2024010300 108422 111074</code>
<code>%%BeginData:        162 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1-128 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1-cc dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/gs1-128composite {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /usematrix false def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs true def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    dontdraw { /usematrix true def } if</code>
<code></code>
<code>    % Split the linear and composite parts</code>
<code>    barcode (|) search {</code>
<code>        /linear exch def</code>
<code>        pop</code>
<code>        /comp exch def</code>
<code>    } {</code>
<code>        pop /bwipp.missingCompositeComponent (A Composite Component must be provided following a pipe character) //raiseerror exec</code>
<code>    } ifelse</code>
<code></code>
<code>    usematrix not { gsave } if</code>
<code></code>
<code>    options (inkspreadv) 0.0 put</code>
<code>    options (dontdraw) true put</code>
<code>    options (dontlint) true put</code>
<code></code>
<code>    % Lint the combined AI element strings</code>
<code>    linear length comp length add string</code>
<code>    dup 0 linear putinterval</code>
<code>    dup linear length comp putinterval</code>
<code>    /ai //gs1process exec pop pop pop</code>
<code></code>
<code>    % Dummy plot of linear part with CC-A to get width</code>
<code>    options (linkagea) true put</code>
<code>    linear &lt;&lt; options {} forall &gt;&gt; //gs1-128 exec</code>
<code>    (sbs) get 0 exch {add} forall /linwidth exch def</code>
<code></code>
<code>    % Create 2D part and determine type</code>
<code>    options (lintype) (gs1-128) put</code>
<code>    options (linwidth) linwidth put</code>
<code>    comp &lt;&lt; options {} forall &gt;&gt; //gs1-cc exec /compsym exch def</code>
<code>    compsym (pixx) get 99 eq {(a)} {(c)} ifelse /linktype exch def</code>
<code></code>
<code>    % Plot linear part</code>
<code>    linktype (a) eq {</code>
<code>        options (linkagea) true put</code>
<code>        options (linkagec) false put</code>
<code>    } {</code>
<code>        options (linkagea) false put</code>
<code>        options (linkagec) true put</code>
<code>    } ifelse</code>
<code>    linear &lt;&lt; options {} forall &gt;&gt; //gs1-128 exec</code>
<code>    dup (sbs) get /linsbs exch def</code>
<code>    dup (bhs) get 0 get 72 mul /linheight exch def</code>
<code>    usematrix not { //renlinear exec } { pop } ifelse</code>
<code></code>
<code>    % Plot the separator</code>
<code>    mark</code>
<code>    1 linsbs {1 index 0 eq {{1}} {{0}} ifelse repeat} forall</code>
<code>    counttomark 1 sub array astore /sep exch def pop pop</code>
<code>    usematrix not {</code>
<code>        0 linheight rmoveto &lt;&lt;</code>
<code>            /ren //renmatrix</code>
<code>            /pixs sep</code>
<code>            /pixx sep length</code>
<code>            /pixy 1</code>
<code>            /height 1 72 div</code>
<code>            /width sep length 72 div</code>
<code>            /opt options</code>
<code>        &gt;&gt; //renmatrix exec</code>
<code>    } if</code>
<code></code>
<code>    % Plot the 2D part</code>
<code>    linktype (a) eq {</code>
<code>        /s linwidth 2 sub 11 idiv def</code>
<code>        /p s 9 sub 2 idiv def</code>
<code>        /x s p sub 1 sub 11 mul 10 add p 0 eq {2 add} if 99 sub def</code>
<code>    } {</code>
<code>        /x -7 def</code>
<code>    } ifelse</code>
<code></code>
<code>    usematrix not {</code>
<code>        x 1 rmoveto compsym //renmatrix exec</code>
<code></code>
<code>        grestore</code>
<code>    } {</code>
<code>        /ccpixs compsym /pixs get def</code>
<code>        /ccpixx compsym /pixx get def</code>
<code></code>
<code>        /linpixs [</code>
<code>            linsbs { 1 index 1 eq {{0}} {{1}} ifelse repeat } forall  % Alternates i 1/0's (linsbs always begins with "2")</code>
<code>        ] def</code>
<code></code>
<code>        x 0 gt {  % Left pad composite</code>
<code>            /cclpad [ x {0} repeat ] def</code>
<code>            /linlpad 0 array def</code>
<code>        } {  % Left pad linear</code>
<code>            /cclpad 0 array def</code>
<code>            /linlpad [ x neg {0} repeat ] def</code>
<code>        } ifelse</code>
<code></code>
<code>        /diff linwidth ccpixx x add sub def</code>
<code>        diff 0 gt {  % Right pad composite</code>
<code>            /ccrpad [ diff {0} repeat ] def</code>
<code>            /linrpad 0 array def</code>
<code>        } {  % Right pad linear</code>
<code>            /ccrpad 0 array def</code>
<code>            /linrpad [ diff neg {0} repeat ] def</code>
<code>        } ifelse</code>
<code></code>
<code>        /linheight linheight cvi def</code>
<code>        /pixs [</code>
<code>            0 ccpixx ccpixs length 1 sub {</code>
<code>                /i exch def</code>
<code>                cclpad aload pop ccpixs i ccpixx getinterval aload pop ccrpad aload pop</code>
<code>            } for</code>
<code>            linlpad aload pop sep aload pop linrpad aload pop</code>
<code>            linheight { linlpad aload pop linpixs aload pop linrpad aload pop } repeat</code>
<code>        ] def</code>
<code></code>
<code>        /pixx cclpad length ccpixx add ccrpad length add def</code>
<code>        /pixy pixs length pixx idiv def</code>
<code>        &lt;&lt;</code>
<code>        /ren //renmatrix</code>
<code>        /pixs pixs</code>
<code>        /pixx pixx</code>
<code>        /pixy pixy</code>
<code>        /height pixy 72 div</code>
<code>        /width pixx 72 div</code>
<code>        /opt options</code>
<code>        &gt;&gt;</code>
<code></code>
<code>        dontdraw not {</code>
<code>            gsave</code>
<code>            //renmatrix exec</code>
<code>            grestore</code>
<code>        } if</code>
<code>    } ifelse</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /gs1-128composite dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER gs1-128composite--</code>
<code></code>
<code>% --BEGIN ENCODER gs1datamatrix--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renmatrix datamatrix--</code>
<code>% --DESC: GS1 Data Matrix</code>
<code>% --EXAM: (01)09521234543213(17)120508(10)ABCD1234(410)9501101020917</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp gs1datamatrix 0.0 2024010300 78328 77910</code>
<code>%%BeginData:         81 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /datamatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/gs1datamatrix {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs true def</code>
<code>    /gssep false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode /ai //gs1process exec</code>
<code>    /fncs exch def</code>
<code>    /vals exch def</code>
<code>    /ais exch def</code>
<code></code>
<code>    % Create the datamatrix data</code>
<code>    /fnc1 -1 def</code>
<code>    /dmtx [ fnc1 ] def</code>
<code>    0 1 ais length 1 sub {</code>
<code>        /i exch def</code>
<code>        /ai ais i get def</code>
<code>        /val vals i get def</code>
<code>        dmtx length ai length add val length add array</code>
<code>        dup 0 dmtx putinterval</code>
<code>        dup dmtx length ai [ exch {} forall ] putinterval</code>
<code>        dup dmtx length ai length add val [ exch {} forall ] putinterval</code>
<code>        /dmtx exch def</code>
<code>        i ais length 1 sub ne fncs i get and {  % Append FNC1</code>
<code>            dmtx length 1 add array</code>
<code>            dup 0 dmtx putinterval</code>
<code>            dup dmtx length gssep {29} {fnc1} ifelse put</code>
<code>            /dmtx exch def</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    % Compose input to datamatrix</code>
<code>    /barcode dmtx length 1 add 5 mul string def</code>
<code>    /i 0 def /j 0 def {</code>
<code>        i dmtx length eq {exit} if</code>
<code>        dmtx i get dup fnc1 eq {</code>
<code>            pop barcode j (^FNC1) putinterval</code>
<code>            /j j 4 add def</code>
<code>        } {</code>
<code>            barcode exch j exch put</code>
<code>        } ifelse</code>
<code>        /i i 1 add def</code>
<code>        /j j 1 add def</code>
<code>    } loop</code>
<code>    /barcode barcode 0 j getinterval def</code>
<code></code>
<code>    % Get the result of encoding with datamatrix</code>
<code>    options (parse) undef</code>
<code>    options (dontdraw) true put</code>
<code>    options (parsefnc) true put</code>
<code>    /args barcode options //datamatrix exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /gs1datamatrix dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER gs1datamatrix--</code>
<code></code>
<code>% --BEGIN ENCODER gs1datamatrixrectangular--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renmatrix datamatrix--</code>
<code>% --DESC: GS1 Data Matrix Rectangular</code>
<code>% --EXAM: (01)09521234543213(17)120508(10)ABCD1234(410)9501101020917</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp gs1datamatrixrectangular 0.0 2024010300 78547 78118</code>
<code>%%BeginData:         82 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /datamatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/gs1datamatrixrectangular {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs true def</code>
<code>    /dontdraw false def</code>
<code>    /gssep false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode /ai //gs1process exec</code>
<code>    /fncs exch def</code>
<code>    /vals exch def</code>
<code>    /ais exch def</code>
<code></code>
<code>    % Create the datamatrix data</code>
<code>    /fnc1 -1 def</code>
<code>    /dmtx [ fnc1 ] def</code>
<code>    0 1 ais length 1 sub {</code>
<code>        /i exch def</code>
<code>        /ai ais i get def</code>
<code>        /val vals i get def</code>
<code>        dmtx length ai length add val length add array</code>
<code>        dup 0 dmtx putinterval</code>
<code>        dup dmtx length ai [ exch {} forall ] putinterval</code>
<code>        dup dmtx length ai length add val [ exch {} forall ] putinterval</code>
<code>        /dmtx exch def</code>
<code>        i ais length 1 sub ne fncs i get and {  % Append FNC1</code>
<code>            dmtx length 1 add array</code>
<code>            dup 0 dmtx putinterval</code>
<code>            dup dmtx length gssep {29} {fnc1} ifelse put</code>
<code>            /dmtx exch def</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    % Compose input to datamatrix</code>
<code>    /barcode dmtx length 1 add 5 mul string def</code>
<code>    /i 0 def /j 0 def {</code>
<code>        i dmtx length eq {exit} if</code>
<code>        dmtx i get dup fnc1 eq {</code>
<code>            pop barcode j (^FNC1) putinterval</code>
<code>            /j j 4 add def</code>
<code>        } {</code>
<code>            barcode exch j exch put</code>
<code>        } ifelse</code>
<code>        /i i 1 add def</code>
<code>        /j j 1 add def</code>
<code>    } loop</code>
<code>    /barcode barcode 0 j getinterval def</code>
<code></code>
<code>    % Get the result of encoding with datamatrix</code>
<code>    options (parse) undef</code>
<code>    options (dontdraw) true put</code>
<code>    options (parsefnc) true put</code>
<code>    options (format) (rectangle) put</code>
<code>    /args barcode options //datamatrix exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /gs1datamatrixrectangular dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER gs1datamatrixrectangular--</code>
<code></code>
<code>% --BEGIN ENCODER gs1dldatamatrix--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renmatrix datamatrix--</code>
<code>% --DESC: GS1 Digital Link Data Matrix</code>
<code>% --EXAM: https://id.gs1.org/01/09521234543213/22/ABC%2d123?99=XYZ%2f987</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp gs1dldatamatrix 0.0 2024010300 71212 67479</code>
<code>%%BeginData:         49 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /datamatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/gs1dldatamatrix {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs true def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Parse the input</code>
<code>    /fncvals &lt;&lt;</code>
<code>        /parse parse</code>
<code>        /parseonly true</code>
<code>        /parsefnc false</code>
<code>    &gt;&gt; def</code>
<code>    /barcode barcode fncvals //parseinput exec def</code>
<code></code>
<code>    barcode /dl //gs1process exec pop pop pop</code>
<code></code>
<code>    % Get the result of encoding with datamatrix</code>
<code>    options (parse) undef</code>
<code>    options (dontdraw) true put</code>
<code>    /args barcode options //datamatrix exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /gs1dldatamatrix dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER gs1dldatamatrix--</code>
<code></code>
<code>% --BEGIN ENCODER gs1qrcode--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renmatrix qrcode--</code>
<code>% --DESC: GS1 QR Code</code>
<code>% --EXAM: (01)09521234543213(8200)http://www.abc.net(10)ABCD1234(410)9501101020917</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp gs1qrcode 0.0 2024010300 78062 77650</code>
<code>%%BeginData:         79 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /qrcode dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/gs1qrcode {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs true def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode /ai //gs1process exec</code>
<code>    /fncs exch def</code>
<code>    /vals exch def</code>
<code>    /ais exch def</code>
<code></code>
<code>    % Create the qrcode data</code>
<code>    /fnc1 -1 def</code>
<code>    /qrc [ fnc1 ] def</code>
<code>    0 1 ais length 1 sub {</code>
<code>        /i exch def</code>
<code>        /ai ais i get def</code>
<code>        /val vals i get def</code>
<code>        qrc length ai length add val length add array</code>
<code>        dup 0 qrc putinterval</code>
<code>        dup qrc length ai [ exch {} forall ] putinterval</code>
<code>        dup qrc length ai length add val [ exch {} forall ] putinterval</code>
<code>        /qrc exch def</code>
<code>        i ais length 1 sub ne fncs i get and {  % Append FNC1</code>
<code>            qrc length 1 add array</code>
<code>            dup 0 qrc putinterval</code>
<code>            dup qrc length fnc1 put</code>
<code>            /qrc exch def</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    % Compose input to qrcode</code>
<code>    /barcode qrc length 1 add 5 mul string def</code>
<code>    /i 0 def /j 0 def {</code>
<code>        i qrc length eq {exit} if</code>
<code>        qrc i get dup fnc1 eq {</code>
<code>            pop barcode j (^FNC1) putinterval</code>
<code>            /j j 4 add def</code>
<code>        } {</code>
<code>            barcode exch j exch put</code>
<code>        } ifelse</code>
<code>        /i i 1 add def</code>
<code>        /j j 1 add def</code>
<code>    } loop</code>
<code>    /barcode barcode 0 j getinterval def</code>
<code></code>
<code>    % Get the result of encoding with qrcode</code>
<code>    options (parse) undef</code>
<code>    options (dontdraw) true put</code>
<code>    options (parsefnc) true put</code>
<code>    /args barcode options //qrcode exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /gs1qrcode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER gs1qrcode--</code>
<code></code>
<code>% --BEGIN ENCODER gs1dlqrcode--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renmatrix qrcode--</code>
<code>% --DESC: GS1 Digital Link QR Code</code>
<code>% --EXAM: https://id.gs1.org/01/09521234543213/22/ABC%2d123?99=XYZ%2f987</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp gs1dlqrcode 0.0 2024010300 71188 67459</code>
<code>%%BeginData:         49 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /parseinput dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /qrcode dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/gs1dlqrcode {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs true def</code>
<code>    /dontdraw false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    % Parse the input</code>
<code>    /fncvals &lt;&lt;</code>
<code>        /parse parse</code>
<code>        /parseonly true</code>
<code>        /parsefnc false</code>
<code>    &gt;&gt; def</code>
<code>    /barcode barcode fncvals //parseinput exec def</code>
<code></code>
<code>    barcode /dl //gs1process exec pop pop pop</code>
<code></code>
<code>    % Get the result of encoding with qrcode</code>
<code>    options (parse) undef</code>
<code>    options (dontdraw) true put</code>
<code>    /args barcode options //qrcode exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /gs1dlqrcode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER gs1dlqrcode--</code>
<code></code>
<code>% --BEGIN ENCODER gs1dotcode--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput gs1process renmatrix dotcode--</code>
<code>% --DESC: GS1 DotCode</code>
<code>% --EXAM: (235)5vBZIF%!&lt;B;?oa%(01)09521234543213(8008)19052001</code>
<code>% --EXOP: rows=16</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp gs1dotcode 0.0 2024010300 78053 77639</code>
<code>%%BeginData:         80 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /gs1process dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /dotcode dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/gs1dotcode {</code>
<code></code>
<code>    20 dict begin            % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /parse false def</code>
<code>    /dontlint false def</code>
<code>    /lintreqs true def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode /ai //gs1process exec</code>
<code>    /fncs exch def</code>
<code>    /vals exch def</code>
<code>    /ais exch def</code>
<code></code>
<code>    % Create the dotcode data</code>
<code>    /fnc1 -1 def</code>
<code>    /dmtx [ fnc1 ] def</code>
<code>    0 1 ais length 1 sub {</code>
<code>        /i exch def</code>
<code>        /ai ais i get def</code>
<code>        /val vals i get def</code>
<code>        dmtx length ai length add val length add array</code>
<code>        dup 0 dmtx putinterval</code>
<code>        dup dmtx length ai [ exch {} forall ] putinterval</code>
<code>        dup dmtx length ai length add val [ exch {} forall ] putinterval</code>
<code>        /dmtx exch def</code>
<code>        i ais length 1 sub ne fncs i get and {  % Append FNC1</code>
<code>            dmtx length 1 add array</code>
<code>            dup 0 dmtx putinterval</code>
<code>            dup dmtx length fnc1 put</code>
<code>            /dmtx exch def</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    % Compose input to dotcode</code>
<code>    /barcode dmtx length 1 add 5 mul string def</code>
<code>    /i 0 def /j 0 def {</code>
<code>        i dmtx length eq {exit} if</code>
<code>        dmtx i get dup fnc1 eq {</code>
<code>            pop barcode j (^FNC1) putinterval</code>
<code>            /j j 4 add def</code>
<code>        } {</code>
<code>            barcode exch j exch put</code>
<code>        } ifelse</code>
<code>        /i i 1 add def</code>
<code>        /j j 1 add def</code>
<code>    } loop</code>
<code>    /barcode barcode 0 j getinterval def</code>
<code></code>
<code>    % Get the result of encoding with dotcode</code>
<code>    options (parse) undef</code>
<code>    options (dontdraw) true put</code>
<code>    options (parsefnc) true put</code>
<code>    /args barcode options //dotcode exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /gs1dotcode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER gs1dotcode--</code>
<code></code>
<code>% --BEGIN ENCODER hibccode39--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions renlinear code39--</code>
<code>% --DESC: HIBC Code 39</code>
<code>% --EXAM: A999BJC5D6E71</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp hibccode39 0.0 2024010300 67736 67460</code>
<code>%%BeginData:         92 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /code39 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/hibccode39 {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /textxoffset 0.0 def</code>
<code>    /validatecheck false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.hibccode39emptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /hibccode39 //loadctx exec</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>{</code>
<code>    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def</code>
<code>    /charvals 43 dict def</code>
<code>    0 1 42 {charvals exch dup barchars exch 1 getinterval exch put} for</code>
<code>} ctxdef</code>
<code></code>
<code>    % Validate the input</code>
<code>    0 1 barcode length 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch known not {</code>
<code>            /bwipp.hibccode39badCharacter (HIBC Code 39 must contain only digits, capital letters, spaces and the symbols -.$/+%) //raiseerror exec</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    /barlen barcode length validatecheck {1 sub} if def</code>
<code></code>
<code>    /checksum 41 def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch get</code>
<code>        checksum add /checksum exch def</code>
<code>    } for</code>
<code>    /checksum checksum 43 mod def</code>
<code>    validatecheck {</code>
<code>        barcode barlen get barchars checksum get ne {</code>
<code>            /bwipp.hibccode39badCheckDigit (Incorrect HIBC Code 39 check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>        /barcode barcode 0 barlen getinterval def</code>
<code>    } if</code>
<code></code>
<code>    /barcode barlen 2 add string dup 1 barcode putinterval def</code>
<code>    barcode 0 43 put</code>
<code>    barcode barlen 1 add barchars checksum get put</code>
<code></code>
<code>    /text barlen 4 add string def</code>
<code>    text 0 42 put</code>
<code>    text 1 barcode putinterval</code>
<code>    text barlen 2 add barcode barlen 1 add get dup 32 eq {pop 95} if put</code>
<code>    text barlen 3 add 42 put</code>
<code></code>
<code>    % Get the result of encoding with code39</code>
<code>    options (dontdraw) true put</code>
<code>    options (includecheck) false put</code>
<code>    options (validatecheck) false put</code>
<code>    /args barcode options //code39 exec def</code>
<code></code>
<code>    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put</code>
<code>    args (textxalign) (center) put</code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /hibccode39 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER hibccode39--</code>
<code></code>
<code>% --BEGIN ENCODER hibccode128--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renlinear code128--</code>
<code>% --DESC: HIBC Code 128</code>
<code>% --EXAM: A999BJC5D6E71</code>
<code>% --EXOP: includetext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp hibccode128 0.0 2024010300 70507 70300</code>
<code>%%BeginData:         91 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /code128 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/hibccode128 {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textyoffset -8.0 def</code>
<code>    /textxoffset 0.0 def</code>
<code>    /validatecheck false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.hibccode128emptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /hibccode128 //loadctx exec</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>{</code>
<code>    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def</code>
<code>    /charvals 43 dict def</code>
<code>    0 1 42 {charvals exch dup barchars exch 1 getinterval exch put} for</code>
<code>} ctxdef</code>
<code></code>
<code>    % Validate the input</code>
<code>    0 1 barcode length 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch known not {</code>
<code>            /bwipp.hibccode128badCharacter (HIBC Code 128 must contain only digits, capital letters, spaces and the symbols -.$/+%) //raiseerror exec</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    /barlen barcode length validatecheck {1 sub} if def</code>
<code></code>
<code>    /checksum 41 def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch get</code>
<code>        checksum add /checksum exch def</code>
<code>    } for</code>
<code>    /checksum checksum 43 mod def</code>
<code>    validatecheck {</code>
<code>        barcode barlen get barchars checksum get ne {</code>
<code>            /bwipp.hibccode128badCheckDigit (Incorrect HIBC Code 128 check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>        /barcode barcode 0 barlen getinterval def</code>
<code>    } if</code>
<code></code>
<code>    /barcode barlen 2 add string dup 1 barcode putinterval def</code>
<code>    barcode 0 43 put</code>
<code>    barcode barlen 1 add barchars checksum get put</code>
<code></code>
<code>    /text barlen 4 add string def</code>
<code>    text 0 42 put</code>
<code>    text 1 barcode putinterval</code>
<code>    text barlen 2 add barcode barlen 1 add get dup 32 eq {pop 95} if put</code>
<code>    text barlen 3 add 42 put</code>
<code></code>
<code>    % Get the result of encoding with code128</code>
<code>    options (dontdraw) true put</code>
<code>    options (validatecheck) false put</code>
<code>    /args barcode options //code128 exec def</code>
<code></code>
<code>    args (txt) [ [text textxoffset textyoffset textfont textsize] ] put</code>
<code>    args (textxalign) (center) put</code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /hibccode128 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER hibccode128--</code>
<code></code>
<code>% --BEGIN ENCODER hibcdatamatrix--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix datamatrix--</code>
<code>% --DESC: HIBC Data Matrix</code>
<code>% --EXAM: A999BJC5D6E71</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp hibcdatamatrix 0.0 2024010300 68385 68150</code>
<code>%%BeginData:         79 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /datamatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/hibcdatamatrix {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /validatecheck false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.hibcdatamatrixEmptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /hibcdatamatrix //loadctx exec</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>{</code>
<code>    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def</code>
<code>    /charvals 43 dict def</code>
<code>    0 1 42 {charvals exch dup barchars exch 1 getinterval exch put} for</code>
<code>} ctxdef</code>
<code></code>
<code>    % Validate the input</code>
<code>    0 1 barcode length 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch known not {</code>
<code>            /bwipp.hibcdatamatrixBadCharacter (HIBC Data Matrix must contain only digits, capital letters, spaces and the symbols -.$/+%) //raiseerror exec</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    /barlen barcode length validatecheck {1 sub} if def</code>
<code></code>
<code>    /checksum 41 def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch get</code>
<code>        checksum add /checksum exch def</code>
<code>    } for</code>
<code>    /checksum checksum 43 mod def</code>
<code>    validatecheck {</code>
<code>        barcode barlen get barchars checksum get ne {</code>
<code>            /bwipp.hibcdatamatrixBadCheckDigit (Incorrect HIBC Data Matrix check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>        /barcode barcode 0 barlen getinterval def</code>
<code>    } if</code>
<code></code>
<code>    /barcode barlen 2 add string dup 1 barcode putinterval def</code>
<code>    barcode 0 43 put</code>
<code>    barcode barlen 1 add barchars checksum get put</code>
<code></code>
<code>    % Get the result of encoding with datamatrix</code>
<code>    options (dontdraw) true put</code>
<code>    options (validatecheck) false put</code>
<code>    /args barcode options //datamatrix exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /hibcdatamatrix dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER hibcdatamatrix--</code>
<code></code>
<code>% --BEGIN ENCODER hibcdatamatrixrectangular--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix datamatrix--</code>
<code>% --DESC: HIBC Data Matrix Rectangular</code>
<code>% --EXAM: A999BJC5D6E71</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp hibcdatamatrixrectangular 0.0 2024010300 68645 68366</code>
<code>%%BeginData:         80 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /datamatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/hibcdatamatrixrectangular {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /validatecheck false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.hibcdatamatrixrectangularEmptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /hibcdatamatrixrectangular //loadctx exec</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>{</code>
<code>    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def</code>
<code>    /charvals 43 dict def</code>
<code>    0 1 42 {charvals exch dup barchars exch 1 getinterval exch put} for</code>
<code>} ctxdef</code>
<code></code>
<code>    % Validate the input</code>
<code>    0 1 barcode length 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch known not {</code>
<code>            /bwipp.hibcdatamatrixrectangularBadCharacter (HIBC Data Matrix Rectangular must contain only digits, capital letters, spaces and the symbols -.$/+%) //raiseerror exec</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    /barlen barcode length validatecheck {1 sub} if def</code>
<code></code>
<code>    /checksum 41 def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch get</code>
<code>        checksum add /checksum exch def</code>
<code>    } for</code>
<code>    /checksum checksum 43 mod def</code>
<code>    validatecheck {</code>
<code>        barcode barlen get barchars checksum get ne {</code>
<code>            /bwipp.hibcdatamatrixrectangularBadCheckDigit (Incorrect HIBC Data Matrix Rectangular check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>        /barcode barcode 0 barlen getinterval def</code>
<code>    } if</code>
<code></code>
<code>    /barcode barlen 2 add string dup 1 barcode putinterval def</code>
<code>    barcode 0 43 put</code>
<code>    barcode barlen 1 add barchars checksum get put</code>
<code></code>
<code>    % Get the result of encoding with datamatrix</code>
<code>    options (dontdraw) true put</code>
<code>    options (validatecheck) false put</code>
<code>    options (format) (rectangle) put</code>
<code>    /args barcode options //datamatrix exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /hibcdatamatrixrectangular dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER hibcdatamatrixrectangular--</code>
<code></code>
<code>% --BEGIN ENCODER hibcpdf417--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix pdf417--</code>
<code>% --DESC: HIBC PDF417</code>
<code>% --EXAM: A999BJC5D6E71</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp hibcpdf417 0.0 2024010300 68516 68455</code>
<code>%%BeginData:         81 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /pdf417 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/hibcpdf417 {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /columns 2 def</code>
<code>    /validatecheck false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.hibcpdf417EmptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /hibcpdf417 //loadctx exec</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>{</code>
<code>    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def</code>
<code>    /charvals 43 dict def</code>
<code>    0 1 42 {charvals exch dup barchars exch 1 getinterval exch put} for</code>
<code>} ctxdef</code>
<code></code>
<code>    % Validate the input</code>
<code>    0 1 barcode length 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch known not {</code>
<code>            /bwipp.hibcpdf417BadCharacter (HIBC PDF417 must contain only digits, capital letters, spaces and the symbols -.$/+%) //raiseerror exec</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    /barlen barcode length validatecheck {1 sub} if def</code>
<code></code>
<code>    /checksum 41 def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch get</code>
<code>        checksum add /checksum exch def</code>
<code>    } for</code>
<code>    /checksum checksum 43 mod def</code>
<code>    validatecheck {</code>
<code>        barcode barlen get barchars checksum get ne {</code>
<code>            /bwipp.hibcpdf417BadCheckDigit (Incorrect HIBC PDF417 check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>        /barcode barcode 0 barlen getinterval def</code>
<code>    } if</code>
<code></code>
<code>    /barcode barlen 2 add string dup 1 barcode putinterval def</code>
<code>    barcode 0 43 put</code>
<code>    barcode barlen 1 add barchars checksum get put</code>
<code></code>
<code>    % Get the result of encoding with pdf417</code>
<code>    options (dontdraw) true put</code>
<code>    options (columns) columns put</code>
<code>    options (validatecheck) false put</code>
<code>    /args barcode options //pdf417 exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /hibcpdf417 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER hibcpdf417--</code>
<code></code>
<code>% --BEGIN ENCODER hibcmicropdf417--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix micropdf417--</code>
<code>% --DESC: HIBC MicroPDF417</code>
<code>% --EXAM: A999BJC5D6E71</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp hibcmicropdf417 0.0 2024010300 68571 68362</code>
<code>%%BeginData:         81 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /micropdf417 dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/hibcmicropdf417 {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /columns 2 def</code>
<code>    /validatecheck false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.hibcmicropdf417EmptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /hibcmicropdf417 //loadctx exec</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>{</code>
<code>    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def</code>
<code>    /charvals 43 dict def</code>
<code>    0 1 42 {charvals exch dup barchars exch 1 getinterval exch put} for</code>
<code>} ctxdef</code>
<code></code>
<code>    % Validate the input</code>
<code>    0 1 barcode length 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch known not {</code>
<code>            /bwipp.hibcmicropdf417BadCharacter (HIBC MicroPDF417 must contain only digits, capital letters, spaces and the symbols -.$/+%) //raiseerror exec</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    /barlen barcode length validatecheck {1 sub} if def</code>
<code></code>
<code>    /checksum 41 def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch get</code>
<code>        checksum add /checksum exch def</code>
<code>    } for</code>
<code>    /checksum checksum 43 mod def</code>
<code>    validatecheck {</code>
<code>        barcode barlen get barchars checksum get ne {</code>
<code>            /bwipp.hibcmicropdf417BadCheckDigit (Incorrect HIBC MicroPDF417 check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>        /barcode barcode 0 barlen getinterval def</code>
<code>    } if</code>
<code></code>
<code>    /barcode barlen 2 add string dup 1 barcode putinterval def</code>
<code>    barcode 0 43 put</code>
<code>    barcode barlen 1 add barchars checksum get put</code>
<code></code>
<code>    % Get the result of encoding with micropdf417</code>
<code>    options (dontdraw) true put</code>
<code>    options (columns) columns put</code>
<code>    options (validatecheck) false put</code>
<code>    /args barcode options //micropdf417 exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /hibcmicropdf417 dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER hibcmicropdf417--</code>
<code></code>
<code>% --BEGIN ENCODER hibcqrcode--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix qrcode--</code>
<code>% --DESC: HIBC QR Code</code>
<code>% --EXAM: A999BJC5D6E71</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp hibcqrcode 0.0 2024010300 72857 72632</code>
<code>%%BeginData:         79 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /qrcode dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/hibcqrcode {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /validatecheck false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.hibcqrcodeEmptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /hibcqrcode //loadctx exec</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>{</code>
<code>    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def</code>
<code>    /charvals 43 dict def</code>
<code>    0 1 42 {charvals exch dup barchars exch 1 getinterval exch put} for</code>
<code>} ctxdef</code>
<code></code>
<code>    % Validate the input</code>
<code>    0 1 barcode length 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch known not {</code>
<code>            /bwipp.hibcqrcodeBadCharacter (HIBC QR Code must contain only digits, capital letters, spaces and the symbols -.$/+%) //raiseerror exec</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    /barlen barcode length validatecheck {1 sub} if def</code>
<code></code>
<code>    /checksum 41 def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch get</code>
<code>        checksum add /checksum exch def</code>
<code>    } for</code>
<code>    /checksum checksum 43 mod def</code>
<code>    validatecheck {</code>
<code>        barcode barlen get barchars checksum get ne {</code>
<code>            /bwipp.hibcqrcodeBadCheckDigit (Incorrect HIBC QR Code check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>        /barcode barcode 0 barlen getinterval def</code>
<code>    } if</code>
<code></code>
<code>    /barcode barlen 2 add string dup 1 barcode putinterval def</code>
<code>    barcode 0 43 put</code>
<code>    barcode barlen 1 add barchars checksum get put</code>
<code></code>
<code>    % Get the result of encoding with qrcode</code>
<code>    options (dontdraw) true put</code>
<code>    options (validatecheck) false put</code>
<code>    /args barcode options //qrcode exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /hibcqrcode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER hibcqrcode--</code>
<code></code>
<code>% --BEGIN ENCODER hibccodablockf--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix codablockf--</code>
<code>% --DESC: HIBC Codablock F</code>
<code>% --EXAM: A999BJC5D6E71</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp hibccodablockf 0.0 2024010300 68497 68150</code>
<code>%%BeginData:         79 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /codablockf dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/hibccodablockf {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /validatecheck false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.hibccodablockfEmptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /hibccodablockf //loadctx exec</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>{</code>
<code>    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def</code>
<code>    /charvals 43 dict def</code>
<code>    0 1 42 {charvals exch dup barchars exch 1 getinterval exch put} for</code>
<code>} ctxdef</code>
<code></code>
<code>    % Validate the input</code>
<code>    0 1 barcode length 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch known not {</code>
<code>            /bwipp.hibccodablockfBadCharacter (HIBC Codablock F must contain only digits, capital letters, spaces and the symbols -.$/+%) //raiseerror exec</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    /barlen barcode length validatecheck {1 sub} if def</code>
<code></code>
<code>    /checksum 41 def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch get</code>
<code>        checksum add /checksum exch def</code>
<code>    } for</code>
<code>    /checksum checksum 43 mod def</code>
<code>    validatecheck {</code>
<code>        barcode barlen get barchars checksum get ne {</code>
<code>            /bwipp.hibccodablockfBadCheckDigit (Incorrect HIBC Codablock F check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>        /barcode barcode 0 barlen getinterval def</code>
<code>    } if</code>
<code></code>
<code>    /barcode barlen 2 add string dup 1 barcode putinterval def</code>
<code>    barcode 0 43 put</code>
<code>    barcode barlen 1 add barchars checksum get put</code>
<code></code>
<code>    % Get the result of encoding with codablockf</code>
<code>    options (dontdraw) true put</code>
<code>    options (validatecheck) false put</code>
<code>    /args barcode options //codablockf exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /hibccodablockf dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER hibccodablockf--</code>
<code></code>
<code>% --BEGIN ENCODER hibcazteccode--</code>
<code>% --REQUIRES preamble loadctx unloadctx raiseerror processoptions parseinput renmatrix azteccode--</code>
<code>% --DESC: HIBC Aztec Code</code>
<code>% --EXAM: A999BJC5D6E71</code>
<code>% --EXOP:</code>
<code>% --RNDR: renmatrix</code>
<code>%%BeginResource: uk.co.terryburton.bwipp hibcazteccode 0.0 2024010300 68358 68143</code>
<code>%%BeginData:         79 ASCII Lines</code>
<code>%psc /setpacking where {pop currentpacking true setpacking} if</code>
<code>%psc 10 dict</code>
<code>%psc dup /loadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /unloadctx dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /processoptions dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /renmatrix dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc dup /azteccode dup /uk.co.terryburton.bwipp findresource put</code>
<code>%psc begin</code>
<code>/hibcazteccode {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    %psc /ctx null def</code>
<code>    /dontdraw false def</code>
<code>    /validatecheck false def</code>
<code></code>
<code>    currentdict //processoptions exec /options exch def</code>
<code>    /barcode exch def</code>
<code></code>
<code>    barcode () eq {</code>
<code>        /bwipp.hibcazteccodeEmptyData (The data must not be empty) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /hibcazteccode //loadctx exec</code>
<code></code>
<code>    % Create a string of the available characters</code>
<code>{</code>
<code>    /barchars (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%) def</code>
<code>    /charvals 43 dict def</code>
<code>    0 1 42 {charvals exch dup barchars exch 1 getinterval exch put} for</code>
<code>} ctxdef</code>
<code></code>
<code>    % Validate the input</code>
<code>    0 1 barcode length 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch known not {</code>
<code>            /bwipp.hibcazteccodeBadCharacter (HIBC Aztec Code must contain only digits, capital letters, spaces and the symbols -.$/+%) //raiseerror exec</code>
<code>        } if</code>
<code>    } for</code>
<code></code>
<code>    /barlen barcode length validatecheck {1 sub} if def</code>
<code></code>
<code>    /checksum 41 def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        barcode exch 1 getinterval charvals exch get</code>
<code>        checksum add /checksum exch def</code>
<code>    } for</code>
<code>    /checksum checksum 43 mod def</code>
<code>    validatecheck {</code>
<code>        barcode barlen get barchars checksum get ne {</code>
<code>            /bwipp.hibcazteccodeBadCheckDigit (Incorrect HIBC Aztec Code check digit provided) //raiseerror exec</code>
<code>        } if</code>
<code>        /barcode barcode 0 barlen getinterval def</code>
<code>    } if</code>
<code></code>
<code>    /barcode barlen 2 add string dup 1 barcode putinterval def</code>
<code>    barcode 0 43 put</code>
<code>    barcode barlen 1 add barchars checksum get put</code>
<code></code>
<code>    % Get the result of encoding with azteccode</code>
<code>    options (dontdraw) true put</code>
<code>    options (validatecheck) false put</code>
<code>    /args barcode options //azteccode exec def</code>
<code></code>
<code>    args (opt) options put</code>
<code>    args</code>
<code></code>
<code>    dontdraw not //renmatrix if</code>
<code></code>
<code>    //unloadctx exec</code>
<code></code>
<code>    end</code>
<code></code>
<code>}</code>
<code>%psc [/barcode] {null def} forall</code>
<code>bind def</code>
<code>%psc /hibcazteccode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%psc end</code>
<code>%psc /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER hibcazteccode--</code>
<code></code>
<code>% --END TEMPLATE--</code>
<code>% --BEGIN ENCODER channelcode--</code>
<code>% --REQUIRES preamble raiseerror renlinear--</code>
<code>% --DESC: Channel Code</code>
<code>% --EXAM: 3493</code>
<code>% --EXOP: height=0.5 includetext</code>
<code>% --RNDR: renlinear</code>
<code>%%BeginResource: uk.co.terryburton.bwipp channelcode 0.0 2017071000 68302 68105</code>
<code>%%BeginData:        149 ASCII Lines</code>
<code>%%/setpacking where {pop currentpacking true setpacking} if</code>
<code>%%1 dict</code>
<code>%%dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%%dup /renlinear dup /uk.co.terryburton.bwipp findresource put</code>
<code>%%begin</code>
<code>/channelcode {</code>
<code></code>
<code>    20 dict begin                 % Confine variables to local scope</code>
<code></code>
<code>    /options exch def       % We are given an option string</code>
<code>    /barcode exch def       % We are given a barcode string</code>
<code></code>
<code>    /dontdraw false def</code>
<code>    /shortfinder false def</code>
<code>    /includetext false def</code>
<code>    /includecheck false def</code>
<code>    /height 1 def</code>
<code></code>
<code>    % Parse the input options</code>
<code>%psc     options type /stringtype eq {</code>
<code>%psc         1 dict begin</code>
<code>%psc         options {</code>
<code>%psc             token false eq {exit} if dup length string cvs (=) search</code>
<code>%psc             true eq {cvlit exch pop exch def} {cvlit true def} ifelse</code>
<code>%psc         } loop</code>
<code>%psc         currentdict end /options exch def</code>
<code>%psc     } if</code>
<code>    options {def} forall</code>
<code></code>
<code>    /height height cvr def</code>
<code></code>
<code>    % Validate the input</code>
<code>    barcode length 2 lt barcode length 7 gt or {</code>
<code>        /bwipp.channelcodeBadLength (Channel Code must be 2 to 7 digits) //raiseerror exec</code>
<code>    } if</code>
<code>    barcode {</code>
<code>        dup 48 lt exch 57 gt or {</code>
<code>            /bwipp.channelcodeBadCharacter (Channel Code must contain only digits) //raiseerror exec</code>
<code>        } if</code>
<code>    } forall</code>
<code>    barcode cvi [ 26 292 3493 44072 576688 7742862 ] barcode length 2 sub get gt {</code>
<code>        /bwipp.channelcodeTooBig (The Channel Code value is too big for the number of channels) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    /nextb {</code>
<code>        dup</code>
<code>        dup s exch get exch</code>
<code>        dup b exch 1 sub get exch</code>
<code>        dup s exch 1 sub get exch</code>
<code>        b exch 2 sub get exch</code>
<code>        add add add 4 gt {1} {2} ifelse</code>
<code>        1 index chan 2 add lt {</code>
<code>            dup 1 4 index {</code>
<code>                b 3 index 2 index put</code>
<code>                3 index exch sub 1 add 4 index 3 index 1 add nexts</code>
<code>            } for</code>
<code>        } {</code>
<code>            dup 3 index le {</code>
<code>                b 2 index 4 index put</code>
<code>                value target eq {</code>
<code>                    /out [</code>
<code>                        3 1 10 {dup s exch get exch b exch get} for</code>
<code>                    ] 0 chan 2 mul getinterval def</code>
<code>                } if</code>
<code>                /value value 1 add def</code>
<code>            } if</code>
<code>        } ifelse</code>
<code>        pop pop pop pop</code>
<code>    } bind def</code>
<code></code>
<code>    /nexts {</code>
<code>        dup chan 2 add lt {1} {1 index} ifelse 1 3 index {</code>
<code>            s 2 index 2 index put</code>
<code>            2 index exch sub 1 add 3 index 2 index nextb</code>
<code>        } for</code>
<code>        pop pop pop</code>
<code>    } bind def</code>
<code></code>
<code>    /encode {</code>
<code>        /chan exch def</code>
<code>        /target exch def</code>
<code>        /value 0 def</code>
<code>        /out -1 def</code>
<code>        /b [ 1 1 1 0 0 0 0 0 0 0 0 ] def</code>
<code>        /s [ 0 1 1 0 0 0 0 0 0 0 0 ] def</code>
<code>        chan dup 3 nexts</code>
<code>        out</code>
<code>    } bind def</code>
<code></code>
<code>    /barlen barcode length def</code>
<code></code>
<code>    % Determine finder</code>
<code>    /finder shortfinder { [ 1 1 1 1 1 ] } { [ 1 1 1 1 1 1 1 1 1 ] } ifelse def</code>
<code></code>
<code>    % Encode the main data</code>
<code>    /data barcode cvi barlen 1 add encode def</code>
<code></code>
<code>    % Determine check data</code>
<code>    /check [] def</code>
<code>    includecheck {</code>
<code>        /mod23 [</code>
<code>            [] []</code>
<code>            [ 13 12  4  9  3  1 ]</code>
<code>            [ 13  2 12  3 18 16  4  1 ]</code>
<code>            [ 11 16 17  8 20  4 10  2  5  1 ]</code>
<code>            [  1  4 16 18  3 12  2  8  9 13  6  1 ]</code>
<code>            [ 20 16 22 13 15 12  5  4  8  9 21  3  7  1 ]</code>
<code>            [  2  6 18  8  1  3  9  4 12 13 16  2  6 18  8  1 ]</code>
<code>        ] barlen get def</code>
<code>        0</code>
<code>        0 1 data length 1 sub {</code>
<code>            dup data exch get 1 sub exch mod23 exch get mul add</code>
<code>        } for</code>
<code>        23 mod 3 encode /check exch def</code>
<code>    } if</code>
<code></code>
<code>    % Construct the symbol</code>
<code>    /sbs [</code>
<code>        finder aload pop</code>
<code>        data aload pop</code>
<code>        check aload pop</code>
<code>    ] def</code>
<code></code>
<code>    % Create the human readable text</code>
<code>    /txt barlen array def</code>
<code>    0 1 barlen 1 sub {</code>
<code>        /i exch def</code>
<code>        txt i [barcode i 1 getinterval 0 0 () 0] put</code>
<code>    } for</code>
<code></code>
<code>    % Return the arguments</code>
<code>    &lt;&lt;</code>
<code>    /ren //renlinear</code>
<code>    /sbs sbs</code>
<code>    /bhs [sbs length 1 add 2 idiv {height} repeat]</code>
<code>    /bbs [sbs length 1 add 2 idiv {0} repeat]</code>
<code>    /txt txt</code>
<code>    /textxalign (center)</code>
<code>    /opt options</code>
<code>    &gt;&gt;</code>
<code></code>
<code>    dontdraw not //renlinear if</code>
<code></code>
<code>    end</code>
<code></code>
<code>} bind def</code>
<code>%%/channelcode dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%%end</code>
<code>%%/setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END ENCODER channelcode--</code>
<code>%%</code>
<code>%% STUB OUT loadctx</code>
<code>%%</code>
<code>%%</code>
<code>%% STUB OUT processoptions</code>
<code>%%</code>
<code>%%</code>
<code>%% STUB OUT raiseerror</code>
<code>%%</code>
<code>% --BEGIN RENDERER renlinear--</code>
<code>% --REQUIRES preamble raiseerror--</code>
<code>%%BeginResource: uk.co.terryburton.bwipp renlinear 0.0 2015021800 76908 76502</code>
<code>%%BeginData:        237 ASCII Lines</code>
<code>%% /setpacking where {pop currentpacking true setpacking} if</code>
<code>%% 1 dict</code>
<code>%% dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%% begin</code>
<code>/renlinear {</code>
<code>bwipjs_dontdraw { return } if</code>
<code>    20 dict begin          % Confine variables to local scope</code>
<code></code>
<code>    %%/args exch def   % We are given some arguments</code>
<code></code>
<code>    % Default options</code>
<code>    /sbs [] def</code>
<code>    /bhs [] def</code>
<code>    /bbs [] def</code>
<code>    /txt [] def</code>
<code>    /barcolor (unset) def</code>
<code>    /includetext false def</code>
<code>    /textcolor (unset) def</code>
<code>    /textxalign (unset) def</code>
<code>    /textyalign (unset) def</code>
<code>    /textfont (OCR-B) def</code>
<code>    /textsize 10.0 def</code>
<code>    /textxoffset 0.0 def</code>
<code>    /textyoffset 0.0 def</code>
<code>    /textgaps 0.0 def</code>
<code>    /alttext () def</code>
<code>    /bordercolor (unset) def</code>
<code>    /backgroundcolor (unset) def</code>
<code>    /inkspread 0 def      % Was 0.15</code>
<code>    /width 0.0 def</code>
<code>    /barratio 1.0 def</code>
<code>    /spaceratio 1.0 def</code>
<code>    /showborder false def</code>
<code>    /showbearer false def</code>
<code>    /borderleft 10.0 def</code>
<code>    /borderright 10.0 def</code>
<code>    /bordertop 1.0 def      % Was 0.0</code>
<code>    /borderbottom 1.0 def   % Was 0.0</code>
<code>    /borderwidth 0.5 def</code>
<code>    /guardwhitespace false def</code>
<code>    /guardleftpos 0.0 def</code>
<code>    /guardleftypos 0.0 def</code>
<code>    /guardrightpos 0.0 def</code>
<code>    /guardrightypos 0.0 def</code>
<code>    /guardwidth 7.0 def     % Was 5.0</code>
<code>    /guardheight 7.0 def</code>
<code></code>
<code>    {def} forall</code>
<code>    opt currentdict /opt undef currentdict //processoptions exec pop</code>
<code></code>
<code>    textsize 0 le {</code>
<code>        /bwipp.renlinearBadTextsize (The font size must be greater than zero) //raiseerror exec</code>
<code>    } if</code>
<code></code>
<code>    % Create bar elements and put them into the bars array</code>
<code>    /bars sbs length 1 add 2 idiv array def</code>
<code>    /pixx 0 def /pixy 0 def</code>
<code>    0 1 sbs length 1 add 2 idiv 2 mul 2 sub {</code>
<code>        /i exch def</code>
<code>        i 2 mod 0 eq {           % i is even</code>
<code>            /d sbs i get barratio mul barratio sub 1 add def  % d = digit*r-r+1</code>
<code>            sbs i get 0 ne {</code>
<code>                /h bhs i 2 idiv get 72 mul def  % Height from bhs</code>
<code>                /c d 2 div pixx add def         % Centre of the bar = pixx + d/2</code>
<code>                /y bbs i 2 idiv get 72 mul def  % Baseline from bbs</code>
<code>                /w d inkspread sub def          % bar width = digit - inkspread</code>
<code>                bars i 2 idiv [h c y w] put     % Add the bar entry</code>
<code>                h y add pixy gt {/pixy h y add def} if</code>
<code>            } {</code>
<code>                bars i 2 idiv -1 put            % Dummy entry</code>
<code>            } ifelse</code>
<code>        } {</code>
<code>            /d sbs i get spaceratio mul spaceratio sub 1 add def  % d = digit*r-r+1</code>
<code>        } ifelse</code>
<code>        /pixx pixx d add def  % pixx += d</code>
<code>    } for</code>
<code></code>
<code>    gsave</code>
<code></code>
<code>    currentpoint translate</code>
<code></code>
<code>    % Force symbol to given width</code>
<code>    width 0 ne {</code>
<code>        width 72 mul pixx div 1 scale</code>
<code>    } if</code>
<code></code>
<code>    % Display the border and background</code>
<code>    % background is handled by the bwip-js drawing interface.</code>
<code>    %backgroundcolor (unset) ne {</code>
<code>    %    gsave</code>
<code>    %    newpath bl aload pop moveto [ br tr tl ] { aload pop lineto } forall closepath</code>
<code>    %    backgroundcolor setanycolor fill</code>
<code>    %    grestore</code>
<code>    %} if</code>
<code>    /tl [ borderleft borderwidth 2 div add neg        pixy bordertop add borderwidth 2 div add ] def</code>
<code>    /tr [ pixx borderright add borderwidth 2 div add  pixy bordertop add borderwidth 2 div add ] def</code>
<code>    /bl [ borderleft borderwidth 2 div add neg        borderbottom borderwidth 2 div add neg   ] def</code>
<code>    /br [ pixx borderright add borderwidth 2 div add  borderbottom borderwidth 2 div add neg   ] def</code>
<code>    showbearer {  % Overrides showborder</code>
<code>        gsave</code>
<code>        newpath</code>
<code>        bl aload pop moveto br aload pop lineto</code>
<code>        tl aload pop moveto tr aload pop lineto</code>
<code>        bordercolor (unset) ne { bordercolor setanycolor } if</code>
<code>        borderwidth inkspread 2 mul sub setlinewidth stroke</code>
<code>        grestore</code>
<code>    } {</code>
<code>    showborder {</code>
<code>        % This is the original showborder code from the old renlinear.</code>
<code>        % It better spaces the border around the symbol.</code>
<code>        %newpath</code>
<code>        %borderleft neg borderbottom neg moveto</code>
<code>        %pixx borderleft add borderright add 0 rlineto</code>
<code>        %0 pixy borderbottom add bordertop add rlineto</code>
<code>        %pixx borderleft add borderright add neg 0 rlineto</code>
<code>        %0 pixy borderbottom add bordertop add neg rlineto</code>
<code>        %closepath</code>
<code></code>
<code>        gsave</code>
<code>        newpath bl aload pop moveto [ br tr tl ] { aload pop lineto } forall closepath</code>
<code>        bordercolor (unset) ne { bordercolor setanycolor } if</code>
<code>        borderwidth setlinewidth stroke</code>
<code>        grestore</code>
<code>    } if } ifelse</code>
<code></code>
<code>    % Display the bars for elements in the bars array</code>
<code>    gsave</code>
<code>    0 setlinecap</code>
<code>    barcolor (unset) ne { barcolor setanycolor } if</code>
<code>    bars {</code>
<code>        dup -1 ne {</code>
<code>            aload pop newpath setlinewidth moveto 0 exch rlineto stroke</code>
<code>        } {</code>
<code>            pop</code>
<code>        } ifelse</code>
<code>    } forall</code>
<code>    grestore</code>
<code></code>
<code>    % Display the text for elements in the text array</code>
<code>    textcolor (unset) ne { textcolor setanycolor } if</code>
<code>    includetext {</code>
<code>        textxalign (unset) eq textyalign (unset) eq and alttext () eq and {</code>
<code>            /s 0 def /fn () def</code>
<code>            txt {</code>
<code>                {} forall</code>
<code>                2 copy s ne exch fn ne or {</code>
<code>                    2 copy /s exch def /fn exch def</code>
<code>					selectfont</code>
<code>                } {</code>
<code>                    pop pop</code>
<code>                } ifelse</code>
<code>                moveto show</code>
<code>            } forall</code>
<code>        } {</code>
<code>            textfont textsize selectfont</code>
<code>            alttext () eq {</code>
<code>                /txt [ txt { 0 get {} forall } forall ] def</code>
<code>                /tstr txt length string def</code>
<code>                0 1 txt length 1 sub { dup txt exch get tstr 3 1 roll put } for</code>
<code>            } {</code>
<code>                /tstr alttext def</code>
<code>            } ifelse</code>
<code></code>
<code>            % Find true ascent of font</code>
<code>            tstr length 0 eq {</code>
<code>                0</code>
<code>            } {</code>
<code>                gsave</code>
<code>                newpath 0 0 moveto (0) false charpath pathbbox</code>
<code>                4 1 roll pop pop pop</code>
<code>                grestore</code>
<code>                %%currentfont /PaintType known {currentfont /PaintType get 2 eq} {false} ifelse</code>
<code>                %%currentfont /StrokeWidth known and {</code>
<code>                %%  currentfont /StrokeWidth get 2 div 0 exch</code>
<code>                %%  currentfont /FontMatrix get dtransform</code>
<code>                %%  dup mul exch dup mul add sqrt</code>
<code>                %%  add</code>
<code>                %%} if</code>
<code>            } ifelse</code>
<code>            /textascent exch def</code>
<code>            /textwidth tstr stringwidth pop tstr length 1 sub textgaps mul add def</code>
<code></code>
<code>            /textxpos textxoffset pixx textwidth sub 2 div add def</code>
<code>            textxalign (left) eq { /textxpos textxoffset def } if</code>
<code>            textxalign (right) eq { /textxpos pixx textxoffset sub textwidth sub def } if</code>
<code>            textxalign (offleft) eq { /textxpos textwidth textxoffset add neg def } if</code>
<code>            textxalign (offright) eq { /textxpos pixx textxoffset add def } if</code>
<code>            textxalign (justify) eq textwidth pixx lt and {</code>
<code>                /textxpos 0 def</code>
<code>                /textgaps pixx textwidth sub tstr length 1 sub div def</code>
<code>            } if</code>
<code>            /textypos textyoffset textascent add 1 add neg def</code>
<code>            textyalign (above) eq { /textypos textyoffset pixy add 1 add def } if</code>
<code>            textyalign (center) eq { /textypos textyoffset pixy textascent sub 2 div add def } if</code>
<code>            textxpos textypos moveto textgaps 0 tstr ashow</code>
<code>        } ifelse</code>
<code>    } if</code>
<code></code>
<code>    % Display the guard elements</code>
<code>    guardwhitespace {</code>
<code>		(OCR-B) guardheight 2 mul selectfont</code>
<code>        guardleftpos 0 ne {</code>
<code>            guardleftpos neg 2 sub guardleftypos guardheight 2 div sub 1.25 sub moveto</code>
<code>			(&lt;) show</code>
<code>        } if</code>
<code>        guardrightpos 0 ne {</code>
<code>            guardrightpos pixx add guardwidth sub 1 add guardrightypos guardheight 2 div sub 1.25 sub moveto</code>
<code>			(&gt;) show</code>
<code>        } if</code>
<code>    } if</code>
<code></code>
<code>    grestore</code>
<code></code>
<code>    end</code>
<code></code>
<code>} bind def</code>
<code>%% /renlinear dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%% end</code>
<code>%% /setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END RENDERER renlinear--</code>
<code>% --BEGIN RENDERER renmaximatrix--</code>
<code>% --REQUIRES preamble raiseerror--</code>
<code>%%BeginResource: uk.co.terryburton.bwipp renmaximatrix 0.0 2018020400 56037 55803</code>
<code>%%BeginData:         79 ASCII Lines</code>
<code>%%/setpacking where {pop currentpacking true setpacking} if</code>
<code>%%1 dict</code>
<code>%%dup /raiseerror dup /uk.co.terryburton.bwipp findresource put</code>
<code>%%begin</code>
<code>/renmaximatrix {</code>
<code>bwipjs_dontdraw { return } if</code>
<code></code>
<code>    20 dict begin</code>
<code></code>
<code>    /args exch def   % We are given some arguments</code>
<code></code>
<code>    % Default options</code>
<code>    /barcolor (unset) def</code>
<code>    /backgroundcolor (unset) def</code>
<code></code>
<code>    % Apply the renderer options and the user options</code>
<code>    args {def} forall</code>
<code>    opt {def} forall</code>
<code></code>
<code>    /barcolor barcolor cvlit def</code>
<code>    /backgroundcolor backgroundcolor cvlit def</code>
<code></code>
<code>    gsave</code>
<code></code>
<code>    barcolor (unset) ne { barcolor setanycolor } if</code>
<code>	pixs maxicode</code>
<code></code>
<code>    grestore</code>
<code></code>
<code>    end</code>
<code></code>
<code>} bind def</code>
<code>%%/renmaximatrix dup load /uk.co.terryburton.bwipp defineresource pop</code>
<code>%%end</code>
<code>%%/setpacking where {pop setpacking} if</code>
<code>%%EndData</code>
<code>%%EndResource</code>
<code>% --END RENDERER renmaximatrix--</code>
<code>%%</code>
<code>%% STUB OUT unloadctx</code>
<code>%%</code>
</pre>
<script type="text/javascript">
document.getElementById('run-btn').addEventListener('click', () => {
    PSC(document.getElementById('barcode.ps').textContent, []);
});
</script>
</body>
</html>
