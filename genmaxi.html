<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>MaxiCode Glyph Generator</title>
<style>
* {
	font-family:	sans-serif;
	font-size:		12px;
}
input {
	line-height:	1.5;
}
a {
	color:			#3A7BEA;
	cursor:			pointer;
}
a:hover {
	color:			orange;
}
#results {
	display:none;
}
#glyphs {
	padding-top:		1.25ex;
	padding-left:		1.25ex;
	background-color:	#AFC5EA;
}
</style>
</head>
<body>
<table>
<tr><td style="vertical-align:top;white-space:pre">
<div style="line-height:2;white-space:nowrap">
<b>Font Type</b><br>
<label for="anti-aliased"><input type="radio" name="a-or-m" id="anti-aliased" checked><b>Anti-Aliased</b></label>
<label for="mono-chrome"><input type="radio" name="a-or-m" id="mono-chrome"><b>Monochrome</b></label>
<br><b>Scale</b><br>
<label for="scale-1x"><input type="radio" name="scale" id="scale-1x"><b>1X</b></label>
<label for="scale-2x"><input type="radio" name="scale" id="scale-2x" checked><b>2X</b></label>
<label for="scale-3x"><input type="radio" name="scale" id="scale-3x"><b>3X</b></label>
<label for="scale-4x"><input type="radio" name="scale" id="scale-4x"><b>4X</b></label>
<label for="scale-5x"><input type="radio" name="scale" id="scale-5x"><b>5X</b></label>
<label for="scale-6x"><input type="radio" name="scale" id="scale-6x"><b>6X</b></label>
<label for="scale-7x"><input type="radio" name="scale" id="scale-7x"><b>7X</b></label>
<label for="scale-8x"><input type="radio" name="scale" id="scale-8x"><b>8X</b></label>
<label for="scale-9x"><input type="radio" name="scale" id="scale-9x"><b>9X</b></label>
</div>
  <!-- space for download links -->
  <!-- space for download links -->
<b>Result:</b><br>
<canvas id="matrix"></canvas>
<td style="vertical-align:top">
<canvas id="proof0"></canvas>
<td style="vertical-align:top">
<canvas id="proof1"></canvas>
<td style="vertical-align:top">
</table>
<script>
document.getElementById('anti-aliased').addEventListener('click', render, false);
document.getElementById('mono-chrome').addEventListener('click', render, false);
document.getElementById('scale-1x').addEventListener('click', render, false);
document.getElementById('scale-2x').addEventListener('click', render, false);
document.getElementById('scale-3x').addEventListener('click', render, false);
document.getElementById('scale-4x').addEventListener('click', render, false);
document.getElementById('scale-5x').addEventListener('click', render, false);
document.getElementById('scale-6x').addEventListener('click', render, false);
document.getElementById('scale-7x').addEventListener('click', render, false);
document.getElementById('scale-8x').addEventListener('click', render, false);
document.getElementById('scale-9x').addEventListener('click', render, false);
render();
//document.getElementById('dl-proof').addEventListener('click', genproof, false);
//document.getElementById('dl-binary').addEventListener('click', genbinary, false);
//document.getElementById('dl-script').addEventListener('click', genmetrics, false);
function getscale() {
	for (var i = 1; i <= 9; i++) {
		if (document.getElementById('scale-' + i + 'x').checked) {
			return i;
		}
	}
	return 1;
}
function render() {
	let prcvs0 = document.getElementById('proof0'),
		prctx0 = prcvs0.getContext('2d'),
		prcvs1 = document.getElementById('proof1'),
		prctx1 = prcvs1.getContext('2d'),

		scale = getscale(),
		monochrome = document.getElementById('mono-chrome').checked,

		gridsize = 40,
		radius = 2 * scale,
		hexheight = (4 * scale + 2) * gridsize,
		hexwidth  = (Math.ceil(Math.sqrt(3) * scale) * 2 + 2) * gridsize,

		eyegrid = 20,
		eyeside = 4 * scale / 2,
		eyeinner = eyeside * eyegrid,
		eyedelta = 1.30 * eyeside * eyegrid,
		eyeheight = Math.ceil((eyeinner + 5 * eyedelta + eyegrid) / eyegrid) * eyegrid * 2,
		eyewidth = Math.ceil((eyeinner + 5 * eyedelta + eyegrid) / eyegrid) * eyegrid * 2;

	if (!scale) {
		return;
	}

	prcvs0.width  = hexwidth;
	prcvs0.height = hexheight;
	prcvs1.width  = hexwidth;
	prcvs1.height = hexheight;

	//prcvs4.width  = eyewidth;
	//prcvs4.height = eyeheight;

	prctx0.clearRect(0, 0, hexwidth, hexheight);
	prctx1.clearRect(0, 0, hexwidth, hexheight);

	drawHex(prctx0, radius*gridsize, '#f0f0f0', scale <= 2);		// right-align
	if (scale <= 2) {
		drawHex(prctx1, (radius - 0.75) * gridsize, '#f0f0f0', false);
	} else {
		drawHex(prctx1, (radius - Math.floor(scale/3))*gridsize, '#f0f0f0', false); 
	}
	let pcts0 = calcPcts(prcvs0, prctx0);
	let pcts1 = calcPcts(prcvs1, prctx1);

	drawGrid(prcvs0, prctx0, gridsize);
	drawGrid(prcvs1, prctx1, gridsize);
	drawPcts(prcvs0, prctx0, pcts0);
	drawPcts(prcvs1, prctx1, pcts1);
	drawPixels(prcvs0, prctx0, pcts1);

	//drawEye(prcvs4, prctx4);
	drawMatrix(pcts0.maxX - pcts0.minX + 1, pcts1);

	//document.getElementById('results').style.display = 'block';

	function drawGrid(prcvs, prctx, grid) {
		prctx.strokeStyle = 'orange';
		let width = prcvs.width;
		let height = prcvs.height;
		for (let y = grid - 0.5; y < height - 0.5; y += grid) {
			prctx.beginPath();
			prctx.moveTo(0, y);
			prctx.lineTo(width, y);
			prctx.stroke();
		}

		for (let x = grid - 0.5; x < width - 0.5; x += grid) {
			prctx.beginPath();
			prctx.moveTo(x, 0);
			prctx.lineTo(x, height);
			prctx.stroke();
		}

	}
	function drawEye(prcvs, prctx) {
		let x = prcvs.width / 2;
		let y = prcvs.height / 2;

		prctx.fillStyle = '#f0f0f0';
		prctx.beginPath();
		prctx.arc(x, y, eyeinner, 0, 2*Math.PI, false);
		prctx.arc(x, y, eyeinner + eyedelta, 0, 2*Math.PI, true);
		prctx.fill();
		prctx.beginPath();
		prctx.arc(x, y, eyeinner + 2*eyedelta, 0, 2*Math.PI, false);
		prctx.arc(x, y, eyeinner + 3*eyedelta, 0, 2*Math.PI, true);
		prctx.fill();
		prctx.beginPath();
		prctx.arc(x, y, eyeinner + 4*eyedelta, 0, 2*Math.PI, false);
		prctx.arc(x, y, eyeinner + 5*eyedelta, 0, 2*Math.PI, true);
		prctx.fill();
	}
	// Switch sin/cos to rotate the hexagon 90 degrees
	function drawHex(prctx, radius, color, right) {
		let x = hexwidth / 2;
		let y = hexheight / 2;
		if (right) {
			x = hexwidth - gridsize - radius * Math.sqrt(3) / 2;
		}

		prctx.beginPath();
		prctx.moveTo(x + radius * Math.sin(0), y + radius * Math.cos(0));
		for (let seg = 1; seg < 6; seg++) {
		  prctx.lineTo(x + radius * Math.sin(seg * Math.PI / 3),
					 y + radius * Math.cos(seg * Math.PI / 3));
		}
		prctx.closePath();
		prctx.fillStyle = color;
		prctx.fill();
	}

	function calcPcts(prcvs, prctx) {
		let prwidth	 = prcvs.width;
		let prheight = prcvs.height;
		let prdata 	 = prctx.getImageData(0, 0, prwidth, prheight).data;

		let minX  = Infinity;
		let minY  = Infinity;
		let maxX  = 0;
		let maxY  = 0;

		let pcts = {};
		for (let x0 = gridsize; x0 < prwidth ; x0 += gridsize) {
			for (let y0 = gridsize; y0 < prheight; y0 += gridsize) {

				let count = 0;
				for (let y = y0; y < y0 + gridsize; y++) {
					let yoff = prwidth * 4 * y;
					for (let x = x0; x < x0 + gridsize; x++) {
						if (prdata[yoff + x*4 + 3] > 8) {
							count++;
						}
					}
				}
				let pct = Math.round(count * 100 / (gridsize * gridsize));
				let x = (x0 - gridsize) / gridsize;
				let y = (y0 - gridsize) / gridsize;
				if (pct > 55) {
					if (minX > x) minX = x;
					if (minY > y) minY = y;
					if (maxX < x) maxX = x;
					if (maxY < y) maxY = y;
				}
				pcts[(x<<16)|y] = pct;
			}
		}

		pcts.minX = minX;
		pcts.minY = minY;
		pcts.maxX = maxX;
		pcts.maxY = maxY;
		console.log({ minX:minX, maxX:maxX, minY:minY, maxY:maxY });
		return pcts;
	}

	function drawPcts(prcvs, prctx, pcts) {
		prctx.font = '10px sans-serif'
		prctx.fillStyle = 'orange';
		prctx.textAlign = 'center';
		prctx.textBaseline = 'center';
		prctx.strokeStyle = 'black';
		prctx.lineWidth = 2;

		let w = Math.floor(prcvs.width / gridsize) - 1;
		let h = Math.floor(prcvs.height / gridsize) - 1;

		for (let x = 0; x < w; x++) {
			for (let y = 0; y < h; y++) {
				let pct = pcts[(x<<16)|y]|0;
				if (pct > 1 && pct < 100) {
					prctx.fillText(pct + '%',
								(x+1)*gridsize + gridsize/2, (y+1)*gridsize + gridsize/2);
				}
				if (pct > 55) {
					prctx.beginPath();
					prctx.rect((x+1)*gridsize-0.5, (y+1)*gridsize-0.5, gridsize, gridsize);
					prctx.stroke();
				}
			}
		}
	}
				
	function drawPixels(prcvs, prctx, pcts) {
		prctx.fillStyle = 'black';

		let w = Math.floor(prcvs.width / gridsize) - 1;
		let h = Math.floor(prcvs.height / gridsize) - 1;

		for (let x = 0; x < w; x++) {
			for (let y = 0; y < h; y++) {
				let pct = pcts[(x<<16)|y]|0;
				if (pct > 55) {
					prctx.fillRect((x+1)*gridsize-0.5, (y+1)*gridsize-0.5, gridsize, gridsize);
				}
			}
		}
	}

	function drawMatrix(width, pcts) {
		console.log('width = ' + width);
		let mxcvs = document.getElementById('matrix');
		let mxctx = mxcvs.getContext('2d');

		let dx = width;
		let dy = 3 * scale;

		mxcvs.width  = dx * 30
		mxcvs.height = (33 * 3 + 1) * scale;

		let map =
		   ('010101010101010101010101010101\n' +
			'23232323232323232323232323232\n' +
			'010101010101010101010101010101\n' +
			'23232323232323232323232323232\n' +
			'010101010101010101010101010101\n' +
			'23232323232323232323232323232\n' +
			'010101010101010101010101010101\n' +
			'23232323232323232323232323232\n' +
			'010101010101010101010101010101\n' +
			'23232323232323232323232323232\n' +
			'010101010101010101010101010101\n' +
			'23232323232     2323232323232\n' +
			'01010101010       010101010101\n' +
			'2323232323        23232323232\n' +
			'0101010101         10101010101\n' +
			'232323232          3232323232\n' +
			'010101010           0101010101\n' +
			'232323232          3232323232\n' +
			'0101010101         10101010101\n' +
			'2323232323        23232323232\n' +
			'01010101010       010101010101\n' +
			'23232323232      323232323232\n' +
			'010101010101010101010101010101\n' +
			'23232323232323232323232323232\n' +
			'010101010101010101010101010101\n' +
			'23232323232323232323232323232\n' +
			'010101010101010101010101010101\n' +
			'23232323232323232323232323232\n' +
			'010101010101010101010101010101\n' +
			'23232323232323232323232323232\n' +
			'010101010101010101010101010101\n' +
			'23232323232323232323232323232\n' +
			'010101010101010101010101010101\n' +
			'').split('\n');

		let mximg = mxctx.getImageData(0, 0, mxcvs.width, mxcvs.height);
		let mxdata = mximg.data;
		let y0 = 0;
		for (let i = 0; i < map.length; i++, y0 += dy) {
			let row = map[i];
			let x0 = (i & 1) ? Math.floor(dx / 2) : 0;
			for (let j = 0; j < row.length; j++, x0 += dx) {
				if (row[j] != ' ') {
					pixel(x0, y0);
				}
			}
		}
		mxctx.putImageData(mximg, 0, 0);

		function pixel(x0, y0) {
			for (let y = pcts.minY; y <= pcts.maxY; y++) {
				let mxoff = ((y0 + y) * mxcvs.width + x0 + pcts.minX) * 4;
				for (let x = pcts.minX; x <= pcts.maxX; x++) {
					var pct = pcts[(x<<16)|y];
					if (pct > 55) {
						mxdata[mxoff++] = 0;
						mxdata[mxoff++] = 0;
						mxdata[mxoff++] = 0;
						mxdata[mxoff++] = 255;
					} else {
						mxoff += 4;
					}
				}
			}
		}
	}
} // end render()

function genproof(ev) {
	let	scale  = getscale(),
		mono   = document.getElementById('mono-chrome').checked,
		glyphs = [],
		gldata = [],
		width  = 0,
		height = 0;

	for (let i = 0; i <= 4; i++) {
		let cvs = document.getElementById('glyph' + i);
		glyphs.push(cvs);
		gldata.push(cvs.getContext('2d').getImageData(0, 0, cvs.width, cvs.height).data);
		width += cvs.width;
		if (height < cvs.height) {
			height = cvs.height;
		}
	}
	let cvs = document.createElement('canvas');
	cvs.width  = width;
	cvs.height = height;

	let ctx = cvs.getContext('2d');
	ctx.fillStyle = '#fff';
	ctx.fillRect(0, 0, width, height);

	let image = ctx.getImageData(0, 0, width, height);
	let idata = image.data;

	let x0 = 0;
	for (let i = 0; i < glyphs.length; i++) {
		let glyph = glyphs[i];
		let data  = gldata[i];
		let glwidth  = glyph.width;
		let glheight = glyph.height;
		let alphaoff = 3;	// alpha offset
		let y0 = height - glheight;
		for (let y = 0; y < glheight; y++) {
			let offs = ((y0 + y) * width + x0) * 4;
			for (let x = 0; x < glwidth; x++, offs++) {
				let a = data[alphaoff];
				idata[offs++] = 255 - a;
				idata[offs++] = 255 - a;
				idata[offs++] = 255 - a;
				alphaoff += 4;
			}
		}
		x0 += glwidth;
	}

	ctx.putImageData(image, 0, 0);

	let elt = ev.target;
	elt.download = 'fnt2' + (mono ? 'm-' : 'a-') + (scale * 10) + '.png';
	elt.href = cvs.toDataURL();
}
function genbinary(ev) {
	let	scale  = getscale(),
		mono   = document.getElementById('mono-chrome').checked,
		base64 = genfont();

	let elt = ev.target;
	elt.download = 'fnt2' + (mono ? 'm-' : 'a-') + (scale * 10) + '.bin';
	elt.href = 'data:application/octet-stream;base64,' + base64;
}
function genscript(ev) {
	let	scale  = getscale(),
		mono   = document.getElementById('mono-chrome').checked,
		base64 = genfont();

	let elt = ev.target;
	elt.download = 'fnt2' + (mono ? 'm-' : 'a-') + (scale * 10) + '.js_';
	elt.href = 'data:application/octet-stream;base64,' + btoa(
	        '// ' + elt.download.replace(/\.js_/, '.js') + '\n' +
			'bwipjs_fonts.fontsets[2].' + (mono ? 'mono' : 'anti') +
			'[' + (scale * 10) + ']={b64:"' + base64 + '"};\n'
		);
}
function genmetrics(ev) {
	let	scale  = getscale(),
		mono   = document.getElementById('mono-chrome').checked;

	let metrics = [];
	for (let i = 0; i <= 4; i++) {
		let cvs = document.getElementById('glyph' + i);
		let data = cvs.getContext('2d').getImageData(0, 0, cvs.width, cvs.height).data;
		let rect = getrect(data, cvs.width, cvs.height);

		metrics.push(cvs.width);	// advance
		metrics.push(cvs.height);	// top;
		metrics.push(rect.left);
		metrics.push(rect.width);
		metrics.push(rect.height);
	}

	let elt = ev.target;
	elt.download = 'fnt2' + (mono ? 'm-' : 'a-') + (scale * 10) + '.js_';
	elt.href = 'data:application/octet-stream;base64,' + btoa(
			'' + (mono ? 'm' : 'a') + (scale * 10) + ':[' + metrics.join(',') + '],\n'
		);
}
function genfont() {
	let glyphs = [],
		gldata = [],
		width  = 0,
		height = 0;

	let bytes = 0;
	for (let i = 0; i <= 4; i++) {
		let cvs = document.getElementById('glyph' + i);
		let data = cvs.getContext('2d').getImageData(0, 0, cvs.width, cvs.height).data;
		let rect = getrect(data, cvs.width, cvs.height);
		rect.glwidth  = cvs.width;
		rect.glheight = cvs.height;

		bytes += 4 + 	 // directory entry
				 5 * 2 + // font metrics
				 rect.width * rect.height;

		glyphs.push(rect);
		gldata.push(data);
	}

	let uint8 = new Uint8Array(bytes);
	let view  = new DataView(uint8.buffer);
	let offs  = glyphs.length * 4;	// offset to first glyph data

	for (let i = 0; i < glyphs.length; i++) {
		let rect = glyphs[i];
		let data = gldata[i];
		view.setUint32(i * 4, offs, true);
		view.setUint16(offs, rect.glwidth, true);
		offs += 2;
		view.setUint16(offs, rect.glheight - rect.top, true);
		offs += 2;
		view.setUint16(offs, rect.left, true);
		offs += 2;
		view.setUint16(offs, rect.width, true);
		offs += 2;
		view.setUint16(offs, rect.height, true);
		offs += 2;
		for (let y = rect.top; y <= rect.bottom; y++) {
			let alphaoff = (y * rect.glwidth + rect.left) * 4 + 3;
			var hex = '';
			for (let x = rect.left; x <= rect.right; x++) {
				uint8[offs++] = data[alphaoff];
				hex += (data[alphaoff] < 16 ? '0' : '') + data[alphaoff].toString(16);
				alphaoff += 4;
			}
		}
	}
	return btoa(uint8.reduce((data, byte) => data + String.fromCharCode(byte), ''));
}
function getrect(data, width, height) {
	let rect = {};

	// Top padding
	outer: for (let y = 0; y < height; y++) {
		let offs = y * width * 4 + 3;
		for (let x = 0; x < width; x++) {
			if (data[offs]) {
				rect.top = y;
				break outer;
			}
			offs += 4;
		}
	}

	// Bottom padding
	outer: for (let y = height-1; y > 0 ; y--) {
		let offs = y * width * 4 + 3;
		for (let x = 0; x < width; x++) {
			if (data[offs]) {
				rect.bottom = y;
				break outer;
			}
			offs += 4;
		}
	}

	// Left padding
	outer: for (let x = 0; x < width; x++) {
		let offs = x * 4 + 3;
		for (let y = 0; y < height; y++) {
			if (data[offs]) {
				rect.left = x;
				break outer;
			}
			offs += width * 4;
		}
	}

	// Right padding
	outer: for (let x = width-1; x > 0; x--) {
		let offs = x * 4 + 3;
		for (let y = 0; y < height; y++) {
			if (data[offs]) {
				rect.right = x;
				break outer;
			}
			offs += width * 4;
		}
	}

	rect.width  = rect.right - rect.left + 1;
	rect.height = rect.bottom - rect.top + 1;
	return rect;
}
</script>
</body>
</html>
