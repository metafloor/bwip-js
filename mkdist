#!/bin/bash
## file : mkdist

##
## Verify we can find the BWIPP copyright notice
##
COPYR=$(grep '% Copyright (c)' barcode.ps | sed -e 's,%,//,')
if [ "x$COPYR" = x ] ; then
    echo "Unable to find the copyright notice in barcode.ps" 1>&2
    exit 1
fi

##
## Verify we can find the BWIPP file version
##
FILEV=$(grep '% Barcode Writer in Pure PostScript - Version' barcode.ps | sed -e 's,%,//,')
if [ "x$FILEV" = x ] ; then
    echo "Unable to find the version string in barcode.ps" 1>&2
    exit 1
fi

## What year is it?
YEAR="2011-$(date +%Y)"

cat <<@EOF > dist/bwip-js.js
// This file is part of the bwip-js project available at:
//
//    http://metafloor.github.io/bwip-js
//
// Copyright (c) $YEAR Mark Warren
//
// This file contains code automatically generated from:
$FILEV
$COPYR
//
// The MIT License
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
"use strict";

@EOF

cp dist/bwip-js.js dist/bwip-js-min.js
cp dist/bwip-js.js dist/bwip-js-node.js
cp dist/bwip-js.js dist/bwipp.mjs
cp dist/bwip-js.js dist/bwip-js.mjs
cp dist/bwip-js.js dist/bwip-js-node.mjs
cp dist/bwip-js.js dist/bwip-js-rn.mjs
cp dist/bwip-js.js dist/bwip-js-gen.mjs

## This returns the list of bwipp exports
bwipp_exports() {
    grep -E '% --BEGIN ENCODER .*--' barcode.psc | sort -u | \
        sed -e 's/^.*BEGIN ENCODER \(.*\)--.*/bwipp_\1/' -e 's/-/_/g' | tr -s '[:space:]' ','
    echo "bwipp_lookup,bwipp_encode,BWIPP_VERSION"
}

## Finish the bwipp.mjs module
cat src/bwipp.js >> dist/bwipp.mjs
echo "export { $(bwipp_exports) };" >> dist/bwipp.mjs

## Bring in the bwipp.mjs imports for the ESMs
echo "import { $(bwipp_exports) } from './bwipp.mjs';" >> dist/bwip-js.mjs
echo "import { $(bwipp_exports) } from './bwipp.mjs';" >> dist/bwip-js-node.mjs
echo "import { $(bwipp_exports) } from './bwipp.mjs';" >> dist/bwip-js-gen.mjs
echo "import { $(bwipp_exports) } from './bwipp.mjs';" >> dist/bwip-js-rn.mjs

## Add a UMD around the minified and non-minified legacy browser versions
for file in  dist/bwip-js.js dist/bwip-js-min.js ; do
cat - <<@EOF >> $file
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = factory();
    } else {
        root.bwipjs = factory();
    }
}(typeof self !== 'undefined' ? self : this, function () {
@EOF
done

## Add in the exports for each module

exports() {
    awk "\
BEGIN { EMIT=1; } \
/@@BEGIN-/ { EMIT=0; } \
/@@BEGIN-$1-EXPORTS/ { EMIT=1; } \
/@@ENDOF-EXPORTS/ { EMIT=1; } \
/@@BEGIN-/ { next } \
/@@ENDOF-/ { next } \
(EMIT == 1) { print }" < src/exports.js
}


exports NODE-JS >> dist/bwip-js-node.js
exports NODE-JS >> dist/bwip-js-node.mjs
exports BROWSER >> dist/bwip-js.js
exports BROWSER >> dist/bwip-js.mjs
exports REACT-NV >> dist/bwip-js-rn.mjs
exports GENERIC >> dist/bwip-js-gen.mjs

## nodejs common-js
cat src/bwipp.js src/bwipjs.js src/drawing-builtin.js src/drawing-zlibpng.js src/drawing-svg.js src/fontlib.js src/stb_truetype.js >> dist/bwip-js-node.js

## nodejs and react-native ESMs
cat src/bwipjs.js src/drawing-builtin.js src/drawing-zlibpng.js src/drawing-svg.js src/fontlib.js src/stb_truetype.js >> dist/bwip-js-node.mjs
cat src/bwipjs.js src/drawing-builtin.js src/drawing-zlibpng.js src/drawing-svg.js src/fontlib.js src/stb_truetype.js >> dist/bwip-js-rn.mjs

# change the require()s to imports for the node esm (\x27 == apos)
sed -i -E -e 's/var (\w+)\s*=\s*require\((\x27\w+\x27)\)/import \1 from \2/' dist/bwip-js-node.mjs
sed -i -E -e 's/require\((\x27\w+\x27)\)/import \1/' dist/bwip-js-node.mjs

## browser UMD
cat src/bwipp.js src/bwipjs.js src/drawing-builtin.js src/drawing-canvas.js src/drawing-svg.js src/fontlib.js src/stb_truetype.js >> dist/bwip-js.js

## browser ESM
cat src/bwipjs.js src/drawing-builtin.js src/drawing-canvas.js src/drawing-svg.js src/fontlib.js src/stb_truetype.js >> dist/bwip-js.mjs

## generic ESM
cat src/bwipjs.js src/drawing-builtin.js src/drawing-svg.js src/fontlib.js src/stb_truetype.js >> dist/bwip-js-gen.mjs

##
## Shorten the postscript operator names rather than use random variable
## name mangling.
##
node rename
uglifyjs bwipp-min.js >> dist/bwip-js-min.js
rm -f bwipp-min.js

## browser minified - minified exports and no drawing-zlibpng.js
exports BROWSER | cat - src/bwipjs.js src/drawing-builtin.js src/drawing-canvas.js src/drawing-svg.js src/fontlib.js src/stb_truetype.js | uglifyjs --mangle >> dist/bwip-js-min.js

## nodejs and react-native postamble
for file in dist/bwip-js-node.js dist/bwip-js-node.mjs dist/bwip-js-rn.mjs ; do
cat - <<@EOF >> $file
function toUint8Array(data) {
    if (typeof data == "string") {
        var binary = /[^A-Za-z0-9+\/=\s]/.test(data);
        return Buffer.from ? Buffer.from(data, binary ? 'binary' : 'base64')
                           : new Buffer(data, binary ? 'binary' : 'base64');
    } else if (data instanceof Uint8Array) {
        return data;
    } else if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
    }
    throw new ReferenceError("data must be a binary or base64 encoded string or a Buffer/Uint8Array");
}

FontLib.loadFont("OCR-A", 100, 100, "$(base64 fonts/OCRA7.ttf | tr -d '\r\n\t ')");
FontLib.loadFont("OCR-B", 96, 100, "$(base64 fonts/OCRB7.ttf | tr -d '\r\n\t ')");
@EOF
done

## browser postamble
for file in  dist/bwip-js.js dist/bwip-js.mjs dist/bwip-js-min.js ; do
cat - <<@EOF >> $file
function toUint8Array(data) {
    if (typeof data == "string") {
        var binary = /[^A-Za-z0-9+\/=\s]/.test(data);
        var bstr = binary ? data : atob(data),
            len = bstr.length,
            bytes = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
            bytes[i] = bstr.charCodeAt(i);
        }
        return bytes;
    } else if (data instanceof Uint8Array) {
        return data;
    } else if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
    }
    throw new ReferenceError("data must be a binary or base64 encoded string or Uint8Array");
}

FontLib.loadFont("OCR-A", 100, 100, "$(base64 fonts/OCRA7.ttf | tr -d '\r\n\t ')");
FontLib.loadFont("OCR-B", 96, 100, "$(base64 fonts/OCRB7.ttf | tr -d '\r\n\t ')");
@EOF
done

## generic postamble.
## We cannot assume atob() or Buffer is available (and testing for their existence will
## break tree-shaking).
cat - <<@EOF >> dist/bwip-js-gen.mjs
function toUint8Array(data) {
    if (typeof data == "string") {
        if (/[^A-Za-z0-9+\/=\s]/.test(data)) {
            // binary string
            var len = data.length,
                bytes = new Uint8Array(len);
            for (var i = 0; i < len; i++) {
                bytes[i] = data.charCodeAt(i);
            }
            return bytes;
        } else {
            // base64
            data = data.replace(/\s+/g, '');
            var len = data.length;
            if (len & 3) {
                throw 'data is invalid base64 length';
            }
            var u8len = (len >> 2) * 3;
            if (data[len-2] === '=') {
                u8len -= 2;
            } else if (data[len-1] === '=') {
                u8len -= 1;
            }
            var binx = 0;
            var bytes = new Uint8Array(u8len);
            var b64map = toUint8Array.b64map;
            for (var i = 0; i < len; i += 4) {
                var a = b64map[data[i]], b = b64map[data[i+1]],
                    c = b64map[data[i+2]], d = b64map[data[i+3]];
                bytes[binx++] = (a << 2) | (b >> 4);
                bytes[binx++] = (b << 4) | (c >> 2);
                bytes[binx++] = (c << 6) | d;
            }
            return bytes;
        }
    } else if (data instanceof Uint8Array) {
        return data;
    } else if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
    }
    throw new ReferenceError("data must be a binary or base64 encoded string or Uint8Array");
}
toUint8Array.b64map = (function() {
    var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var map = {};
    for (var i = 0; i < 64; i++) {
        map[b64[i]] = i;
    }
    map[64] = 0;    // '=' padding char
    return map;
})();

FontLib.loadFont("OCR-A", 100, 100, "$(base64 fonts/OCRA7.ttf | tr -d '\r\n\t ')");
FontLib.loadFont("OCR-B", 96, 100, "$(base64 fonts/OCRB7.ttf | tr -d '\r\n\t ')");
@EOF

## exports for the cjs nodejs version
cat - <<@EOF >> dist/bwip-js-node.js
module.exports = {
    request:Request, toBuffer:ToBuffer, toSVG:ToSVG, render:Render, raw:ToRaw,
    drawingZlibPng:DrawingZlibPng, drawingSVG:DrawingSVG,
    fixupOptions:FixupOptions, loadFont:LoadFont, FontLib:FontLib,
    BWIPJS_VERSION:BWIPJS_VERSION, BWIPP_VERSION:BWIPP_VERSION,
};
@EOF

# exports for the ESM node version
grep -E '% --BEGIN ENCODER .*--' barcode.psc | sort -u | \
    sed -e 's/^.*BEGIN ENCODER \(.*\)--.*/export function \1(opts,dwg) { return _ToAny(bwipp_\1,opts,dwg); };/' \
        -e 's/-/_/g' >> dist/bwip-js-node.mjs

cat - <<@EOF >> dist/bwip-js-node.mjs
export { ToBuffer as toBuffer, ToSVG as toSVG, Render as render, LoadFont as loadFont,
         DrawingZlibPng as drawingZlibPng, DrawingSVG as drawingSVG,
         BWIPJS_VERSION, BWIPP_VERSION,
};
export default {
    request:Request, toBuffer:ToBuffer, toSVG:ToSVG, render:Render, raw:ToRaw,
    drawingZlibPng:DrawingZlibPng, drawingSVG:DrawingSVG,
    fixupOptions:FixupOptions, loadFont:LoadFont, FontLib, BWIPJS_VERSION, BWIPP_VERSION,
};
@EOF

# exports for the ESM browser version
grep -E '% --BEGIN ENCODER .*--' barcode.psc | sort -u | \
    sed -e 's/^.*BEGIN ENCODER \(.*\)--.*/export function \1(opts,dwg) { return _ToAny(bwipp_\1,opts,dwg); };/' \
        -e 's/-/_/g' >> dist/bwip-js.mjs

cat - <<@EOF >> dist/bwip-js.mjs
export { ToCanvas as toCanvas, ToSVG as toSVG, Render as render, LoadFont as loadFont,
         DrawingCanvas as drawingCanvas, DrawingSVG as drawingSVG,
         BWIPJS_VERSION, BWIPP_VERSION,
};
export default {
    toCanvas:ToCanvas, toSVG:ToSVG, render:Render, raw:ToRaw,
    drawingCanvas:DrawingCanvas, drawingSVG:DrawingSVG,
    fixupOptions:FixupOptions, loadFont:LoadFont, FontLib, BWIPJS_VERSION, BWIPP_VERSION,
};
@EOF

# exports for the react-native ESM version
grep -E '% --BEGIN ENCODER .*--' barcode.psc | sort -u | \
    sed -e 's/^.*BEGIN ENCODER \(.*\)--.*/export function \1(opts,dwg) { return _ToAny(bwipp_\1,opts,dwg); };/' \
        -e 's/-/_/g' >> dist/bwip-js-rn.mjs

cat - <<@EOF >> dist/bwip-js-rn.mjs
export { ToDataURL as toDataURL, ToSVG as toSVG, Render as render, LoadFont as loadFont,
         DrawingDataURL as drawingDataURL, DrawingSVG as drawingSVG,
         BWIPJS_VERSION, BWIPP_VERSION,
};
export default {
    toDataURL:ToDataURL, toSVG:ToSVG, render:Render, raw:ToRaw,
    drawingDataURL:DrawingDataURL, drawingSVG:DrawingSVG,
    fixupOptions:FixupOptions, loadFont:LoadFont, FontLib, BWIPJS_VERSION, BWIPP_VERSION,
};
@EOF

# exports for the generic ESM version
grep -E '% --BEGIN ENCODER .*--' barcode.psc | sort -u | \
    sed -e 's/^.*BEGIN ENCODER \(.*\)--.*/export function \1(opts,dwg) { return _Render(bwipp_\1,opts,dwg); };/' \
        -e 's/-/_/g' >> dist/bwip-js-gen.mjs

cat - <<@EOF >> dist/bwip-js-gen.mjs
export { ToSVG as toSVG, Render as render, LoadFont as loadFont, DrawingSVG as drawingSVG,
         BWIPJS_VERSION, BWIPP_VERSION,
};
export default {
    toSVG:ToSVG, render:Render, raw:ToRaw, drawingSVG:DrawingSVG,
    fixupOptions:FixupOptions, loadFont:LoadFont, FontLib, BWIPJS_VERSION, BWIPP_VERSION,
};
@EOF

# exports for the UMD browser versions
for file in  dist/bwip-js.js dist/bwip-js-min.js ; do
cat - <<@EOF >> $file
    return {
        toCanvas:ToCanvas, toSVG:ToSVG, render:Render, raw:ToRaw,
        drawingCanvas:DrawingCanvas, drawingSVG:DrawingSVG,
        fixupOptions:FixupOptions, loadFont:LoadFont, FontLib:FontLib,
        BWIPJS_VERSION:BWIPJS_VERSION, BWIPP_VERSION:BWIPP_VERSION,
    };
}));
@EOF
done

# Create the .d.ts files
# The files are mostly the same except for the platform-specific exports.

## Generic takes-any-drawing-object
function drawingtypes {
cat - <<@EOF
@EOF
# drawing => Promise<any>
# drawing => any
(
grep -E '% --BEGIN ENCODER .*--' barcode.psc | sort -u | \
    sed -e 's/^.*BEGIN ENCODER \(.*\)--.*/    export function \1<T>(opts: RenderOptions, drawing: DrawingContext<Promise<T>>): Promise<T>;/' -e 's/-/_/g'
grep -E '% --BEGIN ENCODER .*--' barcode.psc | sort -u | \
    sed -e 's/^.*BEGIN ENCODER \(.*\)--.*/    export function \1<T>(opts: RenderOptions, drawing: DrawingContext<T>): T;/' -e 's/-/_/g'
) | sort
echo
}


function browsertypes {
cat - <<@EOF
    export function toCanvas(canvas: string | HTMLCanvasElement, opts: RenderOptions): HTMLCanvasElement;
    export function drawingCanvas(canvas: string | HTMLCanvasElement): DrawingContext<HTMLCanvasElement>;

@EOF
# toCanvas => canvas
(
grep -E '% --BEGIN ENCODER .*--' barcode.psc | sort -u | \
    sed -e 's/^.*BEGIN ENCODER \(.*\)--.*/    export function \1(canvas: string | HTMLCanvasElement, opts: RenderOptions): HTMLCanvasElement;/' -e 's/-/_/g'
drawingtypes
) | sort
}

function nodejstypes {
cat - <<@EOF
    export type ToBufferCallback = (err: string | Error, png: Buffer) => void;
    export function toBuffer(opts: RenderOptions, callback: ToBufferCallback): void;
    export function toBuffer(opts: RenderOptions): Promise<Buffer>;
    export function request(req: Request, res: Response, opts?: RenderOptions): void;
    export function drawingZlibPng(): DrawingContext<Promise<Buffer>>;
    export function drawingZlibPng(callback: ToBufferCallback): DrawingContext<void>;

@EOF
# toBuffer => Promise<Buffer>
# toBuffer callback
(
grep -E '% --BEGIN ENCODER .*--' barcode.psc | sort -u | \
    sed -e 's/^.*BEGIN ENCODER \(.*\)--.*/    export function \1(opts: RenderOptions): Promise<Buffer>;/' -e 's/-/_/g'
grep -E '% --BEGIN ENCODER .*--' barcode.psc | sort -u | \
    sed -e 's/^.*BEGIN ENCODER \(.*\)--.*/    export function \1(opts: RenderOptions, callback: ToBufferCallback): void;/' -e 's/-/_/g'
drawingtypes
) | sort
echo
}

function reactnvtypes {
cat - <<@EOF
    export type ToDataURLCallback = (err: string | Error, png: { width: number; height: number; uri: string }) => void;
    export type DataURL = { width: number; height: number; uri: string };
    export function toDataURL(opts: RenderOptions, callback: ToDataURLCallback): void;
    export function toDataURL(opts: RenderOptions): Promise<DataURL>;
    export function drawingDataURL(callback: ToDataURLCallback): DrawingContext<void>;
    export function drawingDataURL(): DrawingContext<Promise<DataURL>>;

@EOF
# toDataURL => Promise<DataURL>
# toDataURL callback
(
grep -E '% --BEGIN ENCODER .*--' barcode.psc | sort -u | \
    sed -e 's/^.*BEGIN ENCODER \(.*\)--.*/    export function \1(opts: RenderOptions): Promise<DataURL>;/' -e 's/-/_/g'
grep -E '% --BEGIN ENCODER .*--' barcode.psc | sort -u | \
    sed -e 's/^.*BEGIN ENCODER \(.*\)--.*/    export function \1(opts: RenderOptions, callback: ToDataURLCallback): void;/' -e 's/-/_/g'
drawingtypes
) | sort
echo
}

browsertypes | sed -E '/\/\/ platform-specific exports/r /dev/stdin' src/bwip-js.d.ts > dist/bwip-js.d.ts
nodejstypes | sed -E '/\/\/ platform-specific exports/r /dev/stdin' src/bwip-js.d.ts > dist/bwip-js-node.d.ts
reactnvtypes | sed -E '/\/\/ platform-specific exports/r /dev/stdin' src/bwip-js.d.ts > dist/bwip-js-rn.d.ts
drawingtypes | sed -E '/\/\/ platform-specific exports/r /dev/stdin' src/bwip-js.d.ts > dist/bwip-js-gen.d.ts

## Fix up the node d.ts file to include the node types
function fixupnodetypes {
(
cat - <<@EOF
/// <reference types="node" />

import { IncomingMessage as Request, ServerResponse as Response } from 'http';

@EOF
) | sed -i -E '/\/\/ platform-specific includes/r /dev/stdin' $1
}

fixupnodetypes dist/bwip-js-node.d.ts

##
## Refresh the various barcode id to description maps
##
./mkdesc

exit 0
